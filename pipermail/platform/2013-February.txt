From amc79 at cam.ac.uk  Tue Feb  5 15:57:29 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Tue, 5 Feb 2013 15:57:29 +0000
Subject: [ocaml-platform] OCaml Platform - Mailing List
Message-ID: <EE0502C1-A0F4-4C1C-80F9-ADB8D528453A@cam.ac.uk>

Dear caml-list,

As some of you may be aware from the Consortium meeting, there's an ongoing project to create an OCaml Platform.  The Platform will combine the core OCaml compiler distribution from INRIA with a comprehensive, coherent set of libraries, tools, documentation, and other resources.  For example, the OPAM package manager will play a central role in both packaging and distribution, as well as supporting continuous integration testing.

This email is to let you know that we've set up a mailing list to discuss the Platform (platform at lists.ocaml.org), and those who are interested can follow the day-to-day discussions there [1].  Any important announcements, including releases, would also be copied to the caml-list when appropriate, so you don't need to join if you only want updates.

Best wishes,
Amir

[1] http://lists.ocaml.org/listinfo/platform

From amc79 at cam.ac.uk  Mon Feb 11 17:17:47 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Mon, 11 Feb 2013 17:17:47 +0000
Subject: [ocaml-platform] The OCaml Platform
Message-ID: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>

Dear Platform list,

Welcome to those who've joined the list.  Here are some additional notes about the Platform.

## About the Platform ##

The OCaml Platform combines the core OCaml compiler with a coherent set of libraries, tools, docs and other resources.  It is a project led by OCaml Labs in Cambridge, UK and the requirements and direction of the Platform will be guided by the major stakeholders.  We've already spoken with Jane Street and Citrix, and intend to work closely with other Consortium members too.

It is envisaged that the Platform will initially bundle OCaml 4.01 together with a specific set of libraries.  Package management, continuous integration and support for external libraries will be provided by OPAM (see below).  The other components of v0.1 will be settled on through discussion with the major stakeholders and on this list.  Since components will need to work well with each other, they should not be too numerous at first, and authors should be aware that some future work might be required as the Platform develops.

We plan to develop compiler enhancements to assist the development of software using the Platform -- for example, some variety of namespaces would likely provide benefits when using lots of modules.  These projects will be discussed individually in groups headed by experts.

## Platform availability ##

We aim for the Platform to be available via other distributions, e.g. Debian, which necessitates binary packages.  Documentation of the included libraries will also be important (see below) and should aid standardisation.

## Documentation ##

As part of the platform efforts we aim to improve the documentation generation of OCaml tools.  The aim is to support the OCaml Platform with fully cross-referenced documentation from source code, including the ability to incorporate interactive tutorials using the js_of_ocaml compiler.  This would also be combined with a single cross-referenced website.

## Testing and benchmarking ##

A continuous integration framework, based on OPAM, will form part of the Platform infrastructure.  We're calling this infrastructure "OCamlot". OPAM packages can be automatically tested upon submission and reports sent back to maintainers.  OCamlot will execute basic unit tests and also, in later versions, integrate benchmarking.  The build infrastructure is intended to run tests on the full range of community packages in OPAM by using secure virtualization under Citrix XenServer.  If you submit a package, you will be rewarded with regular regression tests across many diverse operating systems and platforms.

## Releases and updates ##

Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.

Best wishes,
Amir

From sylvain+ocaml at le-gall.net  Mon Feb 11 20:02:41 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Mon, 11 Feb 2013 21:02:41 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
Message-ID: <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>

2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
> Dear Platform list,
>
> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>
> ## About the Platform ##
>
> The OCaml Platform combines the core OCaml compiler with a coherent set of libraries, tools, docs and other resources.  It is a project led by OCaml Labs in Cambridge, UK and the requirements and direction of the Platform will be guided by the major stakeholders.  We've already spoken with Jane Street and Citrix, and intend to work closely with other Consortium members too.
>
> It is envisaged that the Platform will initially bundle OCaml 4.01 together with a specific set of libraries.  Package management, continuous integration and support for external libraries will be provided by OPAM (see below).  The other components of v0.1 will be settled on through discussion with the major stakeholders and on this list.  Since components will need to work well with each other, they should not be too numerous at first, and authors should be aware that some future work might be required as the Platform develops.
>

Does it mean they will have to provide interfaces with e.g. monads of
core? (which will probably make everything depends on Core) Or do you
think we will try to have some kind of higher level requirement, like
to have at least a 3rd party module that can integrate?

E.g. considering one of my library "fileutils", does it mean I have to
make fileutils depends on Core or should I just provide a method
"next" to iterate over the results of "ls"?


> We plan to develop compiler enhancements to assist the development of software using the Platform -- for example, some variety of namespaces would likely provide benefits when using lots of modules.  These projects will be discussed individually in groups headed by experts.
>

Does it mean included libraries/tools will have to use this specific
enhancements?

> ## Platform availability ##
>
> We aim for the Platform to be available via other distributions, e.g. Debian, which necessitates binary packages.  Documentation of the included libraries will also be important (see below) and should aid standardisation.

I think we should be more precise on this:
1. target stable distribution of linux Distro (e.g. Debian Stable) at
the time of the release
2. will not aim at being officially part of the Distro (i.e. not try
to have an "ocamlot" package inside Debian)
3. will not interfere with the official package coming from the
distribution (e.g. you can install "ocaml" and
"libfileutils-ocaml-dev" AND "ocamlot" on the same computer).

Point 2. is quite important, because it is clearly an opportunity to
provide a working dev env to people using Debian Stable and that want
to have the latest greatest packages (whereas in Debian, you'll
probably lagging a bit in term of "latest").

>
> ## Documentation ##
>
> As part of the platform efforts we aim to improve the documentation generation of OCaml tools.  The aim is to support the OCaml Platform with fully cross-referenced documentation from source code, including the ability to incorporate interactive tutorials using the js_of_ocaml compiler.  This would also be combined with a single cross-referenced website.
>
> ## Testing and benchmarking ##
>
> A continuous integration framework, based on OPAM, will form part of the Platform infrastructure.  We're calling this infrastructure "OCamlot". OPAM packages can be automatically tested upon submission and reports sent back to maintainers.  OCamlot will execute basic unit tests and also, in later versions, integrate benchmarking.  The build infrastructure is intended to run tests on the full range of community packages in OPAM by using secure virtualization under Citrix XenServer.  If you submit a package, you will be rewarded with regular regression tests across many diverse operating systems and platforms.
>
> ## Releases and updates ##
>
> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>

I propose to have some kind of "moral contract" with upstream, that
will need to backport important patches to the current version of
"ocamlot".


Regards
Sylvain

> Best wishes,
> Amir
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Mon Feb 11 22:31:21 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 11 Feb 2013 17:31:21 -0500
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
Message-ID: <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>

On Mon, Feb 11, 2013 at 3:02 PM, Sylvain Le Gall
<sylvain+ocaml at le-gall.net> wrote:
> 2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
>> Dear Platform list,
>>
>> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>>
>> ## About the Platform ##
>>
>> The OCaml Platform combines the core OCaml compiler with a coherent
>> set of libraries, tools, docs and other resources.  It is a project
>> led by OCaml Labs in Cambridge, UK and the requirements and
>> direction of the Platform will be guided by the major stakeholders.
>> We've already spoken with Jane Street and Citrix, and intend to
>> work closely with other Consortium members too.
>>
>> It is envisaged that the Platform will initially bundle OCaml 4.01
>> together with a specific set of libraries.  Package management,
>> continuous integration and support for external libraries will be
>> provided by OPAM (see below).  The other components of v0.1 will be
>> settled on through discussion with the major stakeholders and on
>> this list.  Since components will need to work well with each
>> other, they should not be too numerous at first, and authors should
>> be aware that some future work might be required as the Platform
>> develops.
>
> Does it mean they will have to provide interfaces with e.g. monads of
> core? (which will probably make everything depends on Core) Or do you
> think we will try to have some kind of higher level requirement, like
> to have at least a 3rd party module that can integrate?

Core is designed to interoperate with other OCaml libraries.
Obviously, I like the conventions of Core and would like to encourage
people to use them.  But I haven't heard anyone propose any kind of
draconian rule to require following Core's interface standards.

> E.g. considering one of my library "fileutils", does it mean I have to
> make fileutils depends on Core or should I just provide a method
> "next" to iterate over the results of "ls"?
>
>> We plan to develop compiler enhancements to assist the development
>> of software using the Platform -- for example, some variety of
>> namespaces would likely provide benefits when using lots of
>> modules.  These projects will be discussed individually in groups
>> headed by experts.
>>
>
> Does it mean included libraries/tools will have to use this specific
> enhancements?

Speaking for no one but myself, I think that if we get a good
namespace system for OCaml, we should probably require that libraries
in the platform use it.  Agreeing on partitioning names seems like a
fundamental bit of work that a platform requires.

I would think that there are other things that one would want to
require, like good use of documentation facilities.

>> ## Platform availability ##
>>
>> We aim for the Platform to be available via other distributions,
>> e.g. Debian, which necessitates binary packages.  Documentation of
>> the included libraries will also be important (see below) and
>> should aid standardisation.
>
> I think we should be more precise on this:
> 1. target stable distribution of linux Distro (e.g. Debian Stable) at
> the time of the release
> 2. will not aim at being officially part of the Distro (i.e. not try
> to have an "ocamlot" package inside Debian)
> 3. will not interfere with the official package coming from the
> distribution (e.g. you can install "ocaml" and
> "libfileutils-ocaml-dev" AND "ocamlot" on the same computer).
>
> Point 2. is quite important, because it is clearly an opportunity to
> provide a working dev env to people using Debian Stable and that want
> to have the latest greatest packages (whereas in Debian, you'll
> probably lagging a bit in term of "latest").
>
>>
>> ## Documentation ##
>>
>> As part of the platform efforts we aim to improve the documentation
>> generation of OCaml tools.  The aim is to support the OCaml
>> Platform with fully cross-referenced documentation from source
>> code, including the ability to incorporate interactive tutorials
>> using the js_of_ocaml compiler.  This would also be combined with a
>> single cross-referenced website.
>>
>> ## Testing and benchmarking ##
>>
>> A continuous integration framework, based on OPAM, will form part
>> of the Platform infrastructure.  We're calling this infrastructure
>> "OCamlot". OPAM packages can be automatically tested upon
>> submission and reports sent back to maintainers.  OCamlot will
>> execute basic unit tests and also, in later versions, integrate
>> benchmarking.  The build infrastructure is intended to run tests on
>> the full range of community packages in OPAM by using secure
>> virtualization under Citrix XenServer.  If you submit a package,
>> you will be rewarded with regular regression tests across many
>> diverse operating systems and platforms.
>>
>> ## Releases and updates ##
>>
>> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>>
>
> I propose to have some kind of "moral contract" with upstream, that
> will need to backport important patches to the current version of
> "ocamlot".
>
>
> Regards
> Sylvain
>
>> Best wishes,
>> Amir
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From sylvain+ocaml at le-gall.net  Tue Feb 12 11:02:10 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 12 Feb 2013 12:02:10 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
Message-ID: <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>

2013/2/11 Yaron Minsky <yminsky at janestreet.com>:
> On Mon, Feb 11, 2013 at 3:02 PM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> 2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
>>> Dear Platform list,
>>>
>>> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>>>
>>> ## About the Platform ##
>>>
>>> The OCaml Platform combines the core OCaml compiler with a coherent
>>> set of libraries, tools, docs and other resources.  It is a project
>>> led by OCaml Labs in Cambridge, UK and the requirements and
>>> direction of the Platform will be guided by the major stakeholders.
>>> We've already spoken with Jane Street and Citrix, and intend to
>>> work closely with other Consortium members too.
>>>
>>> It is envisaged that the Platform will initially bundle OCaml 4.01
>>> together with a specific set of libraries.  Package management,
>>> continuous integration and support for external libraries will be
>>> provided by OPAM (see below).  The other components of v0.1 will be
>>> settled on through discussion with the major stakeholders and on
>>> this list.  Since components will need to work well with each
>>> other, they should not be too numerous at first, and authors should
>>> be aware that some future work might be required as the Platform
>>> develops.
>>
>> Does it mean they will have to provide interfaces with e.g. monads of
>> core? (which will probably make everything depends on Core) Or do you
>> think we will try to have some kind of higher level requirement, like
>> to have at least a 3rd party module that can integrate?
>
> Core is designed to interoperate with other OCaml libraries.
> Obviously, I like the conventions of Core and would like to encourage
> people to use them.  But I haven't heard anyone propose any kind of
> draconian rule to require following Core's interface standards.
>

No offense meant, this was just an example. I would be glad to provide
a 3rd party library that interface with core, but would like to not
put it as a build dependencies of the initial library.

E.g:
- fileutils -> the standard library
- fileutils-core -> the interface to core.
- fileutils-batteries, fileutils-lwt -> the interfaces to batteries and  lwt

>> E.g. considering one of my library "fileutils", does it mean I have to
>> make fileutils depends on Core or should I just provide a method
>> "next" to iterate over the results of "ls"?
>>
>>> We plan to develop compiler enhancements to assist the development
>>> of software using the Platform -- for example, some variety of
>>> namespaces would likely provide benefits when using lots of
>>> modules.  These projects will be discussed individually in groups
>>> headed by experts.
>>>
>>
>> Does it mean included libraries/tools will have to use this specific
>> enhancements?
>
> Speaking for no one but myself, I think that if we get a good
> namespace system for OCaml, we should probably require that libraries
> in the platform use it.  Agreeing on partitioning names seems like a
> fundamental bit of work that a platform requires.
>
> I would think that there are other things that one would want to
> require, like good use of documentation facilities.
>
>>> ## Platform availability ##
>>>
>>> We aim for the Platform to be available via other distributions,
>>> e.g. Debian, which necessitates binary packages.  Documentation of
>>> the included libraries will also be important (see below) and
>>> should aid standardisation.
>>
>> I think we should be more precise on this:
>> 1. target stable distribution of linux Distro (e.g. Debian Stable) at
>> the time of the release
>> 2. will not aim at being officially part of the Distro (i.e. not try
>> to have an "ocamlot" package inside Debian)
>> 3. will not interfere with the official package coming from the
>> distribution (e.g. you can install "ocaml" and
>> "libfileutils-ocaml-dev" AND "ocamlot" on the same computer).
>>
>> Point 2. is quite important, because it is clearly an opportunity to
>> provide a working dev env to people using Debian Stable and that want
>> to have the latest greatest packages (whereas in Debian, you'll
>> probably lagging a bit in term of "latest").
>>
>>>
>>> ## Documentation ##
>>>
>>> As part of the platform efforts we aim to improve the documentation
>>> generation of OCaml tools.  The aim is to support the OCaml
>>> Platform with fully cross-referenced documentation from source
>>> code, including the ability to incorporate interactive tutorials
>>> using the js_of_ocaml compiler.  This would also be combined with a
>>> single cross-referenced website.
>>>
>>> ## Testing and benchmarking ##
>>>
>>> A continuous integration framework, based on OPAM, will form part
>>> of the Platform infrastructure.  We're calling this infrastructure
>>> "OCamlot". OPAM packages can be automatically tested upon
>>> submission and reports sent back to maintainers.  OCamlot will
>>> execute basic unit tests and also, in later versions, integrate
>>> benchmarking.  The build infrastructure is intended to run tests on
>>> the full range of community packages in OPAM by using secure
>>> virtualization under Citrix XenServer.  If you submit a package,
>>> you will be rewarded with regular regression tests across many
>>> diverse operating systems and platforms.
>>>
>>> ## Releases and updates ##
>>>
>>> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>>>
>>
>> I propose to have some kind of "moral contract" with upstream, that
>> will need to backport important patches to the current version of
>> "ocamlot".
>>
>>
>> Regards
>> Sylvain
>>
>>> Best wishes,
>>> Amir
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From thomas at ocamlpro.com  Tue Feb 12 13:03:52 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 12 Feb 2013 14:03:52 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
Message-ID: <5B3083C1-64B7-4261-8CBA-4D25859EC12B@ocamlpro.com>

Hi,

> It is envisaged that the Platform will initially bundle OCaml 4.01 together with a specific set of libraries.  Package management, continuous integration and support for external libraries will be provided by OPAM (see below).  The other components of v0.1 will be settled on through discussion with the major stakeholders and on this list.  Since components will need to work well with each other, they should not be too numerous at first, and authors should be aware that some future work might be required as the Platform develops.

I'm quite keen to make the necessary changes to OPAM to fully supports the platform needs. In order to do so, I've created a new Milestone on github[1] to track feature requests and bugs related to the platform and started to move some existing (and more or less related) issues there.

--
Thomas

[1] https://github.com/OCamlPro/opam/issues?milestone=16



> 
> We plan to develop compiler enhancements to assist the development of software using the Platform -- for example, some variety of namespaces would likely provide benefits when using lots of modules.  These projects will be discussed individually in groups headed by experts.
> 
> ## Platform availability ##
> 
> We aim for the Platform to be available via other distributions, e.g. Debian, which necessitates binary packages.  Documentation of the included libraries will also be important (see below) and should aid standardisation.
> 
> ## Documentation ##
> 
> As part of the platform efforts we aim to improve the documentation generation of OCaml tools.  The aim is to support the OCaml Platform with fully cross-referenced documentation from source code, including the ability to incorporate interactive tutorials using the js_of_ocaml compiler.  This would also be combined with a single cross-referenced website.
> 
> ## Testing and benchmarking ##
> 
> A continuous integration framework, based on OPAM, will form part of the Platform infrastructure.  We're calling this infrastructure "OCamlot". OPAM packages can be automatically tested upon submission and reports sent back to maintainers.  OCamlot will execute basic unit tests and also, in later versions, integrate benchmarking.  The build infrastructure is intended to run tests on the full range of community packages in OPAM by using secure virtualization under Citrix XenServer.  If you submit a package, you will be rewarded with regular regression tests across many diverse operating systems and platforms.
> 
> ## Releases and updates ##
> 
> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
> 
> Best wishes,
> Amir
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform


From yminsky at janestreet.com  Tue Feb 12 13:49:05 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Feb 2013 08:49:05 -0500
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
Message-ID: <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>

I understand what it would mean to have an interface to Lwt or Async,
but what would it mean to have an interface to Core?  Do you mean just
to have a skin for fileutils that follows Core's conventions?

To say the obvious, one can use Core alongside with other libraries
without issue.

y

On Tue, Feb 12, 2013 at 6:02 AM, Sylvain Le Gall
<sylvain+ocaml at le-gall.net> wrote:
> 2013/2/11 Yaron Minsky <yminsky at janestreet.com>:
>> On Mon, Feb 11, 2013 at 3:02 PM, Sylvain Le Gall
>> <sylvain+ocaml at le-gall.net> wrote:
>>> 2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
>>>> Dear Platform list,
>>>>
>>>> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>>>>
>>>> ## About the Platform ##
>>>>
>>>> The OCaml Platform combines the core OCaml compiler with a coherent
>>>> set of libraries, tools, docs and other resources.  It is a project
>>>> led by OCaml Labs in Cambridge, UK and the requirements and
>>>> direction of the Platform will be guided by the major stakeholders.
>>>> We've already spoken with Jane Street and Citrix, and intend to
>>>> work closely with other Consortium members too.
>>>>
>>>> It is envisaged that the Platform will initially bundle OCaml 4.01
>>>> together with a specific set of libraries.  Package management,
>>>> continuous integration and support for external libraries will be
>>>> provided by OPAM (see below).  The other components of v0.1 will be
>>>> settled on through discussion with the major stakeholders and on
>>>> this list.  Since components will need to work well with each
>>>> other, they should not be too numerous at first, and authors should
>>>> be aware that some future work might be required as the Platform
>>>> develops.
>>>
>>> Does it mean they will have to provide interfaces with e.g. monads of
>>> core? (which will probably make everything depends on Core) Or do you
>>> think we will try to have some kind of higher level requirement, like
>>> to have at least a 3rd party module that can integrate?
>>
>> Core is designed to interoperate with other OCaml libraries.
>> Obviously, I like the conventions of Core and would like to encourage
>> people to use them.  But I haven't heard anyone propose any kind of
>> draconian rule to require following Core's interface standards.
>>
>
> No offense meant, this was just an example. I would be glad to provide
> a 3rd party library that interface with core, but would like to not
> put it as a build dependencies of the initial library.
>
> E.g:
> - fileutils -> the standard library
> - fileutils-core -> the interface to core.
> - fileutils-batteries, fileutils-lwt -> the interfaces to batteries and  lwt
>
>>> E.g. considering one of my library "fileutils", does it mean I have to
>>> make fileutils depends on Core or should I just provide a method
>>> "next" to iterate over the results of "ls"?
>>>
>>>> We plan to develop compiler enhancements to assist the development
>>>> of software using the Platform -- for example, some variety of
>>>> namespaces would likely provide benefits when using lots of
>>>> modules.  These projects will be discussed individually in groups
>>>> headed by experts.
>>>>
>>>
>>> Does it mean included libraries/tools will have to use this specific
>>> enhancements?
>>
>> Speaking for no one but myself, I think that if we get a good
>> namespace system for OCaml, we should probably require that libraries
>> in the platform use it.  Agreeing on partitioning names seems like a
>> fundamental bit of work that a platform requires.
>>
>> I would think that there are other things that one would want to
>> require, like good use of documentation facilities.
>>
>>>> ## Platform availability ##
>>>>
>>>> We aim for the Platform to be available via other distributions,
>>>> e.g. Debian, which necessitates binary packages.  Documentation of
>>>> the included libraries will also be important (see below) and
>>>> should aid standardisation.
>>>
>>> I think we should be more precise on this:
>>> 1. target stable distribution of linux Distro (e.g. Debian Stable) at
>>> the time of the release
>>> 2. will not aim at being officially part of the Distro (i.e. not try
>>> to have an "ocamlot" package inside Debian)
>>> 3. will not interfere with the official package coming from the
>>> distribution (e.g. you can install "ocaml" and
>>> "libfileutils-ocaml-dev" AND "ocamlot" on the same computer).
>>>
>>> Point 2. is quite important, because it is clearly an opportunity to
>>> provide a working dev env to people using Debian Stable and that want
>>> to have the latest greatest packages (whereas in Debian, you'll
>>> probably lagging a bit in term of "latest").
>>>
>>>>
>>>> ## Documentation ##
>>>>
>>>> As part of the platform efforts we aim to improve the documentation
>>>> generation of OCaml tools.  The aim is to support the OCaml
>>>> Platform with fully cross-referenced documentation from source
>>>> code, including the ability to incorporate interactive tutorials
>>>> using the js_of_ocaml compiler.  This would also be combined with a
>>>> single cross-referenced website.
>>>>
>>>> ## Testing and benchmarking ##
>>>>
>>>> A continuous integration framework, based on OPAM, will form part
>>>> of the Platform infrastructure.  We're calling this infrastructure
>>>> "OCamlot". OPAM packages can be automatically tested upon
>>>> submission and reports sent back to maintainers.  OCamlot will
>>>> execute basic unit tests and also, in later versions, integrate
>>>> benchmarking.  The build infrastructure is intended to run tests on
>>>> the full range of community packages in OPAM by using secure
>>>> virtualization under Citrix XenServer.  If you submit a package,
>>>> you will be rewarded with regular regression tests across many
>>>> diverse operating systems and platforms.
>>>>
>>>> ## Releases and updates ##
>>>>
>>>> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>>>>
>>>
>>> I propose to have some kind of "moral contract" with upstream, that
>>> will need to backport important patches to the current version of
>>> "ocamlot".
>>>
>>>
>>> Regards
>>> Sylvain
>>>
>>>> Best wishes,
>>>> Amir
>>>> _______________________________________________
>>>> Platform mailing list
>>>> Platform at lists.ocaml.org
>>>> http://lists.ocaml.org/listinfo/platform
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform

From anil at recoil.org  Tue Feb 12 13:58:27 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 12 Feb 2013 13:58:27 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
Message-ID: <01370D44-3117-40B3-9B1A-74C10D5ABE75@recoil.org>

The most pressing problem is with camlp4 extensions that generate
code.  Right now, things break if Core.Std is open, and vanilla OCaml
library calls are used (e.g. List.flatten).

Namespaces offer a solution to this by letting extensions explicitly
open a particular standard library without caring what's happening
around them.  As it stands, we need to be really careful about code
generation, or have camlp4 options to toggle Core-style code on/off.

-anil

On 12 Feb 2013, at 13:49, Yaron Minsky <yminsky at janestreet.com> wrote:

> I understand what it would mean to have an interface to Lwt or Async,
> but what would it mean to have an interface to Core?  Do you mean just
> to have a skin for fileutils that follows Core's conventions?
> 
> To say the obvious, one can use Core alongside with other libraries
> without issue.
> 
> y
> 
> On Tue, Feb 12, 2013 at 6:02 AM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> 2013/2/11 Yaron Minsky <yminsky at janestreet.com>:
>>> On Mon, Feb 11, 2013 at 3:02 PM, Sylvain Le Gall
>>> <sylvain+ocaml at le-gall.net> wrote:
>>>> 2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
>>>>> Dear Platform list,
>>>>> 
>>>>> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>>>>> 
>>>>> ## About the Platform ##
>>>>> 
>>>>> The OCaml Platform combines the core OCaml compiler with a coherent
>>>>> set of libraries, tools, docs and other resources.  It is a project
>>>>> led by OCaml Labs in Cambridge, UK and the requirements and
>>>>> direction of the Platform will be guided by the major stakeholders.
>>>>> We've already spoken with Jane Street and Citrix, and intend to
>>>>> work closely with other Consortium members too.
>>>>> 
>>>>> It is envisaged that the Platform will initially bundle OCaml 4.01
>>>>> together with a specific set of libraries.  Package management,
>>>>> continuous integration and support for external libraries will be
>>>>> provided by OPAM (see below).  The other components of v0.1 will be
>>>>> settled on through discussion with the major stakeholders and on
>>>>> this list.  Since components will need to work well with each
>>>>> other, they should not be too numerous at first, and authors should
>>>>> be aware that some future work might be required as the Platform
>>>>> develops.
>>>> 
>>>> Does it mean they will have to provide interfaces with e.g. monads of
>>>> core? (which will probably make everything depends on Core) Or do you
>>>> think we will try to have some kind of higher level requirement, like
>>>> to have at least a 3rd party module that can integrate?
>>> 
>>> Core is designed to interoperate with other OCaml libraries.
>>> Obviously, I like the conventions of Core and would like to encourage
>>> people to use them.  But I haven't heard anyone propose any kind of
>>> draconian rule to require following Core's interface standards.
>>> 
>> 
>> No offense meant, this was just an example. I would be glad to provide
>> a 3rd party library that interface with core, but would like to not
>> put it as a build dependencies of the initial library.
>> 
>> E.g:
>> - fileutils -> the standard library
>> - fileutils-core -> the interface to core.
>> - fileutils-batteries, fileutils-lwt -> the interfaces to batteries and  lwt
>> 
>>>> E.g. considering one of my library "fileutils", does it mean I have to
>>>> make fileutils depends on Core or should I just provide a method
>>>> "next" to iterate over the results of "ls"?
>>>> 
>>>>> We plan to develop compiler enhancements to assist the development
>>>>> of software using the Platform -- for example, some variety of
>>>>> namespaces would likely provide benefits when using lots of
>>>>> modules.  These projects will be discussed individually in groups
>>>>> headed by experts.
>>>>> 
>>>> 
>>>> Does it mean included libraries/tools will have to use this specific
>>>> enhancements?
>>> 
>>> Speaking for no one but myself, I think that if we get a good
>>> namespace system for OCaml, we should probably require that libraries
>>> in the platform use it.  Agreeing on partitioning names seems like a
>>> fundamental bit of work that a platform requires.
>>> 
>>> I would think that there are other things that one would want to
>>> require, like good use of documentation facilities.
>>> 
>>>>> ## Platform availability ##
>>>>> 
>>>>> We aim for the Platform to be available via other distributions,
>>>>> e.g. Debian, which necessitates binary packages.  Documentation of
>>>>> the included libraries will also be important (see below) and
>>>>> should aid standardisation.
>>>> 
>>>> I think we should be more precise on this:
>>>> 1. target stable distribution of linux Distro (e.g. Debian Stable) at
>>>> the time of the release
>>>> 2. will not aim at being officially part of the Distro (i.e. not try
>>>> to have an "ocamlot" package inside Debian)
>>>> 3. will not interfere with the official package coming from the
>>>> distribution (e.g. you can install "ocaml" and
>>>> "libfileutils-ocaml-dev" AND "ocamlot" on the same computer).
>>>> 
>>>> Point 2. is quite important, because it is clearly an opportunity to
>>>> provide a working dev env to people using Debian Stable and that want
>>>> to have the latest greatest packages (whereas in Debian, you'll
>>>> probably lagging a bit in term of "latest").
>>>> 
>>>>> 
>>>>> ## Documentation ##
>>>>> 
>>>>> As part of the platform efforts we aim to improve the documentation
>>>>> generation of OCaml tools.  The aim is to support the OCaml
>>>>> Platform with fully cross-referenced documentation from source
>>>>> code, including the ability to incorporate interactive tutorials
>>>>> using the js_of_ocaml compiler.  This would also be combined with a
>>>>> single cross-referenced website.
>>>>> 
>>>>> ## Testing and benchmarking ##
>>>>> 
>>>>> A continuous integration framework, based on OPAM, will form part
>>>>> of the Platform infrastructure.  We're calling this infrastructure
>>>>> "OCamlot". OPAM packages can be automatically tested upon
>>>>> submission and reports sent back to maintainers.  OCamlot will
>>>>> execute basic unit tests and also, in later versions, integrate
>>>>> benchmarking.  The build infrastructure is intended to run tests on
>>>>> the full range of community packages in OPAM by using secure
>>>>> virtualization under Citrix XenServer.  If you submit a package,
>>>>> you will be rewarded with regular regression tests across many
>>>>> diverse operating systems and platforms.
>>>>> 
>>>>> ## Releases and updates ##
>>>>> 
>>>>> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>>>>> 
>>>> 
>>>> I propose to have some kind of "moral contract" with upstream, that
>>>> will need to backport important patches to the current version of
>>>> "ocamlot".
>>>> 
>>>> 
>>>> Regards
>>>> Sylvain
>>>> 
>>>>> Best wishes,
>>>>> Amir
>>>>> _______________________________________________
>>>>> Platform mailing list
>>>>> Platform at lists.ocaml.org
>>>>> http://lists.ocaml.org/listinfo/platform
>>>> _______________________________________________
>>>> Platform mailing list
>>>> Platform at lists.ocaml.org
>>>> http://lists.ocaml.org/listinfo/platform
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
> 


From yminsky at janestreet.com  Tue Feb 12 14:15:33 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Feb 2013 09:15:33 -0500
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <01370D44-3117-40B3-9B1A-74C10D5ABE75@recoil.org>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <01370D44-3117-40B3-9B1A-74C10D5ABE75@recoil.org>
Message-ID: <CACLX4jRGVbpMahwS4aWMjZs9sHUEKimW_vmxUb=4OArK_5RBeg@mail.gmail.com>

On Tue, Feb 12, 2013 at 8:58 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> The most pressing problem is with camlp4 extensions that generate
> code.  Right now, things break if Core.Std is open, and vanilla OCaml
> library calls are used (e.g. List.flatten).
>
> Namespaces offer a solution to this by letting extensions explicitly
> open a particular standard library without caring what's happening
> around them.  As it stands, we need to be really careful about code
> generation, or have camlp4 options to toggle Core-style code on/off.

I don't see why this would be a problem with fileutils.  If you want
to use Core's naming conventions and organization, you open Core.Std.
If not, you can just pick and choose the modules you want from
Core.Std.  But either way, I don't see why you need to specialize
fileutils to be usable with Core.  Can you give a concrete example of
an incompatibility?

Similarly with the syntax extensions.  Core needs syntax extensions to
build, but it doesn't need them to use Core.

Now, if you want to interoperate with Core maximally well, i.e., you
want to be able to use Core's functors smoothly and easily, or you
want to use the interface components in Core like Sexpable,
Comparable, Hashable, etc, then you do need to depend on Core.  But
that seems like a fundamenatal issue, and not one that can be
ameliorated by namespaces.

> -anil
>
> On 12 Feb 2013, at 13:49, Yaron Minsky <yminsky at janestreet.com> wrote:
>
>> I understand what it would mean to have an interface to Lwt or Async,
>> but what would it mean to have an interface to Core?  Do you mean just
>> to have a skin for fileutils that follows Core's conventions?
>>
>> To say the obvious, one can use Core alongside with other libraries
>> without issue.
>>
>> y
>>
>> On Tue, Feb 12, 2013 at 6:02 AM, Sylvain Le Gall
>> <sylvain+ocaml at le-gall.net> wrote:
>>> 2013/2/11 Yaron Minsky <yminsky at janestreet.com>:
>>>> On Mon, Feb 11, 2013 at 3:02 PM, Sylvain Le Gall
>>>> <sylvain+ocaml at le-gall.net> wrote:
>>>>> 2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
>>>>>> Dear Platform list,
>>>>>>
>>>>>> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>>>>>>
>>>>>> ## About the Platform ##
>>>>>>
>>>>>> The OCaml Platform combines the core OCaml compiler with a coherent
>>>>>> set of libraries, tools, docs and other resources.  It is a project
>>>>>> led by OCaml Labs in Cambridge, UK and the requirements and
>>>>>> direction of the Platform will be guided by the major stakeholders.
>>>>>> We've already spoken with Jane Street and Citrix, and intend to
>>>>>> work closely with other Consortium members too.
>>>>>>
>>>>>> It is envisaged that the Platform will initially bundle OCaml 4.01
>>>>>> together with a specific set of libraries.  Package management,
>>>>>> continuous integration and support for external libraries will be
>>>>>> provided by OPAM (see below).  The other components of v0.1 will be
>>>>>> settled on through discussion with the major stakeholders and on
>>>>>> this list.  Since components will need to work well with each
>>>>>> other, they should not be too numerous at first, and authors should
>>>>>> be aware that some future work might be required as the Platform
>>>>>> develops.
>>>>>
>>>>> Does it mean they will have to provide interfaces with e.g. monads of
>>>>> core? (which will probably make everything depends on Core) Or do you
>>>>> think we will try to have some kind of higher level requirement, like
>>>>> to have at least a 3rd party module that can integrate?
>>>>
>>>> Core is designed to interoperate with other OCaml libraries.
>>>> Obviously, I like the conventions of Core and would like to encourage
>>>> people to use them.  But I haven't heard anyone propose any kind of
>>>> draconian rule to require following Core's interface standards.
>>>>
>>>
>>> No offense meant, this was just an example. I would be glad to provide
>>> a 3rd party library that interface with core, but would like to not
>>> put it as a build dependencies of the initial library.
>>>
>>> E.g:
>>> - fileutils -> the standard library
>>> - fileutils-core -> the interface to core.
>>> - fileutils-batteries, fileutils-lwt -> the interfaces to batteries and  lwt
>>>
>>>>> E.g. considering one of my library "fileutils", does it mean I have to
>>>>> make fileutils depends on Core or should I just provide a method
>>>>> "next" to iterate over the results of "ls"?
>>>>>
>>>>>> We plan to develop compiler enhancements to assist the development
>>>>>> of software using the Platform -- for example, some variety of
>>>>>> namespaces would likely provide benefits when using lots of
>>>>>> modules.  These projects will be discussed individually in groups
>>>>>> headed by experts.
>>>>>>
>>>>>
>>>>> Does it mean included libraries/tools will have to use this specific
>>>>> enhancements?
>>>>
>>>> Speaking for no one but myself, I think that if we get a good
>>>> namespace system for OCaml, we should probably require that libraries
>>>> in the platform use it.  Agreeing on partitioning names seems like a
>>>> fundamental bit of work that a platform requires.
>>>>
>>>> I would think that there are other things that one would want to
>>>> require, like good use of documentation facilities.
>>>>
>>>>>> ## Platform availability ##
>>>>>>
>>>>>> We aim for the Platform to be available via other distributions,
>>>>>> e.g. Debian, which necessitates binary packages.  Documentation of
>>>>>> the included libraries will also be important (see below) and
>>>>>> should aid standardisation.
>>>>>
>>>>> I think we should be more precise on this:
>>>>> 1. target stable distribution of linux Distro (e.g. Debian Stable) at
>>>>> the time of the release
>>>>> 2. will not aim at being officially part of the Distro (i.e. not try
>>>>> to have an "ocamlot" package inside Debian)
>>>>> 3. will not interfere with the official package coming from the
>>>>> distribution (e.g. you can install "ocaml" and
>>>>> "libfileutils-ocaml-dev" AND "ocamlot" on the same computer).
>>>>>
>>>>> Point 2. is quite important, because it is clearly an opportunity to
>>>>> provide a working dev env to people using Debian Stable and that want
>>>>> to have the latest greatest packages (whereas in Debian, you'll
>>>>> probably lagging a bit in term of "latest").
>>>>>
>>>>>>
>>>>>> ## Documentation ##
>>>>>>
>>>>>> As part of the platform efforts we aim to improve the documentation
>>>>>> generation of OCaml tools.  The aim is to support the OCaml
>>>>>> Platform with fully cross-referenced documentation from source
>>>>>> code, including the ability to incorporate interactive tutorials
>>>>>> using the js_of_ocaml compiler.  This would also be combined with a
>>>>>> single cross-referenced website.
>>>>>>
>>>>>> ## Testing and benchmarking ##
>>>>>>
>>>>>> A continuous integration framework, based on OPAM, will form part
>>>>>> of the Platform infrastructure.  We're calling this infrastructure
>>>>>> "OCamlot". OPAM packages can be automatically tested upon
>>>>>> submission and reports sent back to maintainers.  OCamlot will
>>>>>> execute basic unit tests and also, in later versions, integrate
>>>>>> benchmarking.  The build infrastructure is intended to run tests on
>>>>>> the full range of community packages in OPAM by using secure
>>>>>> virtualization under Citrix XenServer.  If you submit a package,
>>>>>> you will be rewarded with regular regression tests across many
>>>>>> diverse operating systems and platforms.
>>>>>>
>>>>>> ## Releases and updates ##
>>>>>>
>>>>>> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>>>>>>
>>>>>
>>>>> I propose to have some kind of "moral contract" with upstream, that
>>>>> will need to backport important patches to the current version of
>>>>> "ocamlot".
>>>>>
>>>>>
>>>>> Regards
>>>>> Sylvain
>>>>>
>>>>>> Best wishes,
>>>>>> Amir
>>>>>> _______________________________________________
>>>>>> Platform mailing list
>>>>>> Platform at lists.ocaml.org
>>>>>> http://lists.ocaml.org/listinfo/platform
>>>>> _______________________________________________
>>>>> Platform mailing list
>>>>> Platform at lists.ocaml.org
>>>>> http://lists.ocaml.org/listinfo/platform
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>>
>

From sylvain+ocaml at le-gall.net  Tue Feb 12 15:23:14 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 12 Feb 2013 16:23:14 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
Message-ID: <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>

2013/2/12 Yaron Minsky <yminsky at janestreet.com>:
> I understand what it would mean to have an interface to Lwt or Async,
> but what would it mean to have an interface to Core?  Do you mean just
> to have a skin for fileutils that follows Core's conventions?
>

Let's take an example that I know and that I already have thought
about (sorry if it is not Core, but Lwt).

Imagine that I want to use fileutils "ls":
1. val ls : filename -> filename list

It should look like this with lwt:
2. val ls: filename -> (filename list) Lwt.t (I think, Lwt.t being a monad)

So the question would be how to transform 1. into 2. This is quite
important, because you would like to not mix blocking operation with
non-blocking one and have a quite common style in your application.

In the case of Lwt, the solution is pretty straight forward, you just
use a thread (Thread) to wrap 1. and produce 2.

I think the overall question is "do we wish to have a common style for
non-stdlib features", e.g. monads, file descriptor et al. I don't
think this is mandatory but can be a nice long term goal.

But maybe I am going too far, and the point of OCaml Platform is just
to have  a "set of libraries", tested, packaged together and released
every 6 months (which is already an ambitious goal). If this is the
case, please ignore my question -- I'll be already extermly happy to
see an OCaml Platform in 6 months.


> To say the obvious, one can use Core alongside with other libraries
> without issue.

That is a good thing ;-)

>
> y
>
> On Tue, Feb 12, 2013 at 6:02 AM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> 2013/2/11 Yaron Minsky <yminsky at janestreet.com>:
>>> On Mon, Feb 11, 2013 at 3:02 PM, Sylvain Le Gall
>>> <sylvain+ocaml at le-gall.net> wrote:
>>>> 2013/2/11 Amir Chaudhry <amc79 at cam.ac.uk>:
>>>>> Dear Platform list,
>>>>>
>>>>> Welcome to those who've joined the list.  Here are some additional notes about the Platform.
>>>>>
>>>>> ## About the Platform ##
>>>>>
>>>>> The OCaml Platform combines the core OCaml compiler with a coherent
>>>>> set of libraries, tools, docs and other resources.  It is a project
>>>>> led by OCaml Labs in Cambridge, UK and the requirements and
>>>>> direction of the Platform will be guided by the major stakeholders.
>>>>> We've already spoken with Jane Street and Citrix, and intend to
>>>>> work closely with other Consortium members too.
>>>>>
>>>>> It is envisaged that the Platform will initially bundle OCaml 4.01
>>>>> together with a specific set of libraries.  Package management,
>>>>> continuous integration and support for external libraries will be
>>>>> provided by OPAM (see below).  The other components of v0.1 will be
>>>>> settled on through discussion with the major stakeholders and on
>>>>> this list.  Since components will need to work well with each
>>>>> other, they should not be too numerous at first, and authors should
>>>>> be aware that some future work might be required as the Platform
>>>>> develops.
>>>>
>>>> Does it mean they will have to provide interfaces with e.g. monads of
>>>> core? (which will probably make everything depends on Core) Or do you
>>>> think we will try to have some kind of higher level requirement, like
>>>> to have at least a 3rd party module that can integrate?
>>>
>>> Core is designed to interoperate with other OCaml libraries.
>>> Obviously, I like the conventions of Core and would like to encourage
>>> people to use them.  But I haven't heard anyone propose any kind of
>>> draconian rule to require following Core's interface standards.
>>>
>>
>> No offense meant, this was just an example. I would be glad to provide
>> a 3rd party library that interface with core, but would like to not
>> put it as a build dependencies of the initial library.
>>
>> E.g:
>> - fileutils -> the standard library
>> - fileutils-core -> the interface to core.
>> - fileutils-batteries, fileutils-lwt -> the interfaces to batteries and  lwt
>>
>>>> E.g. considering one of my library "fileutils", does it mean I have to
>>>> make fileutils depends on Core or should I just provide a method
>>>> "next" to iterate over the results of "ls"?
>>>>
>>>>> We plan to develop compiler enhancements to assist the development
>>>>> of software using the Platform -- for example, some variety of
>>>>> namespaces would likely provide benefits when using lots of
>>>>> modules.  These projects will be discussed individually in groups
>>>>> headed by experts.
>>>>>
>>>>
>>>> Does it mean included libraries/tools will have to use this specific
>>>> enhancements?
>>>
>>> Speaking for no one but myself, I think that if we get a good
>>> namespace system for OCaml, we should probably require that libraries
>>> in the platform use it.  Agreeing on partitioning names seems like a
>>> fundamental bit of work that a platform requires.
>>>
>>> I would think that there are other things that one would want to
>>> require, like good use of documentation facilities.
>>>
>>>>> ## Platform availability ##
>>>>>
>>>>> We aim for the Platform to be available via other distributions,
>>>>> e.g. Debian, which necessitates binary packages.  Documentation of
>>>>> the included libraries will also be important (see below) and
>>>>> should aid standardisation.
>>>>
>>>> I think we should be more precise on this:
>>>> 1. target stable distribution of linux Distro (e.g. Debian Stable) at
>>>> the time of the release
>>>> 2. will not aim at being officially part of the Distro (i.e. not try
>>>> to have an "ocamlot" package inside Debian)
>>>> 3. will not interfere with the official package coming from the
>>>> distribution (e.g. you can install "ocaml" and
>>>> "libfileutils-ocaml-dev" AND "ocamlot" on the same computer).
>>>>
>>>> Point 2. is quite important, because it is clearly an opportunity to
>>>> provide a working dev env to people using Debian Stable and that want
>>>> to have the latest greatest packages (whereas in Debian, you'll
>>>> probably lagging a bit in term of "latest").
>>>>
>>>>>
>>>>> ## Documentation ##
>>>>>
>>>>> As part of the platform efforts we aim to improve the documentation
>>>>> generation of OCaml tools.  The aim is to support the OCaml
>>>>> Platform with fully cross-referenced documentation from source
>>>>> code, including the ability to incorporate interactive tutorials
>>>>> using the js_of_ocaml compiler.  This would also be combined with a
>>>>> single cross-referenced website.
>>>>>
>>>>> ## Testing and benchmarking ##
>>>>>
>>>>> A continuous integration framework, based on OPAM, will form part
>>>>> of the Platform infrastructure.  We're calling this infrastructure
>>>>> "OCamlot". OPAM packages can be automatically tested upon
>>>>> submission and reports sent back to maintainers.  OCamlot will
>>>>> execute basic unit tests and also, in later versions, integrate
>>>>> benchmarking.  The build infrastructure is intended to run tests on
>>>>> the full range of community packages in OPAM by using secure
>>>>> virtualization under Citrix XenServer.  If you submit a package,
>>>>> you will be rewarded with regular regression tests across many
>>>>> diverse operating systems and platforms.
>>>>>
>>>>> ## Releases and updates ##
>>>>>
>>>>> Upon the first release of the Platform, updates and improvements will form a six-monthly cycle.
>>>>>
>>>>
>>>> I propose to have some kind of "moral contract" with upstream, that
>>>> will need to backport important patches to the current version of
>>>> "ocamlot".
>>>>
>>>>
>>>> Regards
>>>> Sylvain
>>>>
>>>>> Best wishes,
>>>>> Amir
>>>>> _______________________________________________
>>>>> Platform mailing list
>>>>> Platform at lists.ocaml.org
>>>>> http://lists.ocaml.org/listinfo/platform
>>>> _______________________________________________
>>>> Platform mailing list
>>>> Platform at lists.ocaml.org
>>>> http://lists.ocaml.org/listinfo/platform

From daniel.buenzli at erratique.ch  Tue Feb 12 16:52:04 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 12 Feb 2013 17:52:04 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
Message-ID: <B278A2028220473BB899394DBF396033@erratique.ch>

Le lundi, 11 f?vrier 2013 ? 18:17, Amir Chaudhry a ?crit :
> A continuous integration framework, based on OPAM, will form part of the Platform infrastructure. We're calling this infrastructure "OCamlot".  

I just want to let you know that in french this sounds exactly like O camelote (which you could translate by O junk, rubbish, worthless). Now maybe you like to make french words lie.  

Best,

Daniel



From anil at recoil.org  Tue Feb 12 16:53:31 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 12 Feb 2013 16:53:31 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <B278A2028220473BB899394DBF396033@erratique.ch>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <B278A2028220473BB899394DBF396033@erratique.ch>
Message-ID: <0412DAF8-CB9A-4B1F-95FD-DB9F965B7649@recoil.org>

On 12 Feb 2013, at 16:52, Daniel B?nzli <daniel.buenzli at erratique.ch> wrote:

> Le lundi, 11 f?vrier 2013 ? 18:17, Amir Chaudhry a ?crit :
>> A continuous integration framework, based on OPAM, will form part of the Platform infrastructure. We're calling this infrastructure "OCamlot".  
> 
> I just want to let you know that in french this sounds exactly like O camelote (which you could translate by O junk, rubbish, worthless). Now maybe you like to make french words lie.  

I voted for 'opamalot', but got cruelly overridden by everyone else.  Now you can see that I was right!

-anil


From anil at recoil.org  Tue Feb 12 17:02:43 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 12 Feb 2013 17:02:43 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
Message-ID: <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>

On 12 Feb 2013, at 15:23, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:
> 
> In the case of Lwt, the solution is pretty straight forward, you just
> use a thread (Thread) to wrap 1. and produce 2.
> 
> I think the overall question is "do we wish to have a common style for
> non-stdlib features", e.g. monads, file descriptor et al. I don't
> think this is mandatory but can be a nice long term goal.
> 
> But maybe I am going too far, and the point of OCaml Platform is just
> to have  a "set of libraries", tested, packaged together and released
> every 6 months (which is already an ambitious goal). If this is the
> case, please ignore my question -- I'll be already extermly happy to
> see an OCaml Platform in 6 months.

You raise a good question, but there's no easy answer without basics
in place first. After a discussion with JSC/Citrix folks, the very first
focus of the platform is on filling in the blanks on some basic things:

- unified documentation: a cross-referenced documentation set across
multiple libraries, that can be output in different formats. Leo has a
prototype for this based on the new bin-annot files, and will release
it shortly.

- test harness: something that combines unit tests (oUnit) with coverage
and fuzz tests (QuickCheck), and benchmarks (like Criterion in Haskell).
This is something we hope to work with Xavier Clerc on, as he has made
some excellent contributions here.  The test harness should also encode
dependencies on an environment, so that we can run them automatically
in a virtual environment (absolutely required by Citrix, who have an
incredible test suite for Xen that they want to extend to the OCaml code). 

- build: most of the existing build solutions only scale up to small
code bases, so investigating a more unified approach based on compiler-libs
to write an integrated compiler front end that can auto-download
dependencies at the configuration phase, do smart incremental build,
and hook in the test frameworks.

This is all tooling, and can be done independently of the process of
selecting libraries.  For that selection, we need to think of this a bit
like a microkernel: pick the absolute smallest set of libraries we need
(including stripping down the OCaml standard library), and then working
our way up from there into a usable set of package.  Along the way, we'll
need to define 'platform tiers' to determine which ones absolutely have
to supported.

An important note is that there'll be a reward for adapting your code
to run on the Platform.  The test system will regularly run *your* unit
tests on all the support platforms and send you reports.  Don't have a
FreeBSD/mips box, or a Raspberry Pi?  Opamalot will take care of that
for you and let you know if it comes and passes tests.

Amir and Leo are currently writing up the results of the various recent
meetings and will publish it soon.

-anil

From sylvain+ocaml at le-gall.net  Tue Feb 12 18:01:37 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 12 Feb 2013 19:01:37 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
 <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
Message-ID: <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>

2013/2/12 Anil Madhavapeddy <anil at recoil.org>:
> On 12 Feb 2013, at 15:23, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:
>>
>> In the case of Lwt, the solution is pretty straight forward, you just
>> use a thread (Thread) to wrap 1. and produce 2.
>>
>> I think the overall question is "do we wish to have a common style for
>> non-stdlib features", e.g. monads, file descriptor et al. I don't
>> think this is mandatory but can be a nice long term goal.
>>
>> But maybe I am going too far, and the point of OCaml Platform is just
>> to have  a "set of libraries", tested, packaged together and released
>> every 6 months (which is already an ambitious goal). If this is the
>> case, please ignore my question -- I'll be already extermly happy to
>> see an OCaml Platform in 6 months.
>
> You raise a good question, but there's no easy answer without basics
> in place first. After a discussion with JSC/Citrix folks, the very first
> focus of the platform is on filling in the blanks on some basic things:
>
> - unified documentation: a cross-referenced documentation set across
> multiple libraries, that can be output in different formats. Leo has a
> prototype for this based on the new bin-annot files, and will release
> it shortly.

Please coordinate with OASIS project, if we need to generate this
bin-annot file, this is just a matter of changing 2 options and re-run
"oasis setup" before building.

>
> - test harness: something that combines unit tests (oUnit) with coverage
> and fuzz tests (QuickCheck), and benchmarks (like Criterion in Haskell).
> This is something we hope to work with Xavier Clerc on, as he has made
> some excellent contributions here.  The test harness should also encode
> dependencies on an environment, so that we can run them automatically
> in a virtual environment (absolutely required by Citrix, who have an
> incredible test suite for Xen that they want to extend to the OCaml code).
>

Quick note on this point (oUnit):
I am currently working on OUnit 2.0, which will feature:
- HTML output of tests
- JUnit output of tests
- parrallel run of tests (up to your number of core)
- timing...

One of the goal is to integrate well with Jenkins, so that you can
seee the reason why your test is failing directly in the artifact
generated by a test run.

> - build: most of the existing build solutions only scale up to small
> code bases, so investigating a more unified approach based on compiler-libs
> to write an integrated compiler front end that can auto-download
> dependencies at the configuration phase, do smart incremental build,
> and hook in the test frameworks.
>

I would dare to say on this point, that you should focus on "breaking
the longest path". This is an issue we have dealt with since a number
of years in Debian. (each new version of OCaml require to recompile
all packages on all architecture of debian).

Have a look at that:
http://pkg-ocaml-maint.alioth.debian.org/build_order.txt

Each package of a level can be build in parallel. So the compilation
time is roughly the sum of the longest package to build in each level.

The first level is "ocaml', which is among one of the longest step. I
would say that the full set can be build in ~2h on a recent computer.

It is pretty straightforward to write a makefile that will do all this
compilation for you (and it will take you ~30 min to do so). I would
recommed you to start by this very simple solution, that will probably
scale to ~100 packages with no problem.

Knowing the time it takes to compile Haskell or C++, I would say that
we are already pretty good at that -- no need to put it as a top
priority.

> This is all tooling, and can be done independently of the process of
> selecting libraries.  For that selection, we need to think of this a bit
> like a microkernel: pick the absolute smallest set of libraries we need
> (including stripping down the OCaml standard library), and then working
> our way up from there into a usable set of package.  Along the way, we'll
> need to define 'platform tiers' to determine which ones absolutely have
> to supported.
>
> An important note is that there'll be a reward for adapting your code
> to run on the Platform.  The test system will regularly run *your* unit
> tests on all the support platforms and send you reports.  Don't have a
> FreeBSD/mips box, or a Raspberry Pi?  Opamalot will take care of that
> for you and let you know if it comes and passes tests.
>
> Amir and Leo are currently writing up the results of the various recent
> meetings and will publish it soon.
>
> -anil

From gabriel.scherer at gmail.com  Wed Feb 13 13:13:46 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Wed, 13 Feb 2013 14:13:46 +0100
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
 <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
 <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
Message-ID: <CAPFanBGPydLt7iJKhkUj5rZywfNAq_QPz5zzQQBtWU7usGUC0g@mail.gmail.com>

Putting my "Community" and "Free Software" hats on, I wonder about
what the contribution and management process for this "Platform" will
look like. Who exactly is in charge of the project? Who owns the code
it distributes, takes the responsability to react to issues, fix bugs
and evolves the software?

Aiming at "coherence" means having a higher coupling between provided
code than what exists in the community at large (where "community"
here means the wide set of people that publicly releases FLOSS OCaml
software). Is the Platform considered to be a single, unified software
project, or a bundle of several independent software projects?

I know of several models to handle such sort of "starting component of
a programming language ecosystem" (at various degrees of Scale):
- single ownership: a single entity owns and maintains the code: this
is the case of Core, maintained by Jane Street (with an internal
development process), and a well-defined boundary between maintainers
and external contributors (who sign a Contributor License Agreement);
this is also the setting of the "standard library" of most programming
languages (say Scala, Python, or most languages with a distinguished
canonical implementation; also the case of OCaml, but the scope of the
stdlib is much narrower in this case)
- multiple ownership: it is a bundle of individually-owned packages,
the platform mostly choosing to distribute them or not and providing
quality control; my understanding is that this is typically the model
of the Perl CPAN, Haskell's Hackage, etc.; these projects usually have
a wider scope and weaker consistency goals than what seems aimed at
here
- shared ownership: the code ownership is loosely shared between the
various contributors to the project; this is the case of the Linux
kernel, the standard libraries of some languages with strong
contribution dynamics (possibly GHC's library), Batteries, and most
projects that use a Wiki model to build code (eg. Rosetta Code)

What kind of contribution dynamics are you aiming for? When the works
starts to take a shape that is visible to the outside, should I start
telling people "if you have loose time, please consider contributing
to the Platform"?

On Tue, Feb 12, 2013 at 7:01 PM, Sylvain Le Gall
<sylvain+ocaml at le-gall.net> wrote:
> 2013/2/12 Anil Madhavapeddy <anil at recoil.org>:
>> On 12 Feb 2013, at 15:23, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:
>>>
>>> In the case of Lwt, the solution is pretty straight forward, you just
>>> use a thread (Thread) to wrap 1. and produce 2.
>>>
>>> I think the overall question is "do we wish to have a common style for
>>> non-stdlib features", e.g. monads, file descriptor et al. I don't
>>> think this is mandatory but can be a nice long term goal.
>>>
>>> But maybe I am going too far, and the point of OCaml Platform is just
>>> to have  a "set of libraries", tested, packaged together and released
>>> every 6 months (which is already an ambitious goal). If this is the
>>> case, please ignore my question -- I'll be already extermly happy to
>>> see an OCaml Platform in 6 months.
>>
>> You raise a good question, but there's no easy answer without basics
>> in place first. After a discussion with JSC/Citrix folks, the very first
>> focus of the platform is on filling in the blanks on some basic things:
>>
>> - unified documentation: a cross-referenced documentation set across
>> multiple libraries, that can be output in different formats. Leo has a
>> prototype for this based on the new bin-annot files, and will release
>> it shortly.
>
> Please coordinate with OASIS project, if we need to generate this
> bin-annot file, this is just a matter of changing 2 options and re-run
> "oasis setup" before building.
>
>>
>> - test harness: something that combines unit tests (oUnit) with coverage
>> and fuzz tests (QuickCheck), and benchmarks (like Criterion in Haskell).
>> This is something we hope to work with Xavier Clerc on, as he has made
>> some excellent contributions here.  The test harness should also encode
>> dependencies on an environment, so that we can run them automatically
>> in a virtual environment (absolutely required by Citrix, who have an
>> incredible test suite for Xen that they want to extend to the OCaml code).
>>
>
> Quick note on this point (oUnit):
> I am currently working on OUnit 2.0, which will feature:
> - HTML output of tests
> - JUnit output of tests
> - parrallel run of tests (up to your number of core)
> - timing...
>
> One of the goal is to integrate well with Jenkins, so that you can
> seee the reason why your test is failing directly in the artifact
> generated by a test run.
>
>> - build: most of the existing build solutions only scale up to small
>> code bases, so investigating a more unified approach based on compiler-libs
>> to write an integrated compiler front end that can auto-download
>> dependencies at the configuration phase, do smart incremental build,
>> and hook in the test frameworks.
>>
>
> I would dare to say on this point, that you should focus on "breaking
> the longest path". This is an issue we have dealt with since a number
> of years in Debian. (each new version of OCaml require to recompile
> all packages on all architecture of debian).
>
> Have a look at that:
> http://pkg-ocaml-maint.alioth.debian.org/build_order.txt
>
> Each package of a level can be build in parallel. So the compilation
> time is roughly the sum of the longest package to build in each level.
>
> The first level is "ocaml', which is among one of the longest step. I
> would say that the full set can be build in ~2h on a recent computer.
>
> It is pretty straightforward to write a makefile that will do all this
> compilation for you (and it will take you ~30 min to do so). I would
> recommed you to start by this very simple solution, that will probably
> scale to ~100 packages with no problem.
>
> Knowing the time it takes to compile Haskell or C++, I would say that
> we are already pretty good at that -- no need to put it as a top
> priority.
>
>> This is all tooling, and can be done independently of the process of
>> selecting libraries.  For that selection, we need to think of this a bit
>> like a microkernel: pick the absolute smallest set of libraries we need
>> (including stripping down the OCaml standard library), and then working
>> our way up from there into a usable set of package.  Along the way, we'll
>> need to define 'platform tiers' to determine which ones absolutely have
>> to supported.
>>
>> An important note is that there'll be a reward for adapting your code
>> to run on the Platform.  The test system will regularly run *your* unit
>> tests on all the support platforms and send you reports.  Don't have a
>> FreeBSD/mips box, or a Raspberry Pi?  Opamalot will take care of that
>> for you and let you know if it comes and passes tests.
>>
>> Amir and Leo are currently writing up the results of the various recent
>> meetings and will publish it soon.
>>
>> -anil
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From avsm2 at cl.cam.ac.uk  Wed Feb 13 15:03:28 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Wed, 13 Feb 2013 15:03:28 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CAPFanBGPydLt7iJKhkUj5rZywfNAq_QPz5zzQQBtWU7usGUC0g@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
 <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
 <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
 <CAPFanBGPydLt7iJKhkUj5rZywfNAq_QPz5zzQQBtWU7usGUC0g@mail.gmail.com>
Message-ID: <3D52C595-7D31-4300-92E7-1368840A3E24@cl.cam.ac.uk>

The initial process is simple: satisfy the stakeholders who have
committed to wanting the Platform, and are putting resources into
making sure it happens. From the last Consortium meeting, this is
JSC, Citrix and Lexifi in the first instance, expanding to other
Consortium members as appropriate. OCamlPro also have their own
list of people who've expressed interest, of course, and are
heavily involved.

There will no doubt be various expanding circles of support from this
core, but we'll firm that up after we have a concrete thing to discuss.
The actual development will be as open as possible, but I'm keen to
avoid spending lots of time on the issues you describe below without a
baseline.

This isn't to say we don't want people to be involved; quite the
opposite. Until we have a first cut, simply contributing your packages
to the OPAM database will be very helpful to making sure that we have
a representative collection of OCaml packages from which to make
data-driven decisions.

-anil

On 13 Feb 2013, at 13:13, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> Putting my "Community" and "Free Software" hats on, I wonder about
> what the contribution and management process for this "Platform" will
> look like. Who exactly is in charge of the project? Who owns the code
> it distributes, takes the responsability to react to issues, fix bugs
> and evolves the software?
> 
> Aiming at "coherence" means having a higher coupling between provided
> code than what exists in the community at large (where "community"
> here means the wide set of people that publicly releases FLOSS OCaml
> software). Is the Platform considered to be a single, unified software
> project, or a bundle of several independent software projects?
> 
> I know of several models to handle such sort of "starting component of
> a programming language ecosystem" (at various degrees of Scale):
> - single ownership: a single entity owns and maintains the code: this
> is the case of Core, maintained by Jane Street (with an internal
> development process), and a well-defined boundary between maintainers
> and external contributors (who sign a Contributor License Agreement);
> this is also the setting of the "standard library" of most programming
> languages (say Scala, Python, or most languages with a distinguished
> canonical implementation; also the case of OCaml, but the scope of the
> stdlib is much narrower in this case)
> - multiple ownership: it is a bundle of individually-owned packages,
> the platform mostly choosing to distribute them or not and providing
> quality control; my understanding is that this is typically the model
> of the Perl CPAN, Haskell's Hackage, etc.; these projects usually have
> a wider scope and weaker consistency goals than what seems aimed at
> here
> - shared ownership: the code ownership is loosely shared between the
> various contributors to the project; this is the case of the Linux
> kernel, the standard libraries of some languages with strong
> contribution dynamics (possibly GHC's library), Batteries, and most
> projects that use a Wiki model to build code (eg. Rosetta Code)
> 
> What kind of contribution dynamics are you aiming for? When the works
> starts to take a shape that is visible to the outside, should I start
> telling people "if you have loose time, please consider contributing
> to the Platform"?
> 
> On Tue, Feb 12, 2013 at 7:01 PM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> 2013/2/12 Anil Madhavapeddy <anil at recoil.org>:
>>> On 12 Feb 2013, at 15:23, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:
>>>> 
>>>> In the case of Lwt, the solution is pretty straight forward, you just
>>>> use a thread (Thread) to wrap 1. and produce 2.
>>>> 
>>>> I think the overall question is "do we wish to have a common style for
>>>> non-stdlib features", e.g. monads, file descriptor et al. I don't
>>>> think this is mandatory but can be a nice long term goal.
>>>> 
>>>> But maybe I am going too far, and the point of OCaml Platform is just
>>>> to have  a "set of libraries", tested, packaged together and released
>>>> every 6 months (which is already an ambitious goal). If this is the
>>>> case, please ignore my question -- I'll be already extermly happy to
>>>> see an OCaml Platform in 6 months.
>>> 
>>> You raise a good question, but there's no easy answer without basics
>>> in place first. After a discussion with JSC/Citrix folks, the very first
>>> focus of the platform is on filling in the blanks on some basic things:
>>> 
>>> - unified documentation: a cross-referenced documentation set across
>>> multiple libraries, that can be output in different formats. Leo has a
>>> prototype for this based on the new bin-annot files, and will release
>>> it shortly.
>> 
>> Please coordinate with OASIS project, if we need to generate this
>> bin-annot file, this is just a matter of changing 2 options and re-run
>> "oasis setup" before building.
>> 
>>> 
>>> - test harness: something that combines unit tests (oUnit) with coverage
>>> and fuzz tests (QuickCheck), and benchmarks (like Criterion in Haskell).
>>> This is something we hope to work with Xavier Clerc on, as he has made
>>> some excellent contributions here.  The test harness should also encode
>>> dependencies on an environment, so that we can run them automatically
>>> in a virtual environment (absolutely required by Citrix, who have an
>>> incredible test suite for Xen that they want to extend to the OCaml code).
>>> 
>> 
>> Quick note on this point (oUnit):
>> I am currently working on OUnit 2.0, which will feature:
>> - HTML output of tests
>> - JUnit output of tests
>> - parrallel run of tests (up to your number of core)
>> - timing...
>> 
>> One of the goal is to integrate well with Jenkins, so that you can
>> seee the reason why your test is failing directly in the artifact
>> generated by a test run.
>> 
>>> - build: most of the existing build solutions only scale up to small
>>> code bases, so investigating a more unified approach based on compiler-libs
>>> to write an integrated compiler front end that can auto-download
>>> dependencies at the configuration phase, do smart incremental build,
>>> and hook in the test frameworks.
>>> 
>> 
>> I would dare to say on this point, that you should focus on "breaking
>> the longest path". This is an issue we have dealt with since a number
>> of years in Debian. (each new version of OCaml require to recompile
>> all packages on all architecture of debian).
>> 
>> Have a look at that:
>> http://pkg-ocaml-maint.alioth.debian.org/build_order.txt
>> 
>> Each package of a level can be build in parallel. So the compilation
>> time is roughly the sum of the longest package to build in each level.
>> 
>> The first level is "ocaml', which is among one of the longest step. I
>> would say that the full set can be build in ~2h on a recent computer.
>> 
>> It is pretty straightforward to write a makefile that will do all this
>> compilation for you (and it will take you ~30 min to do so). I would
>> recommed you to start by this very simple solution, that will probably
>> scale to ~100 packages with no problem.
>> 
>> Knowing the time it takes to compile Haskell or C++, I would say that
>> we are already pretty good at that -- no need to put it as a top
>> priority.
>> 
>>> This is all tooling, and can be done independently of the process of
>>> selecting libraries.  For that selection, we need to think of this a bit
>>> like a microkernel: pick the absolute smallest set of libraries we need
>>> (including stripping down the OCaml standard library), and then working
>>> our way up from there into a usable set of package.  Along the way, we'll
>>> need to define 'platform tiers' to determine which ones absolutely have
>>> to supported.
>>> 
>>> An important note is that there'll be a reward for adapting your code
>>> to run on the Platform.  The test system will regularly run *your* unit
>>> tests on all the support platforms and send you reports.  Don't have a
>>> FreeBSD/mips box, or a Raspberry Pi?  Opamalot will take care of that
>>> for you and let you know if it comes and passes tests.
>>> 
>>> Amir and Leo are currently writing up the results of the various recent
>>> meetings and will publish it soon.
>>> 
>>> -anil
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
> 


From anil at recoil.org  Wed Feb 13 15:08:50 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Wed, 13 Feb 2013 15:08:50 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
 <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
 <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
Message-ID: <836DE36F-8BEC-4FFD-8418-C59E06832A37@recoil.org>

On 12 Feb 2013, at 18:01, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:

>> - unified documentation: a cross-referenced documentation set across
>> multiple libraries, that can be output in different formats. Leo has a
>> prototype for this based on the new bin-annot files, and will release
>> it shortly.
> 
> Please coordinate with OASIS project, if we need to generate this
> bin-annot file, this is just a matter of changing 2 options and re-run
> "oasis setup" before building.

Not sure what coordination is required here.  bin-annot is part of
ocaml-4.00.0+, so you should be able to generate this by default if the
correct compiler is available.

Having said that, it looks like a -bin-annot tag never got added to
ocamlbuild to match the 'annot' tag, so using it will require yet another
entry in the generated myocamlbuild.ml.

-anil

From mlin at mlin.net  Wed Feb 13 20:10:04 2013
From: mlin at mlin.net (Mike Lin)
Date: Wed, 13 Feb 2013 12:10:04 -0800
Subject: [ocaml-platform] OCamlot
Message-ID: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>

On Mon, Feb 11, 2013 at 9:17 AM, Amir Chaudhry <amc79 at cam.ac.uk> wrote:

>
> ## Testing and benchmarking ##
>
> A continuous integration framework, based on OPAM, will form part of the
> Platform infrastructure.  We're calling this infrastructure "OCamlot". OPAM
> packages can be automatically tested upon submission and reports sent back
> to maintainers.  OCamlot will execute basic unit tests and also, in later
> versions, integrate benchmarking.  The build infrastructure is intended to
> run tests on the full range of community packages in OPAM by using secure
> virtualization under Citrix XenServer.  If you submit a package, you will
> be rewarded with regular regression tests across many diverse operating
> systems and platforms.
>

This in itself sounds like quite a big project! I was wondering, how far
along is it, and what other basic tools are being used? (e.g. I think Anil
has tangentially mentioned there's a Jenkins instance for OPAM)

Was thorough consideration given to building upon/contributing to existing
hosted services like Travis CI or BuildHive? I've had quite good
experiences with these lately, and the default build time limits can be
negotiated, especially if you chip in a couple worker nodes or a bit of
cash.

Mike
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130213/0beafe81/attachment-0001.html>

From amc79 at cam.ac.uk  Wed Feb 13 20:48:01 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Wed, 13 Feb 2013 20:48:01 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
Message-ID: <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>


On 13 Feb 2013, at 20:10, Mike Lin <mlin at mlin.net> wrote:

> On Mon, Feb 11, 2013 at 9:17 AM, Amir Chaudhry <amc79 at cam.ac.uk> wrote:
> 
> ## Testing and benchmarking ##
> 
> A continuous integration framework, based on OPAM, will form part of the Platform infrastructure.  We're calling this infrastructure "OCamlot". OPAM packages can be automatically tested upon submission and reports sent back to maintainers.  OCamlot will execute basic unit tests and also, in later versions, integrate benchmarking.  The build infrastructure is intended to run tests on the full range of community packages in OPAM by using secure virtualization under Citrix XenServer.  If you submit a package, you will be rewarded with regular regression tests across many diverse operating systems and platforms.
> 
> This in itself sounds like quite a big project! I was wondering, how far along is it, and what other basic tools are being used? (e.g. I think Anil has tangentially mentioned there's a Jenkins instance for OPAM)
> 
> Was thorough consideration given to building upon/contributing to existing hosted services like Travis CI or BuildHive? I've had quite good experiences with these lately, and the default build time limits can be negotiated, especially if you chip in a couple worker nodes or a bit of cash.


I'm aware of Travis CI but not looked into BuildHive.  In either case, we're limited to what's offered by those services.  That's Ubuntu Linux 12.04 VMs for Travis and Fedora 17 for BuildHive.  We probably want more targets than this as well as more control, especially in the case of trying to do benchmarking.

Travis CI: http://about.travis-ci.org/docs/user/ci-environment/
BuildHive: https://developer.cloudbees.com/bin/view/DEV/Jenkins+Build%20Machine%20Specifications

Best wishes,
Amir

From mlin at mlin.net  Wed Feb 13 21:24:30 2013
From: mlin at mlin.net (Mike Lin)
Date: Wed, 13 Feb 2013 13:24:30 -0800
Subject: [ocaml-platform] OCamlot
In-Reply-To: <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
Message-ID: <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>

On Wed, Feb 13, 2013 at 12:48 PM, Amir Chaudhry <amc79 at cam.ac.uk> wrote:

>
> > Was thorough consideration given to building upon/contributing to
> existing hosted services like Travis CI or BuildHive? I've had quite good
> experiences with these lately, and the default build time limits can be
> negotiated, especially if you chip in a couple worker nodes or a bit of
> cash.
>
>
> I'm aware of Travis CI but not looked into BuildHive.  In either case,
> we're limited to what's offered by those services.


So therefore we build one from scratch!!??

Travis CI in particular is an open source and highly community-driven
project; GitHub shows almost 200 accepted pull requests. The current
limited OS support probably stems from its origins in Ruby/PHP/Node.js/etc.
where the underlying OS is less influential. But they do also have OS X
workers now, and contributing support for additional platforms would be
highly valuable to a broad community- not just OCaml developers.

I'd asked whether options like that were thoroughly considered before
deciding to invent one here, and I'm sorry but I haven't gotten that
impression so far.

BTW, there are dozens of Haskell projects in Travis CI. Just sayin' :)

Mike
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130213/1997d976/attachment.html>

From edwin+ml-ocaml at etorok.net  Wed Feb 13 22:20:12 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Thu, 14 Feb 2013 00:20:12 +0200
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
Message-ID: <511C119C.7000400@etorok.net>

On 02/13/2013 11:24 PM, Mike Lin wrote:
> 
> 
> 
> On Wed, Feb 13, 2013 at 12:48 PM, Amir Chaudhry <amc79 at cam.ac.uk <mailto:amc79 at cam.ac.uk>> wrote:
> 
> 
>     > Was thorough consideration given to building upon/contributing to existing hosted services like Travis CI or BuildHive? I've had quite good experiences with these lately, and the default build
>     time limits can be negotiated, especially if you chip in a couple worker nodes or a bit of cash.
> 
> 
>     I'm aware of Travis CI but not looked into BuildHive.  In either case, we're limited to what's offered by those services. 
> 
> 
> So therefore we build one from scratch!!??
> 
> Travis CI in particular is an open source and highly community-driven project; GitHub shows almost 200 accepted pull requests. The current limited OS support probably stems from its origins in
> Ruby/PHP/Node.js/etc. where the underlying OS is less influential. But they do also have OS X workers now, and contributing support for additional platforms would be highly valuable to a broad
> community- not just OCaml developers.
> 
> I'd asked whether options like that were thoroughly considered before deciding to invent one here, and I'm sorry but I haven't gotten that impression so far. 
> 
> BTW, there are dozens of Haskell projects in Travis CI. Just sayin' :)

buildbot.net is something you can run on your own (or donated) infrastructure and its quite configurable & portable, see for example:
http://lab.llvm.org:8011/builders
http://lab.llvm.org:8011/console

As for running daily builds on various architectures you don't otherwise have access to:
http://gcc.gnu.org/wiki/CompileFarm
They are NOT just gcc/gnu specific, although some of the boxes are quite slow so I wouldn't build all of opam packages there,
perhaps just 'ocaml + ocaml platform'.

If for some reason you need Solaris builds I've had good experience with:
http://www.opencsw.org/extend-it/signup/to-upstream-maintainers/

Best regards,
--Edwin

From avsm2 at cl.cam.ac.uk  Wed Feb 13 22:42:55 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Wed, 13 Feb 2013 22:42:55 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
Message-ID: <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>

On 13 Feb 2013, at 21:24, Mike Lin <mlin at mlin.net> wrote:
> 
> So therefore we build one from scratch!!??
<snip>
> 
> I'd asked whether options like that were thoroughly considered before deciding to invent one here, and I'm sorry but I haven't gotten that impression so far. 

Yeah, of course.  As with all these things, there's a combination of broad requirements ("does it build on X") with rather specialised ones ("I need to fork this OPAM chroot to build these 3 variants in independent copy-on-write trees").

The question is whether or not a hosted service will hit a brick wall where we simply can't do something we need that's a bit more specialised.  At that point, we'll end up reimplementing all the basic stuff too.

Opamalot is more of a coordination service.  It interfaces with OPAM to get the (non-trivial) package database, version constraints and compiler variants out of it, and comes up with a prioritised schedule of builds and tests that need to be run on different platforms.  Some of these could (and should) run on third-party hosted services such as Travis, just to get some diversity.  Others, however, really require a Xen pool so that more exotic stuff can be done.

For example, the Mirage microkernel should work with a large number of pure OCaml libraries.  Wouldn't it be cool if one of the tests that ran showed you the results of that compilation, and if it fails, what the external dependencies are?  This will never run efficiently on any third-party infrastructure, and it's the ultimate test of portability.

Another one are some of the Citrix/Xen libraries, which require a Xen host to run certain feature tests. This could be hosted on EC2, but probably wouldn't work on Travis (I don't know what hypervisor they use).

Anyway, we're still working our way through what Opamalot should be, but rest assured that it's not an NIH mindset that's causing us to shy away from a third party build service.  When we're growing from nothing as we are, it's nice to have a bit more control over our own infrastructure, and scale out to these hosting services but not be entirely dependent on them.

Note also that Citrix already has an absolutely epic home-grown test suit for Xen that continuously runs hundreds of thousands of functional and stress tests across OCaml code on a large number of physical hosts.  Jon Ludlam's been doing some work on  interfacing OPAM with it.  I'm not entirely sure what that's going to end up looking like, but it's a positive thing :-)

-anil

PS: I was really pleased to see your post about Travis/OCaml/OPAM, as it's been on my list to try for *ages*.  I'm going to give it a whirl this weekend with cohttp!

From avsm2 at cl.cam.ac.uk  Wed Feb 13 22:53:04 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Wed, 13 Feb 2013 22:53:04 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
Message-ID: <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>

On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:

> Opamalot is more of a coordination service.  It interfaces with OPAM to get the (non-trivial) package database, version constraints and compiler variants out of it, and comes up with a prioritised schedule of builds and tests that need to be run on different platforms.  Some of these could (and should) run on third-party hosted services such as Travis, just to get some diversity.  Others, however, really require a Xen pool so that more exotic stuff can be done.

It's also worth noting the difference in execution speeds for adopting a copy-on-write approach.  We  need to test 300+ packages (which will grow) across 3.12.1/4.00.0/4.00.1/4.01.0dev and experimental compiler branches, ideally without recompiling the compiler for each package.  If a package fails to build on a fast architecture (x86), it should immediately be dropped from a slow one.

When Jane Street issues a pull request for a new version of Core [1] we need to run these tests quickly to avoid holding up the release and prioritise that over other pull requests, since it's a high risk patch that touches a lot of other packages.

It's certainly possible to code this up in Travis, but it's certainly not part of the standard continuous build service (unless one of these does offer this -- I would be delighted to be corrected).

I tried building it as a Jenkins plugin, but frankly, life's too short for that.  I can't even get the Jenkins port to install on FreeBSD 9.1/amd64 due to some OpenJDK/JIT compile error.  And the Raspberry Pi is in even worse shape with a big hunk of RAM taken up by a Jenkins worker.

-anil


[1] https://github.com/OCamlPro/opam-repository/pull/382

From wojciech.meyer at gmail.com  Wed Feb 13 23:34:03 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Wed, 13 Feb 2013 23:34:03 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk> (Anil
 Madhavapeddy's message of "Wed, 13 Feb 2013 22:53:04 +0000")
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
Message-ID: <wf38wzkcus.fsf@gmail.com>

Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> writes:

> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
> If a package fails to build on a fast architecture (x86), it should
> immediately be dropped from a slow one.

Atom X86 is actually already slower than ARM Cortex-A15 :-) [*]

My two cents,

--
Wojciech Meyer
http://danmey.org

[*] http://www.androidauthority.com/dual-core-arm-cortex-a15-is-fast-135978/

From mlin at mlin.net  Wed Feb 13 23:36:30 2013
From: mlin at mlin.net (Mike Lin)
Date: Wed, 13 Feb 2013 15:36:30 -0800
Subject: [ocaml-platform] OCamlot
In-Reply-To: <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
Message-ID: <CADxsieZgtxcPCAsVcLH=2K_Hyhe4Odj2YBWGz+zOdSZC=4jgug@mail.gmail.com>

Thanks Anil for coloring in so much detail. Clearly this is actually a lot
more ambitious than my conception of Travis with more OSes :)
I'll look forward to seeing how it all comes together.
Mike



On Wed, Feb 13, 2013 at 2:53 PM, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk>wrote:

> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
>
> > Opamalot is more of a coordination service.  It interfaces with OPAM to
> get the (non-trivial) package database, version constraints and compiler
> variants out of it, and comes up with a prioritised schedule of builds and
> tests that need to be run on different platforms.  Some of these could (and
> should) run on third-party hosted services such as Travis, just to get some
> diversity.  Others, however, really require a Xen pool so that more exotic
> stuff can be done.
>
> It's also worth noting the difference in execution speeds for adopting a
> copy-on-write approach.  We  need to test 300+ packages (which will grow)
> across 3.12.1/4.00.0/4.00.1/4.01.0dev and experimental compiler branches,
> ideally without recompiling the compiler for each package.  If a package
> fails to build on a fast architecture (x86), it should immediately be
> dropped from a slow one.
>
> When Jane Street issues a pull request for a new version of Core [1] we
> need to run these tests quickly to avoid holding up the release and
> prioritise that over other pull requests, since it's a high risk patch that
> touches a lot of other packages.
>
> It's certainly possible to code this up in Travis, but it's certainly not
> part of the standard continuous build service (unless one of these does
> offer this -- I would be delighted to be corrected).
>
> I tried building it as a Jenkins plugin, but frankly, life's too short for
> that.  I can't even get the Jenkins port to install on FreeBSD 9.1/amd64
> due to some OpenJDK/JIT compile error.  And the Raspberry Pi is in even
> worse shape with a big hunk of RAM taken up by a Jenkins worker.
>
> -anil
>
>
> [1] https://github.com/OCamlPro/opam-repository/pull/382
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130213/da9471b9/attachment-0001.html>

From avsm2 at cl.cam.ac.uk  Thu Feb 14 10:53:28 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Thu, 14 Feb 2013 10:53:28 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <wf38wzkcus.fsf@gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
 <wf38wzkcus.fsf@gmail.com>
Message-ID: <21D05975-87E3-4077-9EAE-E5421FF450EB@cl.cam.ac.uk>

On 13 Feb 2013, at 23:34, Wojciech Meyer <wojciech.meyer at gmail.com> wrote:

> Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> writes:
> 
>> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
>> If a package fails to build on a fast architecture (x86), it should
>> immediately be dropped from a slow one.
> 
> Atom X86 is actually already slower than ARM Cortex-A15 :-) [*]

Fair cop; I've been doing some day-to-day dev on my A15 Chromebook
and it's been pretty good... 

-anil


From sylvain+ocaml at le-gall.net  Thu Feb 14 11:15:15 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Thu, 14 Feb 2013 12:15:15 +0100
Subject: [ocaml-platform] OCamlot
In-Reply-To: <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
Message-ID: <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>

2013/2/13 Anil Madhavapeddy <avsm2 at cl.cam.ac.uk>:
> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
>
>> Opamalot is more of a coordination service.  It interfaces with OPAM to get the (non-trivial) package database, version constraints and compiler variants out of it, and comes up with a prioritised schedule of builds and tests that need to be run on different platforms.  Some of these could (and should) run on third-party hosted services such as Travis, just to get some diversity.  Others, however, really require a Xen pool so that more exotic stuff can be done.
>
> It's also worth noting the difference in execution speeds for adopting a copy-on-write approach.  We  need to test 300+ packages (which will grow) across 3.12.1/4.00.0/4.00.1/4.01.0dev and experimental compiler branches, ideally without recompiling the compiler for each package.  If a package fails to build on a fast architecture (x86), it should immediately be dropped from a slow one.

Humm, to be honest, I will:
1. limit the number of compiler version (4.00.1 or 4.01.0 when it will be out)
2. limit the number of packages

I think 300+ packages in OPAM term is the number of tarball. Let's
just take either the last one or the last one that we were to build on
all platform. I don't want to have OUnit 1.1.0 and 2.0.0...

Concerning Travis/Jenkins/whatever, I think we should consider this:
- just create a shell script that do the job and don't interface
strongly with the build system in the core job
- most of the builder I know, can have some restriction, esp
concerning accessing the network. This is not always true but we
should try to avoid downloading stuff
- create a big git repository that basically contains an opam
repository + the builder shell script and do the job inside it
- try to output the results of tests/build in a "common test result
format" (either TAP or JUnit)
- consider that most platform don't allow you to install stuff that
are 3rd party (e.g. C libraries that comes with the OS, like libzmq0
or libfoo.so.XX), I don't think we should build them on our own (let's
focus on OCaml)

I think this can be done independently of the platform we use for
continuous integration, when we will have gained some experience, we
can enhance the process for a specific/preferred platform.

I start to play quite nicely with Jenkins and I think you don't have
to build any plugin to make it works:
- use a matrix project to build on all platform, have a first step on
1 particular platform that need to succeed (integrated, I use it)
- use a shell script to start the build, no maven, no ant (I use it)
- ...

I will look at memory issue with java worker... Let's say I have a
couple of Java specialist sitting next to me. I will need to run one
on my RPi...

Regards
Sylvain

From avsm2 at cl.cam.ac.uk  Thu Feb 14 11:22:03 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Thu, 14 Feb 2013 11:22:03 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
 <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
Message-ID: <44382AB3-6433-45D9-A7E0-A311BCEF7E05@cl.cam.ac.uk>

On 14 Feb 2013, at 11:15, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:

> 2013/2/13 Anil Madhavapeddy <avsm2 at cl.cam.ac.uk>:
>> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
>> 
>>> Opamalot is more of a coordination service.  It interfaces with OPAM to get the (non-trivial) package database, version constraints and compiler variants out of it, and comes up with a prioritised schedule of builds and tests that need to be run on different platforms.  Some of these could (and should) run on third-party hosted services such as Travis, just to get some diversity.  Others, however, really require a Xen pool so that more exotic stuff can be done.
>> 
>> It's also worth noting the difference in execution speeds for adopting a copy-on-write approach.  We  need to test 300+ packages (which will grow) across 3.12.1/4.00.0/4.00.1/4.01.0dev and experimental compiler branches, ideally without recompiling the compiler for each package.  If a package fails to build on a fast architecture (x86), it should immediately be dropped from a slow one.
> 
> Humm, to be honest, I will:
> 1. limit the number of compiler version (4.00.1 or 4.01.0 when it will be out)
> 2. limit the number of packages

The whole point of this system is to test your code on systems that you wouldn't otherwise have access to.  It's much easier to fix breakage by testing continuously against trunk compiler versions, or ARM, or MIPS, on an ongoing basis.

> I think 300+ packages in OPAM term is the number of tarball. Let's
> just take either the last one or the last one that we were to build on
> all platform. I don't want to have OUnit 1.1.0 and 2.0.0...

That's the point of prioritising builds, but remember that older versions
are often depended on by packages, and don't just disappear from the
dependency chain.

-anil

From wojciech.meyer at gmail.com  Thu Feb 14 11:23:34 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Thu, 14 Feb 2013 11:23:34 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
 <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
Message-ID: <CAOg1smC3V8tjNgVwAQAhPvGojJzqAOu-AFbNUHZ-NOKGNo50Lg@mail.gmail.com>

Hi,

Without reading the full thread, as I am at work now.

I'd suggest two important points:

1) writing up, what kind of permutation of os, archtiectures,
compilers,packages we want to test, which are must have, which are
less irrelevant. Maybe at some point we will find that some of the
packages will be more important on the different architectures, so the
list have to be prioritised to schedule jobs efficiently.
2) what other platforms do, what Ruby for rvm does, and Python with
pip does, and maybe what Haskell and cabal does - with the interpreted
languages the requirement of testing on a different architecture is
somewhat lifted.

These are fairly obvious, but once we know it, we probably in a better
position to asses what kind of resources we need..
Wojciech


On Thu, Feb 14, 2013 at 11:15 AM, Sylvain Le Gall
<sylvain+ocaml at le-gall.net> wrote:
> 2013/2/13 Anil Madhavapeddy <avsm2 at cl.cam.ac.uk>:
>> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
>>
>>> Opamalot is more of a coordination service.  It interfaces with OPAM to get the (non-trivial) package database, version constraints and compiler variants out of it, and comes up with a prioritised schedule of builds and tests that need to be run on different platforms.  Some of these could (and should) run on third-party hosted services such as Travis, just to get some diversity.  Others, however, really require a Xen pool so that more exotic stuff can be done.
>>
>> It's also worth noting the difference in execution speeds for adopting a copy-on-write approach.  We  need to test 300+ packages (which will grow) across 3.12.1/4.00.0/4.00.1/4.01.0dev and experimental compiler branches, ideally without recompiling the compiler for each package.  If a package fails to build on a fast architecture (x86), it should immediately be dropped from a slow one.
>
> Humm, to be honest, I will:
> 1. limit the number of compiler version (4.00.1 or 4.01.0 when it will be out)
> 2. limit the number of packages
>
> I think 300+ packages in OPAM term is the number of tarball. Let's
> just take either the last one or the last one that we were to build on
> all platform. I don't want to have OUnit 1.1.0 and 2.0.0...
>
> Concerning Travis/Jenkins/whatever, I think we should consider this:
> - just create a shell script that do the job and don't interface
> strongly with the build system in the core job
> - most of the builder I know, can have some restriction, esp
> concerning accessing the network. This is not always true but we
> should try to avoid downloading stuff
> - create a big git repository that basically contains an opam
> repository + the builder shell script and do the job inside it
> - try to output the results of tests/build in a "common test result
> format" (either TAP or JUnit)
> - consider that most platform don't allow you to install stuff that
> are 3rd party (e.g. C libraries that comes with the OS, like libzmq0
> or libfoo.so.XX), I don't think we should build them on our own (let's
> focus on OCaml)
>
> I think this can be done independently of the platform we use for
> continuous integration, when we will have gained some experience, we
> can enhance the process for a specific/preferred platform.
>
> I start to play quite nicely with Jenkins and I think you don't have
> to build any plugin to make it works:
> - use a matrix project to build on all platform, have a first step on
> 1 particular platform that need to succeed (integrated, I use it)
> - use a shell script to start the build, no maven, no ant (I use it)
> - ...
>
> I will look at memory issue with java worker... Let's say I have a
> couple of Java specialist sitting next to me. I will need to run one
> on my RPi...
>
> Regards
> Sylvain
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From wojciech.meyer at gmail.com  Thu Feb 14 11:24:53 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Thu, 14 Feb 2013 11:24:53 +0000
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CAOg1smC3V8tjNgVwAQAhPvGojJzqAOu-AFbNUHZ-NOKGNo50Lg@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
 <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
 <CAOg1smC3V8tjNgVwAQAhPvGojJzqAOu-AFbNUHZ-NOKGNo50Lg@mail.gmail.com>
Message-ID: <CAOg1smDUHqtXZwr4E5v9oQ84sBNu9fjh05KRVmDfMub7gUwv_A@mail.gmail.com>

Ooops apologises, of course it was raised before, sorry!

On Thu, Feb 14, 2013 at 11:23 AM, Wojciech Meyer
<wojciech.meyer at gmail.com> wrote:
> Hi,
>
> Without reading the full thread, as I am at work now.
>
> I'd suggest two important points:
>
> 1) writing up, what kind of permutation of os, archtiectures,
> compilers,packages we want to test, which are must have, which are
> less irrelevant. Maybe at some point we will find that some of the
> packages will be more important on the different architectures, so the
> list have to be prioritised to schedule jobs efficiently.
> 2) what other platforms do, what Ruby for rvm does, and Python with
> pip does, and maybe what Haskell and cabal does - with the interpreted
> languages the requirement of testing on a different architecture is
> somewhat lifted.
>
> These are fairly obvious, but once we know it, we probably in a better
> position to asses what kind of resources we need..
> Wojciech
>
>
> On Thu, Feb 14, 2013 at 11:15 AM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> 2013/2/13 Anil Madhavapeddy <avsm2 at cl.cam.ac.uk>:
>>> On 13 Feb 2013, at 22:42, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk> wrote:
>>>
>>>> Opamalot is more of a coordination service.  It interfaces with OPAM to get the (non-trivial) package database, version constraints and compiler variants out of it, and comes up with a prioritised schedule of builds and tests that need to be run on different platforms.  Some of these could (and should) run on third-party hosted services such as Travis, just to get some diversity.  Others, however, really require a Xen pool so that more exotic stuff can be done.
>>>
>>> It's also worth noting the difference in execution speeds for adopting a copy-on-write approach.  We  need to test 300+ packages (which will grow) across 3.12.1/4.00.0/4.00.1/4.01.0dev and experimental compiler branches, ideally without recompiling the compiler for each package.  If a package fails to build on a fast architecture (x86), it should immediately be dropped from a slow one.
>>
>> Humm, to be honest, I will:
>> 1. limit the number of compiler version (4.00.1 or 4.01.0 when it will be out)
>> 2. limit the number of packages
>>
>> I think 300+ packages in OPAM term is the number of tarball. Let's
>> just take either the last one or the last one that we were to build on
>> all platform. I don't want to have OUnit 1.1.0 and 2.0.0...
>>
>> Concerning Travis/Jenkins/whatever, I think we should consider this:
>> - just create a shell script that do the job and don't interface
>> strongly with the build system in the core job
>> - most of the builder I know, can have some restriction, esp
>> concerning accessing the network. This is not always true but we
>> should try to avoid downloading stuff
>> - create a big git repository that basically contains an opam
>> repository + the builder shell script and do the job inside it
>> - try to output the results of tests/build in a "common test result
>> format" (either TAP or JUnit)
>> - consider that most platform don't allow you to install stuff that
>> are 3rd party (e.g. C libraries that comes with the OS, like libzmq0
>> or libfoo.so.XX), I don't think we should build them on our own (let's
>> focus on OCaml)
>>
>> I think this can be done independently of the platform we use for
>> continuous integration, when we will have gained some experience, we
>> can enhance the process for a specific/preferred platform.
>>
>> I start to play quite nicely with Jenkins and I think you don't have
>> to build any plugin to make it works:
>> - use a matrix project to build on all platform, have a first step on
>> 1 particular platform that need to succeed (integrated, I use it)
>> - use a shell script to start the build, no maven, no ant (I use it)
>> - ...
>>
>> I will look at memory issue with java worker... Let's say I have a
>> couple of Java specialist sitting next to me. I will need to run one
>> on my RPi...
>>
>> Regards
>> Sylvain
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From wojciech.meyer at gmail.com  Thu Feb 14 19:28:12 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Thu, 14 Feb 2013 19:28:12 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <836DE36F-8BEC-4FFD-8418-C59E06832A37@recoil.org> (Anil
 Madhavapeddy's message of "Wed, 13 Feb 2013 15:08:50 +0000")
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
 <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
 <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
 <836DE36F-8BEC-4FFD-8418-C59E06832A37@recoil.org>
Message-ID: <wfy5eqitkj.fsf@gmail.com>

Anil Madhavapeddy <anil at recoil.org> writes:

> Having said that, it looks like a -bin-annot tag never got added to
> ocamlbuild to match the 'annot' tag, so using it will require yet another
> entry in the generated myocamlbuild.ml.

I'll add it tonight.

-- 
Wojciech Meyer
http://danmey.org

From wojciech.meyer at gmail.com  Thu Feb 14 23:58:31 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Thu, 14 Feb 2013 23:58:31 +0000
Subject: [ocaml-platform] The OCaml Platform
In-Reply-To: <wfy5eqitkj.fsf@gmail.com> (Wojciech Meyer's message of "Thu, 14
 Feb 2013 19:28:12 +0000")
References: <53705329-A8E0-4106-ABDD-0298A8A75B2C@cam.ac.uk>
 <CAOCAUGPRsjQ++QWWcFNtSG6H1OORW1TmSswW5eYZTM6ctGxdSQ@mail.gmail.com>
 <CACLX4jRFS8bpg86G929dqDAcKJeAEe__t_ws+xXiHftoNghegQ@mail.gmail.com>
 <CAOCAUGNLd4tnAHizSKZdcS4uJmkmx4HuqnecKC2YWMNFJepcow@mail.gmail.com>
 <CACLX4jS+zy9289u3mHz+17n7S03KnZLHsey9TAc-d-bJhacxYQ@mail.gmail.com>
 <CAOCAUGP00NanJ=feZq-CetOZ1RYQEL6qG6=UQ5rSgJcM__4L2g@mail.gmail.com>
 <B97940A2-7A7C-46F7-9098-ECB5A8724F33@recoil.org>
 <CAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf=+5Jv6Aw@mail.gmail.com>
 <836DE36F-8BEC-4FFD-8418-C59E06832A37@recoil.org>
 <wfy5eqitkj.fsf@gmail.com>
Message-ID: <wfpq02ih20.fsf@gmail.com>

Wojciech Meyer <wojciech.meyer at gmail.com> writes:

> Anil Madhavapeddy <anil at recoil.org> writes:
>
>> Having said that, it looks like a -bin-annot tag never got added to
>> ocamlbuild to match the 'annot' tag, so using it will require yet another
>> entry in the generated myocamlbuild.ml.
>
> I'll add it tonight.

Actually due to my big surprise bin_annot tag was added with this commit:

commit 80e0d7f14d78a5336722f12bef94b1282506a741
Author: protzenk <protzenk at f963ae5c-01c2-4b8c-9fe0-0dff7051ff02>
Date:   Sat Nov 10 15:02:56 2012 +0000

    Add a new bin_annot tag to OCamlbuild.

not sure if shouldn't rename it to bin-annot to match the command line
option. So it's present on trunk.

Cheers,
--
Wojciech Meyer
http://danmey.org

From yminsky at janestreet.com  Fri Feb 15 03:17:47 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 14 Feb 2013 22:17:47 -0500
Subject: [ocaml-platform] Does Core change too often?
Message-ID: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>

Right now, the Core suite of libraries changes a lot --- we have a new
release of everything every week.  The changes on a given week are
small, but there are always changes.

I can imagine this being something of a problem for OPAM.  If packages
specify specific revisions of the Core suite, then we're going to have
a massive version mismatch problem, where no two libraries can agree
on the version of Core that they need.

I have no obvious ideas as to how to solve this.  Does anyone else
have ideas?  Should we simply encourage packagers to specify a
lower-bound constraint on the Core libraries?

y

From thomas at ocamlpro.com  Fri Feb 15 09:48:00 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Fri, 15 Feb 2013 10:48:00 +0100
Subject: [ocaml-platform] OCamlot
In-Reply-To: <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
 <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
Message-ID: <25AF9514-73D0-4B03-A383-10D9D04F7D40@ocamlpro.com>

> Humm, to be honest, I will:
> 1. limit the number of compiler version (4.00.1 or 4.01.0 when it will be out)
> 2. limit the number of packages
> 
> I think 300+ packages in OPAM term is the number of tarball. Let's
> just take either the last one or the last one that we were to build on
> all platform. I don't want to have OUnit 1.1.0 and 2.0.0...

From my point-of-view, I really would like to see most of the 650+ packages (ie. 350+ unique packages) to be tested, in order to get a very precise idea of the dependencies constraints. This is indeed less useful than getting the latest version for each package, but it's quite important in order to get a reliable and consistent user experience.

Regarding the compiler versions, I think it's very useful to have an easy way to automatically test and benchmarks experimental SVN branches to look for regressions before integrating them in trunk, so I really think that opamalot should be able to do this as well.

Thomas

> 
> Concerning Travis/Jenkins/whatever, I think we should consider this:
> - just create a shell script that do the job and don't interface
> strongly with the build system in the core job
> - most of the builder I know, can have some restriction, esp
> concerning accessing the network. This is not always true but we
> should try to avoid downloading stuff
> - create a big git repository that basically contains an opam
> repository + the builder shell script and do the job inside it
> - try to output the results of tests/build in a "common test result
> format" (either TAP or JUnit)
> - consider that most platform don't allow you to install stuff that
> are 3rd party (e.g. C libraries that comes with the OS, like libzmq0
> or libfoo.so.XX), I don't think we should build them on our own (let's
> focus on OCaml)
> 
> I think this can be done independently of the platform we use for
> continuous integration, when we will have gained some experience, we
> can enhance the process for a specific/preferred platform.
> 
> I start to play quite nicely with Jenkins and I think you don't have
> to build any plugin to make it works:
> - use a matrix project to build on all platform, have a first step on
> 1 particular platform that need to succeed (integrated, I use it)
> - use a shell script to start the build, no maven, no ant (I use it)
> - ...
> 
> I will look at memory issue with java worker... Let's say I have a
> couple of Java specialist sitting next to me. I will need to run one
> on my RPi...
> 
> Regards
> Sylvain
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform


From sylvain+ocaml at le-gall.net  Fri Feb 15 10:24:26 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Fri, 15 Feb 2013 11:24:26 +0100
Subject: [ocaml-platform] OCamlot
In-Reply-To: <25AF9514-73D0-4B03-A383-10D9D04F7D40@ocamlpro.com>
References: <CADxsiea1f67q52Hj2BBsmPddWLW45kBpZXDK+QFsQv+jMVMvpw@mail.gmail.com>
 <56A82DFE-1A63-4577-B498-D552F75BBF99@cam.ac.uk>
 <CADxsiebn6ZmfDARZucy5MWR5h2HLxnV0E6D2o4e1v5Gyh0oEfg@mail.gmail.com>
 <83B10F50-5E11-4138-8F37-0B84FE98953E@cl.cam.ac.uk>
 <8D721B24-3E90-4A5F-8BC9-9DFB3FB18BED@cl.cam.ac.uk>
 <CAOCAUGNOybAf4yZq3_4nKJnMiNptj1F=HnUDwGkQ_-JZKehdmw@mail.gmail.com>
 <25AF9514-73D0-4B03-A383-10D9D04F7D40@ocamlpro.com>
Message-ID: <CAOCAUGODXjvFUpbx-a+WwrDO4YLnX0y4ctW85yLV81eOTmJrYA@mail.gmail.com>

2013/2/15 Thomas Gazagnaire <thomas at ocamlpro.com>:
>> Humm, to be honest, I will:
>> 1. limit the number of compiler version (4.00.1 or 4.01.0 when it will be out)
>> 2. limit the number of packages
>>
>> I think 300+ packages in OPAM term is the number of tarball. Let's
>> just take either the last one or the last one that we were to build on
>> all platform. I don't want to have OUnit 1.1.0 and 2.0.0...
>
> From my point-of-view, I really would like to see most of the 650+ packages (ie. 350+ unique packages) to be tested, in order to get a very precise idea of the dependencies constraints. This is indeed less useful than getting the latest version for each package, but it's quite important in order to get a reliable and consistent user experience.
>

Indeed 350+ package, didn't realize the number... (congrat)

As you stated, this is "less useful". So let's make it a secondary
target and focus on delivering a platform in 6 months. If possible
that would be great but we should focus on the main goal, we will have
to solve enough issues in the first round.

> Regarding the compiler versions, I think it's very useful to have an easy way to automatically test and benchmarks experimental SVN branches to look for regressions before integrating them in trunk, so I really think that opamalot should be able to do this as well.

I think we should have:
1. one chosen compiler version, which will be the target of the next
platform release (e.g 4.01, which happens to be the trunk right now)
2. the SVN trunk, as a "helper" to the  OCaml team so that we provide
them  enough information to have the best possible possible N+1
compiler (at least well tested)

Also 2. is a secondary target, let focus on 1.

My POV: deliver something interesting enough in 6 months.

If we reach a stable OCaml Platform in 3 months: GREAT ! Deliver it to
the community and try to act on the secondary target...

>
> Thomas
>
>>
>> Concerning Travis/Jenkins/whatever, I think we should consider this:
>> - just create a shell script that do the job and don't interface
>> strongly with the build system in the core job
>> - most of the builder I know, can have some restriction, esp
>> concerning accessing the network. This is not always true but we
>> should try to avoid downloading stuff
>> - create a big git repository that basically contains an opam
>> repository + the builder shell script and do the job inside it
>> - try to output the results of tests/build in a "common test result
>> format" (either TAP or JUnit)
>> - consider that most platform don't allow you to install stuff that
>> are 3rd party (e.g. C libraries that comes with the OS, like libzmq0
>> or libfoo.so.XX), I don't think we should build them on our own (let's
>> focus on OCaml)
>>
>> I think this can be done independently of the platform we use for
>> continuous integration, when we will have gained some experience, we
>> can enhance the process for a specific/preferred platform.
>>
>> I start to play quite nicely with Jenkins and I think you don't have
>> to build any plugin to make it works:
>> - use a matrix project to build on all platform, have a first step on
>> 1 particular platform that need to succeed (integrated, I use it)
>> - use a shell script to start the build, no maven, no ant (I use it)
>> - ...
>>
>> I will look at memory issue with java worker... Let's say I have a
>> couple of Java specialist sitting next to me. I will need to run one
>> on my RPi...
>>
>> Regards
>> Sylvain
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>

From sylvain+ocaml at le-gall.net  Fri Feb 15 10:31:19 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Fri, 15 Feb 2013 11:31:19 +0100
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
Message-ID: <CAOCAUGNMcje_b2fqo2pgo2aXudgPGXFESNJkXhLhEffHO0A2cA@mail.gmail.com>

Hi,

2013/2/15 Yaron Minsky <yminsky at janestreet.com>:
> Right now, the Core suite of libraries changes a lot --- we have a new
> release of everything every week.  The changes on a given week are
> small, but there are always changes.
>

I think this is a very good thing. I tend to delay too much the
release of my software and this is bad. Weekly/monthly delivery goals
are good.

> I can imagine this being something of a problem for OPAM.  If packages
> specify specific revisions of the Core suite, then we're going to have
> a massive version mismatch problem, where no two libraries can agree
> on the version of Core that they need.
>
> I have no obvious ideas as to how to solve this.  Does anyone else
> have ideas?  Should we simply encourage packagers to specify a
> lower-bound constraint on the Core libraries?

AFAIU, OPAM constraint model is inspired by Debian constraints
model... Although this is a very complex model, that can probably
express a lot of stuff, but it most often ends up by creating a new
problem (like SAT solving for 350+ packages).

I think that OPAM people should strongly recommend "lower-bound"
constraint and use the testing framework to semi-automate setting an
"higher bound". It can probably only be "semi-automated", because
making the difference between a true build failure and a build failure
cause by an upstream change is not that easy...

Cheers
Sylvain

>
> y
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From mmatalka at gmail.com  Fri Feb 15 11:21:36 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 15 Feb 2013 06:21:36 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 (Yaron Minsky's message of "Thu, 14 Feb 2013 22:17:47 -0500")
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
Message-ID: <8738wxddq7.fsf@li195-236.members.linode.com>

Right now, I think Core not being afraid to change frequently is good.
I'd rather have that than a stale API that kind of sucks.  And I'd hate
to have the public Core get out of synch with what Jane St uses
internally because it increases the overhead for you which decreases the
chance of timely releases.

Multiple versions has not been a problem for me since I convert opam
packages I'm interested in to Nix packages, and Nix handles multiple
versions of installed packages just fine.  It's probably too late in the
game for opam to have this style as well, I don't know anything about
opam's design, but it's worked pretty well in Nix for me.

Beyond that, I think good semantic versioning is probably key.  If the
majority of Core changes are backwards compatible (I have no idea if
this is the case) then installing the right package for a lot of the
apps probably isn't so bad.

/Malcolm

Yaron Minsky <yminsky at janestreet.com> writes:

> Right now, the Core suite of libraries changes a lot --- we have a new
> release of everything every week.  The changes on a given week are
> small, but there are always changes.
>
> I can imagine this being something of a problem for OPAM.  If packages
> specify specific revisions of the Core suite, then we're going to have
> a massive version mismatch problem, where no two libraries can agree
> on the version of Core that they need.
>
> I have no obvious ideas as to how to solve this.  Does anyone else
> have ideas?  Should we simply encourage packagers to specify a
> lower-bound constraint on the Core libraries?
>
> y
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From anil at recoil.org  Fri Feb 15 11:30:53 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 15 Feb 2013 11:30:53 +0000
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
Message-ID: <D842E985-C63B-4AAC-97BB-8801C3241832@recoil.org>

Core changing regularly at the moment is fine.  There aren't many
third-party packages that depend on it, and we can establish lower
bounds.  Note that the constraints aren't a long-term solution for
compatibility, as you can't have multiple simultaneous library
installations at present.

The short-term annoyance is that all the dependent libraries are
tied to Core versioning, and there is needless churn there.  For
example, both Fieldslib and Comparelib had no substantial changes
in 109.09.00 with respect to 109.08.00:
https://github.com/janestreet/comparelib/commit/b4b36651591d3ebfb970bd22cca8daa803bca93b

The biggest impact for this is felt with type_conv, which invariably
results in a complete recompilation cycle.  I'd be interested in how
you feel about independent versioning of some of these libraries
in the longer term.

-anil



On 15 Feb 2013, at 03:17, Yaron Minsky <yminsky at janestreet.com> wrote:

> Right now, the Core suite of libraries changes a lot --- we have a new
> release of everything every week.  The changes on a given week are
> small, but there are always changes.
> 
> I can imagine this being something of a problem for OPAM.  If packages
> specify specific revisions of the Core suite, then we're going to have
> a massive version mismatch problem, where no two libraries can agree
> on the version of Core that they need.
> 
> I have no obvious ideas as to how to solve this.  Does anyone else
> have ideas?  Should we simply encourage packagers to specify a
> lower-bound constraint on the Core libraries?
> 
> y
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
> 


From anil at recoil.org  Fri Feb 15 11:33:48 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 15 Feb 2013 11:33:48 +0000
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <8738wxddq7.fsf@li195-236.members.linode.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
Message-ID: <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>

OPAM has a strong dependency on ocamlfind at the moment, which doesn't
support multiple library versions.  OPAM could be extended to support
multiple installations (since the constraint model expresses it fine),
but would need to understand more of the build process too.

There are some steps towards this already, such as the `.install` files
which automate binary installation/removal.  We were reluctant to put
any more in the first version in the interests of getting something out.

-anil

On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:

> Right now, I think Core not being afraid to change frequently is good.
> I'd rather have that than a stale API that kind of sucks.  And I'd hate
> to have the public Core get out of synch with what Jane St uses
> internally because it increases the overhead for you which decreases the
> chance of timely releases.
> 
> Multiple versions has not been a problem for me since I convert opam
> packages I'm interested in to Nix packages, and Nix handles multiple
> versions of installed packages just fine.  It's probably too late in the
> game for opam to have this style as well, I don't know anything about
> opam's design, but it's worked pretty well in Nix for me.
> 
> Beyond that, I think good semantic versioning is probably key.  If the
> majority of Core changes are backwards compatible (I have no idea if
> this is the case) then installing the right package for a lot of the
> apps probably isn't so bad.
> 
> /Malcolm
> 
> Yaron Minsky <yminsky at janestreet.com> writes:
> 
>> Right now, the Core suite of libraries changes a lot --- we have a new
>> release of everything every week.  The changes on a given week are
>> small, but there are always changes.
>> 
>> I can imagine this being something of a problem for OPAM.  If packages
>> specify specific revisions of the Core suite, then we're going to have
>> a massive version mismatch problem, where no two libraries can agree
>> on the version of Core that they need.
>> 
>> I have no obvious ideas as to how to solve this.  Does anyone else
>> have ideas?  Should we simply encourage packagers to specify a
>> lower-bound constraint on the Core libraries?
>> 
>> y
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
> 


From mmatalka at gmail.com  Fri Feb 15 11:37:50 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 15 Feb 2013 12:37:50 +0100
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
Message-ID: <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>

I get around this in Nix with chroot and building OCAMLPATH on the fly.
On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:

> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
> support multiple library versions.  OPAM could be extended to support
> multiple installations (since the constraint model expresses it fine),
> but would need to understand more of the build process too.
>
> There are some steps towards this already, such as the `.install` files
> which automate binary installation/removal.  We were reluctant to put
> any more in the first version in the interests of getting something out.
>
> -anil
>
> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>
> > Right now, I think Core not being afraid to change frequently is good.
> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
> > to have the public Core get out of synch with what Jane St uses
> > internally because it increases the overhead for you which decreases the
> > chance of timely releases.
> >
> > Multiple versions has not been a problem for me since I convert opam
> > packages I'm interested in to Nix packages, and Nix handles multiple
> > versions of installed packages just fine.  It's probably too late in the
> > game for opam to have this style as well, I don't know anything about
> > opam's design, but it's worked pretty well in Nix for me.
> >
> > Beyond that, I think good semantic versioning is probably key.  If the
> > majority of Core changes are backwards compatible (I have no idea if
> > this is the case) then installing the right package for a lot of the
> > apps probably isn't so bad.
> >
> > /Malcolm
> >
> > Yaron Minsky <yminsky at janestreet.com> writes:
> >
> >> Right now, the Core suite of libraries changes a lot --- we have a new
> >> release of everything every week.  The changes on a given week are
> >> small, but there are always changes.
> >>
> >> I can imagine this being something of a problem for OPAM.  If packages
> >> specify specific revisions of the Core suite, then we're going to have
> >> a massive version mismatch problem, where no two libraries can agree
> >> on the version of Core that they need.
> >>
> >> I have no obvious ideas as to how to solve this.  Does anyone else
> >> have ideas?  Should we simply encourage packagers to specify a
> >> lower-bound constraint on the Core libraries?
> >>
> >> y
> >> _______________________________________________
> >> Platform mailing list
> >> Platform at lists.ocaml.org
> >> http://lists.ocaml.org/listinfo/platform
> > _______________________________________________
> > Platform mailing list
> > Platform at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/platform
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130215/b788dca2/attachment.html>

From yminsky at janestreet.com  Fri Feb 15 11:42:13 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 15 Feb 2013 06:42:13 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
Message-ID: <CACLX4jTi+cFCUFcgdrbhRJf9bBrq5Rn+VVYCSDpFZGCQFtjWSg@mail.gmail.com>

But nix doesn't fix the diamond dependency problem, does it?  If library a
depends on core 109.07 and b depends on 109.08, then an app that wants to
link in both a and b is in some real trouble.

Or am I missing something?
On Feb 15, 2013 6:37 AM, "Malcolm Matalka" <mmatalka at gmail.com> wrote:

> I get around this in Nix with chroot and building OCAMLPATH on the fly.
> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
>
>> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
>> support multiple library versions.  OPAM could be extended to support
>> multiple installations (since the constraint model expresses it fine),
>> but would need to understand more of the build process too.
>>
>> There are some steps towards this already, such as the `.install` files
>> which automate binary installation/removal.  We were reluctant to put
>> any more in the first version in the interests of getting something out.
>>
>> -anil
>>
>> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>
>> > Right now, I think Core not being afraid to change frequently is good.
>> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
>> > to have the public Core get out of synch with what Jane St uses
>> > internally because it increases the overhead for you which decreases the
>> > chance of timely releases.
>> >
>> > Multiple versions has not been a problem for me since I convert opam
>> > packages I'm interested in to Nix packages, and Nix handles multiple
>> > versions of installed packages just fine.  It's probably too late in the
>> > game for opam to have this style as well, I don't know anything about
>> > opam's design, but it's worked pretty well in Nix for me.
>> >
>> > Beyond that, I think good semantic versioning is probably key.  If the
>> > majority of Core changes are backwards compatible (I have no idea if
>> > this is the case) then installing the right package for a lot of the
>> > apps probably isn't so bad.
>> >
>> > /Malcolm
>> >
>> > Yaron Minsky <yminsky at janestreet.com> writes:
>> >
>> >> Right now, the Core suite of libraries changes a lot --- we have a new
>> >> release of everything every week.  The changes on a given week are
>> >> small, but there are always changes.
>> >>
>> >> I can imagine this being something of a problem for OPAM.  If packages
>> >> specify specific revisions of the Core suite, then we're going to have
>> >> a massive version mismatch problem, where no two libraries can agree
>> >> on the version of Core that they need.
>> >>
>> >> I have no obvious ideas as to how to solve this.  Does anyone else
>> >> have ideas?  Should we simply encourage packagers to specify a
>> >> lower-bound constraint on the Core libraries?
>> >>
>> >> y
>> >> _______________________________________________
>> >> Platform mailing list
>> >> Platform at lists.ocaml.org
>> >> http://lists.ocaml.org/listinfo/platform
>> > _______________________________________________
>> > Platform mailing list
>> > Platform at lists.ocaml.org
>> > http://lists.ocaml.org/listinfo/platform
>> >
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130215/30894cc5/attachment-0001.html>

From anil at recoil.org  Fri Feb 15 11:42:59 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 15 Feb 2013 11:42:59 +0000
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
Message-ID: <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>

Right, but the opportunities for re-using previously compiled libraries
are limited, because of the exact-version requirements.  Having multiple
OPAM switches per set of constraints would be almost as good, if much
more burdensome from a command-line perspective.

Do you have your Nix setup available anywhere? I'd definitely like to
have a play with it.

-anil

On 15 Feb 2013, at 11:37, Malcolm Matalka <mmatalka at gmail.com> wrote:

> I get around this in Nix with chroot and building OCAMLPATH on the fly.
> 
> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
> support multiple library versions.  OPAM could be extended to support
> multiple installations (since the constraint model expresses it fine),
> but would need to understand more of the build process too.
> 
> There are some steps towards this already, such as the `.install` files
> which automate binary installation/removal.  We were reluctant to put
> any more in the first version in the interests of getting something out.
> 
> -anil
> 
> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
> 
> > Right now, I think Core not being afraid to change frequently is good.
> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
> > to have the public Core get out of synch with what Jane St uses
> > internally because it increases the overhead for you which decreases the
> > chance of timely releases.
> >
> > Multiple versions has not been a problem for me since I convert opam
> > packages I'm interested in to Nix packages, and Nix handles multiple
> > versions of installed packages just fine.  It's probably too late in the
> > game for opam to have this style as well, I don't know anything about
> > opam's design, but it's worked pretty well in Nix for me.
> >
> > Beyond that, I think good semantic versioning is probably key.  If the
> > majority of Core changes are backwards compatible (I have no idea if
> > this is the case) then installing the right package for a lot of the
> > apps probably isn't so bad.
> >
> > /Malcolm
> >
> > Yaron Minsky <yminsky at janestreet.com> writes:
> >
> >> Right now, the Core suite of libraries changes a lot --- we have a new
> >> release of everything every week.  The changes on a given week are
> >> small, but there are always changes.
> >>
> >> I can imagine this being something of a problem for OPAM.  If packages
> >> specify specific revisions of the Core suite, then we're going to have
> >> a massive version mismatch problem, where no two libraries can agree
> >> on the version of Core that they need.
> >>
> >> I have no obvious ideas as to how to solve this.  Does anyone else
> >> have ideas?  Should we simply encourage packagers to specify a
> >> lower-bound constraint on the Core libraries?
> >>
> >> y
> >> _______________________________________________
> >> Platform mailing list
> >> Platform at lists.ocaml.org
> >> http://lists.ocaml.org/listinfo/platform
> > _______________________________________________
> > Platform mailing list
> > Platform at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/platform
> >
> 


From yminsky at janestreet.com  Fri Feb 15 11:47:48 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 15 Feb 2013 06:47:48 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <D842E985-C63B-4AAC-97BB-8801C3241832@recoil.org>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <D842E985-C63B-4AAC-97BB-8801C3241832@recoil.org>
Message-ID: <CACLX4jRg+9j2Aj-QjZHoGt85Lwzi=BS+d4nvN9fTGn5Sm7TcWQ@mail.gmail.com>

I'm suspicious that the separate versioning will buy us anything, and it
will certainly add complexity to our export process.  In particular, my
hope is that core will become a dependency for many projects, at which
point a weekly release of core will cause lots of churn at the build level
whether or not type-conv is changed.

As for core, the changes aren't massive or terribly churny, but core is
big, and something in it changes every week.  Most users could probably
jump forward five versions and compile cleanly without changing a line of
code.  Given that, I would think that defaulting to inequality constraints
would help a lot.
On Feb 15, 2013 6:31 AM, "Anil Madhavapeddy" <anil at recoil.org> wrote:

> Core changing regularly at the moment is fine.  There aren't many
> third-party packages that depend on it, and we can establish lower
> bounds.  Note that the constraints aren't a long-term solution for
> compatibility, as you can't have multiple simultaneous library
> installations at present.
>
> The short-term annoyance is that all the dependent libraries are
> tied to Core versioning, and there is needless churn there.  For
> example, both Fieldslib and Comparelib had no substantial changes
> in 109.09.00 with respect to 109.08.00:
>
> https://github.com/janestreet/comparelib/commit/b4b36651591d3ebfb970bd22cca8daa803bca93b
>
> The biggest impact for this is felt with type_conv, which invariably
> results in a complete recompilation cycle.  I'd be interested in how
> you feel about independent versioning of some of these libraries
> in the longer term.
>
> -anil
>
>
>
> On 15 Feb 2013, at 03:17, Yaron Minsky <yminsky at janestreet.com> wrote:
>
> > Right now, the Core suite of libraries changes a lot --- we have a new
> > release of everything every week.  The changes on a given week are
> > small, but there are always changes.
> >
> > I can imagine this being something of a problem for OPAM.  If packages
> > specify specific revisions of the Core suite, then we're going to have
> > a massive version mismatch problem, where no two libraries can agree
> > on the version of Core that they need.
> >
> > I have no obvious ideas as to how to solve this.  Does anyone else
> > have ideas?  Should we simply encourage packagers to specify a
> > lower-bound constraint on the Core libraries?
> >
> > y
> > _______________________________________________
> > Platform mailing list
> > Platform at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/platform
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130215/3f7c63e6/attachment.html>

From mmatalka at gmail.com  Fri Feb 15 12:09:09 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 15 Feb 2013 07:09:09 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org> (Anil
 Madhavapeddy's message of "Fri, 15 Feb 2013 11:42:59 +0000")
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
 <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>
Message-ID: <87r4khbwyi.fsf@li195-236.members.linode.com>

My Nix setup is a huge hack right now, but! here is my current public
fork of nixpkgs with an OLD version of opam + Core 108.07.01:

https://github.com/orbitz/nixpkgs/commit/fd598f1b55c94b4d466ac5ddffb304136bdc433e

The only interesting change is I had to patch Async because its build
script requires /bin/bash and /bin/mkdir. And the build failure for
Async is pretty awesome btw :)

(I'm not 100% sure that the above branch works on Nix since I have some
local changes that have been sitting around for awhile, but it gives the
gist.  If more complete, working versions, are interested to anyone I
can put the effort in to give a more complete demonstration)

I also have these cheap scripts I use to create my environment when
playing locally.  This should really be done as an eval like opam's
config but right now I do something like 'ocaml_run.sh make'.  Or
ocaml.sh to get the REPL.  This plays fine with opam (for me) since my
script is additive to the environment.

https://github.com/orbitz/ocaml_wrapper

@yaron - Correct, AFAIK this does not some diamond dep problem.  Based
on what Anil said I guess ocamlfind needs to be modified for that.  Or
the ability for libraries to be built with their deps linked in already.

/Malcolm

Anil Madhavapeddy <anil at recoil.org> writes:

> Right, but the opportunities for re-using previously compiled libraries
> are limited, because of the exact-version requirements.  Having multiple
> OPAM switches per set of constraints would be almost as good, if much
> more burdensome from a command-line perspective.
>
> Do you have your Nix setup available anywhere? I'd definitely like to
> have a play with it.
>
> -anil
>
> On 15 Feb 2013, at 11:37, Malcolm Matalka <mmatalka at gmail.com> wrote:
>
>> I get around this in Nix with chroot and building OCAMLPATH on the fly.
>> 
>> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
>> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
>> support multiple library versions.  OPAM could be extended to support
>> multiple installations (since the constraint model expresses it fine),
>> but would need to understand more of the build process too.
>> 
>> There are some steps towards this already, such as the `.install` files
>> which automate binary installation/removal.  We were reluctant to put
>> any more in the first version in the interests of getting something out.
>> 
>> -anil
>> 
>> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> 
>> > Right now, I think Core not being afraid to change frequently is good.
>> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
>> > to have the public Core get out of synch with what Jane St uses
>> > internally because it increases the overhead for you which decreases the
>> > chance of timely releases.
>> >
>> > Multiple versions has not been a problem for me since I convert opam
>> > packages I'm interested in to Nix packages, and Nix handles multiple
>> > versions of installed packages just fine.  It's probably too late in the
>> > game for opam to have this style as well, I don't know anything about
>> > opam's design, but it's worked pretty well in Nix for me.
>> >
>> > Beyond that, I think good semantic versioning is probably key.  If the
>> > majority of Core changes are backwards compatible (I have no idea if
>> > this is the case) then installing the right package for a lot of the
>> > apps probably isn't so bad.
>> >
>> > /Malcolm
>> >
>> > Yaron Minsky <yminsky at janestreet.com> writes:
>> >
>> >> Right now, the Core suite of libraries changes a lot --- we have a new
>> >> release of everything every week.  The changes on a given week are
>> >> small, but there are always changes.
>> >>
>> >> I can imagine this being something of a problem for OPAM.  If packages
>> >> specify specific revisions of the Core suite, then we're going to have
>> >> a massive version mismatch problem, where no two libraries can agree
>> >> on the version of Core that they need.
>> >>
>> >> I have no obvious ideas as to how to solve this.  Does anyone else
>> >> have ideas?  Should we simply encourage packagers to specify a
>> >> lower-bound constraint on the Core libraries?
>> >>
>> >> y
>> >> _______________________________________________
>> >> Platform mailing list
>> >> Platform at lists.ocaml.org
>> >> http://lists.ocaml.org/listinfo/platform
>> > _______________________________________________
>> > Platform mailing list
>> > Platform at lists.ocaml.org
>> > http://lists.ocaml.org/listinfo/platform
>> >
>> 

From jdimino at janestreet.com  Fri Feb 15 15:22:55 2013
From: jdimino at janestreet.com (Jeremie Dimino)
Date: Fri, 15 Feb 2013 10:22:55 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <87r4khbwyi.fsf@li195-236.members.linode.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
 <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>
 <87r4khbwyi.fsf@li195-236.members.linode.com>
Message-ID: <CANhEzE6PviEc0Y22qWV0WQOqRWv+WLzO2T+15sYgi71DZHxeiA@mail.gmail.com>

On Fri, Feb 15, 2013 at 7:09 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> The only interesting change is I had to patch Async because its build
> script requires /bin/bash and /bin/mkdir. And the build failure for
> Async is pretty awesome btw :)

I believe the bug requiring this hack has now been fixed. Async builds
without it, so I'll just remove it.

From yminsky at janestreet.com  Fri Feb 15 22:11:08 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 15 Feb 2013 17:11:08 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <87r4khbwyi.fsf@li195-236.members.linode.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
 <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>
 <87r4khbwyi.fsf@li195-236.members.linode.com>
Message-ID: <CACLX4jSuA5ox412FSiccnfdQxt+KdONTYMGLxmQ-ePdO0pezHg@mail.gmail.com>

I think the diamond dependency problem is a fundamental semantic
issue, and can't be worked around by tools.  If I use a Core.Map.t
from version 109.06, and the implementation changes in 109.07, then if
libraries A and B both use Core.Map.t's in their interface, there's no
way they can communicate, unless you propagate the versioning into the
library!  You could have a Core_109_07.Map.t, and Core_109_06.Map.t,
but I'm pretty sure madness lies that way...

y

On Fri, Feb 15, 2013 at 7:09 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> My Nix setup is a huge hack right now, but! here is my current public
> fork of nixpkgs with an OLD version of opam + Core 108.07.01:
>
> https://github.com/orbitz/nixpkgs/commit/fd598f1b55c94b4d466ac5ddffb304136bdc433e
>
> The only interesting change is I had to patch Async because its build
> script requires /bin/bash and /bin/mkdir. And the build failure for
> Async is pretty awesome btw :)
>
> (I'm not 100% sure that the above branch works on Nix since I have some
> local changes that have been sitting around for awhile, but it gives the
> gist.  If more complete, working versions, are interested to anyone I
> can put the effort in to give a more complete demonstration)
>
> I also have these cheap scripts I use to create my environment when
> playing locally.  This should really be done as an eval like opam's
> config but right now I do something like 'ocaml_run.sh make'.  Or
> ocaml.sh to get the REPL.  This plays fine with opam (for me) since my
> script is additive to the environment.
>
> https://github.com/orbitz/ocaml_wrapper
>
> @yaron - Correct, AFAIK this does not some diamond dep problem.  Based
> on what Anil said I guess ocamlfind needs to be modified for that.  Or
> the ability for libraries to be built with their deps linked in already.
>
> /Malcolm
>
> Anil Madhavapeddy <anil at recoil.org> writes:
>
>> Right, but the opportunities for re-using previously compiled libraries
>> are limited, because of the exact-version requirements.  Having multiple
>> OPAM switches per set of constraints would be almost as good, if much
>> more burdensome from a command-line perspective.
>>
>> Do you have your Nix setup available anywhere? I'd definitely like to
>> have a play with it.
>>
>> -anil
>>
>> On 15 Feb 2013, at 11:37, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>
>>> I get around this in Nix with chroot and building OCAMLPATH on the fly.
>>>
>>> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
>>> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
>>> support multiple library versions.  OPAM could be extended to support
>>> multiple installations (since the constraint model expresses it fine),
>>> but would need to understand more of the build process too.
>>>
>>> There are some steps towards this already, such as the `.install` files
>>> which automate binary installation/removal.  We were reluctant to put
>>> any more in the first version in the interests of getting something out.
>>>
>>> -anil
>>>
>>> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>
>>> > Right now, I think Core not being afraid to change frequently is good.
>>> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
>>> > to have the public Core get out of synch with what Jane St uses
>>> > internally because it increases the overhead for you which decreases the
>>> > chance of timely releases.
>>> >
>>> > Multiple versions has not been a problem for me since I convert opam
>>> > packages I'm interested in to Nix packages, and Nix handles multiple
>>> > versions of installed packages just fine.  It's probably too late in the
>>> > game for opam to have this style as well, I don't know anything about
>>> > opam's design, but it's worked pretty well in Nix for me.
>>> >
>>> > Beyond that, I think good semantic versioning is probably key.  If the
>>> > majority of Core changes are backwards compatible (I have no idea if
>>> > this is the case) then installing the right package for a lot of the
>>> > apps probably isn't so bad.
>>> >
>>> > /Malcolm
>>> >
>>> > Yaron Minsky <yminsky at janestreet.com> writes:
>>> >
>>> >> Right now, the Core suite of libraries changes a lot --- we have a new
>>> >> release of everything every week.  The changes on a given week are
>>> >> small, but there are always changes.
>>> >>
>>> >> I can imagine this being something of a problem for OPAM.  If packages
>>> >> specify specific revisions of the Core suite, then we're going to have
>>> >> a massive version mismatch problem, where no two libraries can agree
>>> >> on the version of Core that they need.
>>> >>
>>> >> I have no obvious ideas as to how to solve this.  Does anyone else
>>> >> have ideas?  Should we simply encourage packagers to specify a
>>> >> lower-bound constraint on the Core libraries?
>>> >>
>>> >> y
>>> >> _______________________________________________
>>> >> Platform mailing list
>>> >> Platform at lists.ocaml.org
>>> >> http://lists.ocaml.org/listinfo/platform
>>> > _______________________________________________
>>> > Platform mailing list
>>> > Platform at lists.ocaml.org
>>> > http://lists.ocaml.org/listinfo/platform
>>> >
>>>

From mmatalka at gmail.com  Fri Feb 15 22:35:00 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 15 Feb 2013 17:35:00 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CACLX4jSuA5ox412FSiccnfdQxt+KdONTYMGLxmQ-ePdO0pezHg@mail.gmail.com>
 (Yaron Minsky's message of "Fri, 15 Feb 2013 17:11:08 -0500")
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
 <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>
 <87r4khbwyi.fsf@li195-236.members.linode.com>
 <CACLX4jSuA5ox412FSiccnfdQxt+KdONTYMGLxmQ-ePdO0pezHg@mail.gmail.com>
Message-ID: <87ip5tb3zf.fsf@li195-236.members.linode.com>

I don't know how Ocaml linking works, but here is how I believe it works
in Nix, which is mostly C-based packages, of course:

- All packages are given a unique path

- When you compile a package, if its deps are statically linked then
  they are just compiled into it, so it doesn't matter what else you're
  linking against when you use this as dep

- If they are dynamically linked, a post-processing step rewrites the
  binary so all paths to deps are the unique path, I *think* this means
  if you have the diamond problem it's ok because the dep will always
  load the version of the library it was compiled against.

But I could easily be way wrong.

/M

Yaron Minsky <yminsky at janestreet.com> writes:

> I think the diamond dependency problem is a fundamental semantic
> issue, and can't be worked around by tools.  If I use a Core.Map.t
> from version 109.06, and the implementation changes in 109.07, then if
> libraries A and B both use Core.Map.t's in their interface, there's no
> way they can communicate, unless you propagate the versioning into the
> library!  You could have a Core_109_07.Map.t, and Core_109_06.Map.t,
> but I'm pretty sure madness lies that way...
>
> y
>
> On Fri, Feb 15, 2013 at 7:09 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> My Nix setup is a huge hack right now, but! here is my current public
>> fork of nixpkgs with an OLD version of opam + Core 108.07.01:
>>
>> https://github.com/orbitz/nixpkgs/commit/fd598f1b55c94b4d466ac5ddffb304136bdc433e
>>
>> The only interesting change is I had to patch Async because its build
>> script requires /bin/bash and /bin/mkdir. And the build failure for
>> Async is pretty awesome btw :)
>>
>> (I'm not 100% sure that the above branch works on Nix since I have some
>> local changes that have been sitting around for awhile, but it gives the
>> gist.  If more complete, working versions, are interested to anyone I
>> can put the effort in to give a more complete demonstration)
>>
>> I also have these cheap scripts I use to create my environment when
>> playing locally.  This should really be done as an eval like opam's
>> config but right now I do something like 'ocaml_run.sh make'.  Or
>> ocaml.sh to get the REPL.  This plays fine with opam (for me) since my
>> script is additive to the environment.
>>
>> https://github.com/orbitz/ocaml_wrapper
>>
>> @yaron - Correct, AFAIK this does not some diamond dep problem.  Based
>> on what Anil said I guess ocamlfind needs to be modified for that.  Or
>> the ability for libraries to be built with their deps linked in already.
>>
>> /Malcolm
>>
>> Anil Madhavapeddy <anil at recoil.org> writes:
>>
>>> Right, but the opportunities for re-using previously compiled libraries
>>> are limited, because of the exact-version requirements.  Having multiple
>>> OPAM switches per set of constraints would be almost as good, if much
>>> more burdensome from a command-line perspective.
>>>
>>> Do you have your Nix setup available anywhere? I'd definitely like to
>>> have a play with it.
>>>
>>> -anil
>>>
>>> On 15 Feb 2013, at 11:37, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>
>>>> I get around this in Nix with chroot and building OCAMLPATH on the fly.
>>>>
>>>> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
>>>> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
>>>> support multiple library versions.  OPAM could be extended to support
>>>> multiple installations (since the constraint model expresses it fine),
>>>> but would need to understand more of the build process too.
>>>>
>>>> There are some steps towards this already, such as the `.install` files
>>>> which automate binary installation/removal.  We were reluctant to put
>>>> any more in the first version in the interests of getting something out.
>>>>
>>>> -anil
>>>>
>>>> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>
>>>> > Right now, I think Core not being afraid to change frequently is good.
>>>> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
>>>> > to have the public Core get out of synch with what Jane St uses
>>>> > internally because it increases the overhead for you which decreases the
>>>> > chance of timely releases.
>>>> >
>>>> > Multiple versions has not been a problem for me since I convert opam
>>>> > packages I'm interested in to Nix packages, and Nix handles multiple
>>>> > versions of installed packages just fine.  It's probably too late in the
>>>> > game for opam to have this style as well, I don't know anything about
>>>> > opam's design, but it's worked pretty well in Nix for me.
>>>> >
>>>> > Beyond that, I think good semantic versioning is probably key.  If the
>>>> > majority of Core changes are backwards compatible (I have no idea if
>>>> > this is the case) then installing the right package for a lot of the
>>>> > apps probably isn't so bad.
>>>> >
>>>> > /Malcolm
>>>> >
>>>> > Yaron Minsky <yminsky at janestreet.com> writes:
>>>> >
>>>> >> Right now, the Core suite of libraries changes a lot --- we have a new
>>>> >> release of everything every week.  The changes on a given week are
>>>> >> small, but there are always changes.
>>>> >>
>>>> >> I can imagine this being something of a problem for OPAM.  If packages
>>>> >> specify specific revisions of the Core suite, then we're going to have
>>>> >> a massive version mismatch problem, where no two libraries can agree
>>>> >> on the version of Core that they need.
>>>> >>
>>>> >> I have no obvious ideas as to how to solve this.  Does anyone else
>>>> >> have ideas?  Should we simply encourage packagers to specify a
>>>> >> lower-bound constraint on the Core libraries?
>>>> >>
>>>> >> y
>>>> >> _______________________________________________
>>>> >> Platform mailing list
>>>> >> Platform at lists.ocaml.org
>>>> >> http://lists.ocaml.org/listinfo/platform
>>>> > _______________________________________________
>>>> > Platform mailing list
>>>> > Platform at lists.ocaml.org
>>>> > http://lists.ocaml.org/listinfo/platform
>>>> >
>>>>

From yminsky at janestreet.com  Fri Feb 15 22:42:37 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 15 Feb 2013 17:42:37 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <87ip5tb3zf.fsf@li195-236.members.linode.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
 <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>
 <87r4khbwyi.fsf@li195-236.members.linode.com>
 <CACLX4jSuA5ox412FSiccnfdQxt+KdONTYMGLxmQ-ePdO0pezHg@mail.gmail.com>
 <87ip5tb3zf.fsf@li195-236.members.linode.com>
Message-ID: <CACLX4jSGeapZ+OE_Xw+HPj4=-7TXou0AceMaPdKW4GBu5hWRfQ@mail.gmail.com>

I can't imagine how this would work in OCaml.  Imagine that A has a
function:

    val make_map : unit -> float Core.Std.Map.t

and B has this function:

    val consume_map : float Core.Std.Map.t -> unit

If in your own library you write:

    A.consume_map (B.make_map ())

then if A and B link to different versions of Core that have different
versions of the Map type, then the above code shouldn't compile!

I basically think that the Nix model does not map sanely onto OCaml
modules.  And I don't think this is all that OCaml specific.  The same
bug would show up in Java, I would think.

y

On Fri, Feb 15, 2013 at 5:35 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> I don't know how Ocaml linking works, but here is how I believe it works
> in Nix, which is mostly C-based packages, of course:
>
> - All packages are given a unique path
>
> - When you compile a package, if its deps are statically linked then
>   they are just compiled into it, so it doesn't matter what else you're
>   linking against when you use this as dep
>
> - If they are dynamically linked, a post-processing step rewrites the
>   binary so all paths to deps are the unique path, I *think* this means
>   if you have the diamond problem it's ok because the dep will always
>   load the version of the library it was compiled against.
>
> But I could easily be way wrong.
>
> /M
>
> Yaron Minsky <yminsky at janestreet.com> writes:
>
>> I think the diamond dependency problem is a fundamental semantic
>> issue, and can't be worked around by tools.  If I use a Core.Map.t
>> from version 109.06, and the implementation changes in 109.07, then if
>> libraries A and B both use Core.Map.t's in their interface, there's no
>> way they can communicate, unless you propagate the versioning into the
>> library!  You could have a Core_109_07.Map.t, and Core_109_06.Map.t,
>> but I'm pretty sure madness lies that way...
>>
>> y
>>
>> On Fri, Feb 15, 2013 at 7:09 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> My Nix setup is a huge hack right now, but! here is my current public
>>> fork of nixpkgs with an OLD version of opam + Core 108.07.01:
>>>
>>> https://github.com/orbitz/nixpkgs/commit/fd598f1b55c94b4d466ac5ddffb304136bdc433e
>>>
>>> The only interesting change is I had to patch Async because its build
>>> script requires /bin/bash and /bin/mkdir. And the build failure for
>>> Async is pretty awesome btw :)
>>>
>>> (I'm not 100% sure that the above branch works on Nix since I have some
>>> local changes that have been sitting around for awhile, but it gives the
>>> gist.  If more complete, working versions, are interested to anyone I
>>> can put the effort in to give a more complete demonstration)
>>>
>>> I also have these cheap scripts I use to create my environment when
>>> playing locally.  This should really be done as an eval like opam's
>>> config but right now I do something like 'ocaml_run.sh make'.  Or
>>> ocaml.sh to get the REPL.  This plays fine with opam (for me) since my
>>> script is additive to the environment.
>>>
>>> https://github.com/orbitz/ocaml_wrapper
>>>
>>> @yaron - Correct, AFAIK this does not some diamond dep problem.  Based
>>> on what Anil said I guess ocamlfind needs to be modified for that.  Or
>>> the ability for libraries to be built with their deps linked in already.
>>>
>>> /Malcolm
>>>
>>> Anil Madhavapeddy <anil at recoil.org> writes:
>>>
>>>> Right, but the opportunities for re-using previously compiled libraries
>>>> are limited, because of the exact-version requirements.  Having multiple
>>>> OPAM switches per set of constraints would be almost as good, if much
>>>> more burdensome from a command-line perspective.
>>>>
>>>> Do you have your Nix setup available anywhere? I'd definitely like to
>>>> have a play with it.
>>>>
>>>> -anil
>>>>
>>>> On 15 Feb 2013, at 11:37, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>
>>>>> I get around this in Nix with chroot and building OCAMLPATH on the fly.
>>>>>
>>>>> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
>>>>> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
>>>>> support multiple library versions.  OPAM could be extended to support
>>>>> multiple installations (since the constraint model expresses it fine),
>>>>> but would need to understand more of the build process too.
>>>>>
>>>>> There are some steps towards this already, such as the `.install` files
>>>>> which automate binary installation/removal.  We were reluctant to put
>>>>> any more in the first version in the interests of getting something out.
>>>>>
>>>>> -anil
>>>>>
>>>>> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>
>>>>> > Right now, I think Core not being afraid to change frequently is good.
>>>>> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
>>>>> > to have the public Core get out of synch with what Jane St uses
>>>>> > internally because it increases the overhead for you which decreases the
>>>>> > chance of timely releases.
>>>>> >
>>>>> > Multiple versions has not been a problem for me since I convert opam
>>>>> > packages I'm interested in to Nix packages, and Nix handles multiple
>>>>> > versions of installed packages just fine.  It's probably too late in the
>>>>> > game for opam to have this style as well, I don't know anything about
>>>>> > opam's design, but it's worked pretty well in Nix for me.
>>>>> >
>>>>> > Beyond that, I think good semantic versioning is probably key.  If the
>>>>> > majority of Core changes are backwards compatible (I have no idea if
>>>>> > this is the case) then installing the right package for a lot of the
>>>>> > apps probably isn't so bad.
>>>>> >
>>>>> > /Malcolm
>>>>> >
>>>>> > Yaron Minsky <yminsky at janestreet.com> writes:
>>>>> >
>>>>> >> Right now, the Core suite of libraries changes a lot --- we have a new
>>>>> >> release of everything every week.  The changes on a given week are
>>>>> >> small, but there are always changes.
>>>>> >>
>>>>> >> I can imagine this being something of a problem for OPAM.  If packages
>>>>> >> specify specific revisions of the Core suite, then we're going to have
>>>>> >> a massive version mismatch problem, where no two libraries can agree
>>>>> >> on the version of Core that they need.
>>>>> >>
>>>>> >> I have no obvious ideas as to how to solve this.  Does anyone else
>>>>> >> have ideas?  Should we simply encourage packagers to specify a
>>>>> >> lower-bound constraint on the Core libraries?
>>>>> >>
>>>>> >> y
>>>>> >> _______________________________________________
>>>>> >> Platform mailing list
>>>>> >> Platform at lists.ocaml.org
>>>>> >> http://lists.ocaml.org/listinfo/platform
>>>>> > _______________________________________________
>>>>> > Platform mailing list
>>>>> > Platform at lists.ocaml.org
>>>>> > http://lists.ocaml.org/listinfo/platform
>>>>> >
>>>>>

From mmatalka at gmail.com  Fri Feb 15 22:51:45 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 15 Feb 2013 17:51:45 -0500
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CACLX4jSGeapZ+OE_Xw+HPj4=-7TXou0AceMaPdKW4GBu5hWRfQ@mail.gmail.com>
 (Yaron Minsky's message of "Fri, 15 Feb 2013 17:42:37 -0500")
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <8738wxddq7.fsf@li195-236.members.linode.com>
 <4D76ABED-FCEC-4D5A-8F87-0DF38BE07810@recoil.org>
 <CAKziXDUhUjPN4PDpMQVrJFLGv=aAUCNqEH8nGO6BgEWcWYUXOA@mail.gmail.com>
 <B6A7D4F5-FE37-459E-B312-4D0B759F7ADB@recoil.org>
 <87r4khbwyi.fsf@li195-236.members.linode.com>
 <CACLX4jSuA5ox412FSiccnfdQxt+KdONTYMGLxmQ-ePdO0pezHg@mail.gmail.com>
 <87ip5tb3zf.fsf@li195-236.members.linode.com>
 <CACLX4jSGeapZ+OE_Xw+HPj4=-7TXou0AceMaPdKW4GBu5hWRfQ@mail.gmail.com>
Message-ID: <87ehghb37i.fsf@li195-236.members.linode.com>

Oh yes, with that example of course.  I was thinking more along the
lines where you wouldn't expose the raw Core values as your own API, but
obviously that's pretty limited.

Yaron Minsky <yminsky at janestreet.com> writes:

> I can't imagine how this would work in OCaml.  Imagine that A has a
> function:
>
>     val make_map : unit -> float Core.Std.Map.t
>
> and B has this function:
>
>     val consume_map : float Core.Std.Map.t -> unit
>
> If in your own library you write:
>
>     A.consume_map (B.make_map ())
>
> then if A and B link to different versions of Core that have different
> versions of the Map type, then the above code shouldn't compile!
>
> I basically think that the Nix model does not map sanely onto OCaml
> modules.  And I don't think this is all that OCaml specific.  The same
> bug would show up in Java, I would think.
>
> y
>
> On Fri, Feb 15, 2013 at 5:35 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> I don't know how Ocaml linking works, but here is how I believe it works
>> in Nix, which is mostly C-based packages, of course:
>>
>> - All packages are given a unique path
>>
>> - When you compile a package, if its deps are statically linked then
>>   they are just compiled into it, so it doesn't matter what else you're
>>   linking against when you use this as dep
>>
>> - If they are dynamically linked, a post-processing step rewrites the
>>   binary so all paths to deps are the unique path, I *think* this means
>>   if you have the diamond problem it's ok because the dep will always
>>   load the version of the library it was compiled against.
>>
>> But I could easily be way wrong.
>>
>> /M
>>
>> Yaron Minsky <yminsky at janestreet.com> writes:
>>
>>> I think the diamond dependency problem is a fundamental semantic
>>> issue, and can't be worked around by tools.  If I use a Core.Map.t
>>> from version 109.06, and the implementation changes in 109.07, then if
>>> libraries A and B both use Core.Map.t's in their interface, there's no
>>> way they can communicate, unless you propagate the versioning into the
>>> library!  You could have a Core_109_07.Map.t, and Core_109_06.Map.t,
>>> but I'm pretty sure madness lies that way...
>>>
>>> y
>>>
>>> On Fri, Feb 15, 2013 at 7:09 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> My Nix setup is a huge hack right now, but! here is my current public
>>>> fork of nixpkgs with an OLD version of opam + Core 108.07.01:
>>>>
>>>> https://github.com/orbitz/nixpkgs/commit/fd598f1b55c94b4d466ac5ddffb304136bdc433e
>>>>
>>>> The only interesting change is I had to patch Async because its build
>>>> script requires /bin/bash and /bin/mkdir. And the build failure for
>>>> Async is pretty awesome btw :)
>>>>
>>>> (I'm not 100% sure that the above branch works on Nix since I have some
>>>> local changes that have been sitting around for awhile, but it gives the
>>>> gist.  If more complete, working versions, are interested to anyone I
>>>> can put the effort in to give a more complete demonstration)
>>>>
>>>> I also have these cheap scripts I use to create my environment when
>>>> playing locally.  This should really be done as an eval like opam's
>>>> config but right now I do something like 'ocaml_run.sh make'.  Or
>>>> ocaml.sh to get the REPL.  This plays fine with opam (for me) since my
>>>> script is additive to the environment.
>>>>
>>>> https://github.com/orbitz/ocaml_wrapper
>>>>
>>>> @yaron - Correct, AFAIK this does not some diamond dep problem.  Based
>>>> on what Anil said I guess ocamlfind needs to be modified for that.  Or
>>>> the ability for libraries to be built with their deps linked in already.
>>>>
>>>> /Malcolm
>>>>
>>>> Anil Madhavapeddy <anil at recoil.org> writes:
>>>>
>>>>> Right, but the opportunities for re-using previously compiled libraries
>>>>> are limited, because of the exact-version requirements.  Having multiple
>>>>> OPAM switches per set of constraints would be almost as good, if much
>>>>> more burdensome from a command-line perspective.
>>>>>
>>>>> Do you have your Nix setup available anywhere? I'd definitely like to
>>>>> have a play with it.
>>>>>
>>>>> -anil
>>>>>
>>>>> On 15 Feb 2013, at 11:37, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>
>>>>>> I get around this in Nix with chroot and building OCAMLPATH on the fly.
>>>>>>
>>>>>> On Feb 15, 2013 12:34 PM, "Anil Madhavapeddy" <anil at recoil.org> wrote:
>>>>>> OPAM has a strong dependency on ocamlfind at the moment, which doesn't
>>>>>> support multiple library versions.  OPAM could be extended to support
>>>>>> multiple installations (since the constraint model expresses it fine),
>>>>>> but would need to understand more of the build process too.
>>>>>>
>>>>>> There are some steps towards this already, such as the `.install` files
>>>>>> which automate binary installation/removal.  We were reluctant to put
>>>>>> any more in the first version in the interests of getting something out.
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 15 Feb 2013, at 11:21, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>
>>>>>> > Right now, I think Core not being afraid to change frequently is good.
>>>>>> > I'd rather have that than a stale API that kind of sucks.  And I'd hate
>>>>>> > to have the public Core get out of synch with what Jane St uses
>>>>>> > internally because it increases the overhead for you which decreases the
>>>>>> > chance of timely releases.
>>>>>> >
>>>>>> > Multiple versions has not been a problem for me since I convert opam
>>>>>> > packages I'm interested in to Nix packages, and Nix handles multiple
>>>>>> > versions of installed packages just fine.  It's probably too late in the
>>>>>> > game for opam to have this style as well, I don't know anything about
>>>>>> > opam's design, but it's worked pretty well in Nix for me.
>>>>>> >
>>>>>> > Beyond that, I think good semantic versioning is probably key.  If the
>>>>>> > majority of Core changes are backwards compatible (I have no idea if
>>>>>> > this is the case) then installing the right package for a lot of the
>>>>>> > apps probably isn't so bad.
>>>>>> >
>>>>>> > /Malcolm
>>>>>> >
>>>>>> > Yaron Minsky <yminsky at janestreet.com> writes:
>>>>>> >
>>>>>> >> Right now, the Core suite of libraries changes a lot --- we have a new
>>>>>> >> release of everything every week.  The changes on a given week are
>>>>>> >> small, but there are always changes.
>>>>>> >>
>>>>>> >> I can imagine this being something of a problem for OPAM.  If packages
>>>>>> >> specify specific revisions of the Core suite, then we're going to have
>>>>>> >> a massive version mismatch problem, where no two libraries can agree
>>>>>> >> on the version of Core that they need.
>>>>>> >>
>>>>>> >> I have no obvious ideas as to how to solve this.  Does anyone else
>>>>>> >> have ideas?  Should we simply encourage packagers to specify a
>>>>>> >> lower-bound constraint on the Core libraries?
>>>>>> >>
>>>>>> >> y
>>>>>> >> _______________________________________________
>>>>>> >> Platform mailing list
>>>>>> >> Platform at lists.ocaml.org
>>>>>> >> http://lists.ocaml.org/listinfo/platform
>>>>>> > _______________________________________________
>>>>>> > Platform mailing list
>>>>>> > Platform at lists.ocaml.org
>>>>>> > http://lists.ocaml.org/listinfo/platform
>>>>>> >
>>>>>>

From Pietro.Abate at pps.univ-paris-diderot.fr  Mon Feb 18 18:08:49 2013
From: Pietro.Abate at pps.univ-paris-diderot.fr (Pietro Abate)
Date: Mon, 18 Feb 2013 19:08:49 +0100
Subject: [ocaml-platform] Does Core change too often?
In-Reply-To: <CAOCAUGNMcje_b2fqo2pgo2aXudgPGXFESNJkXhLhEffHO0A2cA@mail.gmail.com>
References: <CACLX4jQBiRec5Su0ESZeST_F5Tm1Lxb4VtBGHj5OD-F9KqhF0A@mail.gmail.com>
 <CAOCAUGNMcje_b2fqo2pgo2aXudgPGXFESNJkXhLhEffHO0A2cA@mail.gmail.com>
Message-ID: <20130218180849.GB9384@zed.irill.org>

On 15/02/13 11:31, Sylvain Le Gall wrote:
> > I have no obvious ideas as to how to solve this.  Does anyone else
> > have ideas?  Should we simply encourage packagers to specify a
> > lower-bound constraint on the Core libraries?
> 
> AFAIU, OPAM constraint model is inspired by Debian constraints
> model... Although this is a very complex model, that can probably
> express a lot of stuff, but it most often ends up by creating a new
> problem (like SAT solving for 350+ packages).

>From a SAT solver prospective, 350+ packages are peanuts. Dose, the
library used by opam, can easily manage repositories of about 100K
packages with constraints and all. In this framework, you can also
express ranges (for example) to declare that your library will work
with all the core releases from 1.1 to 1.5 (this is possible as a
package repository, from the solver prospective is a closed repository
and all versions are known). Soft constraints can be used as easily.

However consider that in order to fully exploit the dependency model
supported by opam it would be necessary a stronger policy on versions
(all these tools work with the underlying assumption that versions can
be compared using a canonical function) and some QA tool to routinely
check the health of the repository. This is already all available and
used in Debian and the related know-how can be easily ported to opam
repositories. I definitely see a future where with constraints (and
not only on the core library), but with greater powers, come even
greater responsibilities, and we should plan ahead establishing a
clear packaging policy to avoid problems along the track.

pietro

From gabriel.scherer at gmail.com  Thu Feb 21 13:08:29 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 21 Feb 2013 14:08:29 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
Message-ID: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>

Hi,

Since about a year now, there has been a intermittent discussion ongoing on
the idea of introducing "namespaces" to the OCaml language. The basis for
discussion are some pain points of the current behavior of the current
implementation (all modules live in a flat space that is defined by the
search-path (-I command) and not very resilient to change), but there have
been fairly different ideas about how to best solve those problems, or even
what "namespace" means.
The current flat-module-space has mostly been felt by distributors of
largeish codebases designed not to be used in isolation, but required by
users code, in particular set of libraries for OCaml (in particular
JaneStreet Core or Batteries, and possibly components from the future OCaml
platform).

I have worked on these issues last year with Didier Remy, and also Fabrice
Le Fessant and Nicolas Pouillard, and made an presentation at (the informal
part of) the last meeting the Caml Consortium. Here are a few documents we
we have written in the process:
- a design document: http://gallium.inria.fr/~scherer/namespaces/spec.pdf
- the slides of the talk:
http://gallium.inria.fr/~scherer/namespaces/consortium-talk-2012.pdf

While I think the core problems with the current compilation unit lookup
system are rather consensual, there is little agreement on what a
reasonable extension for the language or implementation would be, or if it
is even needed at all. The documents above take an intentionally "rich"
approach of the question, presenting a formal framework and language
designed to be rather expressive. It would be desirable to isolate a
simpler feature set that would cover the practical needs, but this needs to
a careful examination of the use cases, etc. I think people working or
interested in the OCaml Platform may have interesting inputs on the
problems and use cases at hand.

(A good example of the design trade-off involved is: who should have the
responsibility of choosing the names by which the OCaml user refers to
modules / software components on her system, the user itself or the
component provider? Letting users name things adds flexibility but also
complexity. Having a global shared namespace (eg. opam) makes the overall
design simpler, but also may also forbid some potentially interesting use
cases, such as users keeping version-pinned or modified versions of their
dependencies locally, and being able to explicitly refer either to the
standard version or the local version of a package. Do we want to forbid
that? Allow to pick one choice or the other in the global build system of
the developer's project? Let the developer use and link both standard and
local versions at the same time in a program, to compare them and make
tests, or if one dependency uses the standard version, and the other the
local one? Besides design trade-offs, there are also underlying
implementation questions, as the current OCaml linker has a rather
inflexible semantics in this regard.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130221/38f72438/attachment.html>

From lpw25 at cam.ac.uk  Thu Feb 21 15:36:26 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 21 Feb 2013 15:36:26 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>

> Since about a year now, there has been a intermittent discussion ongoing 
> on the idea of introducing "namespaces" to the OCaml language[...], but 
> there have been fairly different ideas about how to best solve those 
> problems, or even what "namespace" means.

As I see it what we *need* from namespaces is fairly simple:

  Developers must be able to give their components long (hierarchical) 
  names without changing the component's filename.

This allows components with the same filename to coexist within the search 
path. It also allows these components to be grouped together without 
packing them into a single module.

Any other features, such as allowing users to use multiple versions of a 
component or automatically assigning long names to components based on 
their position within the filesystem should be considered superfluous and 
unnecessary for an initial implementation.


In practical terms, what we need (based on Fabrice's "namespaces" branch of 
the OCaml source tree) is to be able to start a file with a syntax like:

  in Core.Std

This path is then included in the .cmi file and other compiled files. Then, 
when a user writes "Core.Std.List", lookup proceeds as follows:

1. Look for a module called Core in the current local environment. 

2. Look for a file "core.cmi" in the search path that is not attached to a 
   namespace.

3. Look for a file "std.cmi" in the search path that is attached to the 
   "Core" namespace.

4. Look for a file "list.cmi" in the search path that is attached to the 
   "Core.Std" namespace.

This lookup scheme could be simplified by, as Gabriel has suggested, using 
a different separator for namespaces (e.g. Core#Std#List). Personally, I 
don't have a strong opinion either way. A new separator is less ambiguous, 
but it is one more piece of syntax for beginners to learn.


Other simple features that would be useful include:

- Opening namespaces  ("open Core.Std")

- Aliasing namespaces  ("open Core.Std as CS")

- Attaching a component to multiple namespaces ("in Core.Std and 
  Core.Containers")

- A command-line option alternative to the "in" syntax.

- A command-line option to pre-open namespaces.

Regards,

Leo


From gabriel.scherer at gmail.com  Thu Feb 21 15:56:13 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 21 Feb 2013 16:56:13 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
Message-ID: <CAPFanBEm35sgHX9EGG3P-UzQ3DCWnavXTyeUN9Fjm81Pjw5-4Q@mail.gmail.com>

How would one specify which search path is associated to a given namespace
path (eg. Core.Std)? Is it easy to integrate into ocamlfind?

On Thu, Feb 21, 2013 at 4:36 PM, Leo White <lpw25 at cam.ac.uk> wrote:

> Since about a year now, there has been a intermittent discussion ongoing
>> on the idea of introducing "namespaces" to the OCaml language[...], but
>> there have been fairly different ideas about how to best solve those
>> problems, or even what "namespace" means.
>>
>
> As I see it what we *need* from namespaces is fairly simple:
>
>  Developers must be able to give their components long (hierarchical)
>  names without changing the component's filename.
>
> This allows components with the same filename to coexist within the search
> path. It also allows these components to be grouped together without
> packing them into a single module.
>
> Any other features, such as allowing users to use multiple versions of a
> component or automatically assigning long names to components based on
> their position within the filesystem should be considered superfluous and
> unnecessary for an initial implementation.
>
>
> In practical terms, what we need (based on Fabrice's "namespaces" branch
> of the OCaml source tree) is to be able to start a file with a syntax like:
>
>  in Core.Std
>
> This path is then included in the .cmi file and other compiled files.
> Then, when a user writes "Core.Std.List", lookup proceeds as follows:
>
> 1. Look for a module called Core in the current local environment.
> 2. Look for a file "core.cmi" in the search path that is not attached to a
>   namespace.
>
> 3. Look for a file "std.cmi" in the search path that is attached to the
> "Core" namespace.
>
> 4. Look for a file "list.cmi" in the search path that is attached to the
> "Core.Std" namespace.
>
> This lookup scheme could be simplified by, as Gabriel has suggested, using
> a different separator for namespaces (e.g. Core#Std#List). Personally, I
> don't have a strong opinion either way. A new separator is less ambiguous,
> but it is one more piece of syntax for beginners to learn.
>
>
> Other simple features that would be useful include:
>
> - Opening namespaces  ("open Core.Std")
>
> - Aliasing namespaces  ("open Core.Std as CS")
>
> - Attaching a component to multiple namespaces ("in Core.Std and
>  Core.Containers")
>
> - A command-line option alternative to the "in" syntax.
>
> - A command-line option to pre-open namespaces.
>
> Regards,
>
> Leo
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130221/2f083c0b/attachment.html>

From lpw25 at cam.ac.uk  Thu Feb 21 16:01:58 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 21 Feb 2013 16:01:58 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBEm35sgHX9EGG3P-UzQ3DCWnavXTyeUN9Fjm81Pjw5-4Q@mail.gmail.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <CAPFanBEm35sgHX9EGG3P-UzQ3DCWnavXTyeUN9Fjm81Pjw5-4Q@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302211601580.28188@hermes-1.csi.cam.ac.uk>

On Feb 21 2013, Gabriel Scherer wrote:

>How would one specify which search path is associated to a given namespace
>path (eg. Core.Std)? Is it easy to integrate into ocamlfind?
>

.cmi files would be looked up exactly as they are now, using the search 
path specified with -I options. The only difference is that when it finds a 
"list.cmi" file it checks if that file is attached to "Core.Std". If the 
file is attached to that namespace then it is used, otherwise the compiler 
keeps looking in the search path for more "list.cmi" files.


From gabriel.scherer at gmail.com  Thu Feb 21 16:12:16 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 21 Feb 2013 17:12:16 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302211601580.28188@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <CAPFanBEm35sgHX9EGG3P-UzQ3DCWnavXTyeUN9Fjm81Pjw5-4Q@mail.gmail.com>
 <Prayer.1.3.5.1302211601580.28188@hermes-1.csi.cam.ac.uk>
Message-ID: <CAPFanBEidBch_3gjDhafDcMA+T5ubSU1bt2N6O4y8-hto5XsuQ@mail.gmail.com>

So in this case you would have to look for list.cmi, std.cmi then core.cmi
(if you don't know which are namespaces, and which are actual compilation
unit names).

One problem with this proposal is that the compiler has no knowledge of the
set of "existing" namespaces. This combines very badly with the
module/namespace syntactic ambiguity: when you write "open Lsit" (List,
with a typo), the compiler will silently accept the opening of the Lsit
namespace. I formalized this semantics in an earlier proposal, but Fabrice
noticed that this was quite bad from an user interface point of view, and
further proposals used a model with "existing" namespaces and
"non-existing" namespaces -- in the current proposal linked above, the
compiler consults an explicit hierarchical mapping.
(Removing the syntactic ambiguity makes this slightly less of a problem,
but it's still a pain to not be warned of namespace typos.)

On Thu, Feb 21, 2013 at 5:01 PM, Leo White <lpw25 at cam.ac.uk> wrote:

> On Feb 21 2013, Gabriel Scherer wrote:
>
>  How would one specify which search path is associated to a given namespace
>> path (eg. Core.Std)? Is it easy to integrate into ocamlfind?
>>
>>
> .cmi files would be looked up exactly as they are now, using the search
> path specified with -I options. The only difference is that when it finds a
> "list.cmi" file it checks if that file is attached to "Core.Std". If the
> file is attached to that namespace then it is used, otherwise the compiler
> keeps looking in the search path for more "list.cmi" files.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130221/74ec3e7e/attachment-0001.html>

From lpw25 at cam.ac.uk  Thu Feb 21 17:00:25 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 21 Feb 2013 17:00:25 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBEidBch_3gjDhafDcMA+T5ubSU1bt2N6O4y8-hto5XsuQ@mail.gmail.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <CAPFanBEm35sgHX9EGG3P-UzQ3DCWnavXTyeUN9Fjm81Pjw5-4Q@mail.gmail.com>
 <Prayer.1.3.5.1302211601580.28188@hermes-1.csi.cam.ac.uk>
 <CAPFanBEidBch_3gjDhafDcMA+T5ubSU1bt2N6O4y8-hto5XsuQ@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302211700250.28188@hermes-1.csi.cam.ac.uk>

On Feb 21 2013, Gabriel Scherer wrote:

>So in this case you would have to look for list.cmi, std.cmi then core.cmi
>(if you don't know which are namespaces, and which are actual compilation
>unit names).

I would probably look for core.cmi then std.cmi and then list.cmi, but 
basically yes.

>One problem with this proposal is that the compiler has no knowledge of the
>set of "existing" namespaces. This combines very badly with the
>module/namespace syntactic ambiguity: when you write "open Lsit" (List,
>with a typo), the compiler will silently accept the opening of the Lsit
>namespace. 
> [...]
>(Removing the syntactic ambiguity makes this slightly less of a problem,
>but it's still a pain to not be warned of namespace typos.)

Catching this error (without syntactic ambiguity) should not actually be 
that hard in practise.

Consider something like "open Core#Sdt". This typo prevents us from finding 
an appropriate .cmi file, because the namespace is Core#Std rather than 
Core#Sdt. The unbound module error could include the fact that a .cmi file 
was found but that its namespace was not open.

The compiler could even locate the unused "open Core#Sdt" and use the new 
spell-checking code to suggest that it might be the cause of the error.

There is obviously still a risk that the typo in the open statement will 
not cause an error because there is another .cmi with the same name whose 
namespace is open. However, the "open Core#Sdt" instruction should still 
raise an "unused open" warning.

Overall, I don't think that it is worth forcing users to pre-declare all 
possible namespaces, just to avoid a slightly confusing error message in 
the case of a typo.

Even if you decide that you need to pre-declare all namespaces it should 
not be the responsibility of the user. It would be better to create special 
".cmi" files to represent the namespaces. These would not contain any 
information other than the name of their parent namespace, they would 
simply exist to show that the namespace existed. This might also make it 
easier to have namespaces and modules use the same seperator.

Leo


From alain at frisch.fr  Thu Feb 21 18:03:01 2013
From: alain at frisch.fr (Alain Frisch)
Date: Thu, 21 Feb 2013 19:03:01 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
Message-ID: <51266155.2060205@frisch.fr>

On 2/21/2013 4:36 PM, Leo White wrote:
> As I see it what we *need* from namespaces is fairly simple:
>
>   Developers must be able to give their components long (hierarchical)
>   names without changing the component's filename.
>
> This allows components with the same filename to coexist within the
> search path. It also allows these components to be grouped together
> without packing them into a single module.

What would be the justification for hierarchical names?  It seems that a 
flat qualifier is enough to support the two goals you mention (making 
components with the same filename coexist, and grouping them with a 
common name).  In practice, we will have a namespace per distributed 
library (e.g. Core, Extlib, Xml-light, ...).  Restricting to flat 
qualifiers might enable a simpler design.

Personally, I'm not even convinced of the need for supporting several 
compilation units with the same filename.  Basically, we will encode 
namespace information inside the .cmi instead of doing it in the 
filename, forcing the compiler to open files only to discover they are 
not in the correct namespace.  Is it really so tedious to use longer 
filenames?  For the library developer, I'd say no.  For the library 
user, maybe, and I'd rather focus on providing ways to make it simpler 
to refer to long module names, such as a good module alias feature in 
the language and/or a way to customize the link between names in source 
files and external module names (a mapping could be specified in 
external files).


Alain

From alain.frisch at lexifi.com  Thu Feb 21 18:23:19 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 21 Feb 2013 19:23:19 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
Message-ID: <51266617.1020107@lexifi.com>

On 2/21/2013 4:36 PM, Leo White wrote:
> As I see it what we *need* from namespaces is fairly simple:
>
>   Developers must be able to give their components long (hierarchical)
>   names without changing the component's filename.
>
> This allows components with the same filename to coexist within the
> search path. It also allows these components to be grouped together
> without packing them into a single module.

What would be the justification for hierarchical names?  It seems that a 
flat qualifier is enough to support the two goals you mention (making 
components with the same filename coexist, and grouping them with a 
common name).  In practice, we will have a namespace per distributed 
library (e.g. Core, Extlib, Xml-light, ...).  Restricting to flat 
qualifiers might enable a simpler design.

Personally, I'm not even convinced of the need for supporting several 
compilation units with the same filename.  Basically, we will encode 
namespace information inside the .cmi instead of doing it in the 
filename, forcing the compiler to open files only to discover they are 
not in the correct namespace.  Is it really so tedious to use longer 
filenames?  For the library developer, I'd say no.  For the library 
user, maybe, and I'd rather focus on providing ways to make it simpler 
to refer to long module names, such as a good module alias feature in 
the language and/or a way to customize the link between names in source 
files and external module names (a mapping could be specified in 
external files).


Alain
_______________________________________________
Platform mailing list
Platform at lists.ocaml.org
http://lists.ocaml.org/listinfo/platform

From lpw25 at cam.ac.uk  Thu Feb 21 18:39:37 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 21 Feb 2013 18:39:37 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <51266155.2060205@frisch.fr>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
Message-ID: <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>

>What would be the justification for hierarchical names?  It seems that a 
>flat qualifier is enough to support the two goals you mention (making 
>components with the same filename coexist, and grouping them with a 
>common name).  In practice, we will have a namespace per distributed 
>library (e.g. Core, Extlib, Xml-light, ...).  Restricting to flat 
>qualifiers might enable a simpler design.

Large libraries can also contain multiple components with the same name. 
For example, a library might provide both Foo.Aysc.IO and Foo.Lwt.IO.

I don't think having hierarchical namespaces really adds much additional 
complexity to the system.

More generally, almost all naming systems are hierarchical. It is a tried 
and tested way of organising things.

>Personally, I'm not even convinced of the need for supporting several 
>compilation units with the same filename.  Basically, we will encode 
>namespace information inside the .cmi instead of doing it in the 
>filename, forcing the compiler to open files only to discover they are 
>not in the correct namespace.  Is it really so tedious to use longer 
>filenames?  

Is it really so tedious for the compiler to look in multiple .cmi files 
until the right one is found?

Long filenames don't allow you to open or alias a namespace, they also 
don't allow you to change the namespaces that are open by default. All of 
which are useful features.

I also think that long filenames *are* tedious, if they weren't people 
would use them already. If you are using a large library, even with a good 
aliasing feature, you would end up writing:

  open Core_Std_Mutex as Mutex
  open Core_Std_Thread as Thread
  open Core_Std_Date as Date

at the beginning of all your files, instead of writing:

  open Core.Std

Regards,

Leo


From zack at upsilon.cc  Thu Feb 21 20:31:40 2013
From: zack at upsilon.cc (Stefano Zacchiroli)
Date: Thu, 21 Feb 2013 21:31:40 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <51266617.1020107@lexifi.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266617.1020107@lexifi.com>
Message-ID: <20130221203140.GA18946@upsilon.cc>

On Thu, Feb 21, 2013 at 07:23:19PM +0100, Alain Frisch wrote:
> What would be the justification for hierarchical names?

One of the advantages that comes to mind is the ability to piggyback on
already existing, world-wide, unambiguous, hierarchical namespaces out
there, such as DNS. It's overly verbose, but if you dream of a very
widespread adoption of the language (a-la Java), then namespaces like
org.apache.... have their advantages in terms of scalability.

Just my 0.02?,
Cheers.
-- 
Stefano Zacchiroli  . . . . . . .  zack at upsilon.cc . . . . o . . . o . o
Ma?tre de conf?rences . . . . . http://upsilon.cc/zack . . . o . . . o o
Debian Project Leader . . . . . . @zack on identi.ca . . o o o . . . o .
? the first rule of tautology club is the first rule of tautology club ?

From xavier.clerc at inria.fr  Fri Feb 22 08:54:37 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Fri, 22 Feb 2013 09:54:37 +0100 (CET)
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130221203140.GA18946@upsilon.cc>
Message-ID: <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>

----- Mail original -----
> On Thu, Feb 21, 2013 at 07:23:19PM +0100, Alain Frisch wrote:
> > What would be the justification for hierarchical names?
> 
> One of the advantages that comes to mind is the ability to piggyback
> on
> already existing, world-wide, unambiguous, hierarchical namespaces
> out
> there, such as DNS. It's overly verbose, but if you dream of a very
> widespread adoption of the language (a-la Java), then namespaces like
> org.apache.... have their advantages in terms of scalability.

I concur. However, I would like to draw your attention on the fact that
hierarchical names tend to convey the intuition that the parent element
somehow "contains" the children elements. In Java, this is an incorrect
assumption, as the namespace is indeed flat. My bet is that if hierarchical
names are used, it has to be reflected in the semantics.


More generally on the subject of namespaces, shouldn't we assess the
merits and mistakes of their equivalents in other languages?


Regards,

Xavier

From alain.frisch at lexifi.com  Fri Feb 22 09:22:23 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 22 Feb 2013 10:22:23 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
 <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
Message-ID: <512738CF.70905@lexifi.com>

On 2/21/2013 7:39 PM, Leo White wrote:
> More generally, almost all naming systems are hierarchical. It is a
> tried and tested way of organising things.

The namespace system I've used most, XML Namespaces, has flat qualifiers 
(we could argue that they are in general URL/URN, with a hierarchical 
structure, but namespaces are really just strings matched with strict 
equality).

I agree with Xavier that if we give a hierarchical syntax to namespaces, 
this should somehow be reflected in the semantics to avoid confusion.

> Is it really so tedious for the compiler to look in multiple .cmi files
> until the right one is found?

Nothing is really tedious for a compiler, but there are technical 
drawbacks of doing so:

  - Performance:  looking up and opening files takes time, especially 
under bad OS such as Windows.

  - It prevents from putting .cmi files from many libraries in the same 
directory, which is sometimes useful (to simplify deployment; to control 
precisely the set of .cmi available for a given file; to improve 
performance by avoiding repeated lookups in many directories).

  - Spurious dependencies: technically, since the compiler will open 
them, all x.cmi files in the search path should be considered as 
dependencies for a module which refers to X.  This is necessary to have 
a correct notion of dependency for the build system (formally, each 
x.cmi could become the "correct one" if its namespace changes in the 
source file; and since all these files are opened, they should not be 
overwritten in parallel).  This complexifies the build system, 
especially for parallel builds, and creates a risk of dependency cycles.


> I also think that long filenames *are* tedious, if they weren't people
> would use them already. If you are using a large library, even with a
> good aliasing feature, you would end up writing:
>
>   open Core_Std_Mutex as Mutex
>   open Core_Std_Thread as Thread
>   open Core_Std_Date as Date
>
> at the beginning of all your files, instead of writing:
>
>   open Core.Std

That's why I've proposed to allow specifying mapping between references 
to external modules in dedicated files.  We could have a file 
core_std.ns (probably shipped with Core) with this content:

Mutex = Core_std_mutex
Thread = Core_std_thread
Date = Core_std_date

and just a reference in the source code (or on the command-line):

   open namespace Core_std

which would load core_std.ns and use the corresponding module renaming 
in the rest of the module.

Regards,

Alain

From sylvain+ocaml at le-gall.net  Fri Feb 22 09:31:20 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Fri, 22 Feb 2013 10:31:20 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
Message-ID: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>

2013/2/22 Xavier Clerc <xavier.clerc at inria.fr>:
> ----- Mail original -----
>> On Thu, Feb 21, 2013 at 07:23:19PM +0100, Alain Frisch wrote:
>> > What would be the justification for hierarchical names?
>>
>> One of the advantages that comes to mind is the ability to piggyback
>> on
>> already existing, world-wide, unambiguous, hierarchical namespaces
>> out
>> there, such as DNS. It's overly verbose, but if you dream of a very
>> widespread adoption of the language (a-la Java), then namespaces like
>> org.apache.... have their advantages in terms of scalability.
>
> I concur. However, I would like to draw your attention on the fact that
> hierarchical names tend to convey the intuition that the parent element
> somehow "contains" the children elements. In Java, this is an incorrect
> assumption, as the namespace is indeed flat. My bet is that if hierarchical
> names are used, it has to be reflected in the semantics.
>
>
> More generally on the subject of namespaces, shouldn't we assess the
> merits and mistakes of their equivalents in other languages?
>

I tend to agree with Alain about the fact that hierarchical namespaces
is overkill. Flat namespace is easier to achieve and will solve most
problems.

Working with Java all days long and its namespace, I would say it is
totally useless to copy that! What the meaning of org.apache? Will I
have to name my libraries net.le-gall.sylvain.Foo or
org.ocamlcore.forge.ounit.OUnit?

Honestly, hierarchical namespace just makes mandatory IDE completion
(read Eclipse or IntelliJ here). And even in this case the
autocomplete boxes are too small to make the difference between
org.apache.utils.String and org.apache.bar.utils.String.

If we have to vote on this topic, I would say: flat namespace and
that's enough for me.

Regards
Sylvain

From daniel.buenzli at erratique.ch  Fri Feb 22 10:39:41 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 11:39:41 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
Message-ID: <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>

This may be a silly suggestion as I'm not sure I'm really convinced by the absolute *need* for namespaces (I'd rather not have an additional concept in a language that I already find sufficiently complex to my taste).

However it strikes me that while it seems to be agreed upon that a simple mechanism like `-pack` solves the problem albeit not in a technically satisfying way, the worked out proposal seems to skyrocket into complexity. The best way to avoid bureaucracy/complexity is not to introduce the tools to be able to manage it...

So if the problem is `-pack` is not good enough because it produces a huge `cmo`, why not just try to find a corresponding concept workable with `cm[x]a` ?  

Here's a proposal --- from a user point of view, I'll let the compiler hackers comment on how/if this could be workable.

Introduce `cmia` files that bundles the `cmi`'s of a `cm[x]a` with the corresponding file name. The name of the `cmia` file (and hence of the `cm[x]a` file) defines your toplevel module name ? la `-pack`. Make it even be backward compatible in the sense that if there's no `cmia` for a `cm[x]a` the modules are accessed as before. Now you have a kind of `-pack` that work with `cm[x]a`.

Best,

Daniel

P.S. flat vs hierarchical, I'd also rather go flat.



From wojciech.meyer at gmail.com  Fri Feb 22 11:38:50 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Fri, 22 Feb 2013 11:38:50 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
Message-ID: <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>

Hi,

I want to say that (not finished yet) proposal looks good to me. I like
the idea of being able to structure the environments into tree.
The reason why I think we should use hierarchy is:
- ability to structure several libraries into same "shelves" - looking
what Haskell does [1]: Control.Arrow or Data.Array. It will help to
provide one and consistent library for the platform. It does not
necessarily require (but enables) to use "provenance" style of naming
(e.g. Java convention)
- it enables us to pack some of the platform specific modules into
single name under some hierarchy, consider:

Win32 # System # Unix
Unix # System # Unix

now we are able to conveniently merge appropriate one of these during
compile time.

I'd like to emphasise that we would need to encourage people in a social
way to use the hierarchies wisely, and have some fixed conventions for
the community projects. One way to do this is the Platform itself - when
it will come with pre-bundled hierarchy people will start putting their
libraries into right shelves.

I'm a big fan of the DSL approach, and the spec have clear semantics
regarding namespaces - namespace a name for an environment.

I don't think I have anything other to say, beside that so far I like
it. Looking forward having more input in the proposal.

--
Wojciech

[1] http://www.haskell.org/ghc/docs/latest/html/libraries/


On Thu, Feb 21, 2013 at 1:08 PM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
> Hi,
>
> Since about a year now, there has been a intermittent discussion ongoing on
> the idea of introducing "namespaces" to the OCaml language. The basis for
> discussion are some pain points of the current behavior of the current
> implementation (all modules live in a flat space that is defined by the
> search-path (-I command) and not very resilient to change), but there have
> been fairly different ideas about how to best solve those problems, or even
> what "namespace" means.
> The current flat-module-space has mostly been felt by distributors of
> largeish codebases designed not to be used in isolation, but required by
> users code, in particular set of libraries for OCaml (in particular
> JaneStreet Core or Batteries, and possibly components from the future OCaml
> platform).
>
> I have worked on these issues last year with Didier Remy, and also Fabrice
> Le Fessant and Nicolas Pouillard, and made an presentation at (the informal
> part of) the last meeting the Caml Consortium. Here are a few documents we
> we have written in the process:
> - a design document: http://gallium.inria.fr/~scherer/namespaces/spec.pdf
> - the slides of the talk:
> http://gallium.inria.fr/~scherer/namespaces/consortium-talk-2012.pdf
>
> While I think the core problems with the current compilation unit lookup
> system are rather consensual, there is little agreement on what a reasonable
> extension for the language or implementation would be, or if it is even
> needed at all. The documents above take an intentionally "rich" approach of
> the question, presenting a formal framework and language designed to be
> rather expressive. It would be desirable to isolate a simpler feature set
> that would cover the practical needs, but this needs to a careful
> examination of the use cases, etc. I think people working or interested in
> the OCaml Platform may have interesting inputs on the problems and use cases
> at hand.
>
> (A good example of the design trade-off involved is: who should have the
> responsibility of choosing the names by which the OCaml user refers to
> modules / software components on her system, the user itself or the
> component provider? Letting users name things adds flexibility but also
> complexity. Having a global shared namespace (eg. opam) makes the overall
> design simpler, but also may also forbid some potentially interesting use
> cases, such as users keeping version-pinned or modified versions of their
> dependencies locally, and being able to explicitly refer either to the
> standard version or the local version of a package. Do we want to forbid
> that? Allow to pick one choice or the other in the global build system of
> the developer's project? Let the developer use and link both standard and
> local versions at the same time in a program, to compare them and make
> tests, or if one dependency uses the standard version, and the other the
> local one? Besides design trade-offs, there are also underlying
> implementation questions, as the current OCaml linker has a rather
> inflexible semantics in this regard.)
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>

From anil at recoil.org  Fri Feb 22 11:41:10 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 22 Feb 2013 11:41:10 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
Message-ID: <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>

There's one scenario which absolutely requires the ability to explicitly open a particular namespace: camlp4 code generation.

Right now, several camlp4 extensions break because they use modules from the standard Pervasives library, and have no way to explicitly state that.  If Core.Std is opened, then compilation fails.  

The two workarounds are:
- hack the build system to pass -pp options to the camlp4 generator. Painful.
- have some facility to explicitly open 'Caml_std' or 'Core_std' locally, irrespective of the current module environment.

I believe namespaces addresses the latter workaround.

-anil

On 22 Feb 2013, at 10:39, Daniel B?nzli <daniel.buenzli at erratique.ch> wrote:

> This may be a silly suggestion as I'm not sure I'm really convinced by the absolute *need* for namespaces (I'd rather not have an additional concept in a language that I already find sufficiently complex to my taste).
> 
> However it strikes me that while it seems to be agreed upon that a simple mechanism like `-pack` solves the problem albeit not in a technically satisfying way, the worked out proposal seems to skyrocket into complexity. The best way to avoid bureaucracy/complexity is not to introduce the tools to be able to manage it...
> 
> So if the problem is `-pack` is not good enough because it produces a huge `cmo`, why not just try to find a corresponding concept workable with `cm[x]a` ?  
> 
> Here's a proposal --- from a user point of view, I'll let the compiler hackers comment on how/if this could be workable.
> 
> Introduce `cmia` files that bundles the `cmi`'s of a `cm[x]a` with the corresponding file name. The name of the `cmia` file (and hence of the `cm[x]a` file) defines your toplevel module name ? la `-pack`. Make it even be backward compatible in the sense that if there's no `cmia` for a `cm[x]a` the modules are accessed as before. Now you have a kind of `-pack` that work with `cm[x]a`.
> 
> Best,
> 
> Daniel
> 
> P.S. flat vs hierarchical, I'd also rather go flat.
> 
> 
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform


From daniel.buenzli at erratique.ch  Fri Feb 22 12:12:16 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 13:12:16 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
Message-ID: <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>

Le vendredi, 22 f?vrier 2013 ? 12:41, Anil Madhavapeddy a ?crit :
> There's one scenario which absolutely requires the ability to explicitly open a particular namespace: camlp4 code generation.

Well I'm not sure I'd like more complexity in the system to support the otherwise ugly tool that camlp4 is. Besides I'm sure this problem can be tackled using modules and the language as it stands instead of introducing a new bureaucratic concept in the language.  

Daniel



From anil at recoil.org  Fri Feb 22 12:14:21 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 22 Feb 2013 12:14:21 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
Message-ID: <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>

On 22 Feb 2013, at 12:12, Daniel B?nzli <daniel.buenzli at erratique.ch> wrote:

> Le vendredi, 22 f?vrier 2013 ? 12:41, Anil Madhavapeddy a ?crit :
>> There's one scenario which absolutely requires the ability to explicitly open a particular namespace: camlp4 code generation.
> 
> Well I'm not sure I'd like more complexity in the system to support the otherwise ugly tool that camlp4 is. Besides I'm sure this problem can be tackled using modules and the language as it stands instead of introducing a new bureaucratic concept in the language.  

This remains a problem in any code-generation approach, including ppx.  Namespaces are just another way of manipulating modules, so we could call them 'module aliases' if having a new word is scaring people off.

-anil

From daniel.buenzli at erratique.ch  Fri Feb 22 12:42:21 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 13:42:21 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
Message-ID: <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>

Le vendredi, 22 f?vrier 2013 ? 12:38, Wojciech Meyer a ?crit :
> The reason why I think we should use hierarchy is:
> - ability to structure several libraries into same "shelves" - looking
> what Haskell does [1]: Control.Arrow or Data.Array. It will help to
> provide one and consistent library for the platform. It does not
> necessarily require (but enables) to use "provenance" style of naming
> (e.g. Java convention)

Actually I find this way of structuring things not pertinent *at all*. It brings absolutely nothing.

First with hierarchies there's always the problem that at certain point you want two things to be in two different places. This is why "tags" are usually better than "folders" to organize things, see e.g. gmail.  

Second if we take the link you provided there are not so much toplevel descriptors which means that it lengthen the names without bringing much benefit except noise. More precisely, for me there are two things that needs to be distinguished:

1) A user looking for a library to solve a problem.
2) A user writing code with the library he found or reading code already written.

In case 1) a tagging system is a better way of finding what he's looking for and this doesn't actually happen in the language anyway. More likely he'll browse opam's html representation (opam recently added tags I'm sure they will eventually implement tag browsing in their html representation)

In case 2) the reader gets absolutely no benefit of these intermediate descriptors/hierarchies (e.g. unsurpisingly Data.Time.Calendar isn't just "Data"). He just need a quick way to access the leaves of the hierarchy. So the hierarchy itself is here again useless in the language, it's only noise.  

Keep it flat.

Daniel



From mmatalka at gmail.com  Fri Feb 22 12:45:39 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 22 Feb 2013 07:45:39 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org> (Anil
 Madhavapeddy's message of "Fri, 22 Feb 2013 11:41:10 +0000")
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
Message-ID: <87r4k8tt3g.fsf@li195-236.members.linode.com>

I'm not paying attention as well as I should be to this thread, but what
you said reminded me of something I'd thought about, maybe it's really
ignorante, but it would be nice if I could do access modules from a
'root' name, kind of like DNS.  So if I have opened Core.Std I can
access the old 'lists' module by doing '.List' or something.  This would
require camlp4 modules to be written intelligently, but the ability would
ensure they know which module they are getting.

Just a thought,
/M

Anil Madhavapeddy <anil at recoil.org> writes:

> There's one scenario which absolutely requires the ability to explicitly open a particular namespace: camlp4 code generation.
>
> Right now, several camlp4 extensions break because they use modules from the standard Pervasives library, and have no way to explicitly state that.  If Core.Std is opened, then compilation fails.  
>
> The two workarounds are:
> - hack the build system to pass -pp options to the camlp4 generator. Painful.
> - have some facility to explicitly open 'Caml_std' or 'Core_std' locally, irrespective of the current module environment.
>
> I believe namespaces addresses the latter workaround.
>
> -anil
>
> On 22 Feb 2013, at 10:39, Daniel B?nzli <daniel.buenzli at erratique.ch> wrote:
>
>> This may be a silly suggestion as I'm not sure I'm really convinced by the absolute *need* for namespaces (I'd rather not have an
>> additional concept in a language that I already find sufficiently complex to my taste).
>> 
>> However it strikes me that while it seems to be agreed upon that a simple mechanism like `-pack` solves the problem albeit not in a
>> technically satisfying way, the worked out proposal seems to skyrocket into complexity. The best way to avoid bureaucracy/complexity is
>> not to introduce the tools to be able to manage it...
>> 
>> So if the problem is `-pack` is not good enough because it produces a huge `cmo`, why not just try to find a corresponding concept workable with `cm[x]a` ?  
>> 
>> Here's a proposal --- from a user point of view, I'll let the compiler hackers comment on how/if this could be workable.
>> 
>> Introduce `cmia` files that bundles the `cmi`'s of a `cm[x]a` with the corresponding file name. The name of the `cmia` file (and hence of
>> the `cm[x]a` file) defines your toplevel module name ? la `-pack`. Make it even be backward compatible in the sense that if there's no
>> cmia` for a `cm[x]a` the modules are accessed as before. Now you have a kind of `-pack` that work with `cm[x]a`.
>> 
>> Best,
>> 
>> Daniel
>> 
>> P.S. flat vs hierarchical, I'd also rather go flat.
>> 
>> 
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From daniel.buenzli at erratique.ch  Fri Feb 22 12:51:05 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 13:51:05 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
 <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>
Message-ID: <15303734606646EF8D66B740EC7BDEBB@erratique.ch>

Le vendredi, 22 f?vrier 2013 ? 13:14, Anil Madhavapeddy a ?crit :
> This remains a problem in any code-generation approach, including ppx. Namespaces are just another way of manipulating modules, so we could call them 'module aliases' if having a new word is scaring people off.

But this is already part of the language (module M = M'), just make its cost negligible. Now maybe it's just a matter of rendering stdlib less pervasives or as you suggest to make its components available under another toplevel name. What I doubt is that some new mechanism really has to be introduced.   

Daniel



From daniel.buenzli at erratique.ch  Fri Feb 22 12:52:23 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 13:52:23 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
Message-ID: <CE8E0B724DB647308BD2EACB8668DB45@erratique.ch>



Le vendredi, 22 f?vrier 2013 ? 13:42, Daniel B?nzli a ?crit :

> First with hierarchies there's always the problem that at certain point you want two things to be in two different places.  

That should read "one thing in two different places" of course.

Daniel



From Maxence.Guesdon at inria.fr  Fri Feb 22 13:13:50 2013
From: Maxence.Guesdon at inria.fr (Maxence Guesdon)
Date: Fri, 22 Feb 2013 14:13:50 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
Message-ID: <20130222141350.04677214@alcazar>

On Fri, 22 Feb 2013 13:42:21 +0100
Daniel B?nzli <daniel.buenzli at erratique.ch> wrote:

> Le vendredi, 22 f?vrier 2013 ? 12:38, Wojciech Meyer a ?crit :
> > The reason why I think we should use hierarchy is:
> > - ability to structure several libraries into same "shelves" - looking
> > what Haskell does [1]: Control.Arrow or Data.Array. It will help to
> > provide one and consistent library for the platform. It does not
> > necessarily require (but enables) to use "provenance" style of naming
> > (e.g. Java convention)
> 
> Actually I find this way of structuring things not pertinent *at all*. It brings absolutely nothing.
> 
> First with hierarchies there's always the problem that at certain point you want two things to be in two different places. This is why "tags" are usually better than "folders" to organize things, see e.g. gmail.  
> 
> Second if we take the link you provided there are not so much toplevel descriptors which means that it lengthen the names without bringing much benefit except noise. More precisely, for me there are two things that needs to be distinguished:
> 
> 1) A user looking for a library to solve a problem.
> 2) A user writing code with the library he found or reading code already written.
> 
> In case 1) a tagging system is a better way of finding what he's looking for and this doesn't actually happen in the language anyway. More likely he'll browse opam's html representation (opam recently added tags I'm sure they will eventually implement tag browsing in their html representation)
> 
> In case 2) the reader gets absolutely no benefit of these intermediate descriptors/hierarchies (e.g. unsurpisingly Data.Time.Calendar isn't just "Data"). He just need a quick way to access the leaves of the hierarchy. So the hierarchy itself is here again useless in the language, it's only noise.  
> 
> Keep it flat.

I fully agree.

All this reminds me of the hierarchy discussions on the batteries list:
  https://lists.forge.ocamlcore.org/pipermail/batteries-devel/2008-November/thread.html#278
The hierarchy looked like this:
  http://batteries.forge.ocamlcore.org/doc.preview:batteries-alpha2/batteries/html/api/index.html

"The flatter, the better".

Cheers,

Maxence, 

From mmatalka at gmail.com  Fri Feb 22 13:52:38 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 22 Feb 2013 08:52:38 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <15303734606646EF8D66B740EC7BDEBB@erratique.ch> ("Daniel
 =?utf-8?Q?B=C3=BCnzli=22's?= message of "Fri, 22 Feb 2013 13:51:05 +0100")
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
 <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>
 <15303734606646EF8D66B740EC7BDEBB@erratique.ch>
Message-ID: <87mwuwtpzt.fsf@li195-236.members.linode.com>

So would a syntax extension always have to store the modules it wants to
be sure to access at the beginning of a file it requires, making sure
not to choose overlapping names?

Daniel B?nzli <daniel.buenzli at erratique.ch> writes:

> Le vendredi, 22 f?vrier 2013 ? 13:14, Anil Madhavapeddy a ?crit :
>> This remains a problem in any code-generation approach, including ppx. Namespaces are just another way of manipulating modules, so we
> could call them 'module aliases' if having a new word is scaring people off.
>
> But this is already part of the language (module M = M'), just make its cost negligible. Now maybe it's just a matter of rendering stdlib
> less pervasives or as you suggest to make its components available under another toplevel name. What I doubt is that some new mechanism
> really has to be introduced.
>
> Daniel
>
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From lpw25 at cam.ac.uk  Fri Feb 22 14:06:22 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 22 Feb 2013 14:06:22 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512738CF.70905@lexifi.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
 <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
 <512738CF.70905@lexifi.com>
Message-ID: <Prayer.1.3.5.1302221406220.21772@hermes-1.csi.cam.ac.uk>

>  - Performance:  looking up and opening files takes time, especially 
>under bad OS such as Windows.

There are a number of possible solutions to spurious opens. The simplest of 
which is to only look for "Core.Std.Mutex" in directories which contain the 
special "Core.Std" .cmi file (mentioned previously as a solution to typos 
in open statements). These special .cmi files could also be extended to 
include a list of modules that have that namespace within the current 
directory which would prevent spurious reads entirely.

>  - It prevents from putting .cmi files from many libraries in the same 
>directory, which is sometimes useful (to simplify deployment; to control 
>precisely the set of .cmi available for a given file; to improve 
>performance by avoiding repeated lookups in many directories).

I think that this ability is of dubious value and not really a big loss.

>  - Spurious dependencies: technically, since the compiler will open 
>them, all x.cmi files in the search path should be considered as 
>dependencies for a module which refers to X.  This is necessary to have 
>a correct notion of dependency for the build system (formally, each 
>x.cmi could become the "correct one" if its namespace changes in the 
>source file; and since all these files are opened, they should not be 
>overwritten in parallel).  This complexifies the build system, 
>especially for parallel builds, and creates a risk of dependency cycles.

The solutions above should solve this problem.

Even without those solutions, there is no need for a proper dependency, 
since changing the namespace would cause there to be two filenames with the 
same name and namespace. This is basically an error, so dependencies should 
not be expected to be correct. It would not be difficult for an OCaml 
specific build system to detect the existence of two files with the same 
name and namespace and raise an error.

There is possibly the need for some kind of partial dependency for parallel 
builds. This is more like a lock than a dependency, so there should be no 
question of circular dependencies. I'm not really familiar with how 
parallel file accesses work on different file systems, but perhaps the 
compiler could lock ".cmi" files before reading and writing. This might be 
a good idea more generally for cases where dependencies have not been 
correctly calculated.

>That's why I've proposed to allow specifying mapping between references 
>to external modules in dedicated files.  We could have a file 
>core_std.ns (probably shipped with Core) with this content:
>
>Mutex = Core_std_mutex
>Thread = Core_std_thread
>Date = Core_std_date
>
>and just a reference in the source code (or on the command-line):
>
>   open namespace Core_std
>
>which would load core_std.ns and use the corresponding module renaming 
>in the rest of the module.

There is very little difference between that suggestion and having 
a core_std.ns file containing:

  Mutex;
  Thread;
  Date;

and using that as a (partial) declaration of a Core_std namespaces, except 
that you have to give every file a unique long filename. So I don't really 
see the particular benefit of using long filenames.

There is also a more general problem with any solution like this, which 
tries to define namespaces (or sets of aliases) in a single file. It is 
difficult to use the namespace from inside the modules that are within the 
namespace. For example, if I use:

  open namespace Core_std

from within mutex.ml then it will attempt to open itself.

This is particularly problematic for language extensions, because they want 
to generate code like:

Core_Std.Mutex.lock

but if they are used within another module in Core_Std then it breaks.

The solution to these problems is to have membership of a namespace encoded 
in the module itself.


From daniel.buenzli at erratique.ch  Fri Feb 22 14:33:57 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 15:33:57 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <87mwuwtpzt.fsf@li195-236.members.linode.com>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
 <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>
 <15303734606646EF8D66B740EC7BDEBB@erratique.ch>
 <87mwuwtpzt.fsf@li195-236.members.linode.com>
Message-ID: <79BEFC008E3447CB92ABBBE0A1D4A92D@erratique.ch>

Le vendredi, 22 f?vrier 2013 ? 14:52, Malcolm Matalka a ?crit :
> So would a syntax extension always have to store the modules it wants to
> be sure to access at the beginning of a file it requires, making sure
> not to choose overlapping names?

Why not ? Each extension could have its own module against which you have to link to use the extension that has the module it uses in it (MyExt.List?).

It's not evident to me that namespaces actually solve the problem either, they just seem to push the problem in the build system. The actual problem seems very related to the problem of hygienic macros (accidental name capture).  

Besides I'm not sure the example Anil gave is as widespread as it seems, it feels like a corner case that could be avoided, as he suggested, by having the ability to refer to stdlib's modules under a toplevel name (OCaml.List) and this still seems in the realm of the module system (and could be realized via something like cmia).  

Daniel




From gabriel.scherer at gmail.com  Fri Feb 22 14:39:44 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 22 Feb 2013 15:39:44 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <79BEFC008E3447CB92ABBBE0A1D4A92D@erratique.ch>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
 <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>
 <15303734606646EF8D66B740EC7BDEBB@erratique.ch>
 <87mwuwtpzt.fsf@li195-236.members.linode.com>
 <79BEFC008E3447CB92ABBBE0A1D4A92D@erratique.ch>
Message-ID: <CAPFanBEbtXgXOE+i+Nb_oxonkXTK-_7Y2jKuZ6U6hSP91sQUWg@mail.gmail.com>

> It's not evident to me that namespaces actually solve the problem either,
they just seem to push the problem in the build system. The actual problem
seems very related to the problem of hygienic macros (accidental name
capture).

Indeed.

What you really want of Camlp4 extensions is not "namespaces", but
*hygiene*. Hygiene in hygenic macro systems means two things:
  1. having binders in macros not capture bound variables in expanded
user-provided code (unless explicitly desired, to implement a new binding
structure as macro)
  2. having bound variables in macros not be captured by user-provided
binders

None of those two distinct aspects are specifically accounted for in the
current OCaml+Camlp4 combination. The lack of the first can be worked
around by being careful in extension code (preserve the scope of
user-provided code and not expand it under extension binders, which is
possible thanks to OCaml expressive "let ... and .." feature), the lack of
the second is more problematic as it would require the extension *user* to
be careful (not happening in practice).

This is related to this bug report by Hongbo:
  http://caml.inria.fr/mantis/view.php?id=5849

Namespaces are only an attempt to workaround the problem by adding an
indirection in naming that would make lack of hygiene less visible. It's a
reasonable side-effect of a namespace proposal, but that cannot reasonably
be the main motivation for adding namespaces. "Let's add this new feature
so that this problem with that ugly tool can be partially fixed in this
ugly way" is not going to fly.

(Note that Lisp languages solve this by embedding the macro facility in the
language itself, instead of having an up-front AST-generation model. This
allows macro expansion to elaborate internal unique names instead of
surface names, which solves this hygiene problem. An OCaml equivalent would
be to give a way to address a module by its internal compilation unit name.)

On Fri, Feb 22, 2013 at 3:33 PM, Daniel B?nzli
<daniel.buenzli at erratique.ch>wrote:

> Le vendredi, 22 f?vrier 2013 ? 14:52, Malcolm Matalka a ?crit :
> > So would a syntax extension always have to store the modules it wants to
> > be sure to access at the beginning of a file it requires, making sure
> > not to choose overlapping names?
>
> Why not ? Each extension could have its own module against which you have
> to link to use the extension that has the module it uses in it
> (MyExt.List?).
>
> It's not evident to me that namespaces actually solve the problem either,
> they just seem to push the problem in the build system. The actual problem
> seems very related to the problem of hygienic macros (accidental name
> capture).
>
> Besides I'm not sure the example Anil gave is as widespread as it seems,
> it feels like a corner case that could be avoided, as he suggested, by
> having the ability to refer to stdlib's modules under a toplevel name
> (OCaml.List) and this still seems in the realm of the module system (and
> could be realized via something like cmia).
>
> Daniel
>
>
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130222/bbdfb83d/attachment.html>

From lpw25 at cam.ac.uk  Fri Feb 22 16:29:24 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 22 Feb 2013 16:29:24 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302221629240.25215@hermes-1.csi.cam.ac.uk>

>I tend to agree with Alain about the fact that hierarchical namespaces
>is overkill. Flat namespace is easier to achieve and will solve most
>problems.

I don't think there is any additional work to support hierarchical 
namespaces.

>Working with Java all days long and its namespace, I would say it is
>totally useless to copy that! What the meaning of org.apache? Will I
>have to name my libraries net.le-gall.sylvain.Foo or
>org.ocamlcore.forge.ounit.OUnit?

There is a big difference between supporting hierarchical names and 
mandating them. It seems fairly ridiculous to assume that people are going 
to suddenly start using long unwieldy names with no obvious benefit.



From lpw25 at cam.ac.uk  Fri Feb 22 16:32:57 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 22 Feb 2013 16:32:57 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
Message-ID: <Prayer.1.3.5.1302221632570.25215@hermes-1.csi.cam.ac.uk>

> So if the problem is `-pack` is not good enough because it produces a 
> huge `cmo`, why not just try to find a corresponding concept workable 
> with `cm[x]a` ?
>
> Here's a proposal --- from a user point of view, I'll let the compiler 
> hackers comment on how/if this could be workable.
>
> Introduce `cmia` files that bundles the `cmi`'s of a `cm[x]a` with the 
> corresponding file name. The name of the `cmia` file (and hence of the 
> `cm[x]a` file) defines your toplevel module name ? la `-pack`. Make it 
> even be backward compatible in the sense that if there's no `cmia` for a 
> `cm[x]a` the modules are accessed as before. Now you have a kind of 
> `-pack` that work with `cm[x]a`.

The problem with such a proposal is: what happens when someone tries to 
apply a functor to this `cmia` module?

Either it represents a module, in which case it must be a large .cmo file, 
or it is not a module and cannot be used as such.

Once you have top-level module names that are not actually modules, what 
you have *is* a namespace.


From lpw25 at cam.ac.uk  Fri Feb 22 16:40:25 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 22 Feb 2013 16:40:25 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
Message-ID: <Prayer.1.3.5.1302221640250.25215@hermes-1.csi.cam.ac.uk>

> Actually I find this way of structuring things not pertinent *at all*. It 
> brings absolutely nothing.
>
> First with hierarchies there's always the problem that at certain point 
> you want two things to be in two different places. This is why "tags" are 
> usually better than "folders" to organize things, see e.g. gmail.

There is no real reason that something cannot be placed in two locations 
within the hierarchy.

> Second if we take the link you provided there are not so much toplevel 
> descriptors which means that it lengthen the names without bringing much 
> benefit except noise. 

I agree with this in general. However, there are some specific cases where 
a hierarchical namespace is very useful. For example:

1. In some very large libraries, it is useful to be able to divide the 
modules into sub-components that can opened individually.

2. In some libraries it is useful to provide multiple versions of some 
components (e.g. Foo.Async.Io and Foo.Lwt.Io).

Since it doesn't cost anything to support hierarchical namespaces, I see no 
strong reason to not do so.


From lpw25 at cam.ac.uk  Fri Feb 22 17:10:39 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 22 Feb 2013 17:10:39 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBEbtXgXOE+i+Nb_oxonkXTK-_7Y2jKuZ6U6hSP91sQUWg@mail.gmail.com>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <82945BD2E9BD45CC9154D7B9BBFD1333@erratique.ch>
 <CA64CD77-8B29-4547-9D4B-47A4C6C31CB2@recoil.org>
 <15303734606646EF8D66B740EC7BDEBB@erratique.ch>
 <87mwuwtpzt.fsf@li195-236.members.linode.com>
 <79BEFC008E3447CB92ABBBE0A1D4A92D@erratique.ch>
 <CAPFanBEbtXgXOE+i+Nb_oxonkXTK-_7Y2jKuZ6U6hSP91sQUWg@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302221710390.21744@hermes-1.csi.cam.ac.uk>

>> It's not evident to me that namespaces actually solve the problem either,
>they just seem to push the problem in the build system. The actual problem
>seems very related to the problem of hygienic macros (accidental name
>capture).
>
>Indeed.
>

There is also another issue using language extensions which namespaces 
solve. When you write a language extension to produce code that calls your 
library, you need to have it produce calls like:

  Foo.Comp.func ()

where Foo is the packed module that your library produces.

However, then you cannot use the syntax extension within your library 
because the Foo module does not exist yet.

This is why, for example, COW's quotations need command-line arguments to 
tell them whether they are inside COW or not.

More generally, packed modules create two different names for a module, one 
used within the other packed modules, and one used externally. Namespaces 
can simply avoid this problem because not all modules in the namespace need 
to exist before the namespace can be used.

>"Let's add this new feature
>so that this problem with that ugly tool can be partially fixed in this
>ugly way" is not going to fly.

I actually think that long names are a perfectly valid solution for hygene, 
rather than an ugly one. I can also think of at least 4 other problems that 
namespaces solve:

1. Grouping modules without using "pack". 
2. Providing multiple names for modules (e.g. "Core.Std.List" and 
   "Platform.List").
3. The circular naming problem described above. 
4. Control of the default set of names that are open when compiling a 
   module.

All of which are of obvious benefit to the platform (which is what we are 
discussing on this list).


From alain.frisch at lexifi.com  Fri Feb 22 17:22:44 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 22 Feb 2013 18:22:44 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302221406220.21772@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
 <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
 <512738CF.70905@lexifi.com>
 <Prayer.1.3.5.1302221406220.21772@hermes-1.csi.cam.ac.uk>
Message-ID: <5127A964.7080506@lexifi.com>

On 2/22/2013 3:06 PM, Leo White wrote:
> There are a number of possible solutions to spurious opens. The simplest
> of which is to only look for "Core.Std.Mutex" in directories which
> contain the special "Core.Std" .cmi file (mentioned previously as a
> solution to typos in open statements). These special .cmi files could
> also be extended to include a list of modules that have that namespace
> within the current directory which would prevent spurious reads entirely.

This seems a little bit hackish to me, and likely to require more 
over-engineering (do we need a tool to create those .cmi files; if they 
are plain text file, it's ugly to use the .cmi extension).

>>  - It prevents from putting .cmi files from many libraries in the same
>> directory, which is sometimes useful (to simplify deployment; to
>> control precisely the set of .cmi available for a given file; to
>> improve performance by avoiding repeated lookups in many directories).
>
> I think that this ability is of dubious value and not really a big loss.

We use this quite intensively on LexiFi's code base.  This really speeds 
up compilation time under Windows, and we also use it to simplify 
deployment (our application is shipped with some .cmi files from many 
libraries and automatically compiles user-provided addins against them; 
it would be tedious -- and useless -- to reproduce a complete hierarchy 
of libraries on the installation side).

We would hate to have the third-party libraries we use adopt a new 
feature (namespaces) which solves a problem we don't have but forces us 
to change in non trivial ways how we organize our code base and deployment.

> This is basically an error, so dependencies
> should not be expected to be correct.

I don't agree.  Having wrong dependencies is a nightmare to debug and 
during development having errors in the code is not an exceptional 
situation.  A robust build system should handle nicely things like 
moving files around, renaming them, etc.

> There is possibly the need for some kind of partial dependency for
> parallel builds. This is more like a lock than a dependency, so there
> should be no question of circular dependencies. I'm not really familiar
> with how parallel file accesses work on different file systems, but
> perhaps the compiler could lock ".cmi" files before reading and writing.
> This might be a good idea more generally for cases where dependencies
> have not been correctly calculated.

These locks do not really solve the problem.  Imagine you have a big 
project with two modules

   foo/a.ml in namespace Foo
   bar/a.ml in namespace Bar

Now you compile x.ml which refers to Foo # A. "ocamldep -modules" 
reports that the dependencies for it include mode "A", which must be 
mapped to all buildable a.cmi/a.cmx in your tree, i.e. both foo/a and 
bar/a.  (Things are even worse if you use the same syntax as for 
modules, because then any reference like Foo.A must be interpreted as a 
potential dependency to foo.cmi/cmx or to a.cmi/cmx.)  But maybe 
bar/a.ml refers to x.ml, and then you have a circular dependency.

I'd like any proposal about namespaces to come with a description of (i) 
how ocamldep is supposed to behave; (ii) how build systems (based on, 
say, make, omake and ocamlbuild) are supposed to be adapted.

So here it is for my proposal of using "short names" declared in 
external files:

   - Doing "open namespace Core_std" is strictly equivalent to doing 
"module Mutex == Core_std_mutex;; module Thread == Core_std_thread;; 
module Date == Core_std_date" assuming a new module aliasing feature 
(available in structures and signatures).

   - ocamldep would read the core_std.ns file (meaning that it must 
exist and be up-to-date when ocamldep runs; I expect those files to be 
quite static so this shouldn't be a big problem -- otherwise, we would 
need to have a first pass where ocamldep would returns the list of .ns 
files to be opened, and the build system would arrange to build them).

  - when ocamldep encounters a module reference "Mutex" in a scope where 
an alias "module Mutex == Core_std_mutex" has been defined (manually or 
by loading core_std.ns), it reports a dependency to module 
Core_std_mutex instead of Mutex.

  - the build systems do not have to be adapted.



>
>> That's why I've proposed to allow specifying mapping between
>> references to external modules in dedicated files.  We could have a
>> file core_std.ns (probably shipped with Core) with this content:
>>
>> Mutex = Core_std_mutex
>> Thread = Core_std_thread
>> Date = Core_std_date
>>
>> and just a reference in the source code (or on the command-line):
>>
>>   open namespace Core_std
>>
>> which would load core_std.ns and use the corresponding module renaming
>> in the rest of the module.
>
> There is very little difference between that suggestion and having a
> core_std.ns file containing:
>
>   Mutex;
>   Thread;
>   Date;
>
> and using that as a (partial) declaration of a Core_std namespaces,
> except that you have to give every file a unique long filename. So I
> don't really see the particular benefit of using long filenames.

With my proposal, you don't force users of the library to use the new 
feature (meaning that if for some reason your local build system does 
not work nicely with namespaces, you can always refer to modules using 
their long names).  Moreover, the semantics is very easy to explain, the 
linker does not need to be changed, and we don't change how OCaml 
behaves w.r.t. to the file system (your proposal prevents users from 
using the currently valid technique of copying .cmi files from many 
libraries in the same directory).

> There is also a more general problem with any solution like this, which
> tries to define namespaces (or sets of aliases) in a single file. It is
> difficult to use the namespace from inside the modules that are within
> the namespace. For example, if I use:
>
>   open namespace Core_std
>
> from within mutex.ml then it will attempt to open itself.


I don't understand the problem.  The source file would be 
core_std_mutex.ml and it is fine if it does "open namespace Core_std" as 
long as it doesn't refer to Mutex (which would be a circular dependency).


Alain

From lpw25 at cam.ac.uk  Fri Feb 22 18:12:20 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 22 Feb 2013 18:12:20 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5127A964.7080506@lexifi.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
 <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
 <512738CF.70905@lexifi.com>
 <Prayer.1.3.5.1302221406220.21772@hermes-1.csi.cam.ac.uk>
 <5127A964.7080506@lexifi.com>
Message-ID: <Prayer.1.3.5.1302221812200.21744@hermes-1.csi.cam.ac.uk>

>This seems a little bit hackish to me, and likely to require more 
>over-engineering (do we need a tool to create those .cmi files; if they 
>are plain text file, it's ugly to use the .cmi extension).

I'm still not sure that they are really needed, but if they are the 
simplest thing to do would be to automatically generate some kind of 
"core.std.cmn" file whenever an mli file was compiled that contained "in 
Core.Std". This would basically indicate that a "Core.Std" namespace 
existed and that some ".cmi" files in this directory used it.

>We use this quite intensively on LexiFi's code base.  This really speeds 
>up compilation time under Windows, and we also use it to simplify 
>deployment (our application is shipped with some .cmi files from many 
>libraries and automatically compiles user-provided addins against them; 
>it would be tedious -- and useless -- to reproduce a complete hierarchy 
>of libraries on the installation side).
>
>We would hate to have the third-party libraries we use adopt a new 
>feature (namespaces) which solves a problem we don't have but forces us 
>to change in non trivial ways how we organize our code base and deployment.

It is quite a specialised case, but I don't think it would be too hard to 
accommodate. If the compiler accepted filenames like "list.1.cmi" as 
possible files containing a "List" module, then you could safely put all 
your files in a single directory.

>> This is basically an error, so dependencies
>> should not be expected to be correct.
>
>I don't agree.  Having wrong dependencies is a nightmare to debug and 
>during development having errors in the code is not an exceptional 
>situation.  A robust build system should handle nicely things like 
>moving files around, renaming them, etc.

I didn't mean that the build system wouldn't detect the error only that it 
wouldn't detect it until dependencies were recalculated.

>Imagine you have a big 
>project with two modules
>
>   foo/a.ml in namespace Foo
>   bar/a.ml in namespace Bar
>
>Now you compile x.ml which refers to Foo # A. "ocamldep -modules" 
>reports that the dependencies for it include mode "A", which must be 
>mapped to all buildable a.cmi/a.cmx in your tree, i.e. both foo/a and 
>bar/a.  (Things are even worse if you use the same syntax as for 
>modules, because then any reference like Foo.A must be interpreted as a 
>potential dependency to foo.cmi/cmx or to a.cmi/cmx.)  But maybe 
>bar/a.ml refers to x.ml, and then you have a circular dependency.

This won't a problem if you use a build system specialised for OCaml, since 
they would know about namespaces and create the following dependencies:

x.ml: Foo#A
Foo#A: foo/a.ml
Bar#A: bar/a.ml

Even the makefile output of OCamlDep could be modified to avoid this 
problem using phony targets, although it is probably not worth it.

>I'd like any proposal about namespaces to come with a description of (i) 
>how ocamldep is supposed to behave; (ii) how build systems (based on, 
>say, make, omake and ocamlbuild) are supposed to be adapted.

For namespaces:

 - Whenever ocamldep encounters a line "in A#B" within c.mli then it creates
   a dependency "A#B#C: c.mli".

 - Whenever it finds a use A#B#C in a file e.mli it creates a dependency 
   "e.mli: A#B#C".

 - Build systems are modified to include support for phony namespace 
targets.


From alain.frisch at lexifi.com  Fri Feb 22 18:21:11 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 22 Feb 2013 19:21:11 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302221812200.21744@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
 <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
 <512738CF.70905@lexifi.com>
 <Prayer.1.3.5.1302221406220.21772@hermes-1.csi.cam.ac.uk>
 <5127A964.7080506@lexifi.com>
 <Prayer.1.3.5.1302221812200.21744@hermes-1.csi.cam.ac.uk>
Message-ID: <5127B717.3020303@lexifi.com>

On 2/22/2013 7:12 PM, Leo White wrote:
> For namespaces:
>
> - Whenever ocamldep encounters a line "in A#B" within c.mli then it creates
>    a dependency "A#B#C: c.mli".
>
> - Whenever it finds a use A#B#C in a file e.mli it creates a dependency
>    "e.mli: A#B#C".
>
> - Build systems are modified to include support for phony namespace
> targets.

Are you suggesting that support for namespace would require to change 
make and omake, or just their "OCaml-specific" rules (defined in user 
land, not in the tool itself)?

I'm not sure that what you describe above correspond to phony targets as 
currently understood by make and omake (I might be wrong).

Could you also describe how this would be affected if we allow opening 
namespaces?  It seems to me that the safe thing to do would be quite 
ugly (a reference to a module "A" would create many candidate 
dependencies for all opened namespaces).  Moreover, would you support 
opening namespaces within namespaces (i.e. is "open namespace A;; open 
namespace B" a valid way to open the namespace A/B?)

Alain

From daniel.buenzli at erratique.ch  Fri Feb 22 18:23:03 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 19:23:03 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302221632570.25215@hermes-1.csi.cam.ac.uk>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <Prayer.1.3.5.1302221632570.25215@hermes-1.csi.cam.ac.uk>
Message-ID: <7A0C87A588744F9A8DF39D4FBC24B26E@erratique.ch>

Le vendredi, 22 f?vrier 2013 ? 17:32, Leo White a ?crit :
> The problem with such a proposal is: what happens when someone tries to
> apply a functor to this `cmia` module?

Then you cannot do anything but treat it like a regular module. I don't see any problem in that, everything in the cmxa will be linked in in your functor application and that's all.  

I'm sure the compiler should be able to treat that without any problem or overly complexity.

Daniel

From daniel.buenzli at erratique.ch  Fri Feb 22 18:40:08 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 19:40:08 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302221640250.25215@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
 <Prayer.1.3.5.1302221640250.25215@hermes-1.csi.cam.ac.uk>
Message-ID: <795AFF51E6A046BFA465D3177EB757CA@erratique.ch>

Le vendredi, 22 f?vrier 2013 ? 17:40, Leo White a ?crit :
> There is no real reason that something cannot be placed in two locations  
> within the hierarchy.

But as I suggested from the perspective of programming *in the language* there no point of having it at two different location. Even from the perspective of reading code it's confusing you have to learn all the places where a module may be and understand that all these modules are in fact the same.  

> I agree with this in general. However, there are some specific cases where
> a hierarchical namespace is very useful. For example:
>  
> 1. In some very large libraries, it is useful to be able to divide the  
> modules into sub-components that can opened individually.
>  
> 2. In some libraries it is useful to provide multiple versions of some  
> components (e.g. Foo.Async.Io and Foo.Lwt.Io).

For me all this should be solved within the realm of the module system. Maybe we need to fix the way we link things in (since that seems to be the only reason why -pack is not deemed reasonable). But I really see no point in introducing new namings mechanisms into the core language.

Daniel  



From xavier.clerc at inria.fr  Fri Feb 22 19:04:00 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Fri, 22 Feb 2013 20:04:00 +0100 (CET)
Subject: [ocaml-platform] =?iso-8859-1?q?Re=A0=3A_Re=3A__on_the_need_and_d?=
 =?iso-8859-1?q?esign_of_OCaml_namespaces?=
In-Reply-To: <795AFF51E6A046BFA465D3177EB757CA@erratique.ch>
Message-ID: <1584174905.3005845.1361559840840.JavaMail.root@inria.fr>


----- Daniel B?nzli <daniel.buenzli at erratique.ch> a ?crit?:
> For me all this should be solved within the realm of the module system. Maybe we need to fix the way we link things in (since that seems to be the only reason why -pack is not deemed reasonable). But I really see no point in introducing new namings mechanisms into the core language.

I beg to differ. My understanding is that we
need to be able to gather several modules
under a name *without* crafting a new
module in the process.


Regards,

Xavier

From martin at mjambon.com  Fri Feb 22 19:50:30 2013
From: martin at mjambon.com (Martin Jambon)
Date: Fri, 22 Feb 2013 11:50:30 -0800
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
Message-ID: <5127CC06.6020503@mjambon.com>

On 02/22/2013 02:39 AM, Daniel B?nzli wrote:
> This may be a silly suggestion as I'm not sure I'm really convinced
> by the absolute *need* for namespaces (I'd rather not have an
> additional concept in a language that I already find sufficiently
> complex to my taste).

Namespaces allow a single organization to provide a collection of 
optional packages named consistently (e.g. String, Json, Http, 
Elasticsearch, ... instead of having to invent silly names for each of 
these because there are gazillions of implementations out there).

A namespace identifies a software vendor (an organized group of people), 
who can manage the name of their packages and modules unilaterally, i.e. 
without having to worry about the rest of the world (which includes 
competitors and people who just won't talk to each other).

It is different from the concept of module, which cannot be split into 
optional packages.


> However it strikes me that while it seems to be agreed upon that a
> simple mechanism like `-pack` solves the problem albeit not in a
> technically satisfying way, the worked out proposal seems to
> skyrocket into complexity. The best way to avoid
> bureaucracy/complexity is not to introduce the tools to be able to
> manage it...
>
> So if the problem is `-pack` is not good enough because it produces a
> huge `cmo`, why not just try to find a corresponding concept workable
> with `cm[x]a` ?
>
> Here's a proposal --- from a user point of view, I'll let the
> compiler hackers comment on how/if this could be workable.
>
> Introduce `cmia` files that bundles the `cmi`'s of a `cm[x]a` with
> the corresponding file name. The name of the `cmia` file (and hence
> of the `cm[x]a` file) defines your toplevel module name ? la `-pack`.
> Make it even be backward compatible in the sense that if there's no
> `cmia` for a `cm[x]a` the modules are accessed as before. Now you
> have a kind of `-pack` that work with `cm[x]a`.
>
> Best,
>
> Daniel
>
> P.S. flat vs hierarchical, I'd also rather go flat.
>
>
> _______________________________________________ Platform mailing
> list Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>


From daniel.buenzli at erratique.ch  Fri Feb 22 20:38:58 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 22 Feb 2013 21:38:58 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5127CC06.6020503@mjambon.com>
References: <20130221203140.GA18946@upsilon.cc>
 <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <5127CC06.6020503@mjambon.com>
Message-ID: <94440EF45702487982C8218E9DCD05A6@erratique.ch>


Le vendredi, 22 f?vrier 2013 ? 20:04, Xavier Clerc a ?crit :
> I beg to differ. My understanding is that we
> need to be able to gather several modules
> under a name *without* crafting a new
> module in the process.

Why exactly ? What's the problem if a new module is crafted in the process ? For me the problem seems only to be related to the way modules are linked in (the "pack problem" to give it a name). From a conceptual perspective I see absolutely no other, orthogonal, concept at play and hence see no reason to introduce a new one in the core language.  
  




Le vendredi, 22 f?vrier 2013 ? 20:50, Martin Jambon a ?crit :

> It is different from the concept of module, which cannot be split into
> optional packages.  

Ibid.

Maybe that's what should be challenged.

Daniel



From xavier.clerc at inria.fr  Fri Feb 22 21:51:25 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Fri, 22 Feb 2013 22:51:25 +0100 (CET)
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <94440EF45702487982C8218E9DCD05A6@erratique.ch>
Message-ID: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>

----- Mail original -----
> 
> Le vendredi, 22 f?vrier 2013 ? 20:04, Xavier Clerc a ?crit :
> > I beg to differ. My understanding is that we
> > need to be able to gather several modules
> > under a name *without* crafting a new
> > module in the process.
> 
> Why exactly ? What's the problem if a new module is crafted in the
> process ? For me the problem seems only to be related to the way
> modules are linked in (the "pack problem" to give it a name). From a
> conceptual perspective I see absolutely no other, orthogonal,
> concept at play and hence see no reason to introduce a new one in
> the core language.

Well, as you point out, once you have built a full-fledged module,
you cannot break it into pieces even if you are only interested in
some parts of it.

On the other hand, if namespaces are added to the language, "pack"
would still be useful, as you may sometimes actually need to build
a module from pieces -- e. g. in order to pass it to a functor.

So, as of today, we have :
  - "archives" (cma / cmxa) allowing to gather modules but without
    naming (at the language level) the gathering ; 
  - "packs" allowing to gather modules into a module.
I regard namespaces are gathering modules into a named entity but
without creating a module. Hence, it is a new beast, different from
archives and packs.


Xavier

From Christophe.Troestler at umons.ac.be  Sun Feb 24 19:26:45 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Sun, 24 Feb 2013 20:26:45 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
Message-ID: <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>

On Fri, 22 Feb 2013 11:41:10 +0000, Anil Madhavapeddy wrote:
>
> There's one scenario which absolutely requires the ability to 
> explicitly open a particular namespace: camlp4 code generation.
>
> Right now, several camlp4 extensions break because they use modules 
> from the standard Pervasives library, and have no way to explicitly 
> state that.  If Core.Std is opened, then compilation fails.
>
> The two workarounds are:
> - hack the build system to pass -pp options to the camlp4 
> generator. Painful.
> - have some facility to explicitly open 'Caml_std' or 'Core_std' 
> locally, irrespective of the current module environment.
>
> I believe namespaces addresses the latter workaround.

Camlp4 can insert some code to alias the standard modules needed by 
code generation at the beginning of the source files (not foolproof 
because a name needs to be generated but good enough in practice).  
It would be better if that facility was provided by a Camlp4 module 
instead of needing to be redone by each extension.

From Christophe.Troestler at umons.ac.be  Sun Feb 24 19:39:34 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Sun, 24 Feb 2013 20:39:34 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
References: <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
Message-ID: <20130224.203934.694409055502204737.Christophe.Troestler@umons.ac.be>

On Fri, 22 Feb 2013 11:39:41 +0100, Daniel B?nzli wrote:
>
> So if the problem is `-pack` is not good enough because it produces 
> a huge `cmo`, why not just try to find a corresponding concept 
> workable with `cm[x]a` ?

As I understand it, people are not happy with -pack not for the large 
cm[x]a files but because the whole library is included in every 
executable even if only a small subset of the library is used.  Would 
the "problem" with -pack still exist if this was solved?

From lpw25 at cam.ac.uk  Mon Feb 25 11:35:09 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 25 Feb 2013 11:35:09 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5127B717.3020303@lexifi.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <Prayer.1.3.5.1302211536260.28188@hermes-1.csi.cam.ac.uk>
 <51266155.2060205@frisch.fr>
 <Prayer.1.3.5.1302211839370.23538@hermes-1.csi.cam.ac.uk>
 <512738CF.70905@lexifi.com>
 <Prayer.1.3.5.1302221406220.21772@hermes-1.csi.cam.ac.uk>
 <5127A964.7080506@lexifi.com>
 <Prayer.1.3.5.1302221812200.21744@hermes-1.csi.cam.ac.uk>
 <5127B717.3020303@lexifi.com>
Message-ID: <Prayer.1.3.5.1302251135090.28414@hermes-1.csi.cam.ac.uk>

>Are you suggesting that support for namespace would require to change 
>make and omake, or just their "OCaml-specific" rules (defined in user 
>land, not in the tool itself)?

Just their OCaml-specific rules.

>I'm not sure that what you describe above correspond to phony targets as 
>currently understood by make and omake (I might be wrong).

I think that a phony target is just a target without a corresponding file 
(I might also be wrong).

Although, I had forgotten the OCamlDep only creates dependencies on modules 
that have an existing .ml or .mli file. So instead of using phony targets, 
I propose the following solution:

 - Whenever it finds a use A#B#C in a file e.mli it creates a dependency
   "e.cmi: c.cmi" if it can find an ".mli" or ".ml" file in its search path 
   which starts with the line "in A#B".
 
 - Build systems are left as they are.

>Could you also describe how this would be affected if we allow opening 
>namespaces?  It seems to me that the safe thing to do would be quite 
>ugly (a reference to a module "A" would create many candidate 
>dependencies for all opened namespaces).

With the solution given above, a reference to "A" would only create a 
dependency on the "a.cmi" that was in the more recently opened namespace.

> Moreover, would you support 
>opening namespaces within namespaces (i.e. is "open namespace A;; open 
>namespace B" a valid way to open the namespace A/B?)

I would like to but it is not a deal-breaker.


From yminsky at janestreet.com  Mon Feb 25 14:12:11 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 09:12:11 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
Message-ID: <CACLX4jRghjMpz9UFnQYJo719k1nvykRkO8LkrE8dFVOcv1REvw@mail.gmail.com>

On Sun, Feb 24, 2013 at 2:26 PM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Fri, 22 Feb 2013 11:41:10 +0000, Anil Madhavapeddy wrote:
>>
>>
>> There's one scenario which absolutely requires the ability to explicitly
>> open a particular namespace: camlp4 code generation.
>>
>> Right now, several camlp4 extensions break because they use modules from
>> the standard Pervasives library, and have no way to explicitly state that.
>> If Core.Std is opened, then compilation fails.
>>
>> The two workarounds are:
>> - hack the build system to pass -pp options to the camlp4 generator.
>> Painful.
>> - have some facility to explicitly open 'Caml_std' or 'Core_std' locally,
>> irrespective of the current module environment.
>>
>> I believe namespaces addresses the latter workaround.
>
>
> Camlp4 can insert some code to alias the standard modules needed by code
> generation at the beginning of the source files (not foolproof because a
> name needs to be generated but good enough in practice).  It would be better
> if that facility was provided by a Camlp4 module instead of needing to be
> redone by each extension.

I like this workaround a lot, and am embarrassed not to have thought
of it myself...

y

From yminsky at janestreet.com  Mon Feb 25 14:14:17 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 09:14:17 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130224.203934.694409055502204737.Christophe.Troestler@umons.ac.be>
References: <2089553086.2672683.1361523277007.JavaMail.root@inria.fr>
 <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <20130224.203934.694409055502204737.Christophe.Troestler@umons.ac.be>
Message-ID: <CACLX4jSufMQWkSpfGvmXv3g+rLzn8Z0EixjAWf7-iCrTk+EZYA@mail.gmail.com>

On Sun, Feb 24, 2013 at 2:39 PM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Fri, 22 Feb 2013 11:39:41 +0100, Daniel B?nzli wrote:
>>
>> So if the problem is `-pack` is not good enough because it produces a huge
>> `cmo`, why not just try to find a corresponding concept workable with
>> `cm[x]a` ?
>
> As I understand it, people are not happy with -pack not for the large cm[x]a
> files but because the whole library is included in every executable even if
> only a small subset of the library is used.  Would the "problem" with -pack
> still exist if this was solved?

I think of there as being three key problems with -pack:

- The pack is a single unit that has to be loaded or not as a unit (as
  per your point.
- The pack is a choke-point in the dependency graph.  If you depend on
  one thing in a pack, that you need to be recompiled if anything in
  the pack changes.
- Opening a pack like Core.Std is brutally slow, and really affects
  performance of the build.

I think all of these issues need solving.

y

From yminsky at janestreet.com  Mon Feb 25 14:15:27 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 09:15:27 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRghjMpz9UFnQYJo719k1nvykRkO8LkrE8dFVOcv1REvw@mail.gmail.com>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
 <CACLX4jRghjMpz9UFnQYJo719k1nvykRkO8LkrE8dFVOcv1REvw@mail.gmail.com>
Message-ID: <CACLX4jR=P1a97ubM5GhC3CvE5EXv9D0axpY74yKcQQ6LvNJPfw@mail.gmail.com>

On Mon, Feb 25, 2013 at 9:12 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Sun, Feb 24, 2013 at 2:26 PM, Christophe TROESTLER
> <Christophe.Troestler at umons.ac.be> wrote:
>> On Fri, 22 Feb 2013 11:41:10 +0000, Anil Madhavapeddy wrote:
>>>
>>>
>>> There's one scenario which absolutely requires the ability to explicitly
>>> open a particular namespace: camlp4 code generation.
>>>
>>> Right now, several camlp4 extensions break because they use modules from
>>> the standard Pervasives library, and have no way to explicitly state that.
>>> If Core.Std is opened, then compilation fails.
>>>
>>> The two workarounds are:
>>> - hack the build system to pass -pp options to the camlp4 generator.
>>> Painful.
>>> - have some facility to explicitly open 'Caml_std' or 'Core_std' locally,
>>> irrespective of the current module environment.
>>>
>>> I believe namespaces addresses the latter workaround.
>>
>>
>> Camlp4 can insert some code to alias the standard modules needed by code
>> generation at the beginning of the source files (not foolproof because a
>> name needs to be generated but good enough in practice).  It would be better
>> if that facility was provided by a Camlp4 module instead of needing to be
>> redone by each extension.
>
> I like this workaround a lot, and am embarrassed not to have thought
> of it myself...

As a side note, if we were to build such a facility for ppx and/or
camlp4, I'd love for camlp4 extensions to refer to Pervasives
explicitly, and not rely on the assumption that it has been opened.

y

From anil at recoil.org  Mon Feb 25 14:15:54 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 25 Feb 2013 14:15:54 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
Message-ID: <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>

On 24 Feb 2013, at 19:26, Christophe TROESTLER <Christophe.Troestler at umons.ac.be> wrote:

> On Fri, 22 Feb 2013 11:41:10 +0000, Anil Madhavapeddy wrote:
>> 
>> There's one scenario which absolutely requires the ability to explicitly open a particular namespace: camlp4 code generation.
>> 
>> Right now, several camlp4 extensions break because they use modules from the standard Pervasives library, and have no way to explicitly state that.  If Core.Std is opened, then compilation fails.
>> 
>> The two workarounds are:
>> - hack the build system to pass -pp options to the camlp4 generator. Painful.
>> - have some facility to explicitly open 'Caml_std' or 'Core_std' locally, irrespective of the current module environment.
>> 
>> I believe namespaces addresses the latter workaround.
> 
> Camlp4 can insert some code to alias the standard modules needed by code generation at the beginning of the source files (not foolproof because a name needs to be generated but good enough in practice).  It would be better if that facility was provided by a Camlp4 module instead of needing to be redone by each extension.

That's an interesting idea.  The only hitch is that it's a little hard to do in one pass, as the code generation is called on the local AST fragment.

I think it would work if placed as a feature into type_conv itself, as the individual generators (e.g. sexp/orm) all register themselves with it quite early.  They could request global modules, which type_conv does in one pass (thus also avoiding duplicate requests for the original namespace).

CCing Markus Mottl to see what he thinks...

-anil


From markus.mottl at gmail.com  Mon Feb 25 15:10:27 2013
From: markus.mottl at gmail.com (Markus Mottl)
Date: Mon, 25 Feb 2013 10:10:27 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
 <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
Message-ID: <CAP_800qsUuA8yH1LT_g9f_zZbdvtXO5Hu5fk192cp_S96k2hnw@mail.gmail.com>

On Mon, Feb 25, 2013 at 9:15 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I think it would work if placed as a feature into type_conv itself, as the individual generators (e.g. sexp/orm) all register themselves with it quite early.  They could request global modules, which type_conv does in one pass (thus also avoiding duplicate requests for the original namespace).

I'm not sure that type_conv should be the place to implement this.
Since this issue can affect all kinds of camlp4 macros, it seems like
a feature that camlp4 should provide.  There should be some
standardized module name, e.g. "Camlp4_stdlib" or similar, which would
allow generated code to refer to the original OCaml standard library.

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com

From daniel.buenzli at erratique.ch  Mon Feb 25 18:04:49 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Mon, 25 Feb 2013 19:04:49 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
Message-ID: <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>



Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :

> So, as of today, we have :- "archives" (cma / cmxa) allowing to gather modules but without
> naming (at the language level) the gathering ;  
> - "packs" allowing to gather modules into a module.
> I regard namespaces are gathering modules into a named entity but
> without creating a module. Hence, it is a new beast, different from
> archives and packs.

So basically a new concept is introduced because "pack" is not technically satisfying. That's not the way I would like the language I program in to be designed. I'd rather see the problems pack has fixed which I'm sure could be done by allowing archives to be named at the language level as a module.   

Daniel

From xavier.clerc at inria.fr  Mon Feb 25 19:13:56 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Mon, 25 Feb 2013 20:13:56 +0100 (CET)
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
Message-ID: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>

----- Mail original -----
> 
> 
> Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
> 
> > So, as of today, we have :- "archives" (cma / cmxa) allowing to
> > gather modules but without
> > naming (at the language level) the gathering ;
> > - "packs" allowing to gather modules into a module.
> > I regard namespaces are gathering modules into a named entity but
> > without creating a module. Hence, it is a new beast, different from
> > archives and packs.
> 
> So basically a new concept is introduced because "pack" is not
> technically satisfying.

This is no what I mean.
Packs and namespaces serve two different purposes.
It just happens that the lack of namespace forced
people (including me) to use packs as namespaces.


Xavier

From yminsky at janestreet.com  Mon Feb 25 19:16:03 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 14:16:03 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
Message-ID: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>

On Mon, Feb 25, 2013 at 1:04 PM, Daniel B?nzli
<daniel.buenzli at erratique.ch> wrote:
>
>
> Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
>
>> So, as of today, we have :- "archives" (cma / cmxa) allowing to gather modules but without
>> naming (at the language level) the gathering ;
>> - "packs" allowing to gather modules into a module.
>> I regard namespaces are gathering modules into a named entity but
>> without creating a module. Hence, it is a new beast, different from
>> archives and packs.
>
> So basically a new concept is introduced because "pack" is not
> technically satisfying. That's not the way I would like the language
> I program in to be designed. I'd rather see the problems pack has
> fixed which I'm sure could be done by allowing archives to be named
> at the language level as a module.

You might be right, but I think there's a deep issue here that
shouldn't be dismissed so lightly.  The argument is that modules are
simply too powerful to be used as the complete solution to namespace
management.  Deciding that the only principled approach is to always
pick the most powerful, most general purpose primitive is attractive,
but not always sane...

y

From daniel.buenzli at erratique.ch  Mon Feb 25 20:37:03 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Mon, 25 Feb 2013 21:37:03 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
 <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
Message-ID: <D4D47CDC93394A469721ED9185CBE186@erratique.ch>

Le lundi, 25 f?vrier 2013 ? 20:16, Yaron Minsky a ?crit :
> You might be right, but I think there's a deep issue here that
> shouldn't be dismissed so lightly.  

I don't dismiss it. I would prefer it to be solved with already existing concepts.  

> The argument is that modules are
> simply too powerful to be used as the complete solution to namespace
> management.  

In which sense ? Why is too powerful ? What does powerful mean in that particular case ? That is I think what prevents me from understanding the need for namespaces.

> Deciding that the only principled approach is to always
> pick the most powerful, most general purpose primitive is attractive,
> but not always sane...

That's not the way I reason, the principle I have here is to try, *if pratical*, to use existing concepts rather than pile new ones in the language. Now I would really like to be convinced that we need namespaces it's just that so far the arguments presented all seem to revolve around "module aliasing"/"pack" do the job but it doesn't because of implementation issues.  

Daniel



From alain.frisch at lexifi.com  Mon Feb 25 21:24:09 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 25 Feb 2013 22:24:09 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
Message-ID: <512BD679.4010501@lexifi.com>

On 2/25/2013 8:13 PM, Xavier Clerc wrote:
> This is no what I mean.
> Packs and namespaces serve two different purposes.
> It just happens that the lack of namespace forced
> people (including me) to use packs as namespaces.

Why forced?  I haven't seen a lot of libraries relying on -pack instead 
of using unique enough module names (but it's true that I don't use a 
lot of third-party libraries).  Using the library name as a common 
prefix for all its modules (and maybe having a module whose name is the 
library name itself in case of libraries with a clear notion of "main 
public module") seems a quite good solution to me and a better one than 
-pack.  Maybe this solution is not so good for libraries whose goal is 
to act as a "standard library" (such as Core), because the intention is 
to create the impression that the library is actually part of the 
language (I don't have the impression to use a library when I write 
String.length or List.map, contrary to when I write Xmlm.make_input); so 
I understand why Jane Street is reluctant to have Core_list.map 
everywhere in their code.  But would it really be a problem to have the 
users write "open Kaputt_abbreviations" instead of "open 
Kaputt.Abbreviations", or Bolt_logger.log instead of Bolt.Logger.log?


Alain

From xavier.clerc at inria.fr  Mon Feb 25 21:40:30 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Mon, 25 Feb 2013 22:40:30 +0100 (CET)
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512BD679.4010501@lexifi.com>
Message-ID: <748650772.3709054.1361828430427.JavaMail.root@inria.fr>

----- Mail original -----
> On 2/25/2013 8:13 PM, Xavier Clerc wrote:
> > This is no what I mean.
> > Packs and namespaces serve two different purposes.
> > It just happens that the lack of namespace forced
> > people (including me) to use packs as namespaces.
> 
> Why forced?

"forced" was maybe too strong... :-)


> I haven't seen a lot of libraries relying on -pack
> instead
> of using unique enough module names (but it's true that I don't use a
> lot of third-party libraries).  Using the library name as a common
> prefix for all its modules (and maybe having a module whose name is
> the
> library name itself in case of libraries with a clear notion of "main
> public module") seems a quite good solution to me and a better one
> than
> -pack.

Well, it is not a bad solution, but packing allows to open the library
at once. Not to say that this is a must have but I find it convenient
in practice.


>  Maybe this solution is not so good for libraries whose goal
> is
> to act as a "standard library" (such as Core), because the intention
> is
> to create the impression that the library is actually part of the
> language (I don't have the impression to use a library when I write
> String.length or List.map, contrary to when I write Xmlm.make_input);
> so
> I understand why Jane Street is reluctant to have Core_list.map
> everywhere in their code.  But would it really be a problem to have
> the
> users write "open Kaputt_abbreviations" instead of "open
> Kaputt.Abbreviations", or Bolt_logger.log instead of Bolt.Logger.log?

For those libraries, with few modules, it could be a decent solution.
But for Barista (with 50+ modules), it is nice to be able to open the
library as mentioned above. Moreover, library code is also made lighter
by packing: in another Bolt module, "Logger.log" is sufficient (there
is no ambiguity) while your solution would imply to write "Bolt_logger.log".

It just occurs to me that packing obviously allows (or enforces)
"closed" namespaces: no one can add a module to the packed module.
Is the ability to "close" a namespace something considered useful?

Xavier

From yminsky at janestreet.com  Mon Feb 25 21:50:33 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 16:50:33 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
 <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
Message-ID: <CACLX4jR9o6sixnzfdaFpBfWoNAOPMK3EW1tnU3rPUBoR793hbg@mail.gmail.com>

On Mon, Feb 25, 2013 at 3:43 PM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Mon, 25 Feb 2013 14:16:03 -0500, Yaron Minsky wrote:
>>
>> On Mon, Feb 25, 2013 at 1:04 PM, Daniel B?nzli
>> <daniel.buenzli at erratique.ch> wrote:
>> >
>> >
>> > Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
>> >
>> >> So, as of today, we have :
>> >> - "archives" (cma / cmxa) allowing to gather modules but without
>> >> naming (at the language level) the gathering ;
>> >> - "packs" allowing to gather modules into a module.
>> >> I regard namespaces are gathering modules into a named entity but
>> >> without creating a module. Hence, it is a new beast, different from
>> >> archives and packs.
>> >
>> > So basically a new concept is introduced because "pack" is not
>> > technically satisfying. That's not the way I would like the language
>> > I program in to be designed. I'd rather see the problems pack has
>> > fixed which I'm sure could be done by allowing archives to be named
>> > at the language level as a module.
>>
>> You might be right, but I think there's a deep issue here that
>> shouldn't be dismissed so lightly.  The argument is that modules are
>> simply too powerful to be used as the complete solution to namespace
>> management.  Deciding that the only principled approach is to always
>> pick the most powerful, most general purpose primitive is attractive,
>> but not always sane...
>
> That's an interesting take on this.  Would you care to elaborate on
> why a module approach may not be sane?  Is it from a semantic or an
> implementation point of view?

To be clear: I'm not an expert on the internals of the compiler, and
am mostly repeating claims made by others who are.

But my understanding is roughly this: we want namespaces to behave
differently than modules currently do: in particular, we need to be
able to depend on only a subset of a namespace, and to track
dependencies within the different components of a namespace.

One could imagine building these features into modules directly, but
this is hampered by the fact there is a rich set of operators on
modules, for example, you can apply a functor to a module.

It's of course possible that either (a) one could naturally add these
features to modules directly and thus neatly avoid the need for
another language feature; or (b) that one could have two classes of
modules whose implementations differ under the skin but that present
themselves almost identically to users.

But I am unaware of anyone who understand the compiler internals who
believes either (a) or (b) is reasonably easy to do.

y

From yminsky at janestreet.com  Mon Feb 25 21:53:31 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 16:53:31 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512BD679.4010501@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
Message-ID: <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>

I understand your point Alain, but while what you're saying is
technically reasonable, I think it doesn't hold together.  When
programming in the large, it is useful to be able to manipulate the
namespace and group parts of the world together.  Many libraries, not
just Core or Async, want to be able to remap the world by adding a
collection of related names to the namespace.  The ability to do the
moral equivalent of:

   open Core.Std

is powerful and important.  Your proposal of having people add
prefixes to module names does not fit the bill, and the resulting
system does not, in my opinion, scale.

y

On Mon, Feb 25, 2013 at 4:24 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 2/25/2013 8:13 PM, Xavier Clerc wrote:
>>
>> This is no what I mean.
>> Packs and namespaces serve two different purposes.
>> It just happens that the lack of namespace forced
>> people (including me) to use packs as namespaces.
>
>
> Why forced?  I haven't seen a lot of libraries relying on -pack instead of
> using unique enough module names (but it's true that I don't use a lot of
> third-party libraries).  Using the library name as a common prefix for all
> its modules (and maybe having a module whose name is the library name itself
> in case of libraries with a clear notion of "main public module") seems a
> quite good solution to me and a better one than -pack.  Maybe this solution
> is not so good for libraries whose goal is to act as a "standard library"
> (such as Core), because the intention is to create the impression that the
> library is actually part of the language (I don't have the impression to use
> a library when I write String.length or List.map, contrary to when I write
> Xmlm.make_input); so I understand why Jane Street is reluctant to have
> Core_list.map everywhere in their code.  But would it really be a problem to
> have the users write "open Kaputt_abbreviations" instead of "open
> Kaputt.Abbreviations", or Bolt_logger.log instead of Bolt.Logger.log?
>
>
> Alain
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Mon Feb 25 23:04:56 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 25 Feb 2013 18:04:56 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130225.233726.511656759701836935.Christophe.Troestler@umons.ac.be>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <CACLX4jR9o6sixnzfdaFpBfWoNAOPMK3EW1tnU3rPUBoR793hbg@mail.gmail.com>
 <20130225.233726.511656759701836935.Christophe.Troestler@umons.ac.be>
Message-ID: <CACLX4jTn_2bdwtGVpZVhhYyrVirhOxrgRAt_Lgj5HsGb6pvr_w@mail.gmail.com>

On Mon, Feb 25, 2013 at 5:37 PM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Mon, 25 Feb 2013 16:50:33 -0500, Yaron Minsky wrote:
>>
>> On Mon, Feb 25, 2013 at 3:43 PM, Christophe TROESTLER
>> <Christophe.Troestler at umons.ac.be> wrote:
>> > On Mon, 25 Feb 2013 14:16:03 -0500, Yaron Minsky wrote:
>> >>
>> >> On Mon, Feb 25, 2013 at 1:04 PM, Daniel B?nzli
>> >> <daniel.buenzli at erratique.ch> wrote:
>> >> >
>> >> >
>> >> > Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
>> >> >
>> >> >> So, as of today, we have :
>> >> >> - "archives" (cma / cmxa) allowing to gather modules but without
>> >> >> naming (at the language level) the gathering ;
>> >> >> - "packs" allowing to gather modules into a module.
>> >> >> I regard namespaces are gathering modules into a named entity but
>> >> >> without creating a module. Hence, it is a new beast, different from
>> >> >> archives and packs.
>> >> >
>> >> > So basically a new concept is introduced because "pack" is not
>> >> > technically satisfying. That's not the way I would like the language
>> >> > I program in to be designed. I'd rather see the problems pack has
>> >> > fixed which I'm sure could be done by allowing archives to be named
>> >> > at the language level as a module.
>> >>
>> >> You might be right, but I think there's a deep issue here that
>> >> shouldn't be dismissed so lightly.  The argument is that modules are
>> >> simply too powerful to be used as the complete solution to namespace
>> >> management.  Deciding that the only principled approach is to always
>> >> pick the most powerful, most general purpose primitive is attractive,
>> >> but not always sane...
>> >
>> > That's an interesting take on this.  Would you care to elaborate on
>> > why a module approach may not be sane?  Is it from a semantic or an
>> > implementation point of view?
>>
>> To be clear: I'm not an expert on the internals of the compiler, and
>> am mostly repeating claims made by others who are.
>>
>> But my understanding is roughly this: we want namespaces to behave
>> differently than modules currently do: in particular, we need to be
>> able to depend on only a subset of a namespace, and to track
>> dependencies within the different components of a namespace.
>>
>> One could imagine building these features into modules directly, but
>> this is hampered by the fact there is a rich set of operators on
>> modules, for example, you can apply a functor to a module.
>>
>> It's of course possible that either (a) one could naturally add these
>> features to modules directly and thus neatly avoid the need for
>> another language feature; or (b) that one could have two classes of
>> modules whose implementations differ under the skin but that present
>> themselves almost identically to users.
>>
>> But I am unaware of anyone who understand the compiler internals who
>> believes either (a) or (b) is reasonably easy to do.
>
> With no doubt, I understand even less about the compiler internals
> than you do.  Nonetheless, shouldn't these questions receive a
> definitive answer before we speak about namespaces?  I have heard
> neither that these things are hard to do.

It's hard to track the thread; there's a lot going on.  But earlier in
this thread, Leo White mentioned it, raising the functor issue in
particular.

> And, if they are, it would be interesting to understand what
> features of modules hamper their efficiency as simple containers.
> That way, it seems to me, either the technical problems will get
> solved or what kind of "stripped modules" namespaces must be will
> emerge naturally.

Indeed.  Maybe someone can explain that to those of us who are less
schooled in compiler internals...

y

From wojciech.meyer at gmail.com  Mon Feb 25 23:50:13 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Mon, 25 Feb 2013 23:50:13 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <795AFF51E6A046BFA465D3177EB757CA@erratique.ch> ("Daniel
 \=\?utf-8\?Q\?B\=C3\=BCnzli\=22's\?\= message of "Fri,
 22 Feb 2013 19:40:08 +0100")
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
 <Prayer.1.3.5.1302221640250.25215@hermes-1.csi.cam.ac.uk>
 <795AFF51E6A046BFA465D3177EB757CA@erratique.ch>
Message-ID: <wfd2vohs22.fsf@gmail.com>

Hi Daniel,

I appreciate your strong stand that we should not introduce redundant
concepts to the language. I can understand that concept of module can
give the impression of managing compilation units. However I think this
is where the similarities end. Given the semantics of OCaml module
system, that each module is separate compilation unit - it's hard to say
it's flexible enough to cover functionality of namespaces which scale up
across the boundaries of compilation units. All the technical problem of
-pack are because modules are not namespaces. So why not to fix it
properly?

In ML world the smallest abstraction available is function, that scale
up to the level of modules, then we have modules that scale up to the
library level, and then we have an empty place that we try to structure
using modules. It would be natural to think that at the library level,
we should not use modules for abstracting and structuring things.

If you are still not sure, please see what SML community have done many
years ago with their compilation manager:

http://www.smlnj.org/doc/CM/index.html

This is an interesting paper. I don't literally repeat what is inside -
as I read this quite long time ago, but it covers a lot more than just
namespace management.

Hope this will make your more confident.

Daniel B?nzli <daniel.buenzli at erratique.ch> writes:

> Le vendredi, 22 f?vrier 2013 ? 17:40, Leo White a ?crit :
>> There is no real reason that something cannot be placed in two locations
>> within the hierarchy.
>
> But as I suggested from the perspective of programming *in the
> language* there no point of having it at two different location. Even
> from the perspective of reading code it's confusing you have to learn
> all the places where a module may be and understand that all these
> modules are in fact the same.
>
>> I agree with this in general. However, there are some specific cases where
>> a hierarchical namespace is very useful. For example:
>>
>> 1. In some very large libraries, it is useful to be able to divide the
>> modules into sub-components that can opened individually.
>>
>> 2. In some libraries it is useful to provide multiple versions of some
>> components (e.g. Foo.Async.Io and Foo.Lwt.Io).
>
> For me all this should be solved within the realm of the module
> system. Maybe we need to fix the way we link things in (since that
> seems to be the only reason why -pack is not deemed reasonable). But I
> really see no point in introducing new namings mechanisms into the
> core language.
>
> Daniel
>
>

--
Wojciech Meyer
http://danmey.org

From sylvain+ocaml at le-gall.net  Tue Feb 26 00:11:27 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 26 Feb 2013 01:11:27 +0100
Subject: [ocaml-platform] Is this mandatory to continue this discussion
 [was: on the need and design of OCaml namespaces]
Message-ID: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>

Hi,

We almost reach 60 mails in this thread, withouth any clear consensus.

My take on this:
We could build a first version of the platform WITHOUT namespaces. So
lets focus on building a first version (choosing packages, setting up
infrastructure, packaging, testing, website et al)

We will have plenty of time to discuss namespace after a first platform release.

My 2nd take on this:
Put this to vote !
With the following proposals:
A. Implement rich namespace
B. Implement simple flat namespace
C. Fix -pack issue rather than implementing namespace
D. Postpone discussion

Regards
Sylvain

2013/2/26 Wojciech Meyer <wojciech.meyer at gmail.com>:
> Hi Daniel,
>
> I appreciate your strong stand that we should not introduce redundant
> concepts to the language. I can understand that concept of module can
> give the impression of managing compilation units. However I think this
> is where the similarities end. Given the semantics of OCaml module
> system, that each module is separate compilation unit - it's hard to say
> it's flexible enough to cover functionality of namespaces which scale up
> across the boundaries of compilation units. All the technical problem of
> -pack are because modules are not namespaces. So why not to fix it
> properly?
>
> In ML world the smallest abstraction available is function, that scale
> up to the level of modules, then we have modules that scale up to the
> library level, and then we have an empty place that we try to structure
> using modules. It would be natural to think that at the library level,
> we should not use modules for abstracting and structuring things.
>
> If you are still not sure, please see what SML community have done many
> years ago with their compilation manager:
>
> http://www.smlnj.org/doc/CM/index.html
>
> This is an interesting paper. I don't literally repeat what is inside -
> as I read this quite long time ago, but it covers a lot more than just
> namespace management.
>
> Hope this will make your more confident.
>
> Daniel B?nzli <daniel.buenzli at erratique.ch> writes:
>
>> Le vendredi, 22 f?vrier 2013 ? 17:40, Leo White a ?crit :
>>> There is no real reason that something cannot be placed in two locations
>>> within the hierarchy.
>>
>> But as I suggested from the perspective of programming *in the
>> language* there no point of having it at two different location. Even
>> from the perspective of reading code it's confusing you have to learn
>> all the places where a module may be and understand that all these
>> modules are in fact the same.
>>
>>> I agree with this in general. However, there are some specific cases where
>>> a hierarchical namespace is very useful. For example:
>>>
>>> 1. In some very large libraries, it is useful to be able to divide the
>>> modules into sub-components that can opened individually.
>>>
>>> 2. In some libraries it is useful to provide multiple versions of some
>>> components (e.g. Foo.Async.Io and Foo.Lwt.Io).
>>
>> For me all this should be solved within the realm of the module
>> system. Maybe we need to fix the way we link things in (since that
>> seems to be the only reason why -pack is not deemed reasonable). But I
>> really see no point in introducing new namings mechanisms into the
>> core language.
>>
>> Daniel
>>
>>
>
> --
> Wojciech Meyer
> http://danmey.org
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Tue Feb 26 07:45:06 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 08:45:06 +0100
Subject: [ocaml-platform] Is this mandatory to continue this discussion
 [was: on the need and design of OCaml namespaces]
In-Reply-To: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
Message-ID: <512C6802.9030404@lexifi.com>

On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
> My 2nd take on this:
> Put this to vote !
> With the following proposals:
> A. Implement rich namespace
> B. Implement simple flat namespace
> C. Fix -pack issue rather than implementing namespace
> D. Postpone discussion

E. Advertize a naming convention for modules to avoid clashes, and 
provide very light support in the language/compiler/tools to reduce the 
syntactic overhead of using long names for users of "standard libraries".


Alain

From Christophe.Troestler at umons.ac.be  Mon Feb 25 18:21:20 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Mon, 25 Feb 2013 19:21:20 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
References: <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
 <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
Message-ID: <20130225.192120.740978752680372159.Christophe.Troestler@umons.ac.be>

On Mon, 25 Feb 2013 14:15:54 +0000, Anil Madhavapeddy wrote:
> 
> On 24 Feb 2013, at 19:26, Christophe TROESTLER <Christophe.Troestler at umons.ac.be> wrote:
> 
> > Camlp4 can insert some code to alias the standard modules needed
> > by code generation at the beginning of the source files (not
> > foolproof because a name needs to be generated but good enough in
> > practice).  It would be better if that facility was provided by a
> > Camlp4 module instead of needing to be redone by each extension.
> 
> That's an interesting idea.  The only hitch is that it's a little
> hard to do in one pass, as the code generation is called on the
> local AST fragment.

It can be done in one pass thanks to AstFilters.register_str_item_filter.  
Example code:

    let declarations_at_beginning = ref []
    
    (* The filters are evaluated after the whole source is read, thus all
       constants will have been collected. *)
    let () =
      if not_interactive then begin
        let add_top_declarations str_item =
          let add s decl = <:str_item at here< $decl$ $s$ >> in
          List.fold_left add str_item !declarations_at_beginning in
        AstFilters.register_str_item_filter add_top_declarations
      end
    
    let add_to_beginning_of_file decl =
      declarations_at_beginning := decl :: !declarations_at_beginning

From Christophe.Troestler at umons.ac.be  Mon Feb 25 20:28:14 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Mon, 25 Feb 2013 21:28:14 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jSufMQWkSpfGvmXv3g+rLzn8Z0EixjAWf7-iCrTk+EZYA@mail.gmail.com>
References: <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <20130224.203934.694409055502204737.Christophe.Troestler@umons.ac.be>
 <CACLX4jSufMQWkSpfGvmXv3g+rLzn8Z0EixjAWf7-iCrTk+EZYA@mail.gmail.com>
Message-ID: <20130225.212814.570331401676756198.Christophe.Troestler@umons.ac.be>

On Mon, 25 Feb 2013 09:14:17 -0500, Yaron Minsky wrote:
> 
> On Sun, Feb 24, 2013 at 2:39 PM, Christophe TROESTLER
> <Christophe.Troestler at umons.ac.be> wrote:
> > On Fri, 22 Feb 2013 11:39:41 +0100, Daniel B?nzli wrote:
> >>
> >> So if the problem is `-pack` is not good enough because it
> >> produces a huge `cmo`, why not just try to find a corresponding
> >> concept workable with `cm[x]a` ?
> >
> > As I understand it, people are not happy with -pack not for the
> > large cm[x]a files but because the whole library is included in
> > every executable even if only a small subset of the library is
> > used.  Would the "problem" with -pack still exist if this was
> > solved?
> 
> I think of there as being three key problems with -pack:
> 
> - The pack is a single unit that has to be loaded or not as a unit (as
>   per your point.
> - The pack is a choke-point in the dependency graph.  If you depend on
>   one thing in a pack, that you need to be recompiled if anything in
>   the pack changes.
> - Opening a pack like Core.Std is brutally slow, and really affects
>   performance of the build.
> 
> I think all of these issues need solving.

I'd like these issues to be solved too.  Is there any work at the Labs
on these?

From Christophe.Troestler at umons.ac.be  Mon Feb 25 20:43:40 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Mon, 25 Feb 2013 21:43:40 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
 <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
Message-ID: <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>

On Mon, 25 Feb 2013 14:16:03 -0500, Yaron Minsky wrote:
>
> On Mon, Feb 25, 2013 at 1:04 PM, Daniel B?nzli
> <daniel.buenzli at erratique.ch> wrote:
> >
> >
> > Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
> >
> >> So, as of today, we have :
> >> - "archives" (cma / cmxa) allowing to gather modules but without
> >> naming (at the language level) the gathering ;
> >> - "packs" allowing to gather modules into a module.
> >> I regard namespaces are gathering modules into a named entity but
> >> without creating a module. Hence, it is a new beast, different from
> >> archives and packs.
> >
> > So basically a new concept is introduced because "pack" is not
> > technically satisfying. That's not the way I would like the language
> > I program in to be designed. I'd rather see the problems pack has
> > fixed which I'm sure could be done by allowing archives to be named
> > at the language level as a module.
>
> You might be right, but I think there's a deep issue here that
> shouldn't be dismissed so lightly.  The argument is that modules are
> simply too powerful to be used as the complete solution to namespace
> management.  Deciding that the only principled approach is to always
> pick the most powerful, most general purpose primitive is attractive,
> but not always sane...

That's an interesting take on this.  Would you care to elaborate on
why a module approach may not be sane?  Is it from a semantic or an
implementation point of view?

From Christophe.Troestler at umons.ac.be  Mon Feb 25 22:33:39 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Mon, 25 Feb 2013 23:33:39 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <748650772.3709054.1361828430427.JavaMail.root@inria.fr>
References: <512BD679.4010501@lexifi.com>
 <748650772.3709054.1361828430427.JavaMail.root@inria.fr>
Message-ID: <20130225.233339.1226206120450456754.Christophe.Troestler@umons.ac.be>

On Mon, 25 Feb 2013 22:40:30 +0100, Xavier Clerc wrote:
> 
> >  Maybe this solution is not so good for libraries whose goal is to
> >  act as a "standard library" (such as Core), because the intention
> >  is to create the impression that the library is actually part of
> >  the language (I don't have the impression to use a library when I
> >  write String.length or List.map, contrary to when I write
> >  Xmlm.make_input); so I understand why Jane Street is reluctant to
> >  have Core_list.map everywhere in their code.  But would it really
> >  be a problem to have the users write "open Kaputt_abbreviations"
> >  instead of "open Kaputt.Abbreviations", or Bolt_logger.log
> >  instead of Bolt.Logger.log?
> 
> For those libraries, with few modules, it could be a decent solution.
> But for Barista (with 50+ modules), it is nice to be able to open the
> library as mentioned above. Moreover, library code is also made lighter
> by packing: in another Bolt module, "Logger.log" is sufficient (there
> is no ambiguity) while your solution would imply to write "Bolt_logger.log".
> 
> It just occurs to me that packing obviously allows (or enforces)
> "closed" namespaces: no one can add a module to the packed module.
> Is the ability to "close" a namespace something considered useful?

It seems to me that the openness of namespaces is the only feature I
have seen mentioned that modules do not have.  But is the openness of
namespaces something considered useful?  What problem does this solves?

Cheers,
C.

From Christophe.Troestler at umons.ac.be  Mon Feb 25 22:37:26 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Mon, 25 Feb 2013 23:37:26 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jR9o6sixnzfdaFpBfWoNAOPMK3EW1tnU3rPUBoR793hbg@mail.gmail.com>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <CACLX4jR9o6sixnzfdaFpBfWoNAOPMK3EW1tnU3rPUBoR793hbg@mail.gmail.com>
Message-ID: <20130225.233726.511656759701836935.Christophe.Troestler@umons.ac.be>

On Mon, 25 Feb 2013 16:50:33 -0500, Yaron Minsky wrote:
> 
> On Mon, Feb 25, 2013 at 3:43 PM, Christophe TROESTLER
> <Christophe.Troestler at umons.ac.be> wrote:
> > On Mon, 25 Feb 2013 14:16:03 -0500, Yaron Minsky wrote:
> >>
> >> On Mon, Feb 25, 2013 at 1:04 PM, Daniel B?nzli
> >> <daniel.buenzli at erratique.ch> wrote:
> >> >
> >> >
> >> > Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
> >> >
> >> >> So, as of today, we have :
> >> >> - "archives" (cma / cmxa) allowing to gather modules but without
> >> >> naming (at the language level) the gathering ;
> >> >> - "packs" allowing to gather modules into a module.
> >> >> I regard namespaces are gathering modules into a named entity but
> >> >> without creating a module. Hence, it is a new beast, different from
> >> >> archives and packs.
> >> >
> >> > So basically a new concept is introduced because "pack" is not
> >> > technically satisfying. That's not the way I would like the language
> >> > I program in to be designed. I'd rather see the problems pack has
> >> > fixed which I'm sure could be done by allowing archives to be named
> >> > at the language level as a module.
> >>
> >> You might be right, but I think there's a deep issue here that
> >> shouldn't be dismissed so lightly.  The argument is that modules are
> >> simply too powerful to be used as the complete solution to namespace
> >> management.  Deciding that the only principled approach is to always
> >> pick the most powerful, most general purpose primitive is attractive,
> >> but not always sane...
> >
> > That's an interesting take on this.  Would you care to elaborate on
> > why a module approach may not be sane?  Is it from a semantic or an
> > implementation point of view?
> 
> To be clear: I'm not an expert on the internals of the compiler, and
> am mostly repeating claims made by others who are.
> 
> But my understanding is roughly this: we want namespaces to behave
> differently than modules currently do: in particular, we need to be
> able to depend on only a subset of a namespace, and to track
> dependencies within the different components of a namespace.
> 
> One could imagine building these features into modules directly, but
> this is hampered by the fact there is a rich set of operators on
> modules, for example, you can apply a functor to a module.
> 
> It's of course possible that either (a) one could naturally add these
> features to modules directly and thus neatly avoid the need for
> another language feature; or (b) that one could have two classes of
> modules whose implementations differ under the skin but that present
> themselves almost identically to users.
> 
> But I am unaware of anyone who understand the compiler internals who
> believes either (a) or (b) is reasonably easy to do.

With no doubt, I understand even less about the compiler internals
than you do.  Nonetheless, shouldn't these questions receive a
definitive answer before we speak about namespaces?  I have heard
neither that these things are hard to do.  And, if they are, it would
be interesting to understand what features of modules hamper their
efficiency as simple containers.  That way, it seems to me, either the
technical problems will get solved or what kind of "stripped modules"
namespaces must be will emerge naturally.

Best,
C.

From gabriel.scherer at gmail.com  Tue Feb 26 09:37:14 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 26 Feb 2013 10:37:14 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
 <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
Message-ID: <CAPFanBF8tOi7dfuFGsmL4hA7QhfWkskhyr-G3dFeMq2MrDaKqA@mail.gmail.com>

In this post, I'll try to take a high-level view of the discussion that has
happened so far. You can take this as an (opinionated) summary.

The main ideas of my proposal linked at the top, or more generally my work
on what people have been suggesting for namespaces, are the following:

1. Namespaces are about the out-of-the-language-question of how a given
in-source compilation unit name (masquerading as a module name) maps to an
in-filesystem compilation unit.
2. I was suggesting new features that (mostly) do not change the OCaml
language itself, but the semantics of this mapping and the way it is given
to the type-checker. This is a choice that some people may not agree with
(more on that later).
3. Actual OCaml implementations also have a notion of "internal module
name" that is contained in compiled object files; two modules of the same
internal name cannot be mixed together. This has important practical
implication, and we can consider the implementation space for internal
module names.

Alain has a large codebase with house-developed tools, unique build process
conventions, and the ironically unusual constraint of compiling quickly on
Windows. He pushes for having as few changes as possible. No change to the
internal module names (this means developers should use long
hopefully-unique filename to avoid conflicts), no change to the structure
of compilation unit names (no hierarchy), and a simple
compunit-name-to-compunit-name mapping to alleviate the pains. In my
initial proposal, this corresponds to restricting the compilation
environment descriptions to a flat mapping built by literals and merging
only.

Leo has the fairly different use case of Janestreet Core's library in mind:
hierarchy is important (Core.Foo looks better than Core_Foo and "open
namespace Core" is important), changing the language for greater good is
ok, and his particular suggestion is an in-language, compunit-wide "in
Core.Foo" construct that would both be added to the internal module name,
and be used to generate the mapping from compunit names from compunit *on
the developer side*, rather than on the user side (with then the simple
semantics that all mappings from the search path are merged). This can
against be seen as a way to define the compilation environment, giving
slightly more control to the module provider (mostly a placement in a
hierarchy). It corresponds to a restriction of the way to define
compilation environments that is even more severe, the user having no
control (compilation environments are built as the merging of all
developer-generated environments present in the search path).

Daniel is opposed to the addition of a new "namespace" concept to the OCaml
language. It is not completely clear to me whether he objects to:
1. the addition of more flexibility in the way compilation unit names are
mapped to compilation units, outside the language (the mapping file Alain
suggests, the more expressive mapping languages I have considered, or a
compilation-option version of the "in Foo.Bar" proposed by Leo)
2. or only the addition of a new concept *in the language itself*, such as
can be seen if we insist to write Core#Std#Map.Make rather than
Core.Std.Map.Make

I lament that, expect Alain, nobody gives a damn about letting users
redefine their own names or paths in a different way that what the module
provider planned for. I think it's an important part of the design space
that may allow quite convenient things (eg. scenarios of companies
maintaining a in-house repository of modules with pinned version, and still
being to interact with non-curated module collections in the same
programs), but apparently this is not something people care about. Well,
that's how it is, and hopefully this won't turn out to be overly
restrictive in the mid-term future.


## A more detailed discussion of Daniel's arguments

Daniel, I am glad that you defend this point of view, as I myself grow more
and more conservative of language extension ideas (maybe it's a contagious
effect of vicinity to OCaml designers...). I do completely agree that new
language features should be motivated by a (expressivity vs. complexity /
kludgeness) estimation, and that it is not a priori clear that we need
another "programming in the large" concept above modules.

Regarding point (2): About a year ago, I have worked with Nicolas Pouillard
on a way to make the objection go away, by seeing compilation unit names
only as modules in the source code: given a hierarchical compilation
environment, there is a principled way to turn any non-leaf path (that does
not denote a compilation unit by itself) into a module. Instead of
Core#Std#Map, we could write Core#Std.Map (seeing Core#Std as a module) or
even Core.Std.Map (seeing Core as module) without changing the semantics of
my proposal (or any consensual restriction of it). You can find this
specified in an older design document,
  http://gallium.inria.fr/~scherer/namespaces/pack_et_functor_pack.html
I had decided not to link it in my introductory mail because it add a bit
more complexity to the semantics of mapping compilation unit names to
compilation units, and my feeling was that discussing the design space of a
simpler basis was a better way to start a discussion that would certainly
become unwieldy to the risk of being improductive.

Summing things up: if you have a hierarchical mapping outside the language,
you can make it appear in OCaml source code as just as module hierarchy, as
you suggest. I think it actually adds *complexity* to the underlying
design, so there is a price to pay to hide this distinct notion of
(structured) compilation unit name. I would be ready to pay that price if
there is a wide agreement it is the right thing to do, but I personally
favor more explicit designs, at least as an experimentation and discussion
device (I think we should make the difference explicit and have a (module
Core#Std) construct turning a non-leaf compilation unit path into a module
with submodules, with the shared understanding that we can decide to hide
it under a syntactic ambiguity).

(The documentation also discusses the possibility of having *functors* that
span several compilation units, and that is something Yaron has requested
in the past. It is more complex and I don't think it is as ready, robust
and canonical as the module part, so I encourage you to ignore it in the
context of this discussion.)

Regarding point (1), your suggestion to use .cma as an already-existing
grouping of modules in submodules that could help solve module name
conflicts, I feel this is a more anecdotal part of your (still imprecise)
proposal that is more in the "you see it doesn't need to be that complex"
league that an actual principled design. I have a sympathy for the "least
effort" design process that it shares with Alain's proposal, but I think it
should not stop us from thinking about the whole design space in a
scientific way. (For example: unless I'm mistaken, .cma cannot currently
embed .cma, so your proposal for implementation reasons cannot expression
non-flat module hierarchies.) There are important technical details left to
be defined, such as how to avoid internal name clashes between submodules
of different .cma-packs. My intuition is that getting the details
straightened out would amount to re-implementing -pack (in particular the
-for-pack approach to internal module names prefixing) in terms of .cma
rather than .cmo. So the mapping from compilation unit names to compilation
units would still be entirely directed by the filesystem and search path as
it currently is, but with link-economic module packs. Why not, that's an
idea we could explore in more details, but note that its semantics would
still be split in two different "phases":
- a new notion of structured paths Foo#Bar that allows to denote a
compilation unit for bar.cmo embedded into foo.cma
- a possible way to hide this additional structure to source code,
masquerading Foo as a module, with a precise semantics when it is used for
something else than a projection (as in the document linked above; in fact
you could reuse the same proposal, I think)

This particular implementation choice gives away on quite a few things we
might want to have, such as:
- the ability to merge two sets of submodules that share a common parent
name (admittedly this is not useful in a provenance-oriented view of
compilation unit naming, but more in a Data.List view that is not
necessarily the good one to start with)
- the ability for users to build new/distinct parallel module organizations
- more-than-depth-2 hierarchies (implementation detail; might be fixed with
non-neglectible amount of work)
- compilation unit name aliasing / redefinition

But it looks interesting. Please go ahead with more detailed proposals!

On Mon, Feb 25, 2013 at 3:15 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> On 24 Feb 2013, at 19:26, Christophe TROESTLER <
> Christophe.Troestler at umons.ac.be> wrote:
>
> > On Fri, 22 Feb 2013 11:41:10 +0000, Anil Madhavapeddy wrote:
> >>
> >> There's one scenario which absolutely requires the ability to
> explicitly open a particular namespace: camlp4 code generation.
> >>
> >> Right now, several camlp4 extensions break because they use modules
> from the standard Pervasives library, and have no way to explicitly state
> that.  If Core.Std is opened, then compilation fails.
> >>
> >> The two workarounds are:
> >> - hack the build system to pass -pp options to the camlp4 generator.
> Painful.
> >> - have some facility to explicitly open 'Caml_std' or 'Core_std'
> locally, irrespective of the current module environment.
> >>
> >> I believe namespaces addresses the latter workaround.
> >
> > Camlp4 can insert some code to alias the standard modules needed by code
> generation at the beginning of the source files (not foolproof because a
> name needs to be generated but good enough in practice).  It would be
> better if that facility was provided by a Camlp4 module instead of needing
> to be redone by each extension.
>
> That's an interesting idea.  The only hitch is that it's a little hard to
> do in one pass, as the code generation is called on the local AST fragment.
>
> I think it would work if placed as a feature into type_conv itself, as the
> individual generators (e.g. sexp/orm) all register themselves with it quite
> early.  They could request global modules, which type_conv does in one pass
> (thus also avoiding duplicate requests for the original namespace).
>
> CCing Markus Mottl to see what he thinks...
>
> -anil
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130226/ac196941/attachment-0001.html>

From gabriel.scherer at gmail.com  Tue Feb 26 10:12:04 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 26 Feb 2013 11:12:04 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130225.233726.511656759701836935.Christophe.Troestler@umons.ac.be>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <CACLX4jR9o6sixnzfdaFpBfWoNAOPMK3EW1tnU3rPUBoR793hbg@mail.gmail.com>
 <20130225.233726.511656759701836935.Christophe.Troestler@umons.ac.be>
Message-ID: <CAPFanBHHBWoqkb3Ctq4k35mhY=K3WqGa07tsStffEUPqNUK4Bg@mail.gmail.com>

Christophe TROESTLER <Christophe.Troestler at umons.ac.be> wrote:
> It seems to me that the openness of namespaces is the only feature I
> have seen mentioned that modules do not have.  But is the openness of
> namespaces something considered useful?  What problem does this solves?

If you have a haskell-ish view of module hierarchies as functional
classification rather than provenance, eg.
  Data.List
  Data.Array
  Data.Array.Mutable
  Foreign.ForeignPtr
  Control.Concurrent.IO
  ...

then having a "merge {Data.{List,Array.Mutable}} with
{Data.{Array,String}}" is important. This is something open structures
naturally have, and that is not a good fit for closed structures. The
discussion for namespaces (before it landed on this list) insisted on
openness as a distinctive aspect for a while, but then we realized
that, at the moment of compilation of a single module, all the
information about the compilation environment in known, so you can
have a closed view of the world -- even if the world may change
between compilations. This idea that "once everything is decided you
are in a closed world again" allows to present (open) namespaces as
(closed) modules at the source code level if deemed desirable -- see
http://gallium.inria.fr/~scherer/namespaces/pack_et_functor_pack.html

Summary: "open" is not essential, but "open merge" is an useful
primitive to have (even in a closed world). You can always locally
assume that the world is closed, and (locally) close structures are
simpler to deal with.

> With no doubt, I understand even less about the compiler internals
> than you do.  Nonetheless, shouldn't these questions receive a
> definitive answer before we speak about namespaces?  I have heard
> neither that these things are hard to do.  And, if they are, it would
> be interesting to understand what features of modules hamper their
> efficiency as simple containers.  That way, it seems to me, either the
> technical problems will get solved or what kind of "stripped modules"
> namespaces must be will emerge naturally.

The reason why this isn't done more is that the people that know well
about the compiler internals don't want to be bothered with the
namespace discussion (except Alain, that knows very well about these
issues and is active, if maybe a bit conservatively so, in the
discussions), and these questions are full of tedious implementation
details that even the implementors don't keep all in mind at the same
time. Some partial answers:

- The reason why packing everything in a single .cmo (compilation
unit) bloats linking results is that dependencies are handled at a
granularity of the compilation unit. Relying (dynamically) on the
module Foo in your source unit will result in a mention of Foo's
internal name in your compilation unit, and Foo will need to be linked
as a whole. To reduce the granularity in a principled way, one could
decide to track dependencies at the definition/structure-item level
rather than the whole-unit level, but that would be a fairly invasive
implementation change that has so far been resisted, with unclear (and
potentially scary) implications of compilation time changes for
example.

- One should keep in mind that while bytecode compiled files (.cmo and
.cmi) are easy to deal with, native objects (.cmx and friends) are a
pain because of portability issues. The reason why we have this
two-step "-for-pack" then "-pack" process for packing is that
implementors found that (at the time) MacOS systems couldn't be relied
on to manipulate and change .cmx files. That's the reason why you need
to prepare for packing in advance (-for-pack) instead of simply
packing regularly compiled module. These are the kind of limitation
you have to work with in linker-related settings.

On Mon, Feb 25, 2013 at 11:37 PM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Mon, 25 Feb 2013 16:50:33 -0500, Yaron Minsky wrote:
>>
>> On Mon, Feb 25, 2013 at 3:43 PM, Christophe TROESTLER
>> <Christophe.Troestler at umons.ac.be> wrote:
>> > On Mon, 25 Feb 2013 14:16:03 -0500, Yaron Minsky wrote:
>> >>
>> >> On Mon, Feb 25, 2013 at 1:04 PM, Daniel B?nzli
>> >> <daniel.buenzli at erratique.ch> wrote:
>> >> >
>> >> >
>> >> > Le vendredi, 22 f?vrier 2013 ? 22:51, Xavier Clerc a ?crit :
>> >> >
>> >> >> So, as of today, we have :
>> >> >> - "archives" (cma / cmxa) allowing to gather modules but without
>> >> >> naming (at the language level) the gathering ;
>> >> >> - "packs" allowing to gather modules into a module.
>> >> >> I regard namespaces are gathering modules into a named entity but
>> >> >> without creating a module. Hence, it is a new beast, different from
>> >> >> archives and packs.
>> >> >
>> >> > So basically a new concept is introduced because "pack" is not
>> >> > technically satisfying. That's not the way I would like the language
>> >> > I program in to be designed. I'd rather see the problems pack has
>> >> > fixed which I'm sure could be done by allowing archives to be named
>> >> > at the language level as a module.
>> >>
>> >> You might be right, but I think there's a deep issue here that
>> >> shouldn't be dismissed so lightly.  The argument is that modules are
>> >> simply too powerful to be used as the complete solution to namespace
>> >> management.  Deciding that the only principled approach is to always
>> >> pick the most powerful, most general purpose primitive is attractive,
>> >> but not always sane...
>> >
>> > That's an interesting take on this.  Would you care to elaborate on
>> > why a module approach may not be sane?  Is it from a semantic or an
>> > implementation point of view?
>>
>> To be clear: I'm not an expert on the internals of the compiler, and
>> am mostly repeating claims made by others who are.
>>
>> But my understanding is roughly this: we want namespaces to behave
>> differently than modules currently do: in particular, we need to be
>> able to depend on only a subset of a namespace, and to track
>> dependencies within the different components of a namespace.
>>
>> One could imagine building these features into modules directly, but
>> this is hampered by the fact there is a rich set of operators on
>> modules, for example, you can apply a functor to a module.
>>
>> It's of course possible that either (a) one could naturally add these
>> features to modules directly and thus neatly avoid the need for
>> another language feature; or (b) that one could have two classes of
>> modules whose implementations differ under the skin but that present
>> themselves almost identically to users.
>>
>> But I am unaware of anyone who understand the compiler internals who
>> believes either (a) or (b) is reasonably easy to do.
>
> With no doubt, I understand even less about the compiler internals
> than you do.  Nonetheless, shouldn't these questions receive a
> definitive answer before we speak about namespaces?  I have heard
> neither that these things are hard to do.  And, if they are, it would
> be interesting to understand what features of modules hamper their
> efficiency as simple containers.  That way, it seems to me, either the
> technical problems will get solved or what kind of "stripped modules"
> namespaces must be will emerge naturally.
>
> Best,
> C.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From sylvain+ocaml at le-gall.net  Tue Feb 26 10:26:40 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 26 Feb 2013 11:26:40 +0100
Subject: [ocaml-platform] Fwd: Is this mandatory to continue this discussion
 [was: on the need and design of OCaml namespaces]
In-Reply-To: <512C6802.9030404@lexifi.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
Message-ID: <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>

As you started this discussion and you write a nice summary in your
last email, can you setup a vote form?

The most simple way is to use a Google Form. If you don't feel
confident, send me the text of each proposal (like the proposals I
write in the forwarded email) + link to your summary + relevant post
(a la weekly ocaml news) and I will setup a form for you.

I think it would be even better that all proposal get an implementor
name attached to it, so we know who will be in charge of the next
action...

Regards
Sylvain



---------- Forwarded message ----------
From: Alain Frisch <alain.frisch at lexifi.com>
Date: 2013/2/26
Subject: Re: [ocaml-platform] Is this mandatory to continue this
discussion [was: on the need and design of OCaml namespaces]
To: Sylvain Le Gall <sylvain+ocaml at le-gall.net>
Cc : Wojciech Meyer <wojciech.meyer at gmail.com>, Didier Remy
<didier.remy at inria.fr>, "platform at lists.ocaml.org"
<platform at lists.ocaml.org>


On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
>
> My 2nd take on this:
> Put this to vote !
> With the following proposals:
> A. Implement rich namespace
> B. Implement simple flat namespace
> C. Fix -pack issue rather than implementing namespace
> D. Postpone discussion


E. Advertize a naming convention for modules to avoid clashes, and
provide very light support in the language/compiler/tools to reduce
the syntactic overhead of using long names for users of "standard
libraries".


Alain

From gabriel.scherer at gmail.com  Tue Feb 26 10:49:00 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 26 Feb 2013 11:49:00 +0100
Subject: [ocaml-platform] Is this mandatory to continue this discussion
 [was: on the need and design of OCaml namespaces]
In-Reply-To: <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
Message-ID: <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>

I'm sorry if you feel the discussion is unproductive or distracts
attention from other important issues related to the OCaml platform.
I, for one, am glad that a discussion of this design question is done
in the open for the first time -- at the price, indeed, of some
lengths of text, but I didn't feel the signal/noise ratio was that
bad.

I'm not sure "voting" on something is the right way to go, as it would
have little actual weight when it comes to convincing the actual
language maintainers to implement or integrate changes, or the people
having specific needs (JaneStreet, or Alain) that their needs will be
respected by the course of events. We could have an opinion poll, but
we already have access to the opinions expressed so far (out of
memory: Leo, Anil and Yaron have a rather precise hierarchical
proposal, Alain wishes to avoid tooling changes, and other people that
have been less involved so far vary between mild interest and strong
doubts that proposed changes tackle the problem in the right
direction).

I feel there is space left for valuable ideas and technical
contributions, by Daniel and Cristophe for example. If there is a
feeling that this is too noisy and drowns other -platform discussion,
I'm ready to take it to another discussion channel (but I would
personally appreciate public archives to be available).

On Tue, Feb 26, 2013 at 11:26 AM, Sylvain Le Gall
<sylvain+ocaml at le-gall.net> wrote:
> As you started this discussion and you write a nice summary in your
> last email, can you setup a vote form?
>
> The most simple way is to use a Google Form. If you don't feel
> confident, send me the text of each proposal (like the proposals I
> write in the forwarded email) + link to your summary + relevant post
> (a la weekly ocaml news) and I will setup a form for you.
>
> I think it would be even better that all proposal get an implementor
> name attached to it, so we know who will be in charge of the next
> action...
>
> Regards
> Sylvain
>
>
>
> ---------- Forwarded message ----------
> From: Alain Frisch <alain.frisch at lexifi.com>
> Date: 2013/2/26
> Subject: Re: [ocaml-platform] Is this mandatory to continue this
> discussion [was: on the need and design of OCaml namespaces]
> To: Sylvain Le Gall <sylvain+ocaml at le-gall.net>
> Cc : Wojciech Meyer <wojciech.meyer at gmail.com>, Didier Remy
> <didier.remy at inria.fr>, "platform at lists.ocaml.org"
> <platform at lists.ocaml.org>
>
>
> On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
>>
>> My 2nd take on this:
>> Put this to vote !
>> With the following proposals:
>> A. Implement rich namespace
>> B. Implement simple flat namespace
>> C. Fix -pack issue rather than implementing namespace
>> D. Postpone discussion
>
>
> E. Advertize a naming convention for modules to avoid clashes, and
> provide very light support in the language/compiler/tools to reduce
> the syntactic overhead of using long names for users of "standard
> libraries".
>
>
> Alain

From avsm2 at cl.cam.ac.uk  Tue Feb 26 11:16:50 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Tue, 26 Feb 2013 11:16:50 +0000
Subject: [ocaml-platform] A reminder of goals [Was: Is this mandatory to
	continue this discussion]
In-Reply-To: <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
Message-ID: <2620F13A-893E-476E-B5C0-CF3A727AF889@cl.cam.ac.uk>

Hi Sylvain,

I requested Gabriel to send out the latest namespaces proposal so that
we could get a better understanding of the subtleties around the separation
of compilation units and namespaces.  The discussion so far as been very
enlightening indeed.  However, we do *not* need to put anything to a vote
at this stage, or indeed ever.

As  I described in a previous mail, our initial stakeholders for the
Platform are a small, targeted set of Consortium users who have described
their requirements, and we will expand this set once the first three (JS,
Citrix and Lexifi) are satisfied.  A vote among a small set of self-selected
participants doesn't help meet those goals.

Package selection should also be driven from this criteria. There is
real work to be done here --- all three users have different standard
libraries that need to converge if we're going to have a Platform that's
actually used by anyone else.  This is also what's driving the desire for
"namespaces":

- how do we switch between different standard libraries, but avoid very
  large binaries and the loss of ocamldoc (which doesn't support pack).

- how do we mix and match code across them without having to functorise
  everything across stdlib modules.  This is why Fabrice cooked up the
  'big functor' patch.

- more open namespaces are particularly useful when pulling in libraries
  such as Lwt, which exports modules such as Lwt_list or Lwt_sequence.
  It would be *much* nicer if I could access some of the blocking functions
  directly within the List module.  Core solves this by overriding the
  entire namespace within Async.Std, at a big compilation-time cost.

Here's what OCL and OCamlPro are doing while we figure this out:

- building a more flexible OCamldoc that can combine compilation units
  into a single, cross-referenced documentation repository.  This will let
  us publish a single docset for a combination of libraries, crucially
  including packed ones.  The current OCamldoc doesn't support packed units,
  which has been a serious problem for years.  Leo almost has a working
  prototype and will mail out to this list shortly.

- We've started work on a continuous test infrastructure for OPAM, which
  Amir will send out details on shortly when we have a base prototype. 
  We've demonstrated mockups to JS and Citrix already, and have a basic
  idea that it matches the workflow needs for the open-source releases of
  JS and Xen well.  This system also uses several major OCaml components
  as an exercise in "eating our own dogfood", such as Core/Async and
  OCamlmq/STOMP and Cohttp.

- large-scale build systems remain a problem, and there are several
  projects ongoing for dealing with 10k+ compilation units, and the
  workflow to operate over portions of those.  Both Citrix and JS have
  complementary work ongoing here, and we just had a meeting last week
  to demo early versions to each other.  More to follow when the writeup
  is done, and how it fits into the existing ecosystem.

All of the above will deliver good, useful value without any language
modifications ever seeing the light of day, but I still don't think we
have a good handle on how to attack the base problem of manipulating
modules more flexibly at compile time. A vote however, won't help bring
this understanding.  More prototyping and experimentation (and Gabriel's
*extremely* useful roundups) really help crystallise this work though.

(I hope that much of this thinking will make its way to the OCaml Workshop
at ICFP later this year for broader dissemination and archival too.)

best,
Anil

On 26 Feb 2013, at 10:26, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:

> As you started this discussion and you write a nice summary in your
> last email, can you setup a vote form?
> 
> The most simple way is to use a Google Form. If you don't feel
> confident, send me the text of each proposal (like the proposals I
> write in the forwarded email) + link to your summary + relevant post
> (a la weekly ocaml news) and I will setup a form for you.
> 
> I think it would be even better that all proposal get an implementor
> name attached to it, so we know who will be in charge of the next
> action...
> 
> Regards
> Sylvain
> 
> 
> 
> ---------- Forwarded message ----------
> From: Alain Frisch <alain.frisch at lexifi.com>
> Date: 2013/2/26
> Subject: Re: [ocaml-platform] Is this mandatory to continue this
> discussion [was: on the need and design of OCaml namespaces]
> To: Sylvain Le Gall <sylvain+ocaml at le-gall.net>
> Cc : Wojciech Meyer <wojciech.meyer at gmail.com>, Didier Remy
> <didier.remy at inria.fr>, "platform at lists.ocaml.org"
> <platform at lists.ocaml.org>
> 
> 
> On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
>> 
>> My 2nd take on this:
>> Put this to vote !
>> With the following proposals:
>> A. Implement rich namespace
>> B. Implement simple flat namespace
>> C. Fix -pack issue rather than implementing namespace
>> D. Postpone discussion
> 
> 
> E. Advertize a naming convention for modules to avoid clashes, and
> provide very light support in the language/compiler/tools to reduce
> the syntactic overhead of using long names for users of "standard
> libraries".
> 
> 
> Alain
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
> 


From avsm2 at cl.cam.ac.uk  Tue Feb 26 11:18:44 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Tue, 26 Feb 2013 11:18:44 +0000
Subject: [ocaml-platform] Is this mandatory to continue this discussion
	[was: on the need and design of OCaml namespaces]
In-Reply-To: <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
 <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>
Message-ID: <A34C7933-03B6-4478-8FC3-AE2FC6E96256@cl.cam.ac.uk>

On 26 Feb 2013, at 10:49, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> I'm sorry if you feel the discussion is unproductive or distracts
> attention from other important issues related to the OCaml platform.
> I, for one, am glad that a discussion of this design question is done
> in the open for the first time -- at the price, indeed, of some
> lengths of text, but I didn't feel the signal/noise ratio was that
> bad.
> 
> I'm not sure "voting" on something is the right way to go, as it would
> have little actual weight when it comes to convincing the actual
> language maintainers to implement or integrate changes, or the people
> having specific needs (JaneStreet, or Alain) that their needs will be
> respected by the course of events. We could have an opinion poll, but
> we already have access to the opinions expressed so far (out of
> memory: Leo, Anil and Yaron have a rather precise hierarchical
> proposal, Alain wishes to avoid tooling changes, and other people that
> have been less involved so far vary between mild interest and strong
> doubts that proposed changes tackle the problem in the right
> direction).
> 
> I feel there is space left for valuable ideas and technical
> contributions, by Daniel and Cristophe for example. If there is a
> feeling that this is too noisy and drowns other -platform discussion,
> I'm ready to take it to another discussion channel (but I would
> personally appreciate public archives to be available).

I completely agree with Gabriel here.  The Platform list is precisely
where this discussion needs to happen, and it is not on the main OCaml
list due to the expected volume.

-anil

From sylvain+ocaml at le-gall.net  Tue Feb 26 11:22:22 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 26 Feb 2013 12:22:22 +0100
Subject: [ocaml-platform] Is this mandatory to continue this discussion
 [was: on the need and design of OCaml namespaces]
In-Reply-To: <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
 <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>
Message-ID: <CAOCAUGMr1SUOBXbODb5vmnd9p8VOwcnMzUgkzdV4Jq6+Ws8Q5g@mail.gmail.com>

2013/2/26 Gabriel Scherer <gabriel.scherer at gmail.com>:
> I'm sorry if you feel the discussion is unproductive or distracts
> attention from other important issues related to the OCaml platform.
> I, for one, am glad that a discussion of this design question is done
> in the open for the first time -- at the price, indeed, of some
> lengths of text, but I didn't feel the signal/noise ratio was that
> bad.

The quality of the discussion is good, no problem.

Let me try to explain my POV:
1. are namespaces a mandatory/specific point of the OCaml platform (v1)
2. if not a mandatory step: let build the platform v1 and care about
this point later (i.e. when it will be in the compiler)
3. if not specific to platform: caml-list will be a better place to discuss this

I am not trying to imply that it is non-productive or whatever, I just
want to focus on what is needed for the OCaml platform. If people feel
this is mandatory, feel free to continue this discussion and ACK that
it is required for ocaml platform. I just want to be sure that
everyone thinks this is required.

IMHO, I think this is not mandatory and I would have expect that the
first thread on platform list would be "what packages to choose for
v1" or "what are the targets arch" or "what is the deadline" or "what
is the policy for including a package in the ocaml-platform". Having
discussion that "at best" will postpone OCaml platform v1 until
namespaces are implemented, is somehow problematic...

The SUCCESS of the ocaml-platform is to deliver something in a few months.

>
> I'm not sure "voting" on something is the right way to go, as it would
> have little actual weight when it comes to convincing the actual
> language maintainers to implement or integrate changes, or the people
> having specific needs (JaneStreet, or Alain) that their needs will be
> respected by the course of events. We could have an opinion poll, but
> we already have access to the opinions expressed so far (out of
> memory: Leo, Anil and Yaron have a rather precise hierarchical
> proposal, Alain wishes to avoid tooling changes, and other people that
> have been less involved so far vary between mild interest and strong
> doubts that proposed changes tackle the problem in the right
> direction).
>
> I feel there is space left for valuable ideas and technical
> contributions, by Daniel and Cristophe for example. If there is a
> feeling that this is too noisy and drowns other -platform discussion,
> I'm ready to take it to another discussion channel (but I would
> personally appreciate public archives to be available).
>

Voting is just a quick way to come with an actionnable item. I care
about delivering something in the near future. If there is no obvious
good choice (which seems to be the case), we should postpone. It will
give time to think about the issue.

> On Tue, Feb 26, 2013 at 11:26 AM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> As you started this discussion and you write a nice summary in your
>> last email, can you setup a vote form?
>>
>> The most simple way is to use a Google Form. If you don't feel
>> confident, send me the text of each proposal (like the proposals I
>> write in the forwarded email) + link to your summary + relevant post
>> (a la weekly ocaml news) and I will setup a form for you.
>>
>> I think it would be even better that all proposal get an implementor
>> name attached to it, so we know who will be in charge of the next
>> action...
>>
>> Regards
>> Sylvain
>>
>>
>>
>> ---------- Forwarded message ----------
>> From: Alain Frisch <alain.frisch at lexifi.com>
>> Date: 2013/2/26
>> Subject: Re: [ocaml-platform] Is this mandatory to continue this
>> discussion [was: on the need and design of OCaml namespaces]
>> To: Sylvain Le Gall <sylvain+ocaml at le-gall.net>
>> Cc : Wojciech Meyer <wojciech.meyer at gmail.com>, Didier Remy
>> <didier.remy at inria.fr>, "platform at lists.ocaml.org"
>> <platform at lists.ocaml.org>
>>
>>
>> On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
>>>
>>> My 2nd take on this:
>>> Put this to vote !
>>> With the following proposals:
>>> A. Implement rich namespace
>>> B. Implement simple flat namespace
>>> C. Fix -pack issue rather than implementing namespace
>>> D. Postpone discussion
>>
>>
>> E. Advertize a naming convention for modules to avoid clashes, and
>> provide very light support in the language/compiler/tools to reduce
>> the syntactic overhead of using long names for users of "standard
>> libraries".
>>
>>
>> Alain

From avsm2 at cl.cam.ac.uk  Tue Feb 26 11:38:43 2013
From: avsm2 at cl.cam.ac.uk (Anil Madhavapeddy)
Date: Tue, 26 Feb 2013 11:38:43 +0000
Subject: [ocaml-platform] Is this mandatory to continue this discussion
	[was: on the need and design of OCaml namespaces]
In-Reply-To: <CAOCAUGMr1SUOBXbODb5vmnd9p8VOwcnMzUgkzdV4Jq6+Ws8Q5g@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
 <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>
 <CAOCAUGMr1SUOBXbODb5vmnd9p8VOwcnMzUgkzdV4Jq6+Ws8Q5g@mail.gmail.com>
Message-ID: <03F0E990-F4CD-4BE3-8BD9-950F5756D6B4@cl.cam.ac.uk>

On 26 Feb 2013, at 11:22, Sylvain Le Gall <sylvain+ocaml at le-gall.net> wrote:
> 
> I am not trying to imply that it is non-productive or whatever, I just
> want to focus on what is needed for the OCaml platform. If people feel
> this is mandatory, feel free to continue this discussion and ACK that
> it is required for ocaml platform. I just want to be sure that
> everyone thinks this is required.
> 
> IMHO, I think this is not mandatory and I would have expect that the
> first thread on platform list would be "what packages to choose for
> v1" or "what are the targets arch" or "what is the deadline" or "what
> is the policy for including a package in the ocaml-platform". Having
> discussion that "at best" will postpone OCaml platform v1 until
> namespaces are implemented, is somehow problematic...
> 
> The SUCCESS of the ocaml-platform is to deliver something in a few months.

Not true. The success of the Platform is to deliver something that
will be used by serious users of OCaml, and to learn from their experiences
at the same time.  We obviously don't intend to take years doing it, but
there's also no mad rush to lash something up in a few weeks.

> Voting is just a quick way to come with an actionnable item. I care
> about delivering something in the near future. If there is no obvious
> good choice (which seems to be the case), we should postpone. It will
> give time to think about the issue.

In this case voting won't lead to any actionable items. Therefore it's
largely a waste of time.  The discussion to date has been extremely
useful, however.

If you have concerns about the timeline or progress, please feel free
to contact me directly and I'll resolve any issues.  Progress has been
great in the past few months, especially with the uptake of OPAM (which
was intended to be the base control plane for future Platform releases,
hence it has support for custom compiler switches and sophisticated
constraints).

-anil

From daniel.buenzli at erratique.ch  Tue Feb 26 11:44:04 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 26 Feb 2013 12:44:04 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <wfd2vohs22.fsf@gmail.com>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
 <Prayer.1.3.5.1302221640250.25215@hermes-1.csi.cam.ac.uk>
 <795AFF51E6A046BFA465D3177EB757CA@erratique.ch>
 <wfd2vohs22.fsf@gmail.com>
Message-ID: <C7CDFED37A54465CB615F8F6AE65D819@erratique.ch>

Le mardi, 26 f?vrier 2013 ? 00:50, Wojciech Meyer a ?crit :
> Given the semantics of OCaml module system, that each module is separate compilation unit

That's not exact. In OCaml each compilation unit is a module (derived from an atomic file) but each module is not a compilation unit.

> All the technical problem of -pack are because modules are not namespaces.
I don't understand this. Modules are namespaces ! They are containers for names and two identical names in two different modules are not deemed equal, that defines a namespace for me. A good deal of the module system is about managing names and their dissemination in the program. Modules are, however, as Yaron points out, much more than that.
  
> In ML world the smallest abstraction available is function, that scale
> up to the level of modules, then we have modules that scale up to the
> library level, and then we have an empty place that we try to structure
> using modules. It would be natural to think that at the library level,
> we should not use modules for abstracting and structuring things.

Well my own *naturalism* leads me to believe that since a good part of modules is about managing names and given their recursive definition (modules can contain modules) I find it natural to try to use them at the library level.  

Daniel

From lpw25 at cam.ac.uk  Tue Feb 26 12:30:15 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 26 Feb 2013 12:30:15 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
 <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
Message-ID: <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>

>That's an interesting take on this.  Would you care to elaborate on
>why a module approach may not be sane?  Is it from a semantic or an
>implementation point of view?

Ignoring the implementation issues for now, consider the run-time semantics 
of the module system.

At run-time a module is a record. Initialising a module involves 
initialising every component of the module and placing them in this record. 
Initialising these components can involve executing arbitrary code; in fact 
the execution of an OCaml program is simply the initialisation of all its 
modules.

The problems with pack are related to these dynamic semantics. In order to 
be a module the "pack" must create a record to represent this module. This 
means that it must initialise all of its components. It is this (rather 
than any detail of pack's implementation) that causes the problems 
identified by Yaron and others.

Now, access to the components of a top-level module could proceed without 
the existence of this record. However, the record is required in order to 
"alias" the module, use the module as a first-class value or use it as the 
argument to a functor.

Any attempt to overcome the problems with pack, whilst still maintaining 
the illusion that the "pack" is a normal module, would result (at the very 
least) in one of the following unhealthy situations:

- The module type of the "pack" module would depend on which of its 
  components were accessed by the program.

- Any use of the "pack" module other than as a simple container 
  (e.g. "module CS = Core.Std") could have a dramatic effect on what was 
  linked into the program and potentially on the semantics of the program.

Namespaces are basically modules that can only be used as a simple 
container. This means that they do not need a corresponding record at 
run-time (or any other run-time representation). This avoids the problems 
with pack as well as enabling other useful features (e.g. open 
definitions).




From lpw25 at cam.ac.uk  Tue Feb 26 12:56:27 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 26 Feb 2013 12:56:27 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBF8tOi7dfuFGsmL4hA7QhfWkskhyr-G3dFeMq2MrDaKqA@mail.gmail.com>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
 <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
 <CAPFanBF8tOi7dfuFGsmL4hA7QhfWkskhyr-G3dFeMq2MrDaKqA@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302261256270.13439@hermes-1.csi.cam.ac.uk>

>I lament that, expect Alain, nobody gives a damn about letting users
>redefine their own names or paths in a different way that what the module
>provider planned for.

I wouldn't say that people don't give a damn about it, only that it is not 
a priority: first we need to be able to give a component the name its 
developer intended for it, then we can worry about how to allow other 
people to rename it.

I also think that it is important that the default case (i.e. use the name 
that the developer gave it) requires no input on the part of the user.


From daniel.buenzli at erratique.ch  Tue Feb 26 13:00:40 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 26 Feb 2013 14:00:40 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
 <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
Message-ID: <FBD7378433A741658B77BD3F9C7B0A40@erratique.ch>

Thanks Leo. For me this is the first clear and argumented explanation of why packs won't work anyways, I'm convinced now. Effectively I don't think we can avoid the unhealthy situations you mention. 

Regarding namespaces, I assume then they don't have any runtime semantics, so you can just see them as a preprocessing step that lengthens the name of a module ? Or do these have other properties ? 

Daniel



From alain.frisch at lexifi.com  Tue Feb 26 13:03:02 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 14:03:02 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
Message-ID: <512CB286.8000501@lexifi.com>

On 02/25/2013 10:53 PM, Yaron Minsky wrote:
> I understand your point Alain, but while what you're saying is
> technically reasonable, I think it doesn't hold together.  When
> programming in the large, it is useful to be able to manipulate the
> namespace and group parts of the world together.

Can you give concrete examples of which manipulations are desired (and why)?

> Many libraries, not
> just Core or Async, want to be able to remap the world by adding a
> collection of related names to the namespace.  The ability to do the
> moral equivalent of:
>
>     open Core.Std
>
> is powerful and important.  Your proposal of having people add
> prefixes to module names does not fit the bill, and the resulting
> system does not, in my opinion, scale.

I believe my proposal covers this use case.  If you depend a lot on a 
specify library which exports many modules, you might indeed want to 
avoid using long names everywhere to access these modules.  That's why I 
propose to give simple ways to alias long modules names to short ones, 
in a way which can be factorized (with external mapping files).

In my proposal, the equivalent of "open Core.Std" would simply be to 
tell the compiler (through a command-line option or with a directive in 
the code) to use a mapping file.  The same can be done within the 
library itself.

Here is a minimalistic version of my proposal, restricted to specifying 
those mapping files on the compiler and tools command-lines.  To make it 
clear that this is only about mapping module references to compiled 
units, let's piggy-back the -I option.  If its argument is a file with a 
.ns suffix and not a directory, the compiler interprets it as a mapping 
file (a sequence of lines of the form "Module_name = 
relative_path_to_compiled_unit", e.g. "List = core_list"), and when this 
-I option is considered during the resolution of a module reference 
(such as "List") and the module is defined in the file, the compiler 
simply resolves the module to the corresponding unit.

This approach could also be used to restrict which units are visible by 
the compiler (and avoid repeated lookup on the file system) without 
moving files around on the file system.

ocamldep (without -modules) would apply the same logic; ocamldep 
-modules could either implement the same logic, or leave it to the build 
system interpreting its output (allowing more dynamic scenarios where 
the mapping file themselves are generated).  I expect ocamldoc to work 
mostly out-of-the-box, even though one could think about using the 
mapping files (in reverse direction) to provide shorter names in the 
generated documentation (or not).

Users of a library are never forced to use the mapping files, and they 
can always refer to a module with its full name (provided the 
corresponding -I <path> is used).

The OCaml stdlib would be adapted to use longer names (stdlib_list, 
stdlib_array, etc) and shipped with a stdlib.ns file opened by default 
(unless -nostdlib is used).  To be clear: this mapping file will be used 
by the stdlib itself, so references within itself don't need to use long 
names.

I'm interested to see concrete examples of manipulation or scenarios 
not be covered by this proposal.


Alain

From yminsky at janestreet.com  Tue Feb 26 13:49:32 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 08:49:32 -0500
Subject: [ocaml-platform] Fwd: Is this mandatory to continue this
 discussion [was: on the need and design of OCaml namespaces]
In-Reply-To: <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
Message-ID: <CACLX4jSTDqtvuT=RW6oLufQ0Lv5rSbME_Vt7k+UrAncuLrj4tQ@mail.gmail.com>

Not to pile on, but I think voting is a terrible idea.  I can't
imagine Xavier paying any attention to the results of such a poll, nor
should he.  The currency we need here is thoughtful designs and
arguments, not head-counts.

On Tue, Feb 26, 2013 at 5:26 AM, Sylvain Le Gall
<sylvain+ocaml at le-gall.net> wrote:
> As you started this discussion and you write a nice summary in your
> last email, can you setup a vote form?
>
> The most simple way is to use a Google Form. If you don't feel
> confident, send me the text of each proposal (like the proposals I
> write in the forwarded email) + link to your summary + relevant post
> (a la weekly ocaml news) and I will setup a form for you.
>
> I think it would be even better that all proposal get an implementor
> name attached to it, so we know who will be in charge of the next
> action...
>
> Regards
> Sylvain
>
>
>
> ---------- Forwarded message ----------
> From: Alain Frisch <alain.frisch at lexifi.com>
> Date: 2013/2/26
> Subject: Re: [ocaml-platform] Is this mandatory to continue this
> discussion [was: on the need and design of OCaml namespaces]
> To: Sylvain Le Gall <sylvain+ocaml at le-gall.net>
> Cc : Wojciech Meyer <wojciech.meyer at gmail.com>, Didier Remy
> <didier.remy at inria.fr>, "platform at lists.ocaml.org"
> <platform at lists.ocaml.org>
>
>
> On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
>>
>> My 2nd take on this:
>> Put this to vote !
>> With the following proposals:
>> A. Implement rich namespace
>> B. Implement simple flat namespace
>> C. Fix -pack issue rather than implementing namespace
>> D. Postpone discussion
>
>
> E. Advertize a naming convention for modules to avoid clashes, and
> provide very light support in the language/compiler/tools to reduce
> the syntactic overhead of using long names for users of "standard
> libraries".
>
>
> Alain
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From lpw25 at cam.ac.uk  Tue Feb 26 13:53:20 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 26 Feb 2013 13:53:20 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <FBD7378433A741658B77BD3F9C7B0A40@erratique.ch>
References: <1895576076.3023042.1361569885728.JavaMail.root@inria.fr>
 <D1C7B5EE824649E5AB38BE711F3E6AC2@erratique.ch>
 <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
 <FBD7378433A741658B77BD3F9C7B0A40@erratique.ch>
Message-ID: <Prayer.1.3.5.1302261353200.24363@hermes-1.csi.cam.ac.uk>

> Regarding namespaces, I assume then they don't have any runtime 
> semantics, so you can just see them as a preprocessing step that 
> lengthens the name of a module ?

Yes, they are a purely compile-time construct.

From Didier.Remy at inria.fr  Tue Feb 26 14:10:58 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Tue, 26 Feb 2013 15:10:58 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <C7CDFED37A54465CB615F8F6AE65D819@erratique.ch>
References: <CAPFanBEwD8c24X1YB-SK4VV-sqqRfOnKkqqAA1sccPORDgTYoA@mail.gmail.com>
 <CAOg1smD3Kqk0oCMqtTnz5s-i+ULBuF_qtfSYoeqsiMSMAOEgLQ@mail.gmail.com>
 <26A79AAC440040AE9B9EBA48C00BBD2D@erratique.ch>
 <Prayer.1.3.5.1302221640250.25215@hermes-1.csi.cam.ac.uk>
 <795AFF51E6A046BFA465D3177EB757CA@erratique.ch> <wfd2vohs22.fsf@gmail.com>
 <C7CDFED37A54465CB615F8F6AE65D819@erratique.ch>
Message-ID: <512CC272.8010707@inria.fr>


> Modules are namespaces !

I think that this assertion is misleading (and wrong), as it confuses the
word "namespaces" that refers to a specific proposal that could be called
"foo" and the intuitive meaning of namespaces that refers to expression
"name management".  In the later sense, yes modules are doing some form of name
management. But in the former sense, no, modules are not doing the same kind
of name management as foo (namespaces).

>    They are containers for names and two identical names in two different
>    modules are not deemed equal, that defines a namespace for me. A good
>    deal of the module system is about managing names and their
>    dissemination in the program. Modules are, however, as Yaron points
>    out, much more than that.

Yes, there are similarities:

  - modules manage _internal_ names: names of values, names of types, and
    names of submodules.  They manage names of objects visible in the OCaml
    world.  They cannot speak about the outer world and of course not manage
    it.

  - namespaces manage names of toplevel modules, of collections of modules.
    They connect the outer world (files in the environment) with the inner
    world of OCaml, but cannot see the the world of OCaml. Modules are
    atomic/opaque objects for namespaces.

So they are similarities, but already some significant differences when just
comparing them in terms of name manipulation.

Moreover, as you noticed, modules do a lot more, and do so simultaneously:
they manage types, generativity, consistency of imports, keep the objects
closed, etc.  Because of this additional invariants in module objects, there
are operations that modules cannot do with names that namespaces can do.
For instance, modules cannot insert a new submodule inside an existing
module, or pick a module from a submodule to and rebuild a new module from
the component outside of its original context/closure: this could break
types, abstraction, (and bindings!)---unless you change the way modules are
typechecked, e.g. using mixin modules to keep track of some internal
dependencies make a difference between before/after linking status.

Namespaces can do almost arbitrary manipulations of toplevel modules and
collection of modules, because they see modules as atomic/opaque objects and
cannot change them.  If namespaces mess up with module names the compiler
and linker may pick the wrong objects but it will catch up those mistakes
because module objects are checked against module objects independently of
the names that were used to pick them.

So the rigid name manipulation of modules with strong invariants combined
with the arbirtrary name manipulation of namespaces remains sound---and with
a clear semantics.

Modules are a very sophisticated concept (think of their meta-theory).
Namespaces are a very trivial concept (trivial tree manipulation).

The complexity of Modules + Namespaces is just the max of the two, that is
the complexity of Modules. Namespaces do not add complexity.

So, I think that the separation of concerns is quite healthly here.  Each
concept can do powerful but different sorts of things in its own world
and the combination remains simple, because they is a clear separation.

> Well my own *naturalism* leads me to believe that since a good part of
> modules is about managing names and given their recursive definition
> (modules can contain modules) I find it natural to try to use them at the
> library level.

I am not sure what you mean by *naturalism*.  Keeping a minimal set of
orthogonal features is probably something to seek for in the design of a
programming language.

So if namespaces were modules, they should not be added, but they are
an orthogonal concept.

If you wished to mix the power of modules and namespaces together as a
single concept, you probably need something like mixin modules (that can
reason about open modules and linking) whose metatheory is even harder than
that of modules plus an additional mechanism to be able to keep track in
mixins of which components can be stripped off at link time.

So *minimalism* in this situation is probably to keep two separate concepts.
At least, this is feasible in the short term.  The mixin approach may
perhaps be superior in the long term, but it cannot be a short term goal.

Besides, namespaces is not a new concept. They already exists in OCaml in a
trivial way, via the canonical mapping of the external file name in which a
module and its interface are implemented and the internal OCaml name of the
module object, plus the search path in which OCaml looks for module objects
to build its initial namespace.

This design choice was an excellent choice in the early days of OCaml when
applications were small and the focus was more on the power of the module
language than on dealing with a large industrial community of users.

Today, this choice shows its limitations.

The proposal is just to relax this rigid rule for building the initial
namespace (i.e. mapping from external file names to internal module
objects).  At the same time, using a tree-like structure rather than a flat
structure would allow for even more flexibility, but conceptually, it is not
significantly different from the flat map.

     Didier

From yminsky at janestreet.com  Tue Feb 26 14:16:09 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 09:16:09 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302261256270.13439@hermes-1.csi.cam.ac.uk>
References: <CAOCAUGOqpDFMZskiWPZUxHe_MemvhfeYavR0T+cH_x54jhE5Ow@mail.gmail.com>
 <6D85F244DC034986B1C25DDDD58E67A1@erratique.ch>
 <6AD05A74-10B1-4595-A7B3-55DC9F17B4C4@recoil.org>
 <20130224.202645.58166825296111937.Christophe.Troestler@umons.ac.be>
 <F87EDE23-AF15-437C-B64E-8EFCD75A4E79@recoil.org>
 <CAPFanBF8tOi7dfuFGsmL4hA7QhfWkskhyr-G3dFeMq2MrDaKqA@mail.gmail.com>
 <Prayer.1.3.5.1302261256270.13439@hermes-1.csi.cam.ac.uk>
Message-ID: <CACLX4jTFbs70XWkjBrZ3JN_AN58frf7GAORtoWW8c=fYrkDTcg@mail.gmail.com>

On Tue, Feb 26, 2013 at 7:56 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> I lament that, expect Alain, nobody gives a damn about letting users
>> redefine their own names or paths in a different way that what the module
>> provider planned for.
>
>
> I wouldn't say that people don't give a damn about it, only that it is not a
> priority: first we need to be able to give a component the name its
> developer intended for it, then we can worry about how to allow other people
> to rename it.
>
> I also think that it is important that the default case (i.e. use the name
> that the developer gave it) requires no input on the part of the user.

I agree.  I would like to let users flexibly redefine namespaces, and
to have multiple namespaces for the same modules.  One example of the
use of this that I'd have in Core is Core.Std and Core.Stable.

Core.Std is the standard thing you open if you want to use Core in the
ordinary way.  Nothing to see here.

Core.Stable exports just a subset of Core, in particular, a set of
so-called "stable" types that are guaranteed not to change from
release to release.  (there are explicit version numbers attached to
these to allow new versions to be minted without changing the old.)
This is useful for building protocols that OCaml programs can
communicate with even when they're built with different versions of
Core.

It would be ideal if the namespace proposal supported this use case,
and once it does, well, it seems like you almost need to have the
flexibility you describe.

From yminsky at janestreet.com  Tue Feb 26 14:30:50 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 09:30:50 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CB286.8000501@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
Message-ID: <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>

On Tue, Feb 26, 2013 at 8:03 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/25/2013 10:53 PM, Yaron Minsky wrote:
>>
>> I understand your point Alain, but while what you're saying is
>> technically reasonable, I think it doesn't hold together.  When
>> programming in the large, it is useful to be able to manipulate the
>> namespace and group parts of the world together.
>
> Can you give concrete examples of which manipulations are desired (and why)?

I think the conversation has gotten confused.  You said "who needs
pack?  Just use hierarchically named modules".  I'm saying: that's
crazy, you need to be able to do simple manipulations of namespaces
(like the ones implied by "open Core.Std" or "open Core.Stable".)

Now you're pointing out that your namespace proposal covers the
manipulations I'm describing.  That may well be right, and I wasn't
contesting that point.

All I'm saying is that simply relying on long module names without any
kind of explicit namespace control does not scale.  I stand by that,
without necessarily objecting to your namespace proposal.

>> Many libraries, not
>> just Core or Async, want to be able to remap the world by adding a
>> collection of related names to the namespace.  The ability to do the
>> moral equivalent of:
>>
>>     open Core.Std
>>
>> is powerful and important.  Your proposal of having people add
>> prefixes to module names does not fit the bill, and the resulting
>> system does not, in my opinion, scale.
>
>
> I believe my proposal covers this use case.  If you depend a lot on a
> specify library which exports many modules, you might indeed want to avoid
> using long names everywhere to access these modules.  That's why I propose
> to give simple ways to alias long modules names to short ones, in a way
> which can be factorized (with external mapping files).
>
> In my proposal, the equivalent of "open Core.Std" would simply be to tell
> the compiler (through a command-line option or with a directive in the code)
> to use a mapping file.  The same can be done within the library itself.
>
> Here is a minimalistic version of my proposal, restricted to specifying
> those mapping files on the compiler and tools command-lines.  To make it
> clear that this is only about mapping module references to compiled units,
> let's piggy-back the -I option.  If its argument is a file with a .ns suffix
> and not a directory, the compiler interprets it as a mapping file (a
> sequence of lines of the form "Module_name =
> relative_path_to_compiled_unit", e.g. "List = core_list"), and when this -I
> option is considered during the resolution of a module reference (such as
> "List") and the module is defined in the file, the compiler simply resolves
> the module to the corresponding unit.
>
> This approach could also be used to restrict which units are visible by the
> compiler (and avoid repeated lookup on the file system) without moving files
> around on the file system.
>
> ocamldep (without -modules) would apply the same logic; ocamldep -modules
> could either implement the same logic, or leave it to the build system
> interpreting its output (allowing more dynamic scenarios where the mapping
> file themselves are generated).  I expect ocamldoc to work mostly
> out-of-the-box, even though one could think about using the mapping files
> (in reverse direction) to provide shorter names in the generated
> documentation (or not).
>
> Users of a library are never forced to use the mapping files, and they can
> always refer to a module with its full name (provided the corresponding -I
> <path> is used).
>
> The OCaml stdlib would be adapted to use longer names (stdlib_list,
> stdlib_array, etc) and shipped with a stdlib.ns file opened by default
> (unless -nostdlib is used).  To be clear: this mapping file will be used by
> the stdlib itself, so references within itself don't need to use long names.
>
> I'm interested to see concrete examples of manipulation or scenarios not be
> covered by this proposal.

I am unaware of any.  I think this does mostly support the
Core.Std/Core.Stable tricks we use.

One thing I'll say is that it is important to be able to add values,
and not just modules, to the namespace.  Open Core.Std also adds
top-level values, as does the traditional standard library (i.e.,
Pervasives), and I don't want to lose that.

y

From sylvain+ocaml at le-gall.net  Tue Feb 26 14:32:07 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Tue, 26 Feb 2013 15:32:07 +0100
Subject: [ocaml-platform] Fwd: Is this mandatory to continue this
 discussion [was: on the need and design of OCaml namespaces]
In-Reply-To: <CACLX4jSTDqtvuT=RW6oLufQ0Lv5rSbME_Vt7k+UrAncuLrj4tQ@mail.gmail.com>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
 <CACLX4jSTDqtvuT=RW6oLufQ0Lv5rSbME_Vt7k+UrAncuLrj4tQ@mail.gmail.com>
Message-ID: <CAOCAUGMUxS39xndKzkfQUqWncGZsnDOXkbCA362q0aZMUVJBJg@mail.gmail.com>

2013/2/26 Yaron Minsky <yminsky at janestreet.com>:
> Not to pile on, but I think voting is a terrible idea.  I can't
> imagine Xavier paying any attention to the results of such a poll, nor
> should he.  The currency we need here is thoughtful designs and
> arguments, not head-counts.
>

As said before, I give up. No voting. That was just an idea (which has
made a lot of people react -- at least it defines what people don't
want).

Although, we should consider adopting a kind of framework like DEP
(http://dep.debian.net/), which can bring stricter rules and better
view on this kind of discussion (and a website to publish the kind of
roundups Gabriel has done).

As mentionned before, this was more about getting an actionnable item
than convincing Xavier. I agree with you that voting is not of
particular interest in this case.

> On Tue, Feb 26, 2013 at 5:26 AM, Sylvain Le Gall
> <sylvain+ocaml at le-gall.net> wrote:
>> As you started this discussion and you write a nice summary in your
>> last email, can you setup a vote form?
>>
>> The most simple way is to use a Google Form. If you don't feel
>> confident, send me the text of each proposal (like the proposals I
>> write in the forwarded email) + link to your summary + relevant post
>> (a la weekly ocaml news) and I will setup a form for you.
>>
>> I think it would be even better that all proposal get an implementor
>> name attached to it, so we know who will be in charge of the next
>> action...
>>
>> Regards
>> Sylvain
>>
>>
>>
>> ---------- Forwarded message ----------
>> From: Alain Frisch <alain.frisch at lexifi.com>
>> Date: 2013/2/26
>> Subject: Re: [ocaml-platform] Is this mandatory to continue this
>> discussion [was: on the need and design of OCaml namespaces]
>> To: Sylvain Le Gall <sylvain+ocaml at le-gall.net>
>> Cc : Wojciech Meyer <wojciech.meyer at gmail.com>, Didier Remy
>> <didier.remy at inria.fr>, "platform at lists.ocaml.org"
>> <platform at lists.ocaml.org>
>>
>>
>> On 02/26/2013 01:11 AM, Sylvain Le Gall wrote:
>>>
>>> My 2nd take on this:
>>> Put this to vote !
>>> With the following proposals:
>>> A. Implement rich namespace
>>> B. Implement simple flat namespace
>>> C. Fix -pack issue rather than implementing namespace
>>> D. Postpone discussion
>>
>>
>> E. Advertize a naming convention for modules to avoid clashes, and
>> provide very light support in the language/compiler/tools to reduce
>> the syntactic overhead of using long names for users of "standard
>> libraries".
>>
>>
>> Alain
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Tue Feb 26 14:38:23 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 09:38:23 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
Message-ID: <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>

Leo, do you have a summary of what you don't like about Alain's
namespace proposal?  I'm not presently able to identify any obvious
weaknesses in it.  The downsides I see are:

- UNSANITARY: Having both "open namespace Core.Std" and Core_List as
  names seems a little unsanity.  Indeed, to provide a decent user
  experience, you probably want to hide the Core_List name almost
  everywhere.  You don't want it showing up in error messages,
  documentation, source files, etc.  When you need to do a bunch of
  work to hide something, maybe it's better not to include it at all.

- NO HIDING: I'm not sure that the other namespace proposals do
  support this, but I'd like to be able to hide some modules so that
  they are not reachable outside of the namespace.  We can do this
  with the current Core.Std, but I don't see how to do it in Alain's
  proposal.

Are there other issues I'm missing?

y

On Tue, Feb 26, 2013 at 9:30 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Tue, Feb 26, 2013 at 8:03 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> On 02/25/2013 10:53 PM, Yaron Minsky wrote:
>>>
>>> I understand your point Alain, but while what you're saying is
>>> technically reasonable, I think it doesn't hold together.  When
>>> programming in the large, it is useful to be able to manipulate the
>>> namespace and group parts of the world together.
>>
>> Can you give concrete examples of which manipulations are desired (and why)?
>
> I think the conversation has gotten confused.  You said "who needs
> pack?  Just use hierarchically named modules".  I'm saying: that's
> crazy, you need to be able to do simple manipulations of namespaces
> (like the ones implied by "open Core.Std" or "open Core.Stable".)
>
> Now you're pointing out that your namespace proposal covers the
> manipulations I'm describing.  That may well be right, and I wasn't
> contesting that point.
>
> All I'm saying is that simply relying on long module names without any
> kind of explicit namespace control does not scale.  I stand by that,
> without necessarily objecting to your namespace proposal.
>
>>> Many libraries, not
>>> just Core or Async, want to be able to remap the world by adding a
>>> collection of related names to the namespace.  The ability to do the
>>> moral equivalent of:
>>>
>>>     open Core.Std
>>>
>>> is powerful and important.  Your proposal of having people add
>>> prefixes to module names does not fit the bill, and the resulting
>>> system does not, in my opinion, scale.
>>
>>
>> I believe my proposal covers this use case.  If you depend a lot on a
>> specify library which exports many modules, you might indeed want to avoid
>> using long names everywhere to access these modules.  That's why I propose
>> to give simple ways to alias long modules names to short ones, in a way
>> which can be factorized (with external mapping files).
>>
>> In my proposal, the equivalent of "open Core.Std" would simply be to tell
>> the compiler (through a command-line option or with a directive in the code)
>> to use a mapping file.  The same can be done within the library itself.
>>
>> Here is a minimalistic version of my proposal, restricted to specifying
>> those mapping files on the compiler and tools command-lines.  To make it
>> clear that this is only about mapping module references to compiled units,
>> let's piggy-back the -I option.  If its argument is a file with a .ns suffix
>> and not a directory, the compiler interprets it as a mapping file (a
>> sequence of lines of the form "Module_name =
>> relative_path_to_compiled_unit", e.g. "List = core_list"), and when this -I
>> option is considered during the resolution of a module reference (such as
>> "List") and the module is defined in the file, the compiler simply resolves
>> the module to the corresponding unit.
>>
>> This approach could also be used to restrict which units are visible by the
>> compiler (and avoid repeated lookup on the file system) without moving files
>> around on the file system.
>>
>> ocamldep (without -modules) would apply the same logic; ocamldep -modules
>> could either implement the same logic, or leave it to the build system
>> interpreting its output (allowing more dynamic scenarios where the mapping
>> file themselves are generated).  I expect ocamldoc to work mostly
>> out-of-the-box, even though one could think about using the mapping files
>> (in reverse direction) to provide shorter names in the generated
>> documentation (or not).
>>
>> Users of a library are never forced to use the mapping files, and they can
>> always refer to a module with its full name (provided the corresponding -I
>> <path> is used).
>>
>> The OCaml stdlib would be adapted to use longer names (stdlib_list,
>> stdlib_array, etc) and shipped with a stdlib.ns file opened by default
>> (unless -nostdlib is used).  To be clear: this mapping file will be used by
>> the stdlib itself, so references within itself don't need to use long names.
>>
>> I'm interested to see concrete examples of manipulation or scenarios not be
>> covered by this proposal.
>
> I am unaware of any.  I think this does mostly support the
> Core.Std/Core.Stable tricks we use.
>
> One thing I'll say is that it is important to be able to add values,
> and not just modules, to the namespace.  Open Core.Std also adds
> top-level values, as does the traditional standard library (i.e.,
> Pervasives), and I don't want to lose that.
>
> y

From Didier.Remy at inria.fr  Tue Feb 26 14:59:08 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Tue, 26 Feb 2013 15:59:08 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
Message-ID: <512CCDBC.8040405@inria.fr>

> One thing I'll say is that it is important to be able to add values,
> and not just modules, to the namespace.  Open Core.Std also adds
> top-level values, as does the traditional standard library (i.e.,
> Pervasives), and I don't want to lose that.

Yaron,

Do you really need this level of granularity?  I'd like to think of
modules as the smallest compilation unit.  Can you give us examples of what
you'd like to do with value manipulation?

     Didier

From gabriel.scherer at gmail.com  Tue Feb 26 15:12:04 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 26 Feb 2013 16:12:04 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
Message-ID: <CAPFanBGVrCei_tZdkxroHG3wJ6G+D3OmW_9LL_x5wpsNMnc0Dg@mail.gmail.com>

Yaron Minsky <yminsky at janestreet.com> wrote:
> One thing I'll say is that it is important to be able to add values,
> and not just modules, to the namespace.  Open Core.Std also adds
> top-level values, as does the traditional standard library (i.e.,
> Pervasives), and I don't want to lose that.

This is handled as a "bonus feature" discussed in
http://gallium.inria.fr/~scherer/namespaces/pack_et_functor_pack.html
, under the name "flat access". The idea is that adding values to
namespaces directly doesn't work very well (in OCaml, values cannot
live outside a compilation unit), but you can have some modules that
will be explicitly opened if you open the namespace (or included if
you use it as a module). However, we're not yet sure that this works
as well as the other aspects of the design, and would recommend
starting without it to get a feel of the system.

On Tue, Feb 26, 2013 at 3:38 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Leo, do you have a summary of what you don't like about Alain's
> namespace proposal?  I'm not presently able to identify any obvious
> weaknesses in it.  The downsides I see are:
>
> - UNSANITARY: Having both "open namespace Core.Std" and Core_List as
>   names seems a little unsanity.  Indeed, to provide a decent user
>   experience, you probably want to hide the Core_List name almost
>   everywhere.  You don't want it showing up in error messages,
>   documentation, source files, etc.  When you need to do a bunch of
>   work to hide something, maybe it's better not to include it at all.

I want to point out that Alain's idea of using long, hopefully-unique
names for the source files, that you deem "unsanitary" here, is also a
workaround for the problem of internal name conflict. In Alain's
proposal, internal names conflicts are (hopfeully) avoided with no
implementation change, just by judicious name choices and letting the
implementation do its work. This imposes this "unsanitary" aspect you
mention, but it is a complexity tradeoff: the other alternative would
be to design a more clever implementation to choose internal names
(than the module's source filename), which could be hidden from the
user (no exposed Core_List) but require an implementation change. I
think that could warrant an exploration (because it could support use
cases such as linking together two versions of the same library, which
isn't possible with a purely filename-based solution), but in the
context Alain's proposal this "unsanitary" aspect has more advantages
than downsides.

> - NO HIDING: I'm not sure that the other namespace proposals do
>   support this, but I'd like to be able to hide some modules so that
>   they are not reachable outside of the namespace.  We can do this
>   with the current Core.Std, but I don't see how to do it in Alain's
>   proposal.

I'm surprised by this "hiding" idea. What does it mean, and what would
be an use case for that?

> Are there other issues I'm missing?

My gut feeling is that a hierarchical model would add little
complexity to Alain's proposal and give a saner semantics to "open
namespace". With a flat model there can be no real notion of "open
namespace", only handcrafted renamings en masse (Core_list -> List,
Core_array -> Array...). (On the other hand "open namespace", if they
are done at the source level, are a source language change, while none
are necessary so far, so they will require more work to handle in any
case.)

There is the problem of internal name conflicts, but that is one of
the more "advanced" questions that may be left out of a first
experiment.

When deciding to leave out some questions for later, it is however
important to wonder whether we're sure that we will actually be able
to extend the design to support them. Some early design choices may
make future extensions harder (without breaking compatibility). One
solution is to make a coherent design that covers advanced features,
and decide to implement only a subset. One other is to try to guess
what will be easy to add afterwards, and be lucky. Finally, one can
experiment with a first design and move to another, but without
committing to backward compatibility (meaning no language release
between the two design iterations).

My personal guess is that
- "flat access" will be easy an easy extension.
- "hierarchical rather than flat mappings" will be relatively easy in
theory but make a painful transition period for providers that have
modules organized flatly and desire to change; but it depends on a
question of "seeing non-leaf namespaces as modules" that Alain's flat
namespaces don't need to consider.
- "extending the mapping description language" must be planned for
beforehand to avoid growing pains.
- "finer implementation of internal names to avoid linking conflicts"
is yet of unknown difficulty, either today and after any first
proposal not tackling this aspect is acted upon.

>
> y
>
> On Tue, Feb 26, 2013 at 9:30 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> On Tue, Feb 26, 2013 at 8:03 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>> On 02/25/2013 10:53 PM, Yaron Minsky wrote:
>>>>
>>>> I understand your point Alain, but while what you're saying is
>>>> technically reasonable, I think it doesn't hold together.  When
>>>> programming in the large, it is useful to be able to manipulate the
>>>> namespace and group parts of the world together.
>>>
>>> Can you give concrete examples of which manipulations are desired (and why)?
>>
>> I think the conversation has gotten confused.  You said "who needs
>> pack?  Just use hierarchically named modules".  I'm saying: that's
>> crazy, you need to be able to do simple manipulations of namespaces
>> (like the ones implied by "open Core.Std" or "open Core.Stable".)
>>
>> Now you're pointing out that your namespace proposal covers the
>> manipulations I'm describing.  That may well be right, and I wasn't
>> contesting that point.
>>
>> All I'm saying is that simply relying on long module names without any
>> kind of explicit namespace control does not scale.  I stand by that,
>> without necessarily objecting to your namespace proposal.
>>
>>>> Many libraries, not
>>>> just Core or Async, want to be able to remap the world by adding a
>>>> collection of related names to the namespace.  The ability to do the
>>>> moral equivalent of:
>>>>
>>>>     open Core.Std
>>>>
>>>> is powerful and important.  Your proposal of having people add
>>>> prefixes to module names does not fit the bill, and the resulting
>>>> system does not, in my opinion, scale.
>>>
>>>
>>> I believe my proposal covers this use case.  If you depend a lot on a
>>> specify library which exports many modules, you might indeed want to avoid
>>> using long names everywhere to access these modules.  That's why I propose
>>> to give simple ways to alias long modules names to short ones, in a way
>>> which can be factorized (with external mapping files).
>>>
>>> In my proposal, the equivalent of "open Core.Std" would simply be to tell
>>> the compiler (through a command-line option or with a directive in the code)
>>> to use a mapping file.  The same can be done within the library itself.
>>>
>>> Here is a minimalistic version of my proposal, restricted to specifying
>>> those mapping files on the compiler and tools command-lines.  To make it
>>> clear that this is only about mapping module references to compiled units,
>>> let's piggy-back the -I option.  If its argument is a file with a .ns suffix
>>> and not a directory, the compiler interprets it as a mapping file (a
>>> sequence of lines of the form "Module_name =
>>> relative_path_to_compiled_unit", e.g. "List = core_list"), and when this -I
>>> option is considered during the resolution of a module reference (such as
>>> "List") and the module is defined in the file, the compiler simply resolves
>>> the module to the corresponding unit.
>>>
>>> This approach could also be used to restrict which units are visible by the
>>> compiler (and avoid repeated lookup on the file system) without moving files
>>> around on the file system.
>>>
>>> ocamldep (without -modules) would apply the same logic; ocamldep -modules
>>> could either implement the same logic, or leave it to the build system
>>> interpreting its output (allowing more dynamic scenarios where the mapping
>>> file themselves are generated).  I expect ocamldoc to work mostly
>>> out-of-the-box, even though one could think about using the mapping files
>>> (in reverse direction) to provide shorter names in the generated
>>> documentation (or not).
>>>
>>> Users of a library are never forced to use the mapping files, and they can
>>> always refer to a module with its full name (provided the corresponding -I
>>> <path> is used).
>>>
>>> The OCaml stdlib would be adapted to use longer names (stdlib_list,
>>> stdlib_array, etc) and shipped with a stdlib.ns file opened by default
>>> (unless -nostdlib is used).  To be clear: this mapping file will be used by
>>> the stdlib itself, so references within itself don't need to use long names.
>>>
>>> I'm interested to see concrete examples of manipulation or scenarios not be
>>> covered by this proposal.
>>
>> I am unaware of any.  I think this does mostly support the
>> Core.Std/Core.Stable tricks we use.
>>
>> One thing I'll say is that it is important to be able to add values,
>> and not just modules, to the namespace.  Open Core.Std also adds
>> top-level values, as does the traditional standard library (i.e.,
>> Pervasives), and I don't want to lose that.
>>
>> y
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Tue Feb 26 15:28:18 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 16:28:18 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
Message-ID: <512CD492.8070204@lexifi.com>

On 02/26/2013 03:38 PM, Yaron Minsky wrote:
> - UNSANITARY: Having both "open namespace Core.Std" and Core_List as
>    names seems a little unsanity.  Indeed, to provide a decent user
>    experience, you probably want to hide the Core_List name almost
>    everywhere.  You don't want it showing up in error messages,
>    documentation, source files, etc.  When you need to do a bunch of
>    work to hide something, maybe it's better not to include it at all.

Concretly, what should the OCamldoc-generated page for a Core module 
look like?  Should the reference to types defined in other Core modules 
be displayed without any indication that they come from Core (without 
clicking on it)?  I would find this very confusing.  Similarly for error 
messages: it is indeed nice to be able to see List instead of Core_list 
when you live with Core all you day long and there is no ambiguity. 
Still, there needs to be a way to have a more explicit error message, 
which could distinguish Stdlib_list from Core_list.  For me, seeing List 
instead Core_list in "common cases" is only nice to have (and definitely 
achievable with a little more effort in my proposal), but being able to 
distinguish Core_list from Stdlib_lib is crucial.  (And I don't think 
that showing Core#List is nicer than Core_list, at least not enough to 
justify the addition of a new notion.)

Having long unique names which can be used in any context is a very good 
property and would also avoid problems reported with camlp4 extensions 
not being able to access a specific "standard" module.  If we can use 
Stdlib_list in any context, we don't need to do any hack to refer to it.

> - NO HIDING: I'm not sure that the other namespace proposals do
>    support this, but I'd like to be able to hide some modules so that
>    they are not reachable outside of the namespace.  We can do this
>    with the current Core.Std, but I don't see how to do it in Alain's
>    proposal.

If the library does not install the .cmi file of the private module, it 
cannot be accessed by any "client code".  We do this regularly for our 
internal libraries.  For me, this is not really related to namespaces.

With my proposal, it is even better: you can install .cmi files so that 
some "privileged" parts of your code base can still access it, but also 
restrict access to other parts by providing a mapping file which does 
not alias the private module (and just arrange so that you don't have a 
-I on the directory where the .cmi is installed).  Currently, what we do 
to achieve it is to have several install directories for some libraries 
and copy a different subset of .cmi files to each of them.


Alain

From alain.frisch at lexifi.com  Tue Feb 26 15:38:52 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 16:38:52 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
Message-ID: <512CD70C.2000105@lexifi.com>

On 02/26/2013 03:30 PM, Yaron Minsky wrote:
> One thing I'll say is that it is important to be able to add values,
> and not just modules, to the namespace.  Open Core.Std also adds
> top-level values, as does the traditional standard library (i.e.,
> Pervasives), and I don't want to lose that.

I can understand that this is nice, but is it really important?

Concretely, we are talking about the necessity to add an extra "open 
Core_std" statement in addition to the namespace opening statement (or a 
corresponding command-line option).  Does this extra open statement 
justify to make concepts less orthogonal?

My "flat mapping" proposal could be extended to support "implicit opens" 
in the same mapping files (in addition to lines like "List = core_list", 
we could have "open Core_std" lines).  I don't think it is a good idea 
to do so, however (and it would require to have two versions of the 
mapping file, one to be used inside the implementation of Core itself 
and another one for client code -- without the open statement).  We 
could also let the user specify implicit opens on the command-line, so 
as to push the problem to the build system or ocamlfind.  Again, I'm not 
sure this is a great idea to do so, but at least, it would make it clear 
that this feature is not related to the module naming system.


Alain

From daniel.buenzli at erratique.ch  Tue Feb 26 15:40:53 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 26 Feb 2013 16:40:53 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CCDBC.8040405@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
Message-ID: <57266456531B41AC848B403A47E6390C@erratique.ch>

Le mardi, 26 f?vrier 2013 ? 15:59, Didier Remy a ?crit :
> Do you really need this level of granularity? I'd like to think of
> modules as the smallest compilation unit. Can you give us examples of what
> you'd like to do with value manipulation?

I have a (yet unreleased) library that provides basic types for computer graphics (vectors, matrices, sizes, quaternions, colors, boxes). I manually "packed" it as follows:

module Gg = struct
  module Float sig ? end

  type m2  
  type m3  
  type m4

  (* Vectors *)
  type v2
  type v3
  type v4
  module type V (* implemented by all vector types *)
  module V2 : sig type t = v2 ? end
  module V3 : sig type t = v3 ? end
  module V4 : sig type t = v4 ? end

  (* Points *)
  type p2 = v2
  type p3 = v3  
  module type P = sig ? end (* implemented by all point types *)
  module P2 : sig type t = p2 ? end
  module P3 : sig type t = p3 ? end

  (* Matrices *)
  module type M = sig ? end (* implemented by all matrix types *)
  module M2 : sig type t = m2 ? end
  module M3 : sig type t = m3 ... end  
  module M4 : sig type t = m4 ? end

  (* Quaternions *)
  type quat = v4  
  module Quat : sig ? end

  (* Sizes *)  
  type size2 = v2  
  type size3 = v3  
  module Size2 = sig ... end
  module Size3 = sig ? end

  (* Boxes *)
  ...

end

The idea was that people using the library would do an  

open Gg;;

at the top of their source. Now I would gladly replace that Gg with a namespace to maybe benefit of smaller executables (e.g. a 2D program that only uses V2, P2, M2). However at toplevel there are quite a few things that are not modules.  

1) Module types. These are mainly here to be able to functorize code over multiple dimensions.

2) Types. Are there for various reasons, first to avoid recursive module definition. Second so that printing of errors in the toplevel and by the compiler do not become long-winded/and or unreadable (e.g. print Gg.size2, Gg.v2 instead of Gg.Size2.t, Gg.V2.t).

3) (Values. I don't do that anymore but initially I also had value constructors for the types but I pushed these back into modules so that the open Gg guarantees you that no value is added to your environment, only types and modules are defined).  

So I guess in that case namespaces won't be of any help since only modules can be attached to them. The obvious solution would then to define all top level types maybe in a Gg.Types module, but I'd loose the short printing of type names and need to introduce artificial modules (Gg.Types).  

Daniel






From yminsky at janestreet.com  Tue Feb 26 15:43:57 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 10:43:57 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CCDBC.8040405@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
Message-ID: <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>

On Tue, Feb 26, 2013 at 9:59 AM, Didier Remy <Didier.Remy at inria.fr> wrote:
>> One thing I'll say is that it is important to be able to add values,
>> and not just modules, to the namespace.  Open Core.Std also adds
>> top-level values, as does the traditional standard library (i.e.,
>> Pervasives), and I don't want to lose that.
>
> Yaron,
>
> Do you really need this level of granularity?  I'd like to think of
> modules as the smallest compilation unit.  Can you give us examples of what
> you'd like to do with value manipulation?

I think we do.  What we want is essentially the same thing that we
need to do when OCaml opens Pervasives by default.  We simply have
another module that we wish to open by default.

There are two reasons for this: the first is to open at the top-level
some constructors and values that are very commonly useful.  Much as
pervasives has None and Some from option available everywhere, we have
Ok and Error from Result.t available everywhere.

Another reason is to shadow values from other modules.  Core.Std hides
various values from Pervasives that we view as harmful.  For example,
we hide ==, and instead expose phys_equal.  (We think == is too
confusing to people from other languages.)

Similarly, Async hides blocking operations that are available in
Core.Std, like print_string, so when you write:

   open Core.Std
   open Async.Std

those problematic values are hidden from.  It would be a shame, I
think, to make every single file that uses Core have to change from:

   open Core.Std

to

   open namespace Core.Std
   open Core.Std.Common

or whatever it would need to be.

y

>     Didier
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Tue Feb 26 15:53:21 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 10:53:21 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBGVrCei_tZdkxroHG3wJ6G+D3OmW_9LL_x5wpsNMnc0Dg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <CAPFanBGVrCei_tZdkxroHG3wJ6G+D3OmW_9LL_x5wpsNMnc0Dg@mail.gmail.com>
Message-ID: <CACLX4jQYbqe44iYQJ6-0Pn55LNsLnAfKEMTjSo9SM5q5n9h=mQ@mail.gmail.com>

I should mention that the term "UNSANITARY" might sound a bit
negative, but that is not intended.  My actual opinion is that Alain's
proposal sounds to me quite practical, and is basically my favorite
proposal thus far (though I consider my own opinion to be of limited
value, because of my lack of understanding of many implementation
issues).  I just wanted for us to call out the downsides explicitly,
so as to better understand what the opposition to Alain's plan might
be.

On Tue, Feb 26, 2013 at 10:12 AM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
> Yaron Minsky <yminsky at janestreet.com> wrote:
>> One thing I'll say is that it is important to be able to add values,
>> and not just modules, to the namespace.  Open Core.Std also adds
>> top-level values, as does the traditional standard library (i.e.,
>> Pervasives), and I don't want to lose that.
>
> This is handled as a "bonus feature" discussed in
> http://gallium.inria.fr/~scherer/namespaces/pack_et_functor_pack.html
> , under the name "flat access". The idea is that adding values to
> namespaces directly doesn't work very well (in OCaml, values cannot
> live outside a compilation unit), but you can have some modules that
> will be explicitly opened if you open the namespace (or included if
> you use it as a module). However, we're not yet sure that this works
> as well as the other aspects of the design, and would recommend
> starting without it to get a feel of the system.

That sounds dandy.

> On Tue, Feb 26, 2013 at 3:38 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> Leo, do you have a summary of what you don't like about Alain's
>> namespace proposal?  I'm not presently able to identify any obvious
>> weaknesses in it.  The downsides I see are:
>>
>> - UNSANITARY: Having both "open namespace Core.Std" and Core_List as
>>   names seems a little unsanity.  Indeed, to provide a decent user
>>   experience, you probably want to hide the Core_List name almost
>>   everywhere.  You don't want it showing up in error messages,
>>   documentation, source files, etc.  When you need to do a bunch of
>>   work to hide something, maybe it's better not to include it at all.
>
> I want to point out that Alain's idea of using long, hopefully-unique
> names for the source files, that you deem "unsanitary" here, is also a
> workaround for the problem of internal name conflict. In Alain's
> proposal, internal names conflicts are (hopfeully) avoided with no
> implementation change, just by judicious name choices and letting the
> implementation do its work. This imposes this "unsanitary" aspect you
> mention, but it is a complexity tradeoff: the other alternative would
> be to design a more clever implementation to choose internal names
> (than the module's source filename), which could be hidden from the
> user (no exposed Core_List) but require an implementation change. I
> think that could warrant an exploration (because it could support use
> cases such as linking together two versions of the same library, which
> isn't possible with a purely filename-based solution), but in the
> context Alain's proposal this "unsanitary" aspect has more advantages
> than downsides.

I don't disagree with any of this.

>> - NO HIDING: I'm not sure that the other namespace proposals do
>>   support this, but I'd like to be able to hide some modules so that
>>   they are not reachable outside of the namespace.  We can do this
>>   with the current Core.Std, but I don't see how to do it in Alain's
>>   proposal.
>
> I'm surprised by this "hiding" idea. What does it mean, and what would
> be an use case for that?
>
>> Are there other issues I'm missing?
>
> My gut feeling is that a hierarchical model would add little
> complexity to Alain's proposal and give a saner semantics to "open
> namespace". With a flat model there can be no real notion of "open
> namespace", only handcrafted renamings en masse (Core_list -> List,
> Core_array -> Array...). (On the other hand "open namespace", if they
> are done at the source level, are a source language change, while none
> are necessary so far, so they will require more work to handle in any
> case.)
>
> There is the problem of internal name conflicts, but that is one of
> the more "advanced" questions that may be left out of a first
> experiment.
>
> When deciding to leave out some questions for later, it is however
> important to wonder whether we're sure that we will actually be able
> to extend the design to support them. Some early design choices may
> make future extensions harder (without breaking compatibility). One
> solution is to make a coherent design that covers advanced features,
> and decide to implement only a subset. One other is to try to guess
> what will be easy to add afterwards, and be lucky. Finally, one can
> experiment with a first design and move to another, but without
> committing to backward compatibility (meaning no language release
> between the two design iterations).

I appreciate your point about picking a modest design.  I would argue,
however, that it's not worth actually implementing a namespace
mechanism that doesn't handle the case of a library like Core.  I
think libraries like Core are really one of the biggest drivers for
namespaces, and it would seem a mistake to build and deploy something
that doesn't solve that problem.

> My personal guess is that
> - "flat access" will be easy an easy extension.
> - "hierarchical rather than flat mappings" will be relatively easy in
> theory but make a painful transition period for providers that have
> modules organized flatly and desire to change; but it depends on a
> question of "seeing non-leaf namespaces as modules" that Alain's flat
> namespaces don't need to consider.
> - "extending the mapping description language" must be planned for
> beforehand to avoid growing pains.
> - "finer implementation of internal names to avoid linking conflicts"
> is yet of unknown difficulty, either today and after any first
> proposal not tackling this aspect is acted upon.

This all sounds reasonable.


>>
>> y
>>
>> On Tue, Feb 26, 2013 at 9:30 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> On Tue, Feb 26, 2013 at 8:03 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>>> On 02/25/2013 10:53 PM, Yaron Minsky wrote:
>>>>>
>>>>> I understand your point Alain, but while what you're saying is
>>>>> technically reasonable, I think it doesn't hold together.  When
>>>>> programming in the large, it is useful to be able to manipulate the
>>>>> namespace and group parts of the world together.
>>>>
>>>> Can you give concrete examples of which manipulations are desired (and why)?
>>>
>>> I think the conversation has gotten confused.  You said "who needs
>>> pack?  Just use hierarchically named modules".  I'm saying: that's
>>> crazy, you need to be able to do simple manipulations of namespaces
>>> (like the ones implied by "open Core.Std" or "open Core.Stable".)
>>>
>>> Now you're pointing out that your namespace proposal covers the
>>> manipulations I'm describing.  That may well be right, and I wasn't
>>> contesting that point.
>>>
>>> All I'm saying is that simply relying on long module names without any
>>> kind of explicit namespace control does not scale.  I stand by that,
>>> without necessarily objecting to your namespace proposal.
>>>
>>>>> Many libraries, not
>>>>> just Core or Async, want to be able to remap the world by adding a
>>>>> collection of related names to the namespace.  The ability to do the
>>>>> moral equivalent of:
>>>>>
>>>>>     open Core.Std
>>>>>
>>>>> is powerful and important.  Your proposal of having people add
>>>>> prefixes to module names does not fit the bill, and the resulting
>>>>> system does not, in my opinion, scale.
>>>>
>>>>
>>>> I believe my proposal covers this use case.  If you depend a lot on a
>>>> specify library which exports many modules, you might indeed want to avoid
>>>> using long names everywhere to access these modules.  That's why I propose
>>>> to give simple ways to alias long modules names to short ones, in a way
>>>> which can be factorized (with external mapping files).
>>>>
>>>> In my proposal, the equivalent of "open Core.Std" would simply be to tell
>>>> the compiler (through a command-line option or with a directive in the code)
>>>> to use a mapping file.  The same can be done within the library itself.
>>>>
>>>> Here is a minimalistic version of my proposal, restricted to specifying
>>>> those mapping files on the compiler and tools command-lines.  To make it
>>>> clear that this is only about mapping module references to compiled units,
>>>> let's piggy-back the -I option.  If its argument is a file with a .ns suffix
>>>> and not a directory, the compiler interprets it as a mapping file (a
>>>> sequence of lines of the form "Module_name =
>>>> relative_path_to_compiled_unit", e.g. "List = core_list"), and when this -I
>>>> option is considered during the resolution of a module reference (such as
>>>> "List") and the module is defined in the file, the compiler simply resolves
>>>> the module to the corresponding unit.
>>>>
>>>> This approach could also be used to restrict which units are visible by the
>>>> compiler (and avoid repeated lookup on the file system) without moving files
>>>> around on the file system.
>>>>
>>>> ocamldep (without -modules) would apply the same logic; ocamldep -modules
>>>> could either implement the same logic, or leave it to the build system
>>>> interpreting its output (allowing more dynamic scenarios where the mapping
>>>> file themselves are generated).  I expect ocamldoc to work mostly
>>>> out-of-the-box, even though one could think about using the mapping files
>>>> (in reverse direction) to provide shorter names in the generated
>>>> documentation (or not).
>>>>
>>>> Users of a library are never forced to use the mapping files, and they can
>>>> always refer to a module with its full name (provided the corresponding -I
>>>> <path> is used).
>>>>
>>>> The OCaml stdlib would be adapted to use longer names (stdlib_list,
>>>> stdlib_array, etc) and shipped with a stdlib.ns file opened by default
>>>> (unless -nostdlib is used).  To be clear: this mapping file will be used by
>>>> the stdlib itself, so references within itself don't need to use long names.
>>>>
>>>> I'm interested to see concrete examples of manipulation or scenarios not be
>>>> covered by this proposal.
>>>
>>> I am unaware of any.  I think this does mostly support the
>>> Core.Std/Core.Stable tricks we use.
>>>
>>> One thing I'll say is that it is important to be able to add values,
>>> and not just modules, to the namespace.  Open Core.Std also adds
>>> top-level values, as does the traditional standard library (i.e.,
>>> Pervasives), and I don't want to lose that.
>>>
>>> y
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Tue Feb 26 16:00:22 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 11:00:22 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CD492.8070204@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <512CD492.8070204@lexifi.com>
Message-ID: <CACLX4jR+3iYQbJrMfjVr0uejFkM12W9uxr_pj5jCH8=TBWe3RQ@mail.gmail.com>

On Tue, Feb 26, 2013 at 10:28 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/26/2013 03:38 PM, Yaron Minsky wrote:
>>
>> - UNSANITARY: Having both "open namespace Core.Std" and Core_List as
>>    names seems a little unsanity.  Indeed, to provide a decent user
>>    experience, you probably want to hide the Core_List name almost
>>    everywhere.  You don't want it showing up in error messages,
>>    documentation, source files, etc.  When you need to do a bunch of
>>    work to hide something, maybe it's better not to include it at all.
>
> Concretly, what should the OCamldoc-generated page for a Core module look
> like?  Should the reference to types defined in other Core modules be
> displayed without any indication that they come from Core (without clicking
> on it)?

I believe that's right.  When you're reading Core's documentation,
much as when you're reading Core's code, you want to see the
in-namespace names.

> I would find this very confusing.  Similarly for error messages: it
> is indeed nice to be able to see List instead of Core_list when you live
> with Core all you day long and there is no ambiguity. Still, there needs to
> be a way to have a more explicit error message, which could distinguish
> Stdlib_list from Core_list.

I think if you've opened the Core namespace in prefernce to the Stdlib
one, you want to see Core_list as List, and you want to see
Stdlib_list as Stdlib_list.

Core should be able to stand up as a full-fledged alternative to the
standard library.  No one wants error messages for the standard
library to suddenly get twice as long because it's littered with
qualifiers.  We want the same for Core.

I would argue that when referencing identifiers in other namespaces,
you should at that point have the namespace qualifier in place.

> For me, seeing List instead Core_list in "common cases" is only nice
> to have (and definitely achievable with a little more effort in my
> proposal), but being able to distinguish Core_list from Stdlib_lib
> is crucial.  (And I don't think that showing Core#List is nicer than
> Core_list, at least not enough to justify the addition of a new
> notion.)

I think you're underselling the importance of keeping names concise.
We've started using Garrigue's short-paths patch, and it is amazing
how much it helps error messages, and the key thing it does is remove
unnecessary qualifications.  OCaml's error messages aren't great as
they are, and making them even longer is a bug user-interface mistake.

> Having long unique names which can be used in any context is a very good
> property and would also avoid problems reported with camlp4 extensions not
> being able to access a specific "standard" module.  If we can use
> Stdlib_list in any context, we don't need to do any hack to refer to it.

I agree that having unique names that are accessible from any context
is good, though I think namespaces could provide this.  You could
refer to Stdlib#List anytime you needed to be explicit, and just use
List when you did not.

That said, I agree that your proposal provides this feature as well,
and that it's a good thing.

>> - NO HIDING: I'm not sure that the other namespace proposals do
>>    support this, but I'd like to be able to hide some modules so that
>>    they are not reachable outside of the namespace.  We can do this
>>    with the current Core.Std, but I don't see how to do it in Alain's
>>    proposal.
>
>
> If the library does not install the .cmi file of the private module, it
> cannot be accessed by any "client code".  We do this regularly for our
> internal libraries.  For me, this is not really related to namespaces.

That's an interesting point.  Maybe we could do the same.

> With my proposal, it is even better: you can install .cmi files so that some
> "privileged" parts of your code base can still access it, but also restrict
> access to other parts by providing a mapping file which does not alias the
> private module (and just arrange so that you don't have a -I on the
> directory where the .cmi is installed).  Currently, what we do to achieve it
> is to have several install directories for some libraries and copy a
> different subset of .cmi files to each of them.
>
>
> Alain

From yminsky at janestreet.com  Tue Feb 26 16:02:59 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 11:02:59 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CD70C.2000105@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CD70C.2000105@lexifi.com>
Message-ID: <CACLX4jTBfmDAY5Jw8JeiiptgdwXpZHuuXMPUE+741tEyF3hdFg@mail.gmail.com>

On Tue, Feb 26, 2013 at 10:38 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/26/2013 03:30 PM, Yaron Minsky wrote:
>>
>> One thing I'll say is that it is important to be able to add values,
>> and not just modules, to the namespace.  Open Core.Std also adds
>> top-level values, as does the traditional standard library (i.e.,
>> Pervasives), and I don't want to lose that.
>
>
> I can understand that this is nice, but is it really important?

I think it is important.  Part of what we're doing in thinking through
Real World OCaml is to figure out what we can do to make using the
system as easy and painless as possible.  Requiring two separate
declarations is asking people to forget one of them (and from the
comments we've gotten from people alpha-testing the book, they make
these mistakes quite a bit.)

The build system I think is just the wrong place to specify this.  You
should be able to control your namespace conveniently from the source.
Specifying implicit opens from the build system is just asking for
people to be confused about how their namespace is controlled.

> Concretely, we are talking about the necessity to add an extra "open
> Core_std" statement in addition to the namespace opening statement (or a
> corresponding command-line option).  Does this extra open statement justify
> to make concepts less orthogonal?
>
> My "flat mapping" proposal could be extended to support "implicit opens" in
> the same mapping files (in addition to lines like "List = core_list", we
> could have "open Core_std" lines).  I don't think it is a good idea to do
> so, however (and it would require to have two versions of the mapping file,
> one to be used inside the implementation of Core itself and another one for
> client code -- without the open statement).  We could also let the user
> specify implicit opens on the command-line, so as to push the problem to the
> build system or ocamlfind.  Again, I'm not sure this is a great idea to do
> so, but at least, it would make it clear that this feature is not related to
> the module naming system.
>
>
> Alain

From daniel.buenzli at erratique.ch  Tue Feb 26 16:30:46 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 26 Feb 2013 17:30:46 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jR+3iYQbJrMfjVr0uejFkM12W9uxr_pj5jCH8=TBWe3RQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <512CD492.8070204@lexifi.com>
 <CACLX4jR+3iYQbJrMfjVr0uejFkM12W9uxr_pj5jCH8=TBWe3RQ@mail.gmail.com>
Message-ID: <39E2254787014808994A33CC794BD208@erratique.ch>

Le mardi, 26 f?vrier 2013 ? 17:00, Yaron Minsky a ?crit :
> I think you're underselling the importance of keeping names concise.
> We've started using Garrigue's short-paths patch, and it is amazing
> how much it helps error messages, and the key thing it does is remove
> unnecessary qualifications. OCaml's error messages aren't great as
> they are, and making them even longer is a bug user-interface mistake.

This is also something that's very important to me. Beyond one (maybe two) "dot" levels I find things to become unreadable, especially when printed as a part of aggregate types like tuples or polymorphic variants.

It was also that reason that prompted me to design the Gg's module mentioned before as it is, i.e. if you take care to define your module signatures as follows:

type a
module A : sig
  type t = a
 (* mention a not t in the signatures *)
  val create : unit -> a  
  val op : a -> a
end

They are still compatible with the M.t convention for functors but you get short Cunit.a type names in errors and your definitions.  

Daniel



From Christophe.Troestler at umons.ac.be  Tue Feb 26 16:37:15 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Tue, 26 Feb 2013 17:37:15 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
References: <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
Message-ID: <20130226.173715.1355231090817746626.Christophe.Troestler@umons.ac.be>

On Tue, 26 Feb 2013 09:30:50 -0500, Yaron Minsky wrote:
> 
> One thing I'll say is that it is important to be able to add values,
> and not just modules, to the namespace.  Open Core.Std also adds
> top-level values, as does the traditional standard library (i.e.,
> Pervasives), and I don't want to lose that.

Would these values be able to run arbitrary code (e.g. initializing an
underlying C library and executing some functions)?

From alain.frisch at lexifi.com  Tue Feb 26 16:43:04 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 17:43:04 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
Message-ID: <512CE618.7080302@lexifi.com>

On 02/26/2013 04:43 PM, Yaron Minsky wrote:
> I think we do.  What we want is essentially the same thing that we
> need to do when OCaml opens Pervasives by default.  We simply have
> another module that we wish to open by default.

Do you agree that this need of importing values automatically in the 
global scope is quite specific to "stdlib" replacements and to basic 
"infrastructure" libraries?  For me, this would justify some "side" 
support for the feature under the form of a command-line option, if this 
can give the expected benefit without touching the language itself.  I 
expect that most of your code base does "open Core.Std", right?  What 
would be the problem of putting this information in the build system so 
that this module is opened by default (and maybe also to enable to 
corresponding "module/unit mapping" with my proposal)?  Generally 
speaking I agree that putting too much information in the build system 
is a bad idea, but here the point is precisely to provide the illusion 
that Core.Std is the standard library (for a specific code base) and to 
avoid one extra "open" statement.

There is default behavior of OCaml of opening Pervasives by default. 
This can be switched of.  Now if Core has to be thought as a different 
standard library, why should we require users to even write "open 
Core.Std" at all?  We should be able to arrange so that the compiler 
opens it by default as it usually opens Pervasives.

Again, for me, this is quite orthogonal to module name management (which 
can be useful to many libraries) and is rather specific to stdlib 
replacement / basic infrastructure libraries.


Alain

From yminsky at janestreet.com  Tue Feb 26 16:48:55 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 11:48:55 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130226.173715.1355231090817746626.Christophe.Troestler@umons.ac.be>
References: <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <20130226.173715.1355231090817746626.Christophe.Troestler@umons.ac.be>
Message-ID: <CACLX4jQwW6AwtgMyFyNvfypQjrs=BP+UeRJ4xhSYX6V4Rv8YsQ@mail.gmail.com>

On Tue, Feb 26, 2013 at 11:37 AM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Tue, 26 Feb 2013 09:30:50 -0500, Yaron Minsky wrote:
>>
>> One thing I'll say is that it is important to be able to add values,
>> and not just modules, to the namespace.  Open Core.Std also adds
>> top-level values, as does the traditional standard library (i.e.,
>> Pervasives), and I don't want to lose that.
>
> Would these values be able to run arbitrary code (e.g. initializing an
> underlying C library and executing some functions)?

I think yes.  It's the exact equivalent of opening a module, which
requires the module be linked in, and all its toplevel effects
executed.

y

From yminsky at janestreet.com  Tue Feb 26 16:53:49 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 11:53:49 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CE618.7080302@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512CE618.7080302@lexifi.com>
Message-ID: <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>

On Tue, Feb 26, 2013 at 11:43 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/26/2013 04:43 PM, Yaron Minsky wrote:
>>
>> I think we do.  What we want is essentially the same thing that we
>> need to do when OCaml opens Pervasives by default.  We simply have
>> another module that we wish to open by default.
>
> Do you agree that this need of importing values automatically in the global
> scope is quite specific to "stdlib" replacements and to basic
> "infrastructure" libraries?

Infrastructure is a relative question.  Core and Async are both
libraries that want this.  But there are more we have internally.
Indeed, we mint a fair number of little programming worlds, each with
their own conventions that are encoded by such a Std library.  There
aren't hundreds of these, but there are probably a dozen.

Generally, it's important to remember the importance of scale.  Jane
Street has a hundred people actively hacking on OCaml every day,
millions of lines of codes and hundreds of software artifacts.  Things
that seem like occasional special cases become first-class
requirements pretty quick.

> For me, this would justify some "side" support
> for the feature under the form of a command-line option, if this can give
> the expected benefit without touching the language itself.
>
> I expect that most of your code base does "open Core.Std", right?
> What would be the problem of putting this information in the build
> system so that this module is opened by default (and maybe also to
> enable to corresponding "module/unit mapping" with my proposal)?
> Generally speaking I agree that putting too much information in the
> build system is a bad idea, but here the point is precisely to
> provide the illusion that Core.Std is the standard library (for a
> specific code base) and to avoid one extra "open" statement.
>
> There is default behavior of OCaml of opening Pervasives by
> default. This can be switched of.  Now if Core has to be thought as
> a different standard library, why should we require users to even
> write "open Core.Std" at all?  We should be able to arrange so that
> the compiler opens it by default as it usually opens Pervasives.
>
> Again, for me, this is quite orthogonal to module name management (which can
> be useful to many libraries) and is rather specific to stdlib replacement /
> basic infrastructure libraries.

I very much disagree.  This is a common enough primitive that people
should be able to do it without hacking the build system.  Indeed,
Daniel seems to have the same requirements as we do.

y

From lpw25 at cam.ac.uk  Tue Feb 26 17:03:28 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 26 Feb 2013 17:03:28 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>

On Feb 26 2013, Yaron Minsky wrote:

>Leo, do you have a summary of what you don't like about Alain's
>namespace proposal?  I'm not presently able to identify any obvious
>weaknesses in it.

I have a few of issues with Alain's proposal specifically, and then a 
second group of issues that are with that kind of proposal in general (i.e. 
defining the namespace separately from the modules it contains).

Issues with Alain's proposal specifically:

 1. Alain's proposal does not include a notion of opening a namespace. The 
    ability to only open a namespace when actually using it (e.g. a local 
    open) would be very useful. For example, this means that the proposal 
    provides no assistance for handling multiple standard libraries in the 
    same program: you can either make "List" equal "Core_List" everywhere or
    you can make it equal "Stdlib_List" everywhere. I see no real reason 
    why Alain's namespaces could not be extended with a namespace opening 
    feature.

 2. Alain's proposal provides no means of aliasing namespaces. Similar to 
    opening a namespace, it would be useful to be able to say "open 
    Core.Std as CS" and then refer to Core_Std_Mutex as "CS#Mutex"

 3. Alain's proposal only supports a flat namespace. As I said before, 
    hierarchical namespaces are very useful in certain situations. 
    Obviously this criticism only makes sense if you first add the ability 
    to open namespaces. Again this feature could easily be added to Alain's 
    proposal.

Issues with this kind of proposal:

 1. They require unique file names. This means that every file must become 
    "package_Module.ml" or "package_Subpackage_Module.ml".

 2. A module's name depends on other files. A module's name (by which I 
    mean its namespaced name) depends on the ".ns" file, this could 
    definitely be confusing.

 3. They require you to manage an ".ns" file. Not a major burden, but it is 
    one more place to look for errors. It also must be included in all 
    calls to the compiler.

 4. To me they put the namespace information in the wrong place. A 
    component should define its own names, it should also not have to open 
    its own namespace.

I think that the first group of issues above are important, but the second 
group of issues are of a more aesthetic nature. Also, if you want to 
automatically open modules along with a namespace, then that is much easier 
with centralised definition of the namespace.

As a side note, if people are okay with long filenames, why not support 
having filenames like "core-std-mutex.mli" and then allow "open namespace 
Core" and "open namespace Core#Std".

These could be treated as if there were automatically a "core.ns":

 namespace Std = "core-std.ns"

and "core-std.ns":

 module Mutex = "core-std-mutex.mli"

that were passed to any compiler invocation that had such files on its 
search path.


From caml at davidb.org  Tue Feb 26 17:31:53 2013
From: caml at davidb.org (David Brown)
Date: Tue, 26 Feb 2013 09:31:53 -0800
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130225.233339.1226206120450456754.Christophe.Troestler@umons.ac.be>
 (Christophe TROESTLER's message of "Mon, 25 Feb 2013 23:33:39 +0100")
References: <512BD679.4010501@lexifi.com>
 <748650772.3709054.1361828430427.JavaMail.root@inria.fr>
 <20130225.233339.1226206120450456754.Christophe.Troestler@umons.ac.be>
Message-ID: <87bob7t20m.fsf@a64.davidb.org>

Christophe TROESTLER <Christophe.Troestler at umons.ac.be> writes:

> It seems to me that the openness of namespaces is the only feature I
> have seen mentioned that modules do not have.  But is the openness of
> namespaces something considered useful?  What problem does this solves?

The simplest case is that it allows different packets to put things in
under the same hierarchy.  As an example, from Haskell:

   Data.List  from 'base'
   Data.Array from 'array'
   Data.Text  from 'text' - which is not part of the distribution

without openness, these would all need a different prefix.

Admittedly, Haskell has it much easier, since modules are very simple,
and cannot be manipulated within the language, other than the contents
of a particular file being a single module.

David

From alain.frisch at lexifi.com  Tue Feb 26 18:14:06 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 19:14:06 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512CE618.7080302@lexifi.com>
 <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>
Message-ID: <512CFB6E.5020705@lexifi.com>

On 2/26/2013 5:53 PM, Yaron Minsky wrote:
> I very much disagree.  This is a common enough primitive that people
> should be able to do it without hacking the build system.  Indeed,
> Daniel seems to have the same requirements as we do.

I'd say "using" the build system rather than hacking it.  Actually, it 
is more about using ocamlfind.  We will anyway need to rely on ocamlfind 
to manage the installation of many libraries, right?  I think that users 
don't really care that passing "-package core" to ocamlfind will result 
in it passing the following three options to the compiler:

   -I ..../core/core.ns
            (* To "open" the the default mapping provided by core *)

   -open Core_std
            (* To open the default module which, in particular,
               overrides definitions in Pervasives. *)

   -I ..../core
            (* So that you can use long names like Core_list if you
               wish, to be explicit *)

(and probably some -ppx options as well :-))


(There could variants like a "-package core.raw" which would only pass 
the third one.)

Do you agree that the information about which libraries are used by a 
specific part of the code base will be part of the build system anyway?

Now we could discuss putting library-related information in the client 
code itself (this is a common request for "syntax extensions", but I 
don't see why this is specific to them), e.g. in the form of special 
comments/attributes understood by ocamlfind, but this seems a different 
topic to me.



Alain

From caml at davidb.org  Tue Feb 26 18:22:53 2013
From: caml at davidb.org (David Brown)
Date: Tue, 26 Feb 2013 10:22:53 -0800
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130226.190037.395291071527003221.Christophe.Troestler@umons.ac.be>
 (Christophe TROESTLER's message of "Tue, 26 Feb 2013 19:00:37 +0100")
References: <748650772.3709054.1361828430427.JavaMail.root@inria.fr>
 <20130225.233339.1226206120450456754.Christophe.Troestler@umons.ac.be>
 <87bob7t20m.fsf@a64.davidb.org>
 <20130226.190037.395291071527003221.Christophe.Troestler@umons.ac.be>
Message-ID: <877glvsznm.fsf@a64.davidb.org>

Christophe TROESTLER <Christophe.Troestler at umons.ac.be> writes:

> On Tue, 26 Feb 2013 09:31:53 -0800, David Brown wrote:
>> 
>> Christophe TROESTLER <Christophe.Troestler at umons.ac.be> writes:
>> 
>> > It seems to me that the openness of namespaces is the only feature I
>> > have seen mentioned that modules do not have.  But is the openness of
>> > namespaces something considered useful?  What problem does this solves?
>> 
>> The simplest case is that it allows different packets to put things in
>> under the same hierarchy.  As an example, from Haskell:
>> 
>>    Data.List  from 'base'
>>    Data.Array from 'array'
>>    Data.Text  from 'text' - which is not part of the distribution
>> 
>> without openness, these would all need a different prefix.
>
> Right but you say what openness is, not why you want it.  IMHO, it is
> unlikely you want to say "open namespace Data"; it is more a
> convenience for documentation and can be handled at another level.

I suppose you could call it a convenience.  But, it allows modules to be
named based on what they do and where they belong, rather than needing
prefixes to distinguish them.  It has the disadvantage that you can't
tell from the name which package a given module comes from.  But, after
an open, this is, in general, the case anyway.

David

From alain.frisch at lexifi.com  Tue Feb 26 18:33:18 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 19:33:18 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
Message-ID: <512CFFEE.1010509@lexifi.com>

On 2/26/2013 6:03 PM, Leo White wrote:
> 1. Alain's proposal does not include a notion of opening a namespace.
> The    ability to only open a namespace when actually using it (e.g. a
> local    open) would be very useful. For example, this means that the
> proposal    provides no assistance for handling multiple standard
> libraries in the    same program: you can either make "List" equal
> "Core_List" everywhere or
>     you can make it equal "Stdlib_List" everywhere. I see no real reason
>     why Alain's namespaces could not be extended with a namespace
> opening    feature.

Yes, my initial proposal was about adding a "(local) namespace opening" 
statement to the language:

   open namespace Core

   let open namespace Core in ....

(Both would look for a core.ns file on the search path.)

I've simplified it even further by restricting its use to entire unit 
and putting the directive it on the command-line instead of the source 
code.  If the need for controlling locally which namespaces are used is 
felt, I won't object to it.  But I'm not yet convinced that this is so 
useful (and it complicates things, such as decicing how to display a 
nice type name in case of type error, because this depends on the 
location in your module).

> 2. Alain's proposal provides no means of aliasing namespaces. Similar to
>     opening a namespace, it would be useful to be able to say "open
> Core.Std as CS" and then refer to Core_Std_Mutex as "CS#Mutex"

I believe that aliasing modules is what matters.  Since I don't 
understand the need for a dedicated notion of namespace yet (with some 
operations on namespaces) I also don't see the need for aliasing them.

> 2. A module's name depends on other files. A module's name (by which I
>     mean its namespaced name) depends on the ".ns" file, this could
> definitely be confusing.

I don't agree with this interpretation: the name of the module depends 
only on its file name, and we provide a convenient way for client code 
to refer to these modules with shorter names, locally.  It is a big 
advantage, for me, that client code could always be written without 
"namespaces", if required.

> 3. They require you to manage an ".ns" file. Not a major burden, but it
> is    one more place to look for errors. It also must be included in all
>     calls to the compiler.

For any serious use of the compiler with some third-party libraries, the 
command-line is not built by hand, but by your build system and/or 
ocamlfind.

> 4. To me they put the namespace information in the wrong place. A
> component should define its own names, it should also not have to open
>     its own namespace.

I guess this is a matter of taste, and corresponds to a conception of 
what namespaces should be as an identified notion, rather than solving 
an actual need or addressing a concrete problem with my proposal 
(correct me if I'm wrong).

> As a side note, if people are okay with long filenames, why not support
> having filenames like "core-std-mutex.mli" and then allow "open
> namespace Core" and "open namespace Core#Std".
>
> These could be treated as if there were automatically a "core.ns":
>
> namespace Std = "core-std.ns"
>
> and "core-std.ns":
>
> module Mutex = "core-std-mutex.mli"
>
> that were passed to any compiler invocation that had such files on its
> search path.

I don't like this implicitness: how can we infer dependencies?  If 
ocamldep sees a reference to "List" in scope where "open namespace Core" 
and "open namespace Bar" are both active, it would have to look for both 
core-list and bar-list files (and there will be a combinatorial 
explosion in the resolution if you allow opening nested namespaces). 
Worse: if we use "ocamldep -modules", this resolution has to be done by 
the build system, so this complex logic (which depends on the location 
in the source file) will have to be re-implemented in omake and other 
build systems around.  It is an important property that "ocamldep 
-modules" does not need to look for the existence of compiled units on 
the current tree.


Alain

From Christophe.Troestler at umons.ac.be  Tue Feb 26 17:44:27 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Tue, 26 Feb 2013 18:44:27 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQwW6AwtgMyFyNvfypQjrs=BP+UeRJ4xhSYX6V4Rv8YsQ@mail.gmail.com>
References: <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <20130226.173715.1355231090817746626.Christophe.Troestler@umons.ac.be>
 <CACLX4jQwW6AwtgMyFyNvfypQjrs=BP+UeRJ4xhSYX6V4Rv8YsQ@mail.gmail.com>
Message-ID: <20130226.184427.1442957797248633338.Christophe.Troestler@umons.ac.be>

On Tue, 26 Feb 2013 11:48:55 -0500, Yaron Minsky wrote:
> 
> On Tue, Feb 26, 2013 at 11:37 AM, Christophe TROESTLER
> <Christophe.Troestler at umons.ac.be> wrote:
> > On Tue, 26 Feb 2013 09:30:50 -0500, Yaron Minsky wrote:
> >>
> >> One thing I'll say is that it is important to be able to add values,
> >> and not just modules, to the namespace.  Open Core.Std also adds
> >> top-level values, as does the traditional standard library (i.e.,
> >> Pervasives), and I don't want to lose that.
> >
> > Would these values be able to run arbitrary code (e.g. initializing an
> > underlying C library and executing some functions)?
> 
> I think yes.  It's the exact equivalent of opening a module, which
> requires the module be linked in, and all its toplevel effects
> executed.

There is something I do not understand: if we allow toplevel values
(possibly by automatically opening a module), these might require that
some other modules in the namespace are initialized.  Will these be
automatically traced?  Or will the other modules need to be specified
on the command line?  But then, compiling something using, say, Core
will not be as easy as adding "-pkg core".  I guess each module can
come with its own dependency file (as we do now with findlib) but then
each use of a module in the namespace will need to be mimicked in the
build system (or the toplevel)...

From yminsky at janestreet.com  Tue Feb 26 19:48:03 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 14:48:03 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CFB6E.5020705@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512CE618.7080302@lexifi.com>
 <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>
 <512CFB6E.5020705@lexifi.com>
Message-ID: <CACLX4jTtVAWtVaRx8514YBs3cJBrfenHggusmQHiUkoQ2Un=nw@mail.gmail.com>

On Tue, Feb 26, 2013 at 1:14 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>
> Do you agree that the information about which libraries are used by a
> specific part of the code base will be part of the build system anyway?
>
> Now we could discuss putting library-related information in the client code
> itself (this is a common request for "syntax extensions", but I don't see
> why this is specific to them), e.g. in the form of special
> comments/attributes understood by ocamlfind, but this seems a different
> topic to me.

Your point is fair.  I guess what I'm saying specifically is that
namespace manipulation belongs in the source.  Right now, if the build
system, it might cause my build to fail, or too much to be linked in,
but it won't change the meaning of my program in a material way.

In short, I'd like to keep the things that affect the meaning of my
program largely in the source.  I agree that for very pervasive
things, like Core.Std or sexplib within Jane Street, you may want to
make this silently present at the build-system level.  But most of the
time, you want to be explicit about this kind of change to the
semantics of your program.

Maybe the main difference between us is this: I want to use namespaces
for multiple libraries, not just highly pervasive ones like Core.  You
think of namespaces as a thing to solve the fairly narrow problem of
Core.  If I thought you were right about this, I would agree with the
rest.

From yminsky at janestreet.com  Tue Feb 26 19:54:55 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 14:54:55 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CFFEE.1010509@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
Message-ID: <CACLX4jTnYba1Ofrb1NKD_+CriLf2Ty10KNpSbptdhj4qiwYGcQ@mail.gmail.com>

On Tue, Feb 26, 2013 at 1:33 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 2/26/2013 6:03 PM, Leo White wrote:
>> 2. Alain's proposal provides no means of aliasing namespaces. Similar to
>>     opening a namespace, it would be useful to be able to say "open
>> Core.Std as CS" and then refer to Core_Std_Mutex as "CS#Mutex"
>
>
> I believe that aliasing modules is what matters.  Since I don't understand
> the need for a dedicated notion of namespace yet (with some operations on
> namespaces) I also don't see the need for aliasing them.

Within Jane Street, we alias modules quite a bit (and it would be nice
if this was lighter weight than it is, but that's another story!).  I
think you'd want to alias namespaces for the same reason.

The intuition is this: by default, you want long descriptive
identifiers.  But for a small scope, you're happy to either make the
identifier disappear entirely (as in, [open namespace
Super_awesome_openGL_renderer]) or make it small (as in, [alias
namespace Render = Super_awesome_openGL_renderer).


>> 2. A module's name depends on other files. A module's name (by which I
>>     mean its namespaced name) depends on the ".ns" file, this could
>> definitely be confusing.
>
>
> I don't agree with this interpretation: the name of the module depends only
> on its file name, and we provide a convenient way for client code to refer
> to these modules with shorter names, locally.  It is a big advantage, for
> me, that client code could always be written without "namespaces", if
> required.

I understand why you view this as an advantage, but I think of this as
roughly a disadvantage.  The "namespace" names I think will be far
more usable and convenient, and those I think should be the primary
ones.  I believe the fully-qualified names should be viewed as a
second-class, low-level feature.  For one thing, having both of them
be primary things that are presented to the user is going to be
awfully confusing.

>> 3. They require you to manage an ".ns" file. Not a major burden, but it
>> is    one more place to look for errors. It also must be included in all
>>     calls to the compiler.
>
>
> For any serious use of the compiler with some third-party libraries, the
> command-line is not built by hand, but by your build system and/or
> ocamlfind.
>
>
>> 4. To me they put the namespace information in the wrong place. A
>> component should define its own names, it should also not have to open
>>     its own namespace.
>
>
> I guess this is a matter of taste, and corresponds to a conception of what
> namespaces should be as an identified notion, rather than solving an actual
> need or addressing a concrete problem with my proposal (correct me if I'm
> wrong).

I think it addresses usability of the overall system.  Your approach
of making the flat names priomary maximizes continuity with toolchains
of the past, but also maximizes the confusion of the system to new
users.  I think we should largely present one way of naming things to
users, and making the namespace-names the primary ones seems like a
clear usability win.

>> As a side note, if people are okay with long filenames, why not support
>> having filenames like "core-std-mutex.mli" and then allow "open
>> namespace Core" and "open namespace Core#Std".
>>
>> These could be treated as if there were automatically a "core.ns":
>>
>> namespace Std = "core-std.ns"
>>
>> and "core-std.ns":
>>
>> module Mutex = "core-std-mutex.mli"
>>
>> that were passed to any compiler invocation that had such files on its
>> search path.
>
>
> I don't like this implicitness: how can we infer dependencies?  If ocamldep
> sees a reference to "List" in scope where "open namespace Core" and "open
> namespace Bar" are both active, it would have to look for both core-list and
> bar-list files (and there will be a combinatorial explosion in the
> resolution if you allow opening nested namespaces). Worse: if we use
> "ocamldep -modules", this resolution has to be done by the build system, so
> this complex logic (which depends on the location in the source file) will
> have to be re-implemented in omake and other build systems around.  It is an
> important property that "ocamldep -modules" does not need to look for the
> existence of compiled units on the current tree.
>
>
> Alain

From Didier.Remy at inria.fr  Tue Feb 26 22:03:52 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Tue, 26 Feb 2013 23:03:52 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
Message-ID: <512D3148.8010805@inria.fr>

Yaron,

>> Do you really need this level of granularity?  I'd like to think of
>> modules as the smallest compilation unit.  Can you give us examples of what
>> you'd like to do with value manipulation?
>
> I think we do.  What we want is essentially the same thing that we
> need to do when OCaml opens Pervasives by default.  We simply have
> another module that we wish to open by default.

This is quite different than cherry-picking values from a module.  Also open
is a bit misleading here, because it must behaves like an include.  While
open brings all subcomponents in scope but does not evaluate them, include
must evaluate (use) all the definitions and binds them in the current
structure.

This is quite different from what happens when building namespaces: when a
new definition shadows an older one in a namespace, the older definition
will not be visible by the linker and will not be evaluated.

"Include-on-open" (called flat-acccess by Gabriel) is doable as Gabriel
explained, and would generalize the behavior of pervasives, but it is
another mechanism than just building a namespace (because it also _uses_ a
module).

> There are two reasons for this: the first is to open at the top-level
> some constructors and values that are very commonly useful.  Much as
> pervasives has None and Some from option available everywhere, we have
> Ok and Error from Result.t available everywhere.

Fine.

> Another reason is to shadow values from other modules.  Core.Std hides
> various values from Pervasives that we view as harmful.  For example,
> we hide ==, and instead expose phys_equal.  (We think == is too
> confusing to people from other languages.)

This example is different I think, and perhaps another solution could be used.
My understanding is that you wish to have your own version of stdlib, say
stdlib_minus_plus.

Why don't you create a new module stdlib_minus_plus that includes stdlib
with a restricted safe interface (so that bindings "minus" will be evaluated
but not visible) and then add your own safer definitions "plus", bind the
resulting module to some namespace Core#stdlib and then use your own version
of Core#stdlib instead of the original stdlib?

It seems that you wish Core.std to be only a diff against the original
stdlib and not a patched copy. Is this the case? Why it is important?

> Similarly, Async hides blocking operations that are available in
> Core.Std, like print_string, so when you write:
>
>     open Core.Std
>     open Async.Std
>
> those problematic values are hidden from.

Isn't this fragile? for example, what happens if the user mistakenly writes
these two lines in the other order? If Async.Std _must_ hide values of
Core.Std for safety reasons (for instance to avoid blocking), why is it not
returning a patched copy of Core.Std with these values overridden instead of
relying on the user to open modules in the right order?

> think, to make every single file that uses Core have to change from:
>
>     open Core.Std
> to
>     open namespace Core.Std
>     open Core.Std.Common
>
> or whatever it would need to be.

I don't see what you mean here.

     Didier

From alain.frisch at lexifi.com  Tue Feb 26 22:17:31 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Feb 2013 23:17:31 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTtVAWtVaRx8514YBs3cJBrfenHggusmQHiUkoQ2Un=nw@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512CE618.7080302@lexifi.com>
 <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>
 <512CFB6E.5020705@lexifi.com>
 <CACLX4jTtVAWtVaRx8514YBs3cJBrfenHggusmQHiUkoQ2Un=nw@mail.gmail.com>
Message-ID: <512D347B.2010200@lexifi.com>

On 2/26/2013 8:48 PM, Yaron Minsky wrote:
> In short, I'd like to keep the things that affect the meaning of my
> program largely in the source.  I agree that for very pervasive
> things, like Core.Std or sexplib within Jane Street, you may want to
> make this silently present at the build-system level.  But most of the
> time, you want to be explicit about this kind of change to the
> semantics of your program.
>
> Maybe the main difference between us is this: I want to use namespaces
> for multiple libraries, not just highly pervasive ones like Core.  You
> think of namespaces as a thing to solve the fairly narrow problem of
> Core.  If I thought you were right about this, I would agree with the
> rest.

I think we agree on why we disagree.  For me, the only problem which is 
serious enough to justify changes to the language and toolchain is about 
name clashes (not being able to use two libraries together because they 
happen to use identical module names).  A simple non-technical solution 
exists today: a policy to avoid such clashes (long names). The only 
cases where this is problematic, I believe, is for big libraries used in 
a pervasive way, for which (i) long names become really tedious for the 
users; (ii) module aliasing is not enough because the library has many 
modules.  I think this is fairly limited and can be solved by very light 
additions to the toolchain, allowing basically to define "user-land 
stdlibs" (with a context-dependent definition of what a stdlib is).  I 
consider other use cases and "required" features of namespaces as nice 
to have (or not) but not important enough to justify any serious 
addition to the language definition and adaptation of existing tools, 
especially when we are talking about breaking some current invariants 
and properties on which some existing users might rely.


Alain

From yminsky at janestreet.com  Tue Feb 26 22:29:05 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 17:29:05 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512D347B.2010200@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512CE618.7080302@lexifi.com>
 <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>
 <512CFB6E.5020705@lexifi.com>
 <CACLX4jTtVAWtVaRx8514YBs3cJBrfenHggusmQHiUkoQ2Un=nw@mail.gmail.com>
 <512D347B.2010200@lexifi.com>
Message-ID: <CACLX4jSabPvq9y4GmuYGeY_6esVvjYnYoZO4sax2d2ezTysmWg@mail.gmail.com>

On Tue, Feb 26, 2013 at 5:17 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 2/26/2013 8:48 PM, Yaron Minsky wrote:
>>
>> In short, I'd like to keep the things that affect the meaning of my
>> program largely in the source.  I agree that for very pervasive
>> things, like Core.Std or sexplib within Jane Street, you may want to
>> make this silently present at the build-system level.  But most of the
>> time, you want to be explicit about this kind of change to the
>> semantics of your program.
>>
>> Maybe the main difference between us is this: I want to use namespaces
>> for multiple libraries, not just highly pervasive ones like Core.  You
>> think of namespaces as a thing to solve the fairly narrow problem of
>> Core.  If I thought you were right about this, I would agree with the
>> rest.
>
>
> I think we agree on why we disagree.  For me, the only problem which is
> serious enough to justify changes to the language and toolchain is about
> name clashes (not being able to use two libraries together because they
> happen to use identical module names).  A simple non-technical solution
> exists today: a policy to avoid such clashes (long names). The only cases
> where this is problematic, I believe, is for big libraries used in a
> pervasive way, for which (i) long names become really tedious for the users;
> (ii) module aliasing is not enough because the library has many modules.

I think the reason we disagree ties to questions of scale.  We have a
number of projects that are big enough to want to build their own
"pervasive" library.  For example, we have a library whose purpose is
designing trading systems.  It has its own Std and its own set of
conventions, and many thousands of lines of code built within that
world.  We also have a separate library whose purpose is building user
interfaces for trading systems.  It too has its own Std and its own
conventions that it wants to standardize on.

Namespace control becomes a real issue in this world quite quickly.  A
solution designed for one hulking Stdlib replacement doesn't address
enough of the problem space.

And I don't think these scale issues are Jane Street only.  A big part
of the goal of the work we're putting in to OCamlLabs and Real World
OCaml and these working groups is to really grow the OCaml community,
and for that, OCaml needs to get good at programming-in-the-large.  I
think good namespace control is a key part of doing that right.

> I think this is fairly limited and can be solved by very light
> additions to the toolchain, allowing basically to define "user-land
> stdlibs" (with a context-dependent definition of what a stdlib is).
> I consider other use cases and "required" features of namespaces as
> nice to have (or not) but not important enough to justify any
> serious addition to the language definition and adaptation of
> existing tools, especially when we are talking about breaking some
> current invariants and properties on which some existing users might
> rely.

I understand where you're coming from, but I don't think it's the
right decision for the future of the language.  I think this is case
where OCaml can and should change.

y

From yminsky at janestreet.com  Tue Feb 26 22:36:06 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 26 Feb 2013 17:36:06 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512D3148.8010805@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512D3148.8010805@inria.fr>
Message-ID: <CACLX4jQaDehu5Oc_LV2UPJUdg7oLTBOw0O0aOO8JAYz3Ds_HkA@mail.gmail.com>

On Tue, Feb 26, 2013 at 5:03 PM, Didier Remy <Didier.Remy at inria.fr> wrote:
> Yaron,
>
>>> Do you really need this level of granularity?  I'd like to think of
>>> modules as the smallest compilation unit.  Can you give us examples of
>>> what
>>> you'd like to do with value manipulation?
>>
>>
>> I think we do.  What we want is essentially the same thing that we
>> need to do when OCaml opens Pervasives by default.  We simply have
>> another module that we wish to open by default.
>
>
> This is quite different than cherry-picking values from a module.  Also open
> is a bit misleading here, because it must behaves like an include.  While
> open brings all subcomponents in scope but does not evaluate them, include
> must evaluate (use) all the definitions and binds them in the current
> structure.

Perhaps I'm just out of my depth here, but I don't really see the
issue.  In Alain's world, you could imagine that a namespace mechanism
definition combines two things: a list of name-remappings, and a list
of names to open.  I would then think that the declaration:

    open namespace Foo

would essentially expand to something like:

    module alias A = Foo_a
    module alias B = Foo_b
    module alias C = Foo_c
    module alias Common = Foo_common
    open Foo_common

and that's that.

> This is quite different from what happens when building namespaces: when a
> new definition shadows an older one in a namespace, the older definition
> will not be visible by the linker and will not be evaluated.
>
> "Include-on-open" (called flat-acccess by Gabriel) is doable as Gabriel
> explained, and would generalize the behavior of pervasives, but it is
> another mechanism than just building a namespace (because it also _uses_ a
> module).

I agree that this essentiall combines together two features into one.
Maybe the difference is that I view this as more feature than bug.

>> There are two reasons for this: the first is to open at the top-level
>> some constructors and values that are very commonly useful.  Much as
>> pervasives has None and Some from option available everywhere, we have
>> Ok and Error from Result.t available everywhere.
>
>
> Fine.
>
>
>> Another reason is to shadow values from other modules.  Core.Std hides
>> various values from Pervasives that we view as harmful.  For example,
>> we hide ==, and instead expose phys_equal.  (We think == is too
>> confusing to people from other languages.)
>
>
> This example is different I think, and perhaps another solution
> could be used.  My understanding is that you wish to have your own
> version of stdlib, say stdlib_minus_plus.
>
> Why don't you create a new module stdlib_minus_plus that includes stdlib
> with a restricted safe interface (so that bindings "minus" will be evaluated
> but not visible) and then add your own safer definitions "plus", bind the
> resulting module to some namespace Core#stdlib and then use your own version
> of Core#stdlib instead of the original stdlib?
>
> It seems that you wish Core.std to be only a diff against the original
> stdlib and not a patched copy. Is this the case? Why it is important?
>
>> Similarly, Async hides blocking operations that are available in
>> Core.Std, like print_string, so when you write:
>>
>>     open Core.Std
>>     open Async.Std
>>
>> those problematic values are hidden from.
>
>
> Isn't this fragile? for example, what happens if the user mistakenly writes
> these two lines in the other order? If Async.Std _must_ hide values of
> Core.Std for safety reasons (for instance to avoid blocking), why is it not
> returning a patched copy of Core.Std with these values overridden instead of
> relying on the user to open modules in the right order?

It is somewhat fragile, but it's reasonably workable, and it allows
you to carefully reach into Core.Std to get unsafe values when you
want to (which you do sometimes want to do).

To be clear, if there was a good mechanism for punching holes in
Core.Std and exporting that, we might be quite happy to do that.  We
just don't have a clean mechanism for doing so in the present world.

>> think, to make every single file that uses Core have to change from:
>>
>>     open Core.Std
>> to
>>     open namespace Core.Std
>>     open Core.Std.Common
>>
>> or whatever it would need to be.
>
>
> I don't see what you mean here.

I merely mean that, in practice, users of Core need to open
Core.Std.Common.  If we don't allow the namespace operation to do it
for them, then users will need to type both lines every time.  This
seems error prone, especially for new users.

Indeed, if we had this, we might just write a ppx extension that gave
us the one-line declaration we want.

y

From Christophe.Troestler at umons.ac.be  Tue Feb 26 18:00:37 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Tue, 26 Feb 2013 19:00:37 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <87bob7t20m.fsf@a64.davidb.org>
References: <748650772.3709054.1361828430427.JavaMail.root@inria.fr>
 <20130225.233339.1226206120450456754.Christophe.Troestler@umons.ac.be>
 <87bob7t20m.fsf@a64.davidb.org>
Message-ID: <20130226.190037.395291071527003221.Christophe.Troestler@umons.ac.be>

On Tue, 26 Feb 2013 09:31:53 -0800, David Brown wrote:
> 
> Christophe TROESTLER <Christophe.Troestler at umons.ac.be> writes:
> 
> > It seems to me that the openness of namespaces is the only feature I
> > have seen mentioned that modules do not have.  But is the openness of
> > namespaces something considered useful?  What problem does this solves?
> 
> The simplest case is that it allows different packets to put things in
> under the same hierarchy.  As an example, from Haskell:
> 
>    Data.List  from 'base'
>    Data.Array from 'array'
>    Data.Text  from 'text' - which is not part of the distribution
> 
> without openness, these would all need a different prefix.

Right but you say what openness is, not why you want it.  IMHO, it is
unlikely you want to say "open namespace Data"; it is more a
convenience for documentation and can be handled at another level.

From Christophe.Troestler at umons.ac.be  Tue Feb 26 22:26:04 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Tue, 26 Feb 2013 23:26:04 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
Message-ID: <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>

On Tue, 26 Feb 2013 12:30:15 +0000, Leo White wrote:
> 
> Ignoring the implementation issues for now, consider the run-time
> semantics of the module system.

Thanks for that explanation.  I have some questions though.

> At run-time a module is a record. Initialising a module involves
> initialising every component of the module and placing them in this
> record. Initialising these components can involve executing arbitrary
> code; in fact the execution of an OCaml program is simply the
> initialisation of all its modules.

How about doing that initialization in a more lazy fashion?
Initializing a module would only create the top level components:
toplevel values and modules?, the modules being only "pointers to
NULL".  when accessing a submodule, the compiler would take note to
initialize that submodule (and link the corresponding cmo/cmx for
packed modules?).  If the modules is used in a functor or as a first
class value, then all submodules present in the signature are
initialized (this could be on the spot ? especially for the toplevel ?
or moved to the place where the module is initialized if that makes a
difference).  To avoid runtime checks, some static analysis is
required to make sure that, when a value is used, the corresponding
submodule has been properly initialized but that may not be too hard.

There are two problems that I can see with this but I think namespaces
have the same ones if they are to be convenient.  The first is about
the initialization code in submodules.  As you say, loading a library
should execute the "toplevel code" of each submodule.  Since this is
rather infrequent, when building the module record, one may add all
module paths containing submodules with initialization code.  That way
the current semantics are preserved and for huge packed modules many
components should still go away.  However, one could argue that if one
does not reference the module at all, its initialization code should
not be executed (alike the behavior one gets when adding cm[x]a on the
command line).

The second problem is that some toplevel value may need some sumodules
to be initialized (because they use these submodules).  Some analysis
is thus required to add these submodules during the record
initialization.  The same is true when one initialize a submodule that
was "NULL" before ? other submodules may need to be initialized first.
This analysis may not be too had to do ? indeed it is already
basically present in ocamldep.

? As an added bonus, one does not have to load the entire module
signature (?4Mb for Core) ? only keep pointers to the signatures of
submodules ? which should speed up compilation.  This is mostly an
orthogonal issue but it could benefit from the same laziness framework.

? This could be done almost for free if packing would rename the
modules to some internal names, gather them in a cm[x]a (and not a
cmo/cmx as of now) and add a module aliasing these internal names to
the desired names for the outside world.

> Any attempt to overcome the problems with pack, whilst still
> maintaining the illusion that the "pack" is a normal module, would
> result (at the very least) in one of the following unhealthy
> situations:
> 
> - The module type of the "pack" module would depend on which of its
>   components were accessed by the program.
> 
> - Any use of the "pack" module other than as a simple container
>   (e.g. "module CS = Core.Std") could have a dramatic effect on what was
>   linked into the program and potentially on the semantics of the
>   program.

Maybe one of these problems occurs with the rough proposal described
above but it is not immediately clear to me.  May you tell?

> Namespaces are basically modules that can only be used as a simple
> container. This means that they do not need a corresponding record at
> run-time (or any other run-time representation). This avoids the
> problems with pack as well as enabling other useful features
> (e.g. open definitions).

I agree that openness may be a desired feature.  Gabriel however said
that it is not essential.  Moreover, one could imagine that a module
wanting to be added to a hierarchy (say "Data") could be repacked at
in the module Data at installation time.  Granted this is not very
nice but this is just intended to show that there are short term
possibilities.

Best,
C.

From gabriel.scherer at gmail.com  Wed Feb 27 06:58:41 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Wed, 27 Feb 2013 07:58:41 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
 <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
Message-ID: <CAPFanBGiaNCetfbWeWWwnj_6cQatWX1dc9b=y-+CGh-m=8BF+w@mail.gmail.com>

I don't like your lazy initialization scheme because it changes the
observable semantics of the the OCaml language when modules have
global side-effects. Currently, the effects are evaluated in the
linking order of the modules, not the use order.

Note that the main difficulty of your proposal is to track
dependencies at a structure item level, rather than at a compilation
unit level as is currently done. Lazyness is arguably bad and in any
case not needed if you have this finer granularity -- but as I argued
this would have large, and possibly unpleasant, implementation
implications.

On Tue, Feb 26, 2013 at 11:26 PM, Christophe TROESTLER
<Christophe.Troestler at umons.ac.be> wrote:
> On Tue, 26 Feb 2013 12:30:15 +0000, Leo White wrote:
>>
>> Ignoring the implementation issues for now, consider the run-time
>> semantics of the module system.
>
> Thanks for that explanation.  I have some questions though.
>
>> At run-time a module is a record. Initialising a module involves
>> initialising every component of the module and placing them in this
>> record. Initialising these components can involve executing arbitrary
>> code; in fact the execution of an OCaml program is simply the
>> initialisation of all its modules.
>
> How about doing that initialization in a more lazy fashion?
> Initializing a module would only create the top level components:
> toplevel values and modules?, the modules being only "pointers to
> NULL".  when accessing a submodule, the compiler would take note to
> initialize that submodule (and link the corresponding cmo/cmx for
> packed modules?).  If the modules is used in a functor or as a first
> class value, then all submodules present in the signature are
> initialized (this could be on the spot ? especially for the toplevel ?
> or moved to the place where the module is initialized if that makes a
> difference).  To avoid runtime checks, some static analysis is
> required to make sure that, when a value is used, the corresponding
> submodule has been properly initialized but that may not be too hard.
>
> There are two problems that I can see with this but I think namespaces
> have the same ones if they are to be convenient.  The first is about
> the initialization code in submodules.  As you say, loading a library
> should execute the "toplevel code" of each submodule.  Since this is
> rather infrequent, when building the module record, one may add all
> module paths containing submodules with initialization code.  That way
> the current semantics are preserved and for huge packed modules many
> components should still go away.  However, one could argue that if one
> does not reference the module at all, its initialization code should
> not be executed (alike the behavior one gets when adding cm[x]a on the
> command line).
>
> The second problem is that some toplevel value may need some sumodules
> to be initialized (because they use these submodules).  Some analysis
> is thus required to add these submodules during the record
> initialization.  The same is true when one initialize a submodule that
> was "NULL" before ? other submodules may need to be initialized first.
> This analysis may not be too had to do ? indeed it is already
> basically present in ocamldep.
>
> ? As an added bonus, one does not have to load the entire module
> signature (?4Mb for Core) ? only keep pointers to the signatures of
> submodules ? which should speed up compilation.  This is mostly an
> orthogonal issue but it could benefit from the same laziness framework.
>
> ? This could be done almost for free if packing would rename the
> modules to some internal names, gather them in a cm[x]a (and not a
> cmo/cmx as of now) and add a module aliasing these internal names to
> the desired names for the outside world.
>
>> Any attempt to overcome the problems with pack, whilst still
>> maintaining the illusion that the "pack" is a normal module, would
>> result (at the very least) in one of the following unhealthy
>> situations:
>>
>> - The module type of the "pack" module would depend on which of its
>>   components were accessed by the program.
>>
>> - Any use of the "pack" module other than as a simple container
>>   (e.g. "module CS = Core.Std") could have a dramatic effect on what was
>>   linked into the program and potentially on the semantics of the
>>   program.
>
> Maybe one of these problems occurs with the rough proposal described
> above but it is not immediately clear to me.  May you tell?
>
>> Namespaces are basically modules that can only be used as a simple
>> container. This means that they do not need a corresponding record at
>> run-time (or any other run-time representation). This avoids the
>> problems with pack as well as enabling other useful features
>> (e.g. open definitions).
>
> I agree that openness may be a desired feature.  Gabriel however said
> that it is not essential.  Moreover, one could imagine that a module
> wanting to be added to a hierarchy (say "Data") could be repacked at
> in the module Data at installation time.  Granted this is not very
> nice but this is just intended to show that there are short term
> possibilities.
>
> Best,
> C.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From daniel.buenzli at erratique.ch  Wed Feb 27 08:49:01 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Wed, 27 Feb 2013 09:49:01 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBGiaNCetfbWeWWwnj_6cQatWX1dc9b=y-+CGh-m=8BF+w@mail.gmail.com>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
 <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
 <CAPFanBGiaNCetfbWeWWwnj_6cQatWX1dc9b=y-+CGh-m=8BF+w@mail.gmail.com>
Message-ID: <1EE73E7CFD924274842D05B2ECE9A5A4@erratique.ch>

Le mercredi, 27 f?vrier 2013 ? 07:58, Gabriel Scherer a ?crit :
> I don't like your lazy initialization scheme because it changes the
> observable semantics of the the OCaml language when modules have
> global side-effects. Currently, the effects are evaluated in the
> linking order of the modules, not the use order.

You are right that it may not be sensible to change that now. On the other hand IIRC my delves into module research a few years ago, in fact the strict initialization semantics combined with the structural (vs nominal) aspect is the source of many headaches, notably the recursive module issue.

While Leo convinced me that "solving pack" won't help us given the current runtime module semantics. I'm rather dubious about the namespace solution since for me (1) If we follow what Yaron wants (and that in someway I also do want) a namespace eventually looks diabolically like a module, at least when you open it (2) It doesn't seem to solve the problem for the small library I mentioned (can now be peek at here [1]) or at least it doesn't allow to me to write it the simple way I'd like to write it.

At that point, I would personally, rather wait for the longer term solutions Didier mentions backed by solid type system research (if that actually solves these problems, I'm no longer up-to-date with these things, e g. Rossberg's 2013 paper) rather than integrate solutions that seem to be guided by ad-hoc considerations. But I guess that's not an option for the platform.  

Daniel

[1] https://github.com/dbuenzli/gg



From alain.frisch at lexifi.com  Wed Feb 27 09:22:18 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 27 Feb 2013 10:22:18 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jSabPvq9y4GmuYGeY_6esVvjYnYoZO4sax2d2ezTysmWg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512CE618.7080302@lexifi.com>
 <CACLX4jTtMVKy+5mB1Mm_PnLngxpy_Ji-Ba=26dtoH0VK5Y_Yew@mail.gmail.com>
 <512CFB6E.5020705@lexifi.com>
 <CACLX4jTtVAWtVaRx8514YBs3cJBrfenHggusmQHiUkoQ2Un=nw@mail.gmail.com>
 <512D347B.2010200@lexifi.com>
 <CACLX4jSabPvq9y4GmuYGeY_6esVvjYnYoZO4sax2d2ezTysmWg@mail.gmail.com>
Message-ID: <512DD04A.9040104@lexifi.com>

On 02/26/2013 11:29 PM, Yaron Minsky wrote:
> I think the reason we disagree ties to questions of scale.  We have a
> number of projects that are big enough to want to build their own
> "pervasive" library.  For example, we have a library whose purpose is
> designing trading systems.  It has its own Std and its own set of
> conventions, and many thousands of lines of code built within that
> world.  We also have a separate library whose purpose is building user
> interfaces for trading systems.  It too has its own Std and its own
> conventions that it wants to standardize on.
>
> Namespace control becomes a real issue in this world quite quickly.  A
> solution designed for one hulking Stdlib replacement doesn't address
> enough of the problem space.

But isn't it the case that in a given part of the project (say, a 
subtree), the code depends on a well-defined number of those libraries, 
and this information is already part of the build system?  If this is 
the case, I suppose that most modules starts with a few global "open 
Foo.Std" statements, so Foo.Std and Bar.Std cannot really share any 
common internal names (or you have to revert to using fully qualified 
names).  I don't see why my proposal would not cover those cases.  It is 
true that I'd probably prefer to use directly long names in LexiFi's 
projects (as we currently do), maybe because of a question of scale, 
maybe because this is a case where I think being more explicit is a good 
thing.  But I don't think my proposal would prevent to do what you want.

> And I don't think these scale issues are Jane Street only.  A big part
> of the goal of the work we're putting in to OCamlLabs and Real World
> OCaml and these working groups is to really grow the OCaml community,
> and for that, OCaml needs to get good at programming-in-the-large.  I
> think good namespace control is a key part of doing that right.

Maybe this is indeed a matter of scale, but the desire to scale in 
itself is not a good justification for a new feature (especially if it 
breaks current properties); a good justification might be to address an 
issue which prevents smooth scaling.  I thought the only serious issue 
was name clashes of modules in different libraries.  I still believe 
that very light namespace control (simple "flat" control over the 
reference->unit mapping) is enough to address this.  During the 
discussion I've seen several other "requirements" (avoiding some "open" 
statements, having extensible namespaces, organizing modules/namespaces 
in a hierarchy), but to me they address problems created by the 
assumption that we must introduce a notion of namespace, not by actual 
problems which currently limit scaling or user-friendliness of the language.

This is not really in contradiction with your position, since your 
mentioned my proposal as one which might be sufficient to you.  But I'd 
like proponents of more advanced stuff to describe which actual problems 
are addressed by their proposal (with arguments not assuming that the 
notion of namespaces is an interesting addition to the language
on its own).

Maybe a good way to move the discussion forward would be to agree first 
on which problems we are trying to solve (and whether they are related 
to scaling, to beginner-friendliness, to tool-friendliness [like 
ocamldoc], etc).

Alain

From alain.frisch at lexifi.com  Wed Feb 27 09:40:31 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 27 Feb 2013 10:40:31 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jQaDehu5Oc_LV2UPJUdg7oLTBOw0O0aOO8JAYz3Ds_HkA@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <512CCDBC.8040405@inria.fr>
 <CACLX4jQEbnyuTs87nsEq_=mmOHOXVKmF3YhEZwv4H_DAJqpSng@mail.gmail.com>
 <512D3148.8010805@inria.fr>
 <CACLX4jQaDehu5Oc_LV2UPJUdg7oLTBOw0O0aOO8JAYz3Ds_HkA@mail.gmail.com>
Message-ID: <512DD48F.1080400@lexifi.com>

After reading again some messages in this thread, I've the feeling that 
people are looking for a better notion of "library", and not strictly 
about ways to manage (module) names.

Currently, a library is made of many different things:

  - Some public interfaces (.cmi files), which need to be located 
somewhere on the file system, often on a library-specific sub-directory.

  - Some compiler flags to add to make them accessible (-I).

  - Some other compiler flags to be added when the library is to be used 
(-pp / -ppx).

  - Some implementation (.cmxa/.a) to be passed to the linker.  Even 
"private" modules in those implementations are not allowed to clash with 
other private modules in other libraries.


The complexity of all that makes the use of ocamlfind more or less 
mandatory.

It seems to me that when people say they want to "open a namespace", 
they really mean "use a library", and they want to be able to specify 
that in the source code, and maybe even for a local scope within a unit. 
  Moreover, they want to extend the notion of "using a library" to even 
more things, like bringing some values in the global scope.

At least this is now my interpretation of some requests specified by 
Yaron, for instance.  Maybe this is only a matter of terminology, but 
I've to say that I can more easily relate to a desire to improve support 
for "libraries", than to the one to introduce namespaces.


Alain

From lpw25 at cam.ac.uk  Wed Feb 27 10:57:14 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 27 Feb 2013 10:57:14 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
 <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
Message-ID: <Prayer.1.3.5.1302271057140.29276@hermes-1.csi.cam.ac.uk>

>How about doing that initialization in a more lazy fashion?
>Initializing a module would only create the top level components:
>toplevel values and modules?, the modules being only "pointers to
>NULL".  when accessing a submodule, the compiler would take note to
>initialize that submodule (and link the corresponding cmo/cmx for
>packed modules?).  If the modules is used in a functor or as a first
>class value, then all submodules present in the signature are
>initialized (this could be on the spot - especially for the toplevel -
>or moved to the place where the module is initialized if that makes a
>difference).  To avoid runtime checks, some static analysis is
>required to make sure that, when a value is used, the corresponding
>submodule has been properly initialized but that may not be too hard.
>
>There are two problems that I can see with this but I think namespaces
>have the same ones if they are to be convenient.  The first is about
>the initialization code in submodules.  As you say, loading a library
>should execute the "toplevel code" of each submodule.  Since this is
>rather infrequent, when building the module record, one may add all
>module paths containing submodules with initialization code.  That way
>the current semantics are preserved and for huge packed modules many
>components should still go away.  However, one could argue that if one
>does not reference the module at all, its initialization code should
>not be executed (alike the behavior one gets when adding cm[x]a on the
>command line).
>
>The second problem is that some toplevel value may need some sumodules
>to be initialized (because they use these submodules).  Some analysis
>is thus required to add these submodules during the record
>initialization.  The same is true when one initialize a submodule that
>was "NULL" before - other submodules may need to be initialized first.
>This analysis may not be too had to do - indeed it is already
>basically present in ocamldep.

Ignoring the fact that this is a dramatic and non-trivial change to the 
language and its implementation, this proposal does not solve the problems 
with pack since it still requires you to link all the modules in the pack 
in case they need to be used (lazily) later on.

It also suffers from a version of my second unhealthy situation: If you do 
anything that requires the runtime representation of the module (e.g. 
"module CS = Core.Std") then you will initialise every sub-module and 
potentially change the semantics of your program.

>I agree that openness may be a desired feature.  Gabriel however said
>that it is not essential. 

I didn't entirely follow what Gabriel said, but I think that he was saying 
a proposal that was locally closed (e.g. within a specific file or using a 
specific namespace definition) could still be globally open. This is 
similar to your suggestion that a "Data" pack could be recompiled/linked to 
add new modules.


From lpw25 at cam.ac.uk  Wed Feb 27 11:51:01 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 27 Feb 2013 11:51:01 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512CFFEE.1010509@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
Message-ID: <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>

>Yes, my initial proposal was about adding a "(local) namespace opening" 
>statement to the language:
>[...]
>I've simplified it even further by restricting its use to entire unit 
>and putting the directive it on the command-line instead of the source 
>code.  If the need for controlling locally which namespaces are used is 
>felt, I won't object to it.  But I'm not yet convinced that this is so 
>useful (and it complicates things, such as decicing how to display a 
>nice type name in case of type error, because this depends on the 
>location in your module).

Without an open statement your proposal does not scale well. The main need 
for namespaces arises out of the fact that people choose the same short 
names for their modules. This will still be the case for the names people 
choose within their ".ns" files. As soon as I want to use two libraries 
that contain modules with the same short name, your proposal will have the 
meaning of the short name decided by the order of command-line arguments. 
This seems very fragile.

I also think that open statements (even at the top of a file) are a very 
good thing. They show which libraries the file is going to use. Currently, 
a file using a library that does not use pack will simply launch straight 
into using modules with short names that give no indication of their 
origin. I must look in the build system to find out what they refer to. By 
encouraging people to use namespaces, these files will instead start with 
"open namespace Foo", and it will be obvious what libraries they are using.

As OPAM (and the platform) become more widely used I expect there to be 
many more small convenience libraries. This will increase the number of 
libraries that are being used within a single project, and it will be 
useful to know from the source files themselves which files use which 
libraries. Up to now OCaml has cleverly avoided this problem by 
discouraging people from using each other's libraries.

>> 2. A module's name depends on other files. A module's name (by which I
>>     mean its namespaced name) depends on the ".ns" file, this could
>> definitely be confusing.
>
>I don't agree with this interpretation: the name of the module depends 
>only on its file name, and we provide a convenient way for client code 
>to refer to these modules with shorter names, locally.  It is a big 
>advantage, for me, that client code could always be written without 
>"namespaces", if required.

I understand that for backwards compatibility it is useful to be able to 
use files via both a namespaced name and a traditional name. However, when 
not worried about backwards compatibility, we should instead be focussed on 
providing a coherent story about how OCaml components are named and how 
these names are managed. For me, this means (for a non-backwards compatible 
library) only providing (or at least actively encouraging) access to 
components through namespaces.

>> As a side note, if people are okay with long filenames, why not support
>> having filenames like "core-std-mutex.mli" and then allow "open
>> namespace Core" and "open namespace Core#Std".
>>
>> [...]
>
>I don't like this implicitness: how can we infer dependencies?  If 
>ocamldep sees a reference to "List" in scope where "open namespace Core" 
>and "open namespace Bar" are both active, it would have to look for both 
>core-list and bar-list files (and there will be a combinatorial 
>explosion in the resolution if you allow opening nested namespaces).

These implicit namespaces are simply a convenience. If you are finding that 
executing ocamldep is taking an unwelcome amount of time then simply make 
your namespaces explicit by providing ".ns" files.

>Worse: if we use "ocamldep -modules", this resolution has to be done by 
>the build system, so this complex logic (which depends on the location 
>in the source file) will have to be re-implemented in omake and other 
>build systems around.  It is an important property that "ocamldep 
>-modules" does not need to look for the existence of compiled units on 
>the current tree.

Firstly, I would like to make clear that this would be no problem for build 
systems that used makefile formatted ocamldep output.

"ocamldep -modules" has always produced an over-estimate of the modules 
that a file uses and then allowed the build system to figure out the rest. 
OCamlDep would simply treat any namespace for which it could find no ".ns" 
file as an implicit namespace. For any module that might be from the 
implicit namespace it would produce a (possibly spurious) dependency. Just 
like before, it would be the build system's job to know which dependencies 
were spurious.

It is not surprising that proposals to fix how OCaml maps names to files 
might require some changes to build tools. However, there aren't that many 
OCaml specifc build tools, they would only be small changes, and they would 
only be necessary for some of the build tools. More importantly there would 
be an extremely simple work around:

 If your build tool hasn't been updated to support implicit namespaces then
 write out the namespaces explicitly (i.e. create some very simple ".ns" 
 files).


From daniel.buenzli at erratique.ch  Wed Feb 27 12:53:56 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Wed, 27 Feb 2013 13:53:56 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
Message-ID: <19F7A93E3D954DC2987C0F0C2A310657@erratique.ch>

Le mercredi, 27 f?vrier 2013 ? 12:51, Leo White a ?crit :
> I also think that open statements (even at the top of a file) are a very
> good thing. They show which libraries the file is going to use. Currently,  
> a file using a library that does not use pack will simply launch straight  
> into using modules with short names that give no indication of their  
> origin. I must look in the build system to find out what they refer to. By  
> encouraging people to use namespaces, these files will instead start with  
> "open namespace Foo", and it will be obvious what libraries they are using.

Note however that this still won't tell you where a particular short module name comes from, especially if you have multiple open statements. Besides for single module libraries --- the way I like to design --- is seems rather pointless to have to say `open namespace Xmlm` to be able to use the Xmlm module.  

Daniel



From alain.frisch at lexifi.com  Wed Feb 27 13:09:28 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 27 Feb 2013 14:09:28 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
Message-ID: <512E0588.3000003@lexifi.com>

On 02/27/2013 12:51 PM, Leo White wrote:
> Without an open statement your proposal does not scale well. The main
> need for namespaces arises out of the fact that people choose the same
> short names for their modules. This will still be the case for the names
> people choose within their ".ns" files. As soon as I want to use two
> libraries that contain modules with the same short name, your proposal
> will have the meaning of the short name decided by the order of
> command-line arguments. This seems very fragile.

I want to see concrete examples!  I don't believe that it is common, in 
the same unit, to access two modules called "List" from two different 
libraries.  Maybe you want to use both String.Set and Int.Set, but 
you're not going to "open" String and Int anyway.  You may also want to 
use Xmllight.parse and Xmlm.parse (although it is not clear that this 
will happen in the same module), but you're not going to open Xmllight 
or Xmlm globally in your unit.

> I also think that open statements (even at the top of a file) are a very
> good thing.

If put at the top of the file, I don't see them as fundamentally 
different from command-line arguments, and the meaning of the short name 
is decided by the order of open statements, which is also quite fragile.

And "open statements" (for modules, not even namespaces) are generally 
considered as a dangerous feature, because they are the source of 
technical problems (dependency analysis), because they make the code 
harder to read and refactorize, and because it makes modules more 
fragile (if a module B is extended with more components, they can hide 
components with the same name from another module A which is open before 
B in some client code).  Making "opens" more local is a way to reduce 
those problems.  I'm thus surprised by your claim that open statements 
are very good thing.


> They show which libraries the file is going to use.

This seems to confirm that what you're aiming at is really a way to 
specify in the source code which libraries are used.  But then we should 
push the reasoning further and ensure this specification is the only one 
required to use a library.  Why should we accept to pass -I / -pp / -ppx 
flags to the compiler (and specify again libraries at link time) when 
the information is already part of the source code?


> Currently, a file using a library that does not use pack will simply
> launch straight into using modules with short names that give no
> indication of their origin.

Many of the third-party libraries I use export a single module, which I 
never "open", and whose name is unique enough to avoid clashes (e.g. 
Postgresql, Sqlite3, Xmlm).  Some libraries use prefixes (Nethtml, with 
an internal Nethtml_scanner module; Lwt comes with Lwt_util, 
Lwt_condition, Lwt_mutex, etc).  It would have been crazy, indeed, for 
Nethtml to have an internal "Scanner" module, or for Lwt to expose a 
"Mutex" module.  I'm fine with this situation, but I can understand that 
in some cases, it would make sense, for instance, to alias Lwt_mutex to 
Mutex in a given project.

So I don't agree with the opinion that -pack is currently the only way 
to avoid clashes!  It would be useful to get some statistics about the 
use of -pack in OPAM.


 > I must look in the build system to find out
> what they refer to. By encouraging people to use namespaces, these files
> will instead start with "open namespace Foo", and it will be obvious
> what libraries they are using.

So if you have a program like:

  open namespace Foo
  open namespace Bar

  (* ... several hundreds of lines ... *)

   .... Baz.parse ...

then, yes, you know that this program uses the Foo and Bar 
libraries/namespaces, but you have no idea where Baz comes from.  This 
is fine, as long as you don't have clashes of "short" names, i.e. Foo 
and Bar are different enough to not provide top-level components of the 
same name.

> As OPAM (and the platform) become more widely used I expect there to be
> many more small convenience libraries. This will increase the number of
> libraries that are being used within a single project, and it will be
> useful to know from the source files themselves which files use which
> libraries.

I like this idea of putting more information in the source code about a 
file "requirements" (let's say, which libraries are used).  This could 
be interpreted directly by the compiler (if there is a well-defined 
convention on how libraries are located and invoked) or by a driver such 
as ocamlfind.  Currently, library dependencies are specified on the 
command-line (hence in the build system) and I agree it makes sense to 
allow specifying that in the source code.

> I understand that for backwards compatibility it is useful to be able to
> use files via both a namespaced name and a traditional name. However,
> when not worried about backwards compatibility, we should instead be
> focussed on providing a coherent story about how OCaml components are
> named and how these names are managed. For me, this means (for a
> non-backwards compatible library) only providing (or at least actively
> encouraging) access to components through namespaces.

I understand your point and I think it makes sense if "namespaces" are 
indeed to be added to the language.

>> Worse: if we use "ocamldep -modules", this resolution has to be done
>> by the build system, so this complex logic (which depends on the
>> location in the source file) will have to be re-implemented in omake
>> and other build systems around.  It is an important property that
>> "ocamldep -modules" does not need to look for the existence of
>> compiled units on the current tree.
>
> Firstly, I would like to make clear that this would be no problem for
> build systems that used makefile formatted ocamldep output.

Indeed.  However, "ocamldep -modules" has been added for good reasons 
and it is the recommended way to use omake.  (And don't know about 
ocamlbuild.)  omake is used by some of the largest OCaml code base around.

> "ocamldep -modules" has always produced an over-estimate of the modules
> that a file uses and then allowed the build system to figure out the
> rest.

"ocamldep -modules" does not produce more false dependencies than 
"ocamldep".  I'd rather say that "ocamldep" (without -modules) misses 
some dependencies (for generated files which are not yet present when 
ocamldep is executed).


> OCamlDep would simply treat any namespace for which it could find
> no ".ns" file as an implicit namespace.

I have to admit that I'm a little bit lost and I don't really know which 
"namespace proposal" we are talking about (mine has only ".ns" file, no 
other notion of namespaces).



Alain

From lpw25 at cam.ac.uk  Wed Feb 27 13:42:58 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 27 Feb 2013 13:42:58 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <19F7A93E3D954DC2987C0F0C2A310657@erratique.ch>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <19F7A93E3D954DC2987C0F0C2A310657@erratique.ch>
Message-ID: <Prayer.1.3.5.1302271342580.14929@hermes-1.csi.cam.ac.uk>

>> I also think that open statements (even at the top of a file) are a 
>> very good thing. They show which libraries the file is going to use. 
>> [...]
>
> Note however that this still won't tell you where a particular short 
> module name comes from, especially if you have multiple open statements.

But they do tell which libraries the module might come from. This is 
usually enough information to infer where it has come from, and when it 
isn't you at least know in which documentation to look for it.

> Besides for single module libraries --- the way I like to design --- is 
> seems rather pointless to have to say `open namespace Xmlm` to be able to 
> use the Xmlm module.

I agree that namespaces aren't needed for single module libraries. Although 
I don't think there is anything stopping you from providing a 
non-namespaced name for your library (Xmlm) as well as a namespaced name 
(Xmlm#Xmlm), for people who wish to be more explicit/consistent.

From lpw25 at cam.ac.uk  Wed Feb 27 14:16:41 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 27 Feb 2013 14:16:41 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512E0588.3000003@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
Message-ID: <Prayer.1.3.5.1302271416410.14929@hermes-1.csi.cam.ac.uk>

>I want to see concrete examples!  

It is difficult to provide examples of people doing something that is not 
currently supported. Using the compiler itself as source of possible module 
names, I see the following module names that I could easily picture 
multiple libraries using:

 Warnings, Tbl, Misc, Config, Errors, Env, Types,
 Protocol, Shell, Common, Table, Log, Options

>Maybe you want to use both String.Set and Int.Set, but 
>you're not going to "open" String and Int anyway.

I can easily imagine libraries that provide there own specialised set 
implementation as Foo.Set. I can also easily imagine that the kind of 
program that requires specialised sets for one kind of data would also 
require specialised sets for another kind of data.

>use Xmllight.parse and Xmlm.parse (although it is not clear that this 
>will happen in the same module), but you're not going to open Xmllight 
>or Xmlm globally in your unit.

But I might open Xmlm and Json (an imaginary json parsing library) in the 
same unit.

>
>> I also think that open statements (even at the top of a file) are a very
>> good thing.
>
>If put at the top of the file, I don't see them as fundamentally 
>different from command-line arguments, and the meaning of the short name 
>is decided by the order of open statements, which is also quite fragile.

Except that open is written by a programmer, whilst command line arguments 
are often written by a tool/build system.

>And "open statements" (for modules, not even namespaces) are generally 
>considered as a dangerous feature, because they are the source of 
>technical problems (dependency analysis), because they make the code 
>harder to read and refactorize, and because it makes modules more 
>fragile (if a module B is extended with more components, they can hide 
>components with the same name from another module A which is open before 
>B in some client code).  Making "opens" more local is a way to reduce 
>those problems.  I'm thus surprised by your claim that open statements 
>are very good thing.

They are a good thing in comparison to command-line arguments. It is 
obviously better if people open things locally, or use the full name 
explicitly (although this can clutter the code and reduce readability).

>> They show which libraries the file is going to use.
>
>This seems to confirm that what you're aiming at is really a way to 
>specify in the source code which libraries are used.  But then we should 
>push the reasoning further and ensure this specification is the only one 
>required to use a library.  Why should we accept to pass -I / -pp / -ppx 
>flags to the compiler (and specify again libraries at link time) when 
>the information is already part of the source code?

I'm certainly not against support for inferring command-line arguments from 
the contents of files, but I do think that they are separate issues.

The "open Foo" is part of the semantics of the program, it has meaning 
regardless of the environment it is being compiled in. Command-line 
arguments are about providing an interface between the program's semantics 
and its surrounding environment (e.g. the filesystem).

There is also a reasonable argument that inferring the compiler arguments 
is the job of tools like ocamldep and the build system, rather than the 
compiler.

>> Currently, a file using a library that does not use pack will simply
>> launch straight into using modules with short names that give no
>> indication of their origin.
>
>Many of the third-party libraries I use export a single module, which I 
>never "open", and whose name is unique enough to avoid clashes (e.g. 
>Postgresql, Sqlite3, Xmlm).  Some libraries use prefixes (Nethtml, with 
>an internal Nethtml_scanner module; Lwt comes with Lwt_util, 
>Lwt_condition, Lwt_mutex, etc).  It would have been crazy, indeed, for 
>Nethtml to have an internal "Scanner" module, or for Lwt to expose a 
>"Mutex" module.  I'm fine with this situation, but I can understand that 
>in some cases, it would make sense, for instance, to alias Lwt_mutex to 
>Mutex in a given project.

More than just make sense, it would actively improve the readability of 
code using modules like Lwt_mutex.

>So I don't agree with the opinion that -pack is currently the only way 
>to avoid clashes!  It would be useful to get some statistics about the 
>use of -pack in OPAM.

I think that it is a little dangerous to judge how much people would use a 
proposal based on how many people used its complicated and deeply flawed 
predecessor.

> > I must look in the build system to find out
>> what they refer to. By encouraging people to use namespaces, these files
>> will instead start with "open namespace Foo", and it will be obvious
>> what libraries they are using.
>
>So if you have a program like:
>
>  open namespace Foo
>  open namespace Bar
>
>  (* ... several hundreds of lines ... *)
>
>   .... Baz.parse ...
>
>then, yes, you know that this program uses the Foo and Bar 
>libraries/namespaces, but you have no idea where Baz comes from.  This 
>is fine, as long as you don't have clashes of "short" names, i.e. Foo 
>and Bar are different enough to not provide top-level components of the 
>same name.

I certainly agree that it is bad practise to rely on shadowing, it would be 
better to open the modules more locally when they have clashes. This is why 
we should provide a way to open namespaces locally. I also think that the 
"open"s at the top of the file are a definite improvement on command-line 
arguments.


>> OCamlDep would simply treat any namespace for which it could find
>> no ".ns" file as an implicit namespace.
>
>I have to admit that I'm a little bit lost and I don't really know which 
>"namespace proposal" we are talking about (mine has only ".ns" file, no 
>other notion of namespaces).

The parts of my post that referred to ocamldep were in response to your 
commments about my addition to your proposal (I think I see how you got 
lost). In other words, they were about adding support for having files like 
"core-mutex.mli" which would automatically be placed in a Core namespace. 
The idea (which I will call implicit namespaces) is that, for convenience, 
you would not need to provide a ".ns" file for these files.

I think that it could cover a majority of the uses of namespaces, while 
still allowing explicit ".ns" files for more complex namespaces and to make 
life easier for build systems. I particularly like how simple this would be 
to explain to a beginner.


From Christophe.Troestler at umons.ac.be  Wed Feb 27 09:55:43 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Wed, 27 Feb 2013 10:55:43 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBGiaNCetfbWeWWwnj_6cQatWX1dc9b=y-+CGh-m=8BF+w@mail.gmail.com>
References: <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
 <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
 <CAPFanBGiaNCetfbWeWWwnj_6cQatWX1dc9b=y-+CGh-m=8BF+w@mail.gmail.com>
Message-ID: <20130227.105543.1788852644925393142.Christophe.Troestler@umons.ac.be>

On Wed, 27 Feb 2013 07:58:41 +0100, Gabriel Scherer wrote:
> 
> I don't like your lazy initialization scheme because it changes the
> observable semantics of the the OCaml language when modules have
> global side-effects. Currently, the effects are evaluated in the
> linking order of the modules, not the use order.

For practical purposes this lazy initialization scheme may be
restricted to packed modules and module aliasing ("module A = B" where
neither A nor B is not used by other values ? this is already
detected?? in the module and B belongs to a packed unit).  I do not
think that people rely on the command line order for packed modules or
even for .cm[x]a libraries.  In the case order matters because of
dependencies, this would be tracked and compilations units would be
topologically ordered w.r.t. this dependency graph so this would be an
added bonus for the user.

> Note that the main difficulty of your proposal is to track
> dependencies at a structure item level, rather than at a compilation
> unit level as is currently done.

Not if we limit it to packed modules ? you already have the cmo/cmx
and in this context I see packing as putting them in a .cm[x]a and
adding a module with submodules pointing to (aliasing) these
compilation units.  These pointers would actually be initialized (and
trigger linking) on actual usage.  [If this was adopted, I think
nobody would object if packing generated a cm[x]a instead of a
cmo/cmx.]

> Lazyness is arguably bad and in any case not needed if you have this
> finer granularity

Would you mind to explain?

> -- but as I argued this would have large, and possibly unpleasant,
> implementation implications.

I can't argue on that ? not knowing much about the compiler internals.
However, it naively seems to me that the proposal relies on many
things that already exist.  Is is possible to have a more detailed
description of why the changes would be so invasive?

From daniel.buenzli at erratique.ch  Wed Feb 27 15:42:06 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Wed, 27 Feb 2013 16:42:06 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302271416410.14929@hermes-1.csi.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <Prayer.1.3.5.1302271416410.14929@hermes-1.csi.cam.ac.uk>
Message-ID: <46BF54AF316D44E4A8436DF0D2051AF5@erratique.ch>

Le mercredi, 27 f?vrier 2013 ? 15:16, Leo White a ?crit :
> It is difficult to provide examples of people doing something that is not  
> currently supported. Using the compiler itself as source of possible module  
> names, I see the following module names that I could easily picture  
> multiple libraries using:
>  
> Warnings, Tbl, Misc, Config, Errors, Env, Types,
> Protocol, Shell, Common, Table, Log, Options

The question is whether these things would be really linked in separately, i.e. if usage of the library does not automatically entails usage of these modules, if it does then something like -pack is sufficient. In the libraries I distribute all the examples of (manual) packs I have are of this nature (Cmdliner and React).  

The first example I hit so far where I thought about "the don't want to link everything" is this unreleased gg module where a 2D program wouldn't care about the 3D stuff. While gg.o is still only 300k, maybe it's only a sign that gg is not modular enough and that it should be factored out into gg2 and gg3 with gg3 depending on gg2 (3d usually needs the 2d stuff anyways).

I wonder if the need for namespaces is only really meaningfull for "battery-like" projects that aim at overtaking your whole source (where -pack is obviously not a solution). But now that we have build tools like opam/oasis/ocamlfind that allow us to easily specify package dependencies couldn't maybe these huge libraries modularize their design and distribute their functionality in smaller composable units ?

> I think that it is a little dangerous to judge how much people would use a  
> proposal based on how many people used its complicated and deeply flawed  
> predecessor.

I don't think it's deeply flawed, it's flawed in the hands of people that didn't understand its implication (and has historically been used by such hands). It works perfectly well for libraries in which all submodules are anyways linked in and I think that for well defined components that have a clear idea on what service they provide this happens more often than you'd think.

Daniel




From yminsky at janestreet.com  Wed Feb 27 16:12:51 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 27 Feb 2013 11:12:51 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <1EE73E7CFD924274842D05B2ECE9A5A4@erratique.ch>
References: <CACLX4jQWSsBaLt3fCJKr4qQKNT7QKtNcXMwn=JQanH9eHPzvbQ@mail.gmail.com>
 <20130225.214340.384795549076963237.Christophe.Troestler@umons.ac.be>
 <Prayer.1.3.5.1302261230150.13439@hermes-1.csi.cam.ac.uk>
 <20130226.232604.1596589063095261139.Christophe.Troestler@umons.ac.be>
 <CAPFanBGiaNCetfbWeWWwnj_6cQatWX1dc9b=y-+CGh-m=8BF+w@mail.gmail.com>
 <1EE73E7CFD924274842D05B2ECE9A5A4@erratique.ch>
Message-ID: <CACLX4jQm7EtyDKKBH7wqTxzv9JsNCNrwcMKTtmoUbMuw5YLe_w@mail.gmail.com>

On Wed, Feb 27, 2013 at 3:49 AM, Daniel B?nzli
<daniel.buenzli at erratique.ch> wrote:
> Le mercredi, 27 f?vrier 2013 ? 07:58, Gabriel Scherer a ?crit :
>> I don't like your lazy initialization scheme because it changes the
>> observable semantics of the the OCaml language when modules have
>> global side-effects. Currently, the effects are evaluated in the
>> linking order of the modules, not the use order.
>
> You are right that it may not be sensible to change that now. On the
> other hand IIRC my delves into module research a few years ago, in
> fact the strict initialization semantics combined with the
> structural (vs nominal) aspect is the source of many headaches,
> notably the recursive module issue.
>
> While Leo convinced me that "solving pack" won't help us given the
> current runtime module semantics. I'm rather dubious about the
> namespace solution since for me (1) If we follow what Yaron wants
> (and that in someway I also do want) a namespace eventually looks
> diabolically like a module, at least when you open it (2) It doesn't
> seem to solve the problem for the small library I mentioned (can now
> be peek at here [1]) or at least it doesn't allow to me to write it
> the simple way I'd like to write it.
>
> At that point, I would personally, rather wait for the longer term
> solutions Didier mentions backed by solid type system research (if
> that actually solves these problems, I'm no longer up-to-date with
> these things, e g. Rossberg's 2013 paper) rather than integrate
> solutions that seem to be guided by ad-hoc considerations. But I
> guess that's not an option for the platform.

I think the Core.Std problem is urgent now.  Compilation times and
executables sizes are absolutely brutal.  I don't think it makes sense
to wait.

> Daniel
>
> [1] https://github.com/dbuenzli/gg
>
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Wed Feb 27 16:31:28 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 27 Feb 2013 11:31:28 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512E0588.3000003@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
Message-ID: <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>

Let me try to summarize the current situation about the argument
between Alain, Leo and myself.  I think Leo and I are roughly on the
same page, but I may be missing things.

- MAKING LONG NAMES AVAILABLE.  Alain prefers to have unambiguous long
  names that are usable in a first class way.  I find this mildly
  distasteful, but would be OK with it as long as it was well hidden
  from the user by default.  Long names shouldn't show up by default
  in source files, error messages or documentation.  I view this as
  quite important for usability of namespaces.

- SOURCE-LEVEL OPENS.  Alain would prefer to have namespace
  manipulations restricted to the command line, and therefore the
  build system.  He thinks of namespaces as something that should be
  used pretty rarely (or at least, there should be very few
  namespaces), and it's therefore OK to push them to the outside.

  Leo and I both believe this is a big mistake.  We expect opens to
  happen fairly commonly, and for there to be many different libraries
  that are organized as namespaces.

  Alain doubts that there would be many module-name clashes.  I
  disagree on this point as does Leo.  We use packed modules
  pervasively (for /every/ library), and as a result, we have lots of
  little namespaces, and lots of repeated names within them (names
  like Common, Protocol, Spec, Config, etc.)

  My biggest objection to having opens be at the build system level is
  that it makes your code more ambiguous.  When you do namespace
  manipulations, you very much want to see what's happening by
  inspecting the source.  We have a vigorous code review system here,
  and I don't want to start adding code review of the build rules to
  it, and this change would require that.

  Alain's claim that opens are a bad thing also seems wrong to me.
  opens should be rare, but all of our proposals involve the
  equivalent of opening a namespace.  Alain is not saying we should
  have none of that (after all, we're all glad that Pervasives is
  opened!).  But what Alain is proposing is to make opening a
  namespace silent at the source level.  This strikes me as a grave
  error.

- NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
  namespace to also implicitly open some modules, this essentially
  adding values to the search path in addition to modules.  I would be
  sad to lose this feature, but I don't think it's absolutely
  essential.  It would merely add boilerplate.  Roughly speaking,
  every time a user of Core writes

     open namespace Core#Std

  instead of

     open namespace Core#Std
     open Core#Std.Common

  they're making a mistake.  I'd like to avoid this error, and I don't
  know really what the objection to the feature is, but in the worst
  case, we can add a syntax extension to work around this problem,
  using a -ppx transformer to add the open ourselves.



On Wed, Feb 27, 2013 at 8:09 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/27/2013 12:51 PM, Leo White wrote:
>>
>> Without an open statement your proposal does not scale well. The main
>> need for namespaces arises out of the fact that people choose the same
>> short names for their modules. This will still be the case for the names
>> people choose within their ".ns" files. As soon as I want to use two
>> libraries that contain modules with the same short name, your proposal
>> will have the meaning of the short name decided by the order of
>> command-line arguments. This seems very fragile.
>
>
> I want to see concrete examples!  I don't believe that it is common, in the
> same unit, to access two modules called "List" from two different libraries.
> Maybe you want to use both String.Set and Int.Set, but you're not going to
> "open" String and Int anyway.  You may also want to use Xmllight.parse and
> Xmlm.parse (although it is not clear that this will happen in the same
> module), but you're not going to open Xmllight or Xmlm globally in your
> unit.
>
>
>> I also think that open statements (even at the top of a file) are a very
>> good thing.
>
>
> If put at the top of the file, I don't see them as fundamentally different
> from command-line arguments, and the meaning of the short name is decided by
> the order of open statements, which is also quite fragile.
>
> And "open statements" (for modules, not even namespaces) are generally
> considered as a dangerous feature, because they are the source of technical
> problems (dependency analysis), because they make the code harder to read
> and refactorize, and because it makes modules more fragile (if a module B is
> extended with more components, they can hide components with the same name
> from another module A which is open before B in some client code).  Making
> "opens" more local is a way to reduce those problems.  I'm thus surprised by
> your claim that open statements are very good thing.
>
>
>
>> They show which libraries the file is going to use.
>
>
> This seems to confirm that what you're aiming at is really a way to specify
> in the source code which libraries are used.  But then we should push the
> reasoning further and ensure this specification is the only one required to
> use a library.  Why should we accept to pass -I / -pp / -ppx flags to the
> compiler (and specify again libraries at link time) when the information is
> already part of the source code?
>
>
>
>> Currently, a file using a library that does not use pack will simply
>> launch straight into using modules with short names that give no
>> indication of their origin.
>
>
> Many of the third-party libraries I use export a single module, which I
> never "open", and whose name is unique enough to avoid clashes (e.g.
> Postgresql, Sqlite3, Xmlm).  Some libraries use prefixes (Nethtml, with an
> internal Nethtml_scanner module; Lwt comes with Lwt_util, Lwt_condition,
> Lwt_mutex, etc).  It would have been crazy, indeed, for Nethtml to have an
> internal "Scanner" module, or for Lwt to expose a "Mutex" module.  I'm fine
> with this situation, but I can understand that in some cases, it would make
> sense, for instance, to alias Lwt_mutex to Mutex in a given project.
>
> So I don't agree with the opinion that -pack is currently the only way to
> avoid clashes!  It would be useful to get some statistics about the use of
> -pack in OPAM.
>
>
>
>> I must look in the build system to find out
>>
>> what they refer to. By encouraging people to use namespaces, these files
>> will instead start with "open namespace Foo", and it will be obvious
>> what libraries they are using.
>
>
> So if you have a program like:
>
>  open namespace Foo
>  open namespace Bar
>
>  (* ... several hundreds of lines ... *)
>
>   .... Baz.parse ...
>
> then, yes, you know that this program uses the Foo and Bar
> libraries/namespaces, but you have no idea where Baz comes from.  This is
> fine, as long as you don't have clashes of "short" names, i.e. Foo and Bar
> are different enough to not provide top-level components of the same name.
>
>
>> As OPAM (and the platform) become more widely used I expect there to be
>> many more small convenience libraries. This will increase the number of
>> libraries that are being used within a single project, and it will be
>> useful to know from the source files themselves which files use which
>> libraries.
>
>
> I like this idea of putting more information in the source code about a file
> "requirements" (let's say, which libraries are used).  This could be
> interpreted directly by the compiler (if there is a well-defined convention
> on how libraries are located and invoked) or by a driver such as ocamlfind.
> Currently, library dependencies are specified on the command-line (hence in
> the build system) and I agree it makes sense to allow specifying that in the
> source code.
>
>
>> I understand that for backwards compatibility it is useful to be able to
>> use files via both a namespaced name and a traditional name. However,
>> when not worried about backwards compatibility, we should instead be
>> focussed on providing a coherent story about how OCaml components are
>> named and how these names are managed. For me, this means (for a
>> non-backwards compatible library) only providing (or at least actively
>> encouraging) access to components through namespaces.
>
>
> I understand your point and I think it makes sense if "namespaces" are
> indeed to be added to the language.
>
>
>>> Worse: if we use "ocamldep -modules", this resolution has to be done
>>> by the build system, so this complex logic (which depends on the
>>> location in the source file) will have to be re-implemented in omake
>>> and other build systems around.  It is an important property that
>>> "ocamldep -modules" does not need to look for the existence of
>>> compiled units on the current tree.
>>
>>
>> Firstly, I would like to make clear that this would be no problem for
>> build systems that used makefile formatted ocamldep output.
>
>
> Indeed.  However, "ocamldep -modules" has been added for good reasons and it
> is the recommended way to use omake.  (And don't know about ocamlbuild.)
> omake is used by some of the largest OCaml code base around.
>
>
>> "ocamldep -modules" has always produced an over-estimate of the modules
>> that a file uses and then allowed the build system to figure out the
>> rest.
>
>
> "ocamldep -modules" does not produce more false dependencies than
> "ocamldep".  I'd rather say that "ocamldep" (without -modules) misses some
> dependencies (for generated files which are not yet present when ocamldep is
> executed).
>
>
>
>> OCamlDep would simply treat any namespace for which it could find
>> no ".ns" file as an implicit namespace.
>
>
> I have to admit that I'm a little bit lost and I don't really know which
> "namespace proposal" we are talking about (mine has only ".ns" file, no
> other notion of namespaces).
>
>
>
> Alain

From alain.frisch at lexifi.com  Wed Feb 27 17:19:26 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 27 Feb 2013 18:19:26 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <Prayer.1.3.5.1302271416410.14929@hermes-1.csi.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <Prayer.1.3.5.1302271416410.14929@hermes-1.csi.cam.ac.uk>
Message-ID: <512E401E.7090504@lexifi.com>

On 02/27/2013 03:16 PM, Leo White wrote:
> It is difficult to provide examples of people doing something that is
> not currently supported. Using the compiler itself as source of possible
> module names, I see the following module names that I could easily
> picture multiple libraries using:
>
> Warnings, Tbl, Misc, Config, Errors, Env, Types,
> Protocol, Shell, Common, Table, Log, Options

It's a good example indeed.  I interpret this situation as the 
consequence of the fact that the compiler has been designed as a 
program, not a reusable library.  The "long filename" approach would be 
to call the source files e.g. ocaml_location, ocaml_env, ocaml_types, 
etc, and use locally, in the source tree, a ocaml.ns file to keep short 
names (Location, Env, Types) in the source code.  Note that implementing 
this refactoring would be very light (rename files in the repository, 
create the .ns filem, adapt the Makefiles accordingly).

A third-party tool could use long names like Ocaml_location, Ocaml_env 
(or explicitly alias those modules to shorter names locally).  But 
indeed, this might be a case where it would make sense to "open 
ocaml.ns" locally, only in, say, in given function of the third-party tool.

>> use Xmllight.parse and Xmlm.parse (although it is not clear that this
>> will happen in the same module), but you're not going to open Xmllight
>> or Xmlm globally in your unit.
>
> But I might open Xmlm and Json (an imaginary json parsing library) in
> the same unit.

I don't think I'd ever want to open such modules globally (maybe only as 
a local open in a few functions).  It would make the code more obscure 
(what does "parse" do?), and is likely to create clashes.

>>> Currently, a file using a library that does not use pack will simply
>>> launch straight into using modules with short names that give no
>>> indication of their origin.
>>
>
>> So I don't agree with the opinion that -pack is currently the only way
>> to avoid clashes!  It would be useful to get some statistics about the
>> use of -pack in OPAM.
>
> I think that it is a little dangerous to judge how much people would use
> a proposal based on how many people used its complicated and deeply
> flawed predecessor.

I was referring to your "currently" sentence.  I know some libraries use 
-pack, but luckily a lot of libraries don't do that, and I believe it is 
a useful piece of information for this discussion to get some statistics 
about this.



Alain

From edwin+ml-ocaml at etorok.net  Wed Feb 27 17:24:12 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Wed, 27 Feb 2013 19:24:12 +0200
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
Message-ID: <512E413C.1060602@etorok.net>

On 02/27/2013 06:31 PM, Yaron Minsky wrote:
> Let me try to summarize the current situation about the argument
> between Alain, Leo and myself.  I think Leo and I are roughly on the
> same page, but I may be missing things.
> 
> - MAKING LONG NAMES AVAILABLE.  Alain prefers to have unambiguous long
>   names that are usable in a first class way.  I find this mildly
>   distasteful, but would be OK with it as long as it was well hidden
>   from the user by default.  Long names shouldn't show up by default
>   in source files, error messages or documentation.  I view this as
>   quite important for usability of namespaces.
> 
> - SOURCE-LEVEL OPENS.  Alain would prefer to have namespace
>   manipulations restricted to the command line, and therefore the
>   build system.  He thinks of namespaces as something that should be
>   used pretty rarely (or at least, there should be very few
>   namespaces), and it's therefore OK to push them to the outside.
> 
>   Leo and I both believe this is a big mistake.  We expect opens to
>   happen fairly commonly, and for there to be many different libraries
>   that are organized as namespaces.
> 
>   Alain doubts that there would be many module-name clashes.  I
>   disagree on this point as does Leo.  We use packed modules
>   pervasively (for /every/ library), and as a result, we have lots of
>   little namespaces, and lots of repeated names within them (names
>   like Common, Protocol, Spec, Config, etc.)
> 
>   My biggest objection to having opens be at the build system level is
>   that it makes your code more ambiguous.  When you do namespace
>   manipulations, you very much want to see what's happening by
>   inspecting the source.  We have a vigorous code review system here,
>   and I don't want to start adding code review of the build rules to
>   it, and this change would require that.
> 
>   Alain's claim that opens are a bad thing also seems wrong to me.
>   opens should be rare, but all of our proposals involve the
>   equivalent of opening a namespace.  Alain is not saying we should
>   have none of that (after all, we're all glad that Pervasives is
>   opened!).  But what Alain is proposing is to make opening a
>   namespace silent at the source level.  This strikes me as a grave
>   error.
> 
> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>   namespace to also implicitly open some modules, this essentially
>   adding values to the search path in addition to modules.  I would be
>   sad to lose this feature, but I don't think it's absolutely
>   essential.  It would merely add boilerplate.  Roughly speaking,
>   every time a user of Core writes
> 
>      open namespace Core#Std
> 
>   instead of
> 
>      open namespace Core#Std
>      open Core#Std.Common
> 
>   they're making a mistake.  I'd like to avoid this error, and I don't
>   know really what the objection to the feature is, but in the worst
>   case, we can add a syntax extension to work around this problem,
>   using a -ppx transformer to add the open ourselves.

I'd like to add a suggestion  for the last last two requirements, from an OCaml user's perspective (i.e. not a platform/platform library implementor).
I don't feel too strongly about what the exact syntax or build system requirements are for namespaces, its just a suggestion.

core/std/common.mli:
namespace Core#Std
(* define a module Common in the Core#Std namespace.
 *  Effect: rename module to Core#Std.Common in the .cmi *)
....

core/std/common.ml:
namespace Core#Std
(* define a module Common in the Core#Std namespace.
 *  Effect: rename module to Core#Std.Common in the .cmi *)
....

Optionally one could also specify -root <path> on the cmdline to automatically create a namespace based on directory hierarchy.
If both are specified its checked that they are equal, and if not an error is shown.

core.mli:
namespace Std = struct
  module Core#Std.Common (* defines that this module is part of the namespace *)
  module Core#SomethingElse.SomeOtherModule
  open Core#Std.Common
  (* defines the Core#Std namespace in the .cmi, and the list of default opens to Core#Std.Common *)
  (* each namespace must have a .cmi named after its toplevel name
end


file_using_core.ml:
open Core#Std (* this opens the Core#Std namespace, and the Core#Std.Common module *)
(* Core#Std is of type 'namespace', so the compiler would know you open a namespace without having to explicitly say so with a keyword *)

(* you could even write *)
open Core (* opens Core namespace *)
open Std.Common (* opens Core#Std.Common module *)

namespace aliasing, and toplevel use:
> namespace Foo = Core#Std
namespace Foo = <
  module Core#Std.Common: sig .... end
  module Core#Std.SomeModule: sig .... end
   ... all modules ...
  open Core#Std.Common

How to find the module Foo#Bar.M:
 when searching for .cmi files:
   look for foo.cmi, and check namespace definitions inside
 when searching for .cmx/.cmo files (this is not optimal!):
   look for m.cmx/m.cmo, and check that full module name is good, skip to next in search path if not
 when searching for .cmxa/.cma files:
   look for a foo.cmxa/foo.cma -> defines all modules for namespace Foo.
At link time only the modules that are actually used are kept (since opening a namespace doesn't have side-effects, unused namespaces/modules can be thrown away).

Best regards,
--Edwin

From xavier.clerc at inria.fr  Wed Feb 27 17:47:42 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 27 Feb 2013 18:47:42 +0100 (CET)
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
Message-ID: <1730018327.495298.1361987262189.JavaMail.root@inria.fr>

----- Mail original -----
> Let me try to summarize the current situation about the argument
> between Alain, Leo and myself.  I think Leo and I are roughly on the
> same page, but I may be missing things.

(...)

> - SOURCE-LEVEL OPENS.  Alain would prefer to have namespace
>   manipulations restricted to the command line, and therefore the
>   build system.  

(...)

>   My biggest objection to having opens be at the build system level
>   is
>   that it makes your code more ambiguous.  When you do namespace
>   manipulations, you very much want to see what's happening by
>   inspecting the source.

I concur. Moreover, even if I am not sure that imitation is the
sincerest form of flattery... I think we should have a look at
how other languages deal with namespaces.

Personal experience never exposed me to a language where namespaces
are solely expressed in the build system. OCaml already looks
alien enough to unevangelized people :-)


Xavier

From alain.frisch at lexifi.com  Wed Feb 27 18:10:48 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 27 Feb 2013 19:10:48 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
Message-ID: <512E4C28.5070608@lexifi.com>

On 02/27/2013 05:31 PM, Yaron Minsky wrote:
> Let me try to summarize the current situation about the argument
> between Alain, Leo and myself.  I think Leo and I are roughly on the
> same page, but I may be missing things.
>
> - MAKING LONG NAMES AVAILABLE.  Alain prefers to have unambiguous long
>    names that are usable in a first class way.  I find this mildly
>    distasteful, but would be OK with it as long as it was well hidden
>    from the user by default.  Long names shouldn't show up by default
>    in source files, error messages or documentation.  I view this as
>    quite important for usability of namespaces.

I don't understand how the user is supposed to interpret names in error 
messages or documentation without explicitly qualified names.  It is ok, 
indeed, to assume that within the documentation of Core, references to 
its "List" module are written as "List", but then references to other 
List modules from other libraries would need to use their long names, 
right?   If another library, not part of Core, references types from 
Core_list, should we use simply "List" in its documentation?  Maybe, 
because Core is intended to be a real replacement of the stdlib, but 
this would perhaps not apply to other libraries, and it should certainly 
not be the default to always use short names for external references.

Being able to say for a given unit which name mapping is in scope is 
useful.  This allows ocamldoc and error messages to use this mapping to 
use short names.  But there is also the request of being able to import 
a name mapping locally, for a sub-structure or locally in a function. 
While I understand this can be useful as a convenience for the 
programmer (example: a tool which needs to use locally the compiler-libs 
could import "ocaml.ns" in a restricted scope), I think it would create 
confusion to use those local mapping to shorten error messages.


> - SOURCE-LEVEL OPENS.  Alain would prefer to have namespace
>    manipulations restricted to the command line, and therefore the
>    build system.  He thinks of namespaces as something that should be
>    used pretty rarely (or at least, there should be very few
>    namespaces), and it's therefore OK to push them to the outside.

This does not completely reflect my position.  My initial proposal was 
about an "open namespace" statement which imports module aliases from a 
.ns file locally.  I've then restricted this proposal to only allow 
importing .ns file globally, and to do that on the command-line in order 
to make the use of "stdlib replacements" as transparent as the official 
stdlib for programmers.  I thought this would be a good thing for Core. 
  Now Leo and you have convinced me that (i) being able to import .ns 
file locally is also quite useful; (ii) allowing to specify global .ns 
file on the command-line is neither necessary nor a good idea.  So let 
me retract my simplified proposal and stick to the original one.

That said, I still believe that one needs a way to tell for instance 
ocamldoc which .ns files to use to shorten references when generating 
the documentation for a given module.  And I believe it would be 
extremely confusing for users to allow to use different .ns files on the 
same page, depending on "open .ns" statements in the .mli file.  So 
either ocamldoc should get this information from the command-line, or it 
should find in the source code itself.  I don't really care, as long as 
this is restricted to a global choice for a given unit.

> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>    namespace to also implicitly open some modules, this essentially
>    adding values to the search path in addition to modules.  I would be
>    sad to lose this feature, but I don't think it's absolutely
>    essential.

I've a preference for keeping independent notions as separate in the 
language design even if they are commonly used together.  But I agree, 
this is a non fundamental issue.



Alain

From yminsky at janestreet.com  Wed Feb 27 19:32:59 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 27 Feb 2013 14:32:59 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512E4C28.5070608@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <512E4C28.5070608@lexifi.com>
Message-ID: <CACLX4jQJ=dkSAHtCjrB22imC1mWdjfD_thNQWONTiTtFa2qK1g@mail.gmail.com>

On Wed, Feb 27, 2013 at 1:10 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/27/2013 05:31 PM, Yaron Minsky wrote:
>>
>> Let me try to summarize the current situation about the argument
>> between Alain, Leo and myself.  I think Leo and I are roughly on the
>> same page, but I may be missing things.
>>
>> - MAKING LONG NAMES AVAILABLE.  Alain prefers to have unambiguous long
>>    names that are usable in a first class way.  I find this mildly
>>    distasteful, but would be OK with it as long as it was well hidden
>>    from the user by default.  Long names shouldn't show up by default
>>    in source files, error messages or documentation.  I view this as
>>    quite important for usability of namespaces.
>
>
> I don't understand how the user is supposed to interpret names in
> error messages or documentation without explicitly qualified names.
> It is ok, indeed, to assume that within the documentation of Core,
> references to its "List" module are written as "List", but then
> references to other List modules from other libraries would need to
> use their long names, right?  If another library, not part of Core,
> references types from Core_list, should we use simply "List" in its
> documentation?  Maybe, because Core is intended to be a real
> replacement of the stdlib, but this would perhaps not apply to other
> libraries, and it should certainly not be the default to always use
> short names for external references.

Garrigue's short-paths patch already goes a long way in this
direction, chopping opened modules from error messages.  Thus, if you
open Core.Std, a Hashtbl.t will show up as "Hashtbl.t", not
"Core.Std.Hashtbl.t".  We are generally quite happy with this outcome,
and it works well in our context.  We'd be happy with the same
behavior with namespaces.

For what it's worth, a Core.Std.List.t actually renders as "list",
since there is a type-equivalence there, and the short-paths patch
picks, well, the type with the shortest path to display.  We're very
happy with this behavior.

I would very much want this to be done for all libraries, not just
Core.  For example, we'd like the same behavior when we open
Async.Std, or, for that matter, My_special_purpose_library.Std.

> Being able to say for a given unit which name mapping is in scope is useful.
> This allows ocamldoc and error messages to use this mapping to use short
> names.  But there is also the request of being able to import a name mapping
> locally, for a sub-structure or locally in a function. While I understand
> this can be useful as a convenience for the programmer (example: a tool
> which needs to use locally the compiler-libs could import "ocaml.ns" in a
> restricted scope), I think it would create confusion to use those local
> mapping to shorten error messages.

The version of this in Garrigue's short-paths patch has been quite
good to us.  That experience leads me to think it's not too
problematic more generally.

>
>
>> - SOURCE-LEVEL OPENS.  Alain would prefer to have namespace
>>    manipulations restricted to the command line, and therefore the
>>    build system.  He thinks of namespaces as something that should be
>>    used pretty rarely (or at least, there should be very few
>>    namespaces), and it's therefore OK to push them to the outside.
>
>
> This does not completely reflect my position.  My initial proposal was about
> an "open namespace" statement which imports module aliases from a .ns file
> locally.  I've then restricted this proposal to only allow importing .ns
> file globally, and to do that on the command-line in order to make the use
> of "stdlib replacements" as transparent as the official stdlib for
> programmers.  I thought this would be a good thing for Core.  Now Leo and
> you have convinced me that (i) being able to import .ns file locally is also
> quite useful; (ii) allowing to specify global .ns file on the command-line
> is neither necessary nor a good idea.  So let me retract my simplified
> proposal and stick to the original one.

Great!

> That said, I still believe that one needs a way to tell for instance
> ocamldoc which .ns files to use to shorten references when generating the
> documentation for a given module.  And I believe it would be extremely
> confusing for users to allow to use different .ns files on the same page,
> depending on "open .ns" statements in the .mli file.  So either ocamldoc
> should get this information from the command-line, or it should find in the
> source code itself.  I don't really care, as long as this is restricted to a
> global choice for a given unit.

I agree with this.

>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>    namespace to also implicitly open some modules, this essentially
>>    adding values to the search path in addition to modules.  I would be
>>    sad to lose this feature, but I don't think it's absolutely
>>    essential.
>
>
> I've a preference for keeping independent notions as separate in the
> language design even if they are commonly used together.  But I agree, this
> is a non fundamental issue.

I see your point about independence, but in my mind, the difference
between managing the namespace of modules and managing the namespace
of values is of more interest to compiler implementors than language
users.  These are really quite close to the same concept, and does
comparatively little semantic violence.

y

From Maxence.Guesdon at inria.fr  Wed Feb 27 19:47:19 2013
From: Maxence.Guesdon at inria.fr (Maxence Guesdon)
Date: Wed, 27 Feb 2013 20:47:19 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <1730018327.495298.1361987262189.JavaMail.root@inria.fr>
References: <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <1730018327.495298.1361987262189.JavaMail.root@inria.fr>
Message-ID: <20130227204719.46012fc7@alcazar>

On Wed, 27 Feb 2013 18:47:42 +0100 (CET)
Xavier Clerc <xavier.clerc at inria.fr> wrote:

> ----- Mail original -----
> > Let me try to summarize the current situation about the argument
> > between Alain, Leo and myself.  I think Leo and I are roughly on the
> > same page, but I may be missing things.
> 
> (...)
> 
> > - SOURCE-LEVEL OPENS.  Alain would prefer to have namespace
> >   manipulations restricted to the command line, and therefore the
> >   build system.  
> 
> (...)
> 
> >   My biggest objection to having opens be at the build system level
> >   is
> >   that it makes your code more ambiguous.  When you do namespace
> >   manipulations, you very much want to see what's happening by
> >   inspecting the source.
> 
> I concur. Moreover, even if I am not sure that imitation is the
> sincerest form of flattery... I think we should have a look at
> how other languages deal with namespaces.
> 
> Personal experience never exposed me to a language where namespaces
> are solely expressed in the build system. OCaml already looks
> alien enough to unevangelized people :-)

I started some F# project some weeks ago. Namespaces are declared in
source code, according to what I saw by now:
  http://msdn.microsoft.com/en-us/library/dd233219.aspx

But I'm really a beginner in this language. If someone on this list
knows about F#, can he/she tell us how it is handled ?

Maxence

From mlin at mlin.net  Wed Feb 27 23:19:55 2013
From: mlin at mlin.net (Mike Lin)
Date: Wed, 27 Feb 2013 15:19:55 -0800
Subject: [ocaml-platform] Is this mandatory to continue this discussion
 [was: on the need and design of OCaml namespaces]
In-Reply-To: <03F0E990-F4CD-4BE3-8BD9-950F5756D6B4@cl.cam.ac.uk>
References: <CAOCAUGMhPVMx9a3OTX_GPtDpgpFVWh4+auVx5Ahw6brMnA1EAw@mail.gmail.com>
 <512C6802.9030404@lexifi.com>
 <CAOCAUGMALCP6Em4dOWVEbNDfVXZnXr35+qMiojq4GdfVSpyV8g@mail.gmail.com>
 <CAPFanBHWRJbjO-arvo-EyBC_fL_Ae4jAhCu4kq=MXOuFfe+tTg@mail.gmail.com>
 <CAOCAUGMr1SUOBXbODb5vmnd9p8VOwcnMzUgkzdV4Jq6+Ws8Q5g@mail.gmail.com>
 <03F0E990-F4CD-4BE3-8BD9-950F5756D6B4@cl.cam.ac.uk>
Message-ID: <CADxsieaE5CQYRzwGJqMhU2UMdTEHcaY0NSKZjjmYJ5T31vF0rQ@mail.gmail.com>

On Tue, Feb 26, 2013 at 3:38 AM, Anil Madhavapeddy <avsm2 at cl.cam.ac.uk>wrote:

> On 26 Feb 2013, at 11:22, Sylvain Le Gall <sylvain+ocaml at le-gall.net>
> wrote:
> >
> > I am not trying to imply that it is non-productive or whatever, I just
> > want to focus on what is needed for the OCaml platform. If people feel
> > this is mandatory, feel free to continue this discussion and ACK that
> > it is required for ocaml platform. I just want to be sure that
> > everyone thinks this is required.
> >
> > IMHO, I think this is not mandatory and I would have expect that the
> > first thread on platform list would be "what packages to choose for
> > v1" or "what are the targets arch" or "what is the deadline" or "what
> > is the policy for including a package in the ocaml-platform". Having
> > discussion that "at best" will postpone OCaml platform v1 until
> > namespaces are implemented, is somehow problematic...
> >
> > The SUCCESS of the ocaml-platform is to deliver something in a few
> months.
>
> Not true. The success of the Platform is to deliver something that
> will be used by serious users of OCaml, and to learn from their experiences
> at the same time.  We obviously don't intend to take years doing it, but
> there's also no mad rush to lash something up in a few weeks.
>

I sympathize with where Sylvain was going with that, though. To learn from
the experiences of serious users of OCaml, you've gotta put something in
their hands. OPAM's 'alpha' period was a great example of shipping early
(clearly with a lot of rough edges) and iterating on it quickly - I hope
you can stick to that model.

So I'd join Sylvain in hoping to see more details/discussion ASAP about
what constitutes the 'minimum viable product' for platform, v1. If we had a
specific backlog like that, it would help people like me know how to
contribute.

Mike
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130227/942b73b3/attachment.html>

From flux-ocaml-platform at inside.org  Thu Feb 28 09:01:01 2013
From: flux-ocaml-platform at inside.org (Erkki Seppala)
Date: Thu, 28 Feb 2013 11:01:01 +0200
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 (Yaron Minsky's message of "Wed, 27 Feb 2013 11:31:28 -0500")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
Message-ID: <m49y5e8stgx.fsf@coffee.modeemi.fi>

TLDR; I agree with the parts of proposal suggesting statement "namespace
X" to be introduced to .ml and .mli files and then statements "open
namespace X", "let namespace Y = X" and their expression forms. And that
this all should be controlled from the source code, not the build
system.

Yaron Minsky <yminsky at janestreet.com> writes:

>   My biggest objection to having opens be at the build system level is
>   that it makes your code more ambiguous.  When you do namespace
>   manipulations, you very much want to see what's happening by
>   inspecting the source.  We have a vigorous code review system here,
>   and I don't want to start adding code review of the build rules to
>   it, and this change would require that.

I agree that namespaces should be defined and accessed through the
source code. Not the least because it depends on the project's chosen
build system on how I should go on changing those definitions. While
currently the situation is the same regarding findlib package
management, I think it is worth considering that perhaps this kind of
namespace system could automatically lead into the build system
(ocamldep?)  inferring which packages you need to use and eliminate that
piece of configuration from the build system. Only special cases would
need more configuration.

While C++ might not be the golden standard to look upon on language
development, perhaps it can serve as an inspiration. Its namespace
system seems to work pretty nicely without complaints from the
developers. It has the following constructs:

namespace X {
  /* introduce values for the namespace X */
  int a = 42;
  namespace Z {
    /* introduce namespace X::Z */
    int b = a;
  }
}

namespace X {
  /* introduce more values for the namespace X */
  int z = 5;
}

namespace Y = X; /* alias a namespace */

int b = X::a; /* access a value in a namespace */

using namespace X; /* bring X to current scope (works in function scope
                      as well */

using X::a; /* bring one value from a namespace to current scope */

In implementation side it works by simply relabeling symbols in the
generated object files which makes the namespaces open.

C++'s compilation system with include files is of course very different
from OCaml, but a similar solution to OCaml would mean having a hidden
internal name (such as namespace_modulename or possibly even something
that like namespace#modulename) for the module created from that
compilation unit. It would need to be limited to a single top-level
namespace specification per compilation unit, so it would work sort of
in reverse compared to C++. For example if x.ml contained statement
"namespace Foo", a module Foo#X would be generated instead of plain X.

This solution would not allow the same module names from different
namespaces to coexist in a single directory, but I don't see this as an
essential feature. The source file names already would be the same, and
OCaml compiler produces object files to the same directory as the
source. If you have a build system copying files around, it could (and
perhaps should!) preserve the directory hierarchy.

> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>   namespace to also implicitly open some modules, this essentially

The previosuly described system would also eliminate the C++-like
ability of introducing values to a namespace, unless special module
names or other changes, such as an automatic opening of some modules,
are implemented. It would be nice to be able to define such top-level
values from multiple compilation units, but I'm uncertain how that would
be implemented.

This approach would need the compiler to find many similarly named .cmi
files and decide the proper one to use based on their contents, as
mentioned in a previous proposal.

Everyone seems to agree that # is a good operator for accessing modules
(or values) from namespaces. Or maybe we could go with \ ;-).

>   But what Alain is proposing is to make opening a namespace silent at
>   the source level.  This strikes me as a grave error.

I agree. At worst this could mean that in large projects developers let
the build system recompile their files so they can see what namespaces
they are using. It seems much better to me to just read it from the
source code, which is the same regardless of the project.

-- 
  _____________________________________________________________________
     / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
    / /_ / // // /\ \/ /                                            \  /
   /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/

From thomas at ocamlpro.com  Thu Feb 28 11:06:57 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Thu, 28 Feb 2013 12:06:57 +0100
Subject: [ocaml-platform] New release of OPAM
Message-ID: <064C1EFD-4FE8-4444-A562-48DA3C4C33C4@ocamlpro.com>

Hi all,

I've released 0.9.4 yesterday. Main changes:
* Disable auto-removal of unused dependencies. This can now be enabled on-demand using `-a`
* Fix compilation and basic usage on Cygwin
* Fix BSD support (use `type` instead of `which` to detect existing commands)
* Add a way to tag external dependencies in OPAM files
* Better error messages when trying to upgrade pinned packages
* Display `depends` and `depopts` fields in `opam info`
* `opam info pkg.version` shows the metadata for this given package version
* Add missing `doc` fields in `.install` files
* `opam list` now only shows installable packages

Remark: compilation from the source archive seems to be broken on Linux, you'll need a patch[1] to make it work.

Tthe last 2 feature requests I'm working on before 1.0.0 are:
* https://github.com/OCamlPro/opam/issues/306 and
* https://github.com/OCamlPro/opam/issues/185

I don't have any blocker bugs anymore so I'm quite confident to announce the first stable release next week. I stil welcome patches to improving the portability of OPAM.

Best,
Thomas

[1] https://github.com/OCamlPro/opam/commit/fb6b37abfa2bfb39f5450fdc0c4ec9cd6b777fdd.diff


From anil at recoil.org  Thu Feb 28 12:41:56 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 28 Feb 2013 12:41:56 +0000
Subject: [ocaml-platform] New release of OPAM
In-Reply-To: <064C1EFD-4FE8-4444-A562-48DA3C4C33C4@ocamlpro.com>
References: <064C1EFD-4FE8-4444-A562-48DA3C4C33C4@ocamlpro.com>
Message-ID: <11B1AF04-9D6E-4080-A8EF-89F04261C904@recoil.org>

On 28 Feb 2013, at 11:06, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:

> Hi all,
> 
> I've released 0.9.4 yesterday. Main changes:
> * Disable auto-removal of unused dependencies. This can now be enabled on-demand using `-a`
> * Fix compilation and basic usage on Cygwin
> * Fix BSD support (use `type` instead of `which` to detect existing commands)
> * Add a way to tag external dependencies in OPAM files
> * Better error messages when trying to upgrade pinned packages
> * Display `depends` and `depopts` fields in `opam info`
> * `opam info pkg.version` shows the metadata for this given package version
> * Add missing `doc` fields in `.install` files
> * `opam list` now only shows installable packages
> 
> Remark: compilation from the source archive seems to be broken on Linux, you'll need a patch[1] to make it work.

I've sent in a pull request for MacOS X Homebrew, and updated the Debian packages for amd64 at:

deb http://www.recoil.org/~avsm/ wheezy main

(still unsigned).

> Tthe last 2 feature requests I'm working on before 1.0.0 are:
> * https://github.com/OCamlPro/opam/issues/306 and
> * https://github.com/OCamlPro/opam/issues/185
> 
> I don't have any blocker bugs anymore so I'm quite confident to announce the first stable release next week. I stil welcome patches to improving the portability of OPAM.

It may be worth waiting for the depext stuff to go into the repository so we're sure that works. I'm going to try and find some time this weekend to convert my Jenkins notes into the repository itself.

-anil

From gabriel.scherer at gmail.com  Thu Feb 28 12:44:59 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 28 Feb 2013 13:44:59 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <m49y5e8stgx.fsf@coffee.modeemi.fi>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
Message-ID: <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>

I think the whole discussion of "compilation argument vs. information
in source header" is misguided. The two places are essentially
isomorphic, and a robust system could make them equi-expressive. In
particular, the idea that what putting namespace information outside
the source code is a regression is incorrect, as the semantics of an
OCaml program *already* depends on the state of the filesystem on
which it is compiled and the search path set at compilation time.
Namespaces by themselves introduce no regression or improvement on
this aspect.

There are practical reasons why one would favor one or the approach in
a particular case, but it is not possible to satisfy all criterions
simultaneously.

1. People are very sensitive about *source language* changes, not so
much about changes in compilation interface (perceived as anecdotical
tooling); this makes it easier to suggest new flags than new language
features. Arguably both should treated with the same care, and in
particular design decisions regarding tooling should be inspected with
scientific rigor. This doesn't happen in practice (which of the
proposed tool changes during this discussion was accompanied with a
rigorous specification of the semantics?), so tooling changes are
easier and faster to get in a language release, and easier to get
half-specified and half-baked.

2. Such header information may need to be shared by several files of a
project and may become a source of painful redundancy. Compilation
flags are an easy way to factorize these redundancies away. In
principle this could also be done in the source code (by having
separate files with this source information, and a semantic
#include-like language construct), but this means yet another language
change that has to be carefully designed.

3. People naturally share source snippets without thinking of sharing
the surrounding contextual information (the state of the compilation
environment), so in practice having information in the source helps to
be more robust wrt. environmental change. In mails, Q&A sites, etc.,
sharing source text is better than a tarball with a _tags file or
whatnot.


It's well and good to hope that any semantic features associated to
namespaces will eventually end up in the source language as well. But
that may be significantly harder than agreeing on those features in
the first place. Because picking a good syntax is really hard, and
because this may require more change to other tools that are not part
of the OCaml compiler distribution, and is therefore more costly for
everyone involved (this is Alain's understandable reason for shunning
any such change). So I would like to encourage people to discuss which
semantics they need and want, what a good design would be, rather than
whether to implement this inside or outside the source language.


On Thu, Feb 28, 2013 at 10:01 AM, Erkki Seppala
<flux-ocaml-platform at inside.org> wrote:
> TLDR; I agree with the parts of proposal suggesting statement "namespace
> X" to be introduced to .ml and .mli files and then statements "open
> namespace X", "let namespace Y = X" and their expression forms. And that
> this all should be controlled from the source code, not the build
> system.
>
> Yaron Minsky <yminsky at janestreet.com> writes:
>
>>   My biggest objection to having opens be at the build system level is
>>   that it makes your code more ambiguous.  When you do namespace
>>   manipulations, you very much want to see what's happening by
>>   inspecting the source.  We have a vigorous code review system here,
>>   and I don't want to start adding code review of the build rules to
>>   it, and this change would require that.
>
> I agree that namespaces should be defined and accessed through the
> source code. Not the least because it depends on the project's chosen
> build system on how I should go on changing those definitions. While
> currently the situation is the same regarding findlib package
> management, I think it is worth considering that perhaps this kind of
> namespace system could automatically lead into the build system
> (ocamldep?)  inferring which packages you need to use and eliminate that
> piece of configuration from the build system. Only special cases would
> need more configuration.
>
> While C++ might not be the golden standard to look upon on language
> development, perhaps it can serve as an inspiration. Its namespace
> system seems to work pretty nicely without complaints from the
> developers. It has the following constructs:
>
> namespace X {
>   /* introduce values for the namespace X */
>   int a = 42;
>   namespace Z {
>     /* introduce namespace X::Z */
>     int b = a;
>   }
> }
>
> namespace X {
>   /* introduce more values for the namespace X */
>   int z = 5;
> }
>
> namespace Y = X; /* alias a namespace */
>
> int b = X::a; /* access a value in a namespace */
>
> using namespace X; /* bring X to current scope (works in function scope
>                       as well */
>
> using X::a; /* bring one value from a namespace to current scope */
>
> In implementation side it works by simply relabeling symbols in the
> generated object files which makes the namespaces open.
>
> C++'s compilation system with include files is of course very different
> from OCaml, but a similar solution to OCaml would mean having a hidden
> internal name (such as namespace_modulename or possibly even something
> that like namespace#modulename) for the module created from that
> compilation unit. It would need to be limited to a single top-level
> namespace specification per compilation unit, so it would work sort of
> in reverse compared to C++. For example if x.ml contained statement
> "namespace Foo", a module Foo#X would be generated instead of plain X.
>
> This solution would not allow the same module names from different
> namespaces to coexist in a single directory, but I don't see this as an
> essential feature. The source file names already would be the same, and
> OCaml compiler produces object files to the same directory as the
> source. If you have a build system copying files around, it could (and
> perhaps should!) preserve the directory hierarchy.
>
>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>   namespace to also implicitly open some modules, this essentially
>
> The previosuly described system would also eliminate the C++-like
> ability of introducing values to a namespace, unless special module
> names or other changes, such as an automatic opening of some modules,
> are implemented. It would be nice to be able to define such top-level
> values from multiple compilation units, but I'm uncertain how that would
> be implemented.
>
> This approach would need the compiler to find many similarly named .cmi
> files and decide the proper one to use based on their contents, as
> mentioned in a previous proposal.
>
> Everyone seems to agree that # is a good operator for accessing modules
> (or values) from namespaces. Or maybe we could go with \ ;-).
>
>>   But what Alain is proposing is to make opening a namespace silent at
>>   the source level.  This strikes me as a grave error.
>
> I agree. At worst this could mean that in large projects developers let
> the build system recompile their files so they can see what namespaces
> they are using. It seems much better to me to just read it from the
> source code, which is the same regardless of the project.
>
> --
>   _____________________________________________________________________
>      / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
>     / /_ / // // /\ \/ /                                            \  /
>    /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Thu Feb 28 13:02:51 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 28 Feb 2013 14:02:51 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <m49y5e8stgx.fsf@coffee.modeemi.fi>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
Message-ID: <512F557B.1030106@lexifi.com>

On 02/28/2013 10:01 AM, Erkki Seppala wrote:
> While C++ might not be the golden standard to look upon on language
> development, perhaps it can serve as an inspiration. Its namespace
> system seems to work pretty nicely without complaints from the
> developers. It has the following constructs:

FWIW, this seems very similar to .Net.

It is interesting to see how this could be transposed more directly to 
OCaml.  This would change the current understanding that namespaces 
should control the name of compilation units.  Instead, every components 
created in a unit (sub-module, value, type) would be attached to a 
namespace, and a single compilation unit could export values/types/etc 
in different namespaces.

We could have a module exporting:

type Namespace1#foo = ...
val Namespace2#bar: string
module Namespace2#SubModule : sig ... end

probably with some syntax to factorize those prefixes:

namespace Namespace1 {
   type foo = ...
}

and ways to "open" namespaces ("using ...") and alias them.

This is really about attaching a "namespace" to every named component in 
structures/signatures.  (And we would need ways to define the namespace 
attached to a compilation unit.)

I don't see something like that happening for OCaml, though, because the 
overlap between this kind of namespaces and modules would be huge.


-- Alain

From yminsky at janestreet.com  Thu Feb 28 14:23:05 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 28 Feb 2013 09:23:05 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
Message-ID: <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>

On Thu, Feb 28, 2013 at 7:44 AM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
> I think the whole discussion of "compilation argument vs. information
> in source header" is misguided. The two places are essentially
> isomorphic, and a robust system could make them equi-expressive. In
> particular, the idea that what putting namespace information outside
> the source code is a regression is incorrect, as the semantics of an
> OCaml program *already* depends on the state of the filesystem on
> which it is compiled and the search path set at compilation time.
> Namespaces by themselves introduce no regression or improvement on
> this aspect.

I strongly disagree with this line of argument.  Sure, they are
technically equally powerful, but that doesn't tell you much.  Good
programming language design is in part about thinking about people,
not just about isomorphisms.

And yes, the OCaml program's semantics depend on the state of the
filesystem.  But right now, if you read the source files, you're
pretty close to understanding the program.  Build systems are hard to
read, and are idiosyncratic, differing a lot from project to project.
The more semantics issues you bury there, the more you hide them from
the programmer, and the worse off you are.

> There are practical reasons why one would favor one or the approach in
> a particular case, but it is not possible to satisfy all criterions
> simultaneously.
>
> 1. People are very sensitive about *source language* changes, not so
> much about changes in compilation interface (perceived as anecdotical
> tooling); this makes it easier to suggest new flags than new language
> features. Arguably both should treated with the same care, and in
> particular design decisions regarding tooling should be inspected with
> scientific rigor. This doesn't happen in practice (which of the
> proposed tool changes during this discussion was accompanied with a
> rigorous specification of the semantics?), so tooling changes are
> easier and faster to get in a language release, and easier to get
> half-specified and half-baked.

I agree that it's more work to make a language change.  But
programming in the large is important, and is worth putting real work
into.  Up until now, the OCaml community hasn't worried about the
issue, and as the community grows up and the use of the language
grows, I believe we need to get this right.

> 2. Such header information may need to be shared by several files of a
> project and may become a source of painful redundancy. Compilation
> flags are an easy way to factorize these redundancies away. In
> principle this could also be done in the source code (by having
> separate files with this source information, and a semantic
> #include-like language construct), but this means yet another language
> change that has to be carefully designed.

We have all of this overhead now within Jane Street, with packed
libraries being the rule.  My experience is it's just not that big of
a deal.  Putting this in the build files is a clear problem in my
mind.

> 3. People naturally share source snippets without thinking of sharing
> the surrounding contextual information (the state of the compilation
> environment), so in practice having information in the source helps to
> be more robust wrt. environmental change. In mails, Q&A sites, etc.,
> sharing source text is better than a tarball with a _tags file or
> whatnot.

Agreed.  This seems like an argument in favor of opening namespaces
explicitly in the source.

> It's well and good to hope that any semantic features associated to
> namespaces will eventually end up in the source language as well. But
> that may be significantly harder than agreeing on those features in
> the first place. Because picking a good syntax is really hard, and
> because this may require more change to other tools that are not part
> of the OCaml compiler distribution, and is therefore more costly for
> everyone involved (this is Alain's understandable reason for shunning
> any such change). So I would like to encourage people to discuss which
> semantics they need and want, what a good design would be, rather than
> whether to implement this inside or outside the source language.

I disagree, precisely because the presence or absence of namespace
declarations in the source language is in my mind an important part of
the semantics of namespaces.

> On Thu, Feb 28, 2013 at 10:01 AM, Erkki Seppala
> <flux-ocaml-platform at inside.org> wrote:
>> TLDR; I agree with the parts of proposal suggesting statement "namespace
>> X" to be introduced to .ml and .mli files and then statements "open
>> namespace X", "let namespace Y = X" and their expression forms. And that
>> this all should be controlled from the source code, not the build
>> system.
>>
>> Yaron Minsky <yminsky at janestreet.com> writes:
>>
>>>   My biggest objection to having opens be at the build system level is
>>>   that it makes your code more ambiguous.  When you do namespace
>>>   manipulations, you very much want to see what's happening by
>>>   inspecting the source.  We have a vigorous code review system here,
>>>   and I don't want to start adding code review of the build rules to
>>>   it, and this change would require that.
>>
>> I agree that namespaces should be defined and accessed through the
>> source code. Not the least because it depends on the project's chosen
>> build system on how I should go on changing those definitions. While
>> currently the situation is the same regarding findlib package
>> management, I think it is worth considering that perhaps this kind of
>> namespace system could automatically lead into the build system
>> (ocamldep?)  inferring which packages you need to use and eliminate that
>> piece of configuration from the build system. Only special cases would
>> need more configuration.
>>
>> While C++ might not be the golden standard to look upon on language
>> development, perhaps it can serve as an inspiration. Its namespace
>> system seems to work pretty nicely without complaints from the
>> developers. It has the following constructs:
>>
>> namespace X {
>>   /* introduce values for the namespace X */
>>   int a = 42;
>>   namespace Z {
>>     /* introduce namespace X::Z */
>>     int b = a;
>>   }
>> }
>>
>> namespace X {
>>   /* introduce more values for the namespace X */
>>   int z = 5;
>> }
>>
>> namespace Y = X; /* alias a namespace */
>>
>> int b = X::a; /* access a value in a namespace */
>>
>> using namespace X; /* bring X to current scope (works in function scope
>>                       as well */
>>
>> using X::a; /* bring one value from a namespace to current scope */
>>
>> In implementation side it works by simply relabeling symbols in the
>> generated object files which makes the namespaces open.
>>
>> C++'s compilation system with include files is of course very different
>> from OCaml, but a similar solution to OCaml would mean having a hidden
>> internal name (such as namespace_modulename or possibly even something
>> that like namespace#modulename) for the module created from that
>> compilation unit. It would need to be limited to a single top-level
>> namespace specification per compilation unit, so it would work sort of
>> in reverse compared to C++. For example if x.ml contained statement
>> "namespace Foo", a module Foo#X would be generated instead of plain X.
>>
>> This solution would not allow the same module names from different
>> namespaces to coexist in a single directory, but I don't see this as an
>> essential feature. The source file names already would be the same, and
>> OCaml compiler produces object files to the same directory as the
>> source. If you have a build system copying files around, it could (and
>> perhaps should!) preserve the directory hierarchy.
>>
>>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>>   namespace to also implicitly open some modules, this essentially
>>
>> The previosuly described system would also eliminate the C++-like
>> ability of introducing values to a namespace, unless special module
>> names or other changes, such as an automatic opening of some modules,
>> are implemented. It would be nice to be able to define such top-level
>> values from multiple compilation units, but I'm uncertain how that would
>> be implemented.
>>
>> This approach would need the compiler to find many similarly named .cmi
>> files and decide the proper one to use based on their contents, as
>> mentioned in a previous proposal.
>>
>> Everyone seems to agree that # is a good operator for accessing modules
>> (or values) from namespaces. Or maybe we could go with \ ;-).
>>
>>>   But what Alain is proposing is to make opening a namespace silent at
>>>   the source level.  This strikes me as a grave error.
>>
>> I agree. At worst this could mean that in large projects developers let
>> the build system recompile their files so they can see what namespaces
>> they are using. It seems much better to me to just read it from the
>> source code, which is the same regardless of the project.
>>
>> --
>>   _____________________________________________________________________
>>      / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
>>     / /_ / // // /\ \/ /                                            \  /
>>    /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From gabriel.scherer at gmail.com  Thu Feb 28 14:30:27 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 28 Feb 2013 15:30:27 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
Message-ID: <CAPFanBHnUD2i0PMtB-SYY+yRVXbPDV9n5o19pHBo_WwbgSbmsw@mail.gmail.com>

> I disagree, precisely because the presence or absence of namespace
> declarations in the source language is in my mind an important part of
> the semantics of namespaces.

It is a very important part of the *syntax* of namespaces.

On Thu, Feb 28, 2013 at 3:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Thu, Feb 28, 2013 at 7:44 AM, Gabriel Scherer
> <gabriel.scherer at gmail.com> wrote:
>> I think the whole discussion of "compilation argument vs. information
>> in source header" is misguided. The two places are essentially
>> isomorphic, and a robust system could make them equi-expressive. In
>> particular, the idea that what putting namespace information outside
>> the source code is a regression is incorrect, as the semantics of an
>> OCaml program *already* depends on the state of the filesystem on
>> which it is compiled and the search path set at compilation time.
>> Namespaces by themselves introduce no regression or improvement on
>> this aspect.
>
> I strongly disagree with this line of argument.  Sure, they are
> technically equally powerful, but that doesn't tell you much.  Good
> programming language design is in part about thinking about people,
> not just about isomorphisms.
>
> And yes, the OCaml program's semantics depend on the state of the
> filesystem.  But right now, if you read the source files, you're
> pretty close to understanding the program.  Build systems are hard to
> read, and are idiosyncratic, differing a lot from project to project.
> The more semantics issues you bury there, the more you hide them from
> the programmer, and the worse off you are.
>
>> There are practical reasons why one would favor one or the approach in
>> a particular case, but it is not possible to satisfy all criterions
>> simultaneously.
>>
>> 1. People are very sensitive about *source language* changes, not so
>> much about changes in compilation interface (perceived as anecdotical
>> tooling); this makes it easier to suggest new flags than new language
>> features. Arguably both should treated with the same care, and in
>> particular design decisions regarding tooling should be inspected with
>> scientific rigor. This doesn't happen in practice (which of the
>> proposed tool changes during this discussion was accompanied with a
>> rigorous specification of the semantics?), so tooling changes are
>> easier and faster to get in a language release, and easier to get
>> half-specified and half-baked.
>
> I agree that it's more work to make a language change.  But
> programming in the large is important, and is worth putting real work
> into.  Up until now, the OCaml community hasn't worried about the
> issue, and as the community grows up and the use of the language
> grows, I believe we need to get this right.
>
>> 2. Such header information may need to be shared by several files of a
>> project and may become a source of painful redundancy. Compilation
>> flags are an easy way to factorize these redundancies away. In
>> principle this could also be done in the source code (by having
>> separate files with this source information, and a semantic
>> #include-like language construct), but this means yet another language
>> change that has to be carefully designed.
>
> We have all of this overhead now within Jane Street, with packed
> libraries being the rule.  My experience is it's just not that big of
> a deal.  Putting this in the build files is a clear problem in my
> mind.
>
>> 3. People naturally share source snippets without thinking of sharing
>> the surrounding contextual information (the state of the compilation
>> environment), so in practice having information in the source helps to
>> be more robust wrt. environmental change. In mails, Q&A sites, etc.,
>> sharing source text is better than a tarball with a _tags file or
>> whatnot.
>
> Agreed.  This seems like an argument in favor of opening namespaces
> explicitly in the source.
>
>> It's well and good to hope that any semantic features associated to
>> namespaces will eventually end up in the source language as well. But
>> that may be significantly harder than agreeing on those features in
>> the first place. Because picking a good syntax is really hard, and
>> because this may require more change to other tools that are not part
>> of the OCaml compiler distribution, and is therefore more costly for
>> everyone involved (this is Alain's understandable reason for shunning
>> any such change). So I would like to encourage people to discuss which
>> semantics they need and want, what a good design would be, rather than
>> whether to implement this inside or outside the source language.
>
> I disagree, precisely because the presence or absence of namespace
> declarations in the source language is in my mind an important part of
> the semantics of namespaces.
>
>> On Thu, Feb 28, 2013 at 10:01 AM, Erkki Seppala
>> <flux-ocaml-platform at inside.org> wrote:
>>> TLDR; I agree with the parts of proposal suggesting statement "namespace
>>> X" to be introduced to .ml and .mli files and then statements "open
>>> namespace X", "let namespace Y = X" and their expression forms. And that
>>> this all should be controlled from the source code, not the build
>>> system.
>>>
>>> Yaron Minsky <yminsky at janestreet.com> writes:
>>>
>>>>   My biggest objection to having opens be at the build system level is
>>>>   that it makes your code more ambiguous.  When you do namespace
>>>>   manipulations, you very much want to see what's happening by
>>>>   inspecting the source.  We have a vigorous code review system here,
>>>>   and I don't want to start adding code review of the build rules to
>>>>   it, and this change would require that.
>>>
>>> I agree that namespaces should be defined and accessed through the
>>> source code. Not the least because it depends on the project's chosen
>>> build system on how I should go on changing those definitions. While
>>> currently the situation is the same regarding findlib package
>>> management, I think it is worth considering that perhaps this kind of
>>> namespace system could automatically lead into the build system
>>> (ocamldep?)  inferring which packages you need to use and eliminate that
>>> piece of configuration from the build system. Only special cases would
>>> need more configuration.
>>>
>>> While C++ might not be the golden standard to look upon on language
>>> development, perhaps it can serve as an inspiration. Its namespace
>>> system seems to work pretty nicely without complaints from the
>>> developers. It has the following constructs:
>>>
>>> namespace X {
>>>   /* introduce values for the namespace X */
>>>   int a = 42;
>>>   namespace Z {
>>>     /* introduce namespace X::Z */
>>>     int b = a;
>>>   }
>>> }
>>>
>>> namespace X {
>>>   /* introduce more values for the namespace X */
>>>   int z = 5;
>>> }
>>>
>>> namespace Y = X; /* alias a namespace */
>>>
>>> int b = X::a; /* access a value in a namespace */
>>>
>>> using namespace X; /* bring X to current scope (works in function scope
>>>                       as well */
>>>
>>> using X::a; /* bring one value from a namespace to current scope */
>>>
>>> In implementation side it works by simply relabeling symbols in the
>>> generated object files which makes the namespaces open.
>>>
>>> C++'s compilation system with include files is of course very different
>>> from OCaml, but a similar solution to OCaml would mean having a hidden
>>> internal name (such as namespace_modulename or possibly even something
>>> that like namespace#modulename) for the module created from that
>>> compilation unit. It would need to be limited to a single top-level
>>> namespace specification per compilation unit, so it would work sort of
>>> in reverse compared to C++. For example if x.ml contained statement
>>> "namespace Foo", a module Foo#X would be generated instead of plain X.
>>>
>>> This solution would not allow the same module names from different
>>> namespaces to coexist in a single directory, but I don't see this as an
>>> essential feature. The source file names already would be the same, and
>>> OCaml compiler produces object files to the same directory as the
>>> source. If you have a build system copying files around, it could (and
>>> perhaps should!) preserve the directory hierarchy.
>>>
>>>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>>>   namespace to also implicitly open some modules, this essentially
>>>
>>> The previosuly described system would also eliminate the C++-like
>>> ability of introducing values to a namespace, unless special module
>>> names or other changes, such as an automatic opening of some modules,
>>> are implemented. It would be nice to be able to define such top-level
>>> values from multiple compilation units, but I'm uncertain how that would
>>> be implemented.
>>>
>>> This approach would need the compiler to find many similarly named .cmi
>>> files and decide the proper one to use based on their contents, as
>>> mentioned in a previous proposal.
>>>
>>> Everyone seems to agree that # is a good operator for accessing modules
>>> (or values) from namespaces. Or maybe we could go with \ ;-).
>>>
>>>>   But what Alain is proposing is to make opening a namespace silent at
>>>>   the source level.  This strikes me as a grave error.
>>>
>>> I agree. At worst this could mean that in large projects developers let
>>> the build system recompile their files so they can see what namespaces
>>> they are using. It seems much better to me to just read it from the
>>> source code, which is the same regardless of the project.
>>>
>>> --
>>>   _____________________________________________________________________
>>>      / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
>>>     / /_ / // // /\ \/ /                                            \  /
>>>    /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform

From wojciech.meyer at gmail.com  Thu Feb 28 14:45:06 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Thu, 28 Feb 2013 14:45:06 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <m49y5e8stgx.fsf@coffee.modeemi.fi>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
Message-ID: <CAOg1smCVCcGd2Fmg2+aU9HS6YdjBLuPgbLnWUVPwHBpCRmpXTA@mail.gmail.com>

I'd argue that the namespaces in the C++ should be a best example how
to implement namespaces in general.

C++ lacks compilation of interfaces, so the header filles containing
the prototypes, are literaly included. For that reason, in C++ we need
to write something like this:

// Implement pretty printer for complex number class
// but here we want see just Complex class that belongs to the parent namespace
namespace std {
namespace complex {
  class Complex;
  }
}

ostream operator << (const ostream&, const std::complex::Complex&);

for somebody who've never had occasion to use nested namespaces, and
tried, will see how much it is to get the exposed the interface right
which basically originates from the un-natural literal inclusion of
the headers. So the declarations *will* clutter the source files.
Other problem is name mangling, C++ symbols can be very long, and in
case of Clang we get 6GB of RAM to link the compiler. (because of the
templates + literal header inclusion + name mangling). We need to
decide upon how to mangle names.

BTW: I never considered namespaces in C++ as a bad feature of the
language, but when actually I tried use them, I found that maybe there
are quite complex to use in nested setting.

That's said, they are canonnical examples what to do, and what not to
do in the language.

Probably getting it right is not massively difficult as there are just
few possible operations that are sensible on the language level that
implement them and C++ has all of them.
So:

namespace { ... } // Define namespace
using namespace std; // with a local equivalent
using namespace std::complex::Complex // with a local equivalent
new std::complex::Complex; // Fully scoped access
new complex::Complex; // Assuming that the namespace was open before
namespace complex = std::complex; // Alias for a namespace

The same example would apply to OCaml of course.

Sorrry, for these C++ snippets, but I think Erkki in principle was
right that C++ namespaces are very similar to what we want as a basis
of the system, but if I wouldn't say that namespaces in C++ worked
flawlessly in C++ even years ago.


Wojciech

On Thu, Feb 28, 2013 at 9:01 AM, Erkki Seppala
<flux-ocaml-platform at inside.org> wrote:
> TLDR; I agree with the parts of proposal suggesting statement "namespace
> X" to be introduced to .ml and .mli files and then statements "open
> namespace X", "let namespace Y = X" and their expression forms. And that
> this all should be controlled from the source code, not the build
> system.
>
> Yaron Minsky <yminsky at janestreet.com> writes:
>
>>   My biggest objection to having opens be at the build system level is
>>   that it makes your code more ambiguous.  When you do namespace
>>   manipulations, you very much want to see what's happening by
>>   inspecting the source.  We have a vigorous code review system here,
>>   and I don't want to start adding code review of the build rules to
>>   it, and this change would require that.
>
> I agree that namespaces should be defined and accessed through the
> source code. Not the least because it depends on the project's chosen
> build system on how I should go on changing those definitions. While
> currently the situation is the same regarding findlib package
> management, I think it is worth considering that perhaps this kind of
> namespace system could automatically lead into the build system
> (ocamldep?)  inferring which packages you need to use and eliminate that
> piece of configuration from the build system. Only special cases would
> need more configuration.
>
> While C++ might not be the golden standard to look upon on language
> development, perhaps it can serve as an inspiration. Its namespace
> system seems to work pretty nicely without complaints from the
> developers. It has the following constructs:
>
> namespace X {
>   /* introduce values for the namespace X */
>   int a = 42;
>   namespace Z {
>     /* introduce namespace X::Z */
>     int b = a;
>   }
> }
>
> namespace X {
>   /* introduce more values for the namespace X */
>   int z = 5;
> }
>
> namespace Y = X; /* alias a namespace */
>
> int b = X::a; /* access a value in a namespace */
>
> using namespace X; /* bring X to current scope (works in function scope
>                       as well */
>
> using X::a; /* bring one value from a namespace to current scope */
>
> In implementation side it works by simply relabeling symbols in the
> generated object files which makes the namespaces open.
>
> C++'s compilation system with include files is of course very different
> from OCaml, but a similar solution to OCaml would mean having a hidden
> internal name (such as namespace_modulename or possibly even something
> that like namespace#modulename) for the module created from that
> compilation unit. It would need to be limited to a single top-level
> namespace specification per compilation unit, so it would work sort of
> in reverse compared to C++. For example if x.ml contained statement
> "namespace Foo", a module Foo#X would be generated instead of plain X.
>
> This solution would not allow the same module names from different
> namespaces to coexist in a single directory, but I don't see this as an
> essential feature. The source file names already would be the same, and
> OCaml compiler produces object files to the same directory as the
> source. If you have a build system copying files around, it could (and
> perhaps should!) preserve the directory hierarchy.
>
>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>   namespace to also implicitly open some modules, this essentially
>
> The previosuly described system would also eliminate the C++-like
> ability of introducing values to a namespace, unless special module
> names or other changes, such as an automatic opening of some modules,
> are implemented. It would be nice to be able to define such top-level
> values from multiple compilation units, but I'm uncertain how that would
> be implemented.
>
> This approach would need the compiler to find many similarly named .cmi
> files and decide the proper one to use based on their contents, as
> mentioned in a previous proposal.
>
> Everyone seems to agree that # is a good operator for accessing modules
> (or values) from namespaces. Or maybe we could go with \ ;-).
>
>>   But what Alain is proposing is to make opening a namespace silent at
>>   the source level.  This strikes me as a grave error.
>
> I agree. At worst this could mean that in large projects developers let
> the build system recompile their files so they can see what namespaces
> they are using. It seems much better to me to just read it from the
> source code, which is the same regardless of the project.
>
> --
>   _____________________________________________________________________
>      / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
>     / /_ / // // /\ \/ /                                            \  /
>    /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From gabriel.scherer at gmail.com  Thu Feb 28 15:07:09 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 28 Feb 2013 16:07:09 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAOg1smCVCcGd2Fmg2+aU9HS6YdjBLuPgbLnWUVPwHBpCRmpXTA@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAOg1smCVCcGd2Fmg2+aU9HS6YdjBLuPgbLnWUVPwHBpCRmpXTA@mail.gmail.com>
Message-ID: <CAPFanBGPDZ=5C5wVbz_ud-Xp_tHsDP7Jmgxy0g08BWvKtOm8TA@mail.gmail.com>

> Probably getting it right is not massively difficult as there are just
> few possible operations that are sensible on the language level that
> implement them and C++ has all of them.
> So:
>
> namespace { ... } // Define namespace
> using namespace std; // with a local equivalent
> using namespace std::complex::Complex // with a local equivalent
> new std::complex::Complex; // Fully scoped access
> new complex::Complex; // Assuming that the namespace was open before
> namespace complex = std::complex; // Alias for a namespace

Note that all these operations are expressible from the primitives
considered in the specification
http://gallium.inria.fr/~scherer/namespaces/spec.pdf :
- "namespace { ... }" is just a compilation environment literal
- "using namespace std" is a transformation that turns the compilation
environment Env into (Env + Env#Std), where "+" is some choice of
merge operator among those described in the specification (the
differences are in how conflicts are handled and subenvironments are
treated)
- rebinding similarly turns Env into (Env + { Complex => Env#Std#Complex })

On Thu, Feb 28, 2013 at 3:45 PM, Wojciech Meyer
<wojciech.meyer at gmail.com> wrote:
> I'd argue that the namespaces in the C++ should be a best example how
> to implement namespaces in general.
>
> C++ lacks compilation of interfaces, so the header filles containing
> the prototypes, are literaly included. For that reason, in C++ we need
> to write something like this:
>
> // Implement pretty printer for complex number class
> // but here we want see just Complex class that belongs to the parent namespace
> namespace std {
> namespace complex {
>   class Complex;
>   }
> }
>
> ostream operator << (const ostream&, const std::complex::Complex&);
>
> for somebody who've never had occasion to use nested namespaces, and
> tried, will see how much it is to get the exposed the interface right
> which basically originates from the un-natural literal inclusion of
> the headers. So the declarations *will* clutter the source files.
> Other problem is name mangling, C++ symbols can be very long, and in
> case of Clang we get 6GB of RAM to link the compiler. (because of the
> templates + literal header inclusion + name mangling). We need to
> decide upon how to mangle names.
>
> BTW: I never considered namespaces in C++ as a bad feature of the
> language, but when actually I tried use them, I found that maybe there
> are quite complex to use in nested setting.
>
> That's said, they are canonnical examples what to do, and what not to
> do in the language.
>
> Probably getting it right is not massively difficult as there are just
> few possible operations that are sensible on the language level that
> implement them and C++ has all of them.
> So:
>
> namespace { ... } // Define namespace
> using namespace std; // with a local equivalent
> using namespace std::complex::Complex // with a local equivalent
> new std::complex::Complex; // Fully scoped access
> new complex::Complex; // Assuming that the namespace was open before
> namespace complex = std::complex; // Alias for a namespace
>
> The same example would apply to OCaml of course.
>
> Sorrry, for these C++ snippets, but I think Erkki in principle was
> right that C++ namespaces are very similar to what we want as a basis
> of the system, but if I wouldn't say that namespaces in C++ worked
> flawlessly in C++ even years ago.
>
>
> Wojciech
>
> On Thu, Feb 28, 2013 at 9:01 AM, Erkki Seppala
> <flux-ocaml-platform at inside.org> wrote:
>> TLDR; I agree with the parts of proposal suggesting statement "namespace
>> X" to be introduced to .ml and .mli files and then statements "open
>> namespace X", "let namespace Y = X" and their expression forms. And that
>> this all should be controlled from the source code, not the build
>> system.
>>
>> Yaron Minsky <yminsky at janestreet.com> writes:
>>
>>>   My biggest objection to having opens be at the build system level is
>>>   that it makes your code more ambiguous.  When you do namespace
>>>   manipulations, you very much want to see what's happening by
>>>   inspecting the source.  We have a vigorous code review system here,
>>>   and I don't want to start adding code review of the build rules to
>>>   it, and this change would require that.
>>
>> I agree that namespaces should be defined and accessed through the
>> source code. Not the least because it depends on the project's chosen
>> build system on how I should go on changing those definitions. While
>> currently the situation is the same regarding findlib package
>> management, I think it is worth considering that perhaps this kind of
>> namespace system could automatically lead into the build system
>> (ocamldep?)  inferring which packages you need to use and eliminate that
>> piece of configuration from the build system. Only special cases would
>> need more configuration.
>>
>> While C++ might not be the golden standard to look upon on language
>> development, perhaps it can serve as an inspiration. Its namespace
>> system seems to work pretty nicely without complaints from the
>> developers. It has the following constructs:
>>
>> namespace X {
>>   /* introduce values for the namespace X */
>>   int a = 42;
>>   namespace Z {
>>     /* introduce namespace X::Z */
>>     int b = a;
>>   }
>> }
>>
>> namespace X {
>>   /* introduce more values for the namespace X */
>>   int z = 5;
>> }
>>
>> namespace Y = X; /* alias a namespace */
>>
>> int b = X::a; /* access a value in a namespace */
>>
>> using namespace X; /* bring X to current scope (works in function scope
>>                       as well */
>>
>> using X::a; /* bring one value from a namespace to current scope */
>>
>> In implementation side it works by simply relabeling symbols in the
>> generated object files which makes the namespaces open.
>>
>> C++'s compilation system with include files is of course very different
>> from OCaml, but a similar solution to OCaml would mean having a hidden
>> internal name (such as namespace_modulename or possibly even something
>> that like namespace#modulename) for the module created from that
>> compilation unit. It would need to be limited to a single top-level
>> namespace specification per compilation unit, so it would work sort of
>> in reverse compared to C++. For example if x.ml contained statement
>> "namespace Foo", a module Foo#X would be generated instead of plain X.
>>
>> This solution would not allow the same module names from different
>> namespaces to coexist in a single directory, but I don't see this as an
>> essential feature. The source file names already would be the same, and
>> OCaml compiler produces object files to the same directory as the
>> source. If you have a build system copying files around, it could (and
>> perhaps should!) preserve the directory hierarchy.
>>
>>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>>   namespace to also implicitly open some modules, this essentially
>>
>> The previosuly described system would also eliminate the C++-like
>> ability of introducing values to a namespace, unless special module
>> names or other changes, such as an automatic opening of some modules,
>> are implemented. It would be nice to be able to define such top-level
>> values from multiple compilation units, but I'm uncertain how that would
>> be implemented.
>>
>> This approach would need the compiler to find many similarly named .cmi
>> files and decide the proper one to use based on their contents, as
>> mentioned in a previous proposal.
>>
>> Everyone seems to agree that # is a good operator for accessing modules
>> (or values) from namespaces. Or maybe we could go with \ ;-).
>>
>>>   But what Alain is proposing is to make opening a namespace silent at
>>>   the source level.  This strikes me as a grave error.
>>
>> I agree. At worst this could mean that in large projects developers let
>> the build system recompile their files so they can see what namespaces
>> they are using. It seems much better to me to just read it from the
>> source code, which is the same regardless of the project.
>>
>> --
>>   _____________________________________________________________________
>>      / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
>>     / /_ / // // /\ \/ /                                            \  /
>>    /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From Didier.Remy at inria.fr  Thu Feb 28 15:12:52 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Thu, 28 Feb 2013 16:12:52 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
Message-ID: <512F73F4.1040005@inria.fr>

>> I think the whole discussion of "compilation argument vs. information
>> in source header" is misguided. The two places are essentially
>> isomorphic, and a robust system could make them equi-expressive. In
>> particular, the idea that what putting namespace information outside
>> the source code is a regression is incorrect, as the semantics of an
>> OCaml program *already* depends on the state of the filesystem on
>> which it is compiled and the search path set at compilation time.
>> Namespaces by themselves introduce no regression or improvement on
>> this aspect.
>
> I strongly disagree with this line of argument.  Sure, they are
> technically equally powerful, but that doesn't tell you much.  Good
> programming language design is in part about thinking about people,
> not just about isomorphisms.

I think what Gabriel meant (at least, this is what I think), is that we
should agree on the semantics first and only later care about where
we should place namespace construction commands.

Defining the semantics means:

   - a mathematical model of namespaces: are they flat mappings of strings
     to module objects or trees of module objects? or are they also
     mapping "whatever" to values? Do they carry additional information such
     as auto-open tags?

  - some operations to create and transform namespaces.

  - some operation to invoke namespaces from the core language.

  - a description of the operations in term transformations of the
    namespace, compiler/linker environments.

Gabriel has proposed a model that very view messages refer to in the
discussion.
                               ----------------

Once we agree on the semantics, we somewhat know the maximum we can do with
namespaces.  We then probably wish to restrict what we can do because too
much expressiveness may just invite the user to shoot in his foot.

                               ----------------

Once we agree with the expressiveness that we wish namespaces to provide, we
need to design a small set of constructs not necessarily the same as the
mathematical operations used to described the semantics.  There will be
design choices because there are often several ways to obtain the same
thing.

We will need some syntactic notation. There is absolutely no point in
discussing this so early. Who cares now whether we should use # or \ for
namespace accesses?

Here, we should also decide where operations should go, in separate files,
in command lines, in .ml headers or being inlined anywhere.  Yes, it is
important, as well as the syntax, but it won't change the semantics and
should come later.

                               ----------------

So far, the discussion has mixed all aspects at the same time.  It also
mixes technical questions/problems that may have objective answers with
questions of style, taste, feeling, users, etc. that are much more
subjective in nature.  They are important as well, but they belong to step 2
or 3 and not to step 1.

The discussion is certainly moving---with several hundreds of messages, but
basic aspects of the design such as flat/hierarchical namespaces or should
there be auto-opens, and what should they do hasn't been agreed on yet.

     Didier

From yminsky at janestreet.com  Thu Feb 28 15:32:42 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 28 Feb 2013 10:32:42 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CAPFanBHnUD2i0PMtB-SYY+yRVXbPDV9n5o19pHBo_WwbgSbmsw@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <CAPFanBHnUD2i0PMtB-SYY+yRVXbPDV9n5o19pHBo_WwbgSbmsw@mail.gmail.com>
Message-ID: <CACLX4jQqs0Zud+rS0xBsi1wA4C33t6hVeXZMEtHkN+v_GCPkvw@mail.gmail.com>

On Thu, Feb 28, 2013 at 9:30 AM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
>> I disagree, precisely because the presence or absence of namespace
>> declarations in the source language is in my mind an important part of
>> the semantics of namespaces.
>
> It is a very important part of the *syntax* of namespaces.

I'm not a PL guy by training, so maybe I have the terminology wrong.
I would have thought that things like local namespace opens, which
interact with the scoping of the language, would be part of the
semantics.

But I suppose if you include in the language the build scripts, then
where that specification goes is perhaps a syntactic question.

But it is, in either case, important, and more important than whether
you use a paren or a square bracket.

> On Thu, Feb 28, 2013 at 3:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> On Thu, Feb 28, 2013 at 7:44 AM, Gabriel Scherer
>> <gabriel.scherer at gmail.com> wrote:
>>> I think the whole discussion of "compilation argument vs. information
>>> in source header" is misguided. The two places are essentially
>>> isomorphic, and a robust system could make them equi-expressive. In
>>> particular, the idea that what putting namespace information outside
>>> the source code is a regression is incorrect, as the semantics of an
>>> OCaml program *already* depends on the state of the filesystem on
>>> which it is compiled and the search path set at compilation time.
>>> Namespaces by themselves introduce no regression or improvement on
>>> this aspect.
>>
>> I strongly disagree with this line of argument.  Sure, they are
>> technically equally powerful, but that doesn't tell you much.  Good
>> programming language design is in part about thinking about people,
>> not just about isomorphisms.
>>
>> And yes, the OCaml program's semantics depend on the state of the
>> filesystem.  But right now, if you read the source files, you're
>> pretty close to understanding the program.  Build systems are hard to
>> read, and are idiosyncratic, differing a lot from project to project.
>> The more semantics issues you bury there, the more you hide them from
>> the programmer, and the worse off you are.
>>
>>> There are practical reasons why one would favor one or the approach in
>>> a particular case, but it is not possible to satisfy all criterions
>>> simultaneously.
>>>
>>> 1. People are very sensitive about *source language* changes, not so
>>> much about changes in compilation interface (perceived as anecdotical
>>> tooling); this makes it easier to suggest new flags than new language
>>> features. Arguably both should treated with the same care, and in
>>> particular design decisions regarding tooling should be inspected with
>>> scientific rigor. This doesn't happen in practice (which of the
>>> proposed tool changes during this discussion was accompanied with a
>>> rigorous specification of the semantics?), so tooling changes are
>>> easier and faster to get in a language release, and easier to get
>>> half-specified and half-baked.
>>
>> I agree that it's more work to make a language change.  But
>> programming in the large is important, and is worth putting real work
>> into.  Up until now, the OCaml community hasn't worried about the
>> issue, and as the community grows up and the use of the language
>> grows, I believe we need to get this right.
>>
>>> 2. Such header information may need to be shared by several files of a
>>> project and may become a source of painful redundancy. Compilation
>>> flags are an easy way to factorize these redundancies away. In
>>> principle this could also be done in the source code (by having
>>> separate files with this source information, and a semantic
>>> #include-like language construct), but this means yet another language
>>> change that has to be carefully designed.
>>
>> We have all of this overhead now within Jane Street, with packed
>> libraries being the rule.  My experience is it's just not that big of
>> a deal.  Putting this in the build files is a clear problem in my
>> mind.
>>
>>> 3. People naturally share source snippets without thinking of sharing
>>> the surrounding contextual information (the state of the compilation
>>> environment), so in practice having information in the source helps to
>>> be more robust wrt. environmental change. In mails, Q&A sites, etc.,
>>> sharing source text is better than a tarball with a _tags file or
>>> whatnot.
>>
>> Agreed.  This seems like an argument in favor of opening namespaces
>> explicitly in the source.
>>
>>> It's well and good to hope that any semantic features associated to
>>> namespaces will eventually end up in the source language as well. But
>>> that may be significantly harder than agreeing on those features in
>>> the first place. Because picking a good syntax is really hard, and
>>> because this may require more change to other tools that are not part
>>> of the OCaml compiler distribution, and is therefore more costly for
>>> everyone involved (this is Alain's understandable reason for shunning
>>> any such change). So I would like to encourage people to discuss which
>>> semantics they need and want, what a good design would be, rather than
>>> whether to implement this inside or outside the source language.
>>
>> I disagree, precisely because the presence or absence of namespace
>> declarations in the source language is in my mind an important part of
>> the semantics of namespaces.
>>
>>> On Thu, Feb 28, 2013 at 10:01 AM, Erkki Seppala
>>> <flux-ocaml-platform at inside.org> wrote:
>>>> TLDR; I agree with the parts of proposal suggesting statement "namespace
>>>> X" to be introduced to .ml and .mli files and then statements "open
>>>> namespace X", "let namespace Y = X" and their expression forms. And that
>>>> this all should be controlled from the source code, not the build
>>>> system.
>>>>
>>>> Yaron Minsky <yminsky at janestreet.com> writes:
>>>>
>>>>>   My biggest objection to having opens be at the build system level is
>>>>>   that it makes your code more ambiguous.  When you do namespace
>>>>>   manipulations, you very much want to see what's happening by
>>>>>   inspecting the source.  We have a vigorous code review system here,
>>>>>   and I don't want to start adding code review of the build rules to
>>>>>   it, and this change would require that.
>>>>
>>>> I agree that namespaces should be defined and accessed through the
>>>> source code. Not the least because it depends on the project's chosen
>>>> build system on how I should go on changing those definitions. While
>>>> currently the situation is the same regarding findlib package
>>>> management, I think it is worth considering that perhaps this kind of
>>>> namespace system could automatically lead into the build system
>>>> (ocamldep?)  inferring which packages you need to use and eliminate that
>>>> piece of configuration from the build system. Only special cases would
>>>> need more configuration.
>>>>
>>>> While C++ might not be the golden standard to look upon on language
>>>> development, perhaps it can serve as an inspiration. Its namespace
>>>> system seems to work pretty nicely without complaints from the
>>>> developers. It has the following constructs:
>>>>
>>>> namespace X {
>>>>   /* introduce values for the namespace X */
>>>>   int a = 42;
>>>>   namespace Z {
>>>>     /* introduce namespace X::Z */
>>>>     int b = a;
>>>>   }
>>>> }
>>>>
>>>> namespace X {
>>>>   /* introduce more values for the namespace X */
>>>>   int z = 5;
>>>> }
>>>>
>>>> namespace Y = X; /* alias a namespace */
>>>>
>>>> int b = X::a; /* access a value in a namespace */
>>>>
>>>> using namespace X; /* bring X to current scope (works in function scope
>>>>                       as well */
>>>>
>>>> using X::a; /* bring one value from a namespace to current scope */
>>>>
>>>> In implementation side it works by simply relabeling symbols in the
>>>> generated object files which makes the namespaces open.
>>>>
>>>> C++'s compilation system with include files is of course very different
>>>> from OCaml, but a similar solution to OCaml would mean having a hidden
>>>> internal name (such as namespace_modulename or possibly even something
>>>> that like namespace#modulename) for the module created from that
>>>> compilation unit. It would need to be limited to a single top-level
>>>> namespace specification per compilation unit, so it would work sort of
>>>> in reverse compared to C++. For example if x.ml contained statement
>>>> "namespace Foo", a module Foo#X would be generated instead of plain X.
>>>>
>>>> This solution would not allow the same module names from different
>>>> namespaces to coexist in a single directory, but I don't see this as an
>>>> essential feature. The source file names already would be the same, and
>>>> OCaml compiler produces object files to the same directory as the
>>>> source. If you have a build system copying files around, it could (and
>>>> perhaps should!) preserve the directory hierarchy.
>>>>
>>>>> - NAMESPACES WITH VALUES.  I have argued for allowing the opening of a
>>>>>   namespace to also implicitly open some modules, this essentially
>>>>
>>>> The previosuly described system would also eliminate the C++-like
>>>> ability of introducing values to a namespace, unless special module
>>>> names or other changes, such as an automatic opening of some modules,
>>>> are implemented. It would be nice to be able to define such top-level
>>>> values from multiple compilation units, but I'm uncertain how that would
>>>> be implemented.
>>>>
>>>> This approach would need the compiler to find many similarly named .cmi
>>>> files and decide the proper one to use based on their contents, as
>>>> mentioned in a previous proposal.
>>>>
>>>> Everyone seems to agree that # is a good operator for accessing modules
>>>> (or values) from namespaces. Or maybe we could go with \ ;-).
>>>>
>>>>>   But what Alain is proposing is to make opening a namespace silent at
>>>>>   the source level.  This strikes me as a grave error.
>>>>
>>>> I agree. At worst this could mean that in large projects developers let
>>>> the build system recompile their files so they can see what namespaces
>>>> they are using. It seems much better to me to just read it from the
>>>> source code, which is the same regardless of the project.
>>>>
>>>> --
>>>>   _____________________________________________________________________
>>>>      / __// /__ ____  __               http://www.modeemi.fi/~flux/\   \
>>>>     / /_ / // // /\ \/ /                                            \  /
>>>>    /_/  /_/ \___/ /_/\_\@modeemi.fi                                  \/
>>>> _______________________________________________
>>>> Platform mailing list
>>>> Platform at lists.ocaml.org
>>>> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Thu Feb 28 15:38:21 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 28 Feb 2013 10:38:21 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512F73F4.1040005@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
Message-ID: <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>

I agree with your point about settilng deep semantic issues ahead of
syntactic one.  I would however submit that the question of whether
you should:

- Have opens in the language proper, including local opens
- Have renames for namespaces in the language proper

are questions that seem worth settling relatively early, since any
semantics for namespaces that don't support this are likely, I
believe, to be insufficient.

Is there really still much disagreement on this point?  Alain seems at
this point content to include such operations, and I don't fully
understand what objections there are to it at this point.

(I do think the first order of business is to ask questions not of
semantics and mathematical models, but of goals.  It's hard to design
something without knowing what one is trying to achieve.  That said, I
think that bit has been reasonably well settled at this point.)

y

On Thu, Feb 28, 2013 at 10:12 AM, Didier Remy <Didier.Remy at inria.fr> wrote:
>>> I think the whole discussion of "compilation argument vs. information
>>> in source header" is misguided. The two places are essentially
>>> isomorphic, and a robust system could make them equi-expressive. In
>>> particular, the idea that what putting namespace information outside
>>> the source code is a regression is incorrect, as the semantics of an
>>> OCaml program *already* depends on the state of the filesystem on
>>> which it is compiled and the search path set at compilation time.
>>> Namespaces by themselves introduce no regression or improvement on
>>> this aspect.
>>
>>
>> I strongly disagree with this line of argument.  Sure, they are
>> technically equally powerful, but that doesn't tell you much.  Good
>> programming language design is in part about thinking about people,
>> not just about isomorphisms.
>
>
> I think what Gabriel meant (at least, this is what I think), is that we
> should agree on the semantics first and only later care about where
> we should place namespace construction commands.
>
> Defining the semantics means:
>
>   - a mathematical model of namespaces: are they flat mappings of strings
>     to module objects or trees of module objects? or are they also
>     mapping "whatever" to values? Do they carry additional information such
>     as auto-open tags?
>
>  - some operations to create and transform namespaces.
>
>  - some operation to invoke namespaces from the core language.
>
>  - a description of the operations in term transformations of the
>    namespace, compiler/linker environments.
>
> Gabriel has proposed a model that very view messages refer to in the
> discussion.
>                               ----------------
>
> Once we agree on the semantics, we somewhat know the maximum we can do with
> namespaces.  We then probably wish to restrict what we can do because too
> much expressiveness may just invite the user to shoot in his foot.
>
>                               ----------------
>
> Once we agree with the expressiveness that we wish namespaces to provide, we
> need to design a small set of constructs not necessarily the same as the
> mathematical operations used to described the semantics.  There will be
> design choices because there are often several ways to obtain the same
> thing.
>
> We will need some syntactic notation. There is absolutely no point in
> discussing this so early. Who cares now whether we should use # or \ for
> namespace accesses?
>
> Here, we should also decide where operations should go, in separate files,
> in command lines, in .ml headers or being inlined anywhere.  Yes, it is
> important, as well as the syntax, but it won't change the semantics and
> should come later.
>
>                               ----------------
>
> So far, the discussion has mixed all aspects at the same time.  It also
> mixes technical questions/problems that may have objective answers with
> questions of style, taste, feeling, users, etc. that are much more
> subjective in nature.  They are important as well, but they belong to step 2
> or 3 and not to step 1.
>
> The discussion is certainly moving---with several hundreds of messages, but
> basic aspects of the design such as flat/hierarchical namespaces or should
> there be auto-opens, and what should they do hasn't been agreed on yet.
>
>     Didier
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From daniel.buenzli at erratique.ch  Thu Feb 28 15:59:47 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Thu, 28 Feb 2013 16:59:47 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512F73F4.1040005@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
Message-ID: <D73E2EDFB3B048328EED52193A4DD62E@erratique.ch>

Le jeudi, 28 f?vrier 2013 ? 16:12, Didier Remy a ?crit :
> Defining the semantics means:
>  
> - a mathematical model of namespaces: are they flat mappings of strings
> to module objects or trees of module objects? or are they also
> mapping "whatever" to values? Do they carry additional information such
> as auto-open tags?

I had a cursory look at Maxence link on F# and Java's packages [1]. It seems both allow only types and modules to be part of a namespace, I wonder if there's a reason to that.

If opening a namespace may also open a module seems to be equivalent to be able to attach values to namespacea. That is if opening the namespace `Ns` defines the value `f` in my scope, for me, I should also be able to refer to this `f` via `Ns.f` otherwise the elements of a namespace seems to change depending on whether it is opened or not.  

Daniel

[1] http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html
  


From Didier.Remy at inria.fr  Thu Feb 28 22:17:55 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Thu, 28 Feb 2013 23:17:55 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
Message-ID: <512FD793.30208@inria.fr>

> I agree with your point about settilng deep semantic issues ahead of
> syntactic one.  I would however submit that the question of whether
> you should:
>
> - Have opens in the language proper, including local opens
> - Have renames for namespaces in the language proper

Yes, this is  the minimal, and probably agreed on.

The main question whether namespaces are hierarchical or flat is still not
answered, Flat namespaces are not much of an extension to OCaml and do not
raise many questions about their semantics.  This is the benefit of Alain's
proposal---but also its weakness to be limited in expressiveness.

If namespaces are hierarchical, the simplest model is that of a graph where
inner nodes are namespaces, leave nodes are module objects, edges are
names (and directed).

One question raised is whether edges should also carry auto-open flags, so
that whenever a node is opened all other nodes reachable by auto-open edges
are also opened.  This feature is strongly desired by Yaron, but it raises
further issues...

There is no reason for having just one such edge. Indeed, the idea is to
break big modules into smaller ones so that only actually used modules need
to be linked. The same should hold for auto-open modules.

However, since opening modules is not commutative, auto-open edges must be
ordered.  This means that the mental model to give to the user is not just
a directed graph with label edges whose leaves are module objects, as
described above, but whose edges (at least those flagged auto-opened) are
also ordered.  I think this is a bit more complicated and not so nice that
edges need to be both ordered and named...

The problem comes from module leaves.  For inner nodes one could check the
absence of conflicting names at the end of auto-open edges when building
namespaces so that the order of opens would not matter.  But one cannot do
so for leaves, because modules should remain opaque to namespaces (I think),
hence conflicts cannot be detected when building the namespace,

Yet another question raised by auto-open flags, which Gabriel and I
discussed  today is how auto-open behaves on access paths.  Assume,
for instance, a namespace containing:

         ROOT . --Core--> C --Pervasives*--> M
                           \
                             --Std*--> S

and that the module M contains a submodule List.  Should the user always
write Core#Pervasives#List or could he simply write Core#List, since given
that Pervasives is auto-open it could have just written

            open Core
            List

to designate module M.List. Indeed, one could expect that both

         let open path in Name
and
         path#Name

return the same object.  This way, the ordinary user would not need to know
about the Pervasives module.  Only the expert user who wishes to open just
the Pervasives module and not its parent will have to know its existence and
write

         open Core#Pervasive

Unfortunately, this choice of semantics implies that paths must be
interpreted in a much more complex way: path#name need not only look at the
node at path for an edge labeled Name but also at all nodes (recursively)
reachable by auto-open edges!

With these (small) complications in mind, do we still wish to have
auto-open edges? It this the good model?

----------------

In their absence, one would have to perform the auto-opens manually, and
the order of opens would therefore be given by the user.

The reason for auto-opens is to allow the user to just write

         open Core

instead of

         open Core
         open Pervasive
         open Std

Perhaps, an alternative to auto-open would be to allow one to write open
directives in .ns files as well. Then, a file myenv.ns could both build a
namespace and pre-open some of the nodes, including some of its leaves.  The
user could then just put something as concise as

         use myenv.ns

at the top of his *.ml files. And if he opens myenv.ns he will have a very
clear idea of what names should be visible.

Just an idea, which I don't like so much either.  But is shows that there
are still important details to be thought of and choices to be made.

----------------

Notice that the problem comes from the fact that leaves of namespaces are
opaque modules (and I think modules should remain opaque to namespaces), and
as a result conflicting interfaces of modules cannot be detected when
building a namespace, combined with the fact that the open construct of the
module language is not itself strict (i.e. it may override bindings) and
thus does not commute.

         Didier

