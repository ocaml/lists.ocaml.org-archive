<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ocaml-platform] Followup to Leo's proposal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:platform%40lists.ocaml.org?Subject=Re%3A%20%5Bocaml-platform%5D%20Followup%20to%20Leo%27s%20proposal&In-Reply-To=%3C871ubitd8r.fsf%40kingston.cl.cam.ac.uk%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000284.html">
   <LINK REL="Next"  HREF="000288.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ocaml-platform] Followup to Leo's proposal</H1>
    <B>Leo White</B> 
    <A HREF="mailto:platform%40lists.ocaml.org?Subject=Re%3A%20%5Bocaml-platform%5D%20Followup%20to%20Leo%27s%20proposal&In-Reply-To=%3C871ubitd8r.fsf%40kingston.cl.cam.ac.uk%3E"
       TITLE="[ocaml-platform] Followup to Leo's proposal">lpw25 at cam.ac.uk
       </A><BR>
    <I>Thu Mar 14 11:47:00 GMT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="000284.html">[ocaml-platform] Followup to Leo's proposal
</A></li>
        <LI>Next message: <A HREF="000288.html">[ocaml-platform] Followup to Leo's proposal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#287">[ date ]</a>
              <a href="thread.html#287">[ thread ]</a>
              <a href="subject.html#287">[ subject ]</a>
              <a href="author.html#287">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> The semantics is simpler to define with flat namespaces and it makes
</I>&gt;<i> a qualified reference (Foo#M) very explicit, without having to know which namespaces exist, without having to read
</I>&gt;<i> external files, etc.  You only have to look for &quot;using namespace ... as ...&quot; statements in scope to know which actual
</I>&gt;<i> namespace Foo refers to, and ocamldep can trivially do it.
</I>
Actually, you would still need to look in search path files for
aliases. This would be true for any proposal that allows users to create
their own namespaces from existing modules.

&gt;<i>  In other words, ocamldep can return an exact result (a pair
</I>&gt;<i> of fully resolved namespace name + module name) for qualified references, without looking at the file system (for
</I>&gt;<i> &quot;namespace through filenames&quot;) or parsing &quot;search path files&quot;.
</I>
It would still need to parse search path files.

&gt;<i>  For unqualified references, it needs to report for each
</I>&gt;<i> module name the list of possible (fully resolved) namespaces (i.e. the &quot;open namespace&quot; statements in scope).  Again,
</I>&gt;<i> this can be done just by looking at the source code.
</I>
It could do that with hierarchical namespaces, there would just be more
of them. Or it could use a different output format, and then there would
be the same amount of output for flat or hierarchical namespaces.

&gt;<i> Having a new mode where ocamldep would do the resolution to actual file names (based on search path files) is nice as
</I>&gt;<i> well, but my understanding is that:
</I>&gt;<i>
</I>&gt;<i>   - This does not work with &quot;simple namespaces through filenames&quot; (in case of generated source files).
</I>
The idea is that the build system would produce a search path file
including mappings for these generated files. So it would work perfectly
fine for generated files that specify their namespace through their
filename. It would also work for generated files whose name will be
defined by a &quot;-name&quot; argument.

&gt;<i>   - This does not play well with the idea of generating the search path files themselves during the build (or you need
</I>&gt;<i> explicit staging).  In my experience, such limitations always end up creating tedious problems in large code base, even
</I>&gt;<i> if they look quite minor at first.
</I>
I'm talking about generating a search path file that is just passed to
ocamldep. So rather than running &quot;ocamldep -modules&quot; and then using
information from the build system to interpret it, that information is
encoded as a search path file, and regular ocamldep does the work for
you.
</PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000284.html">[ocaml-platform] Followup to Leo's proposal
</A></li>
	<LI>Next message: <A HREF="000288.html">[ocaml-platform] Followup to Leo's proposal
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#287">[ date ]</a>
              <a href="thread.html#287">[ thread ]</a>
              <a href="subject.html#287">[ subject ]</a>
              <a href="author.html#287">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ocaml.org/listinfo/platform">More information about the Platform
mailing list</a><br>
</body></html>
