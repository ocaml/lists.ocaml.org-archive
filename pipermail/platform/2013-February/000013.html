<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ocaml-platform] The OCaml Platform
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:platform%40lists.ocaml.org?Subject=Re%3A%20%5Bocaml-platform%5D%20The%20OCaml%20Platform&In-Reply-To=%3CCAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf%3D%2B5Jv6Aw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000012.html">
   <LINK REL="Next"  HREF="000014.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ocaml-platform] The OCaml Platform</H1>
    <B>Sylvain Le Gall</B> 
    <A HREF="mailto:platform%40lists.ocaml.org?Subject=Re%3A%20%5Bocaml-platform%5D%20The%20OCaml%20Platform&In-Reply-To=%3CCAOCAUGPOPWCAeJCki84Uw6wbxOyWQS7DCjuTx3SRLf%3D%2B5Jv6Aw%40mail.gmail.com%3E"
       TITLE="[ocaml-platform] The OCaml Platform">sylvain+ocaml at le-gall.net
       </A><BR>
    <I>Tue Feb 12 18:01:37 GMT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="000012.html">[ocaml-platform] The OCaml Platform
</A></li>
        <LI>Next message: <A HREF="000014.html">[ocaml-platform] The OCaml Platform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13">[ date ]</a>
              <a href="thread.html#13">[ thread ]</a>
              <a href="subject.html#13">[ subject ]</a>
              <a href="author.html#13">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2013/2/12 Anil Madhavapeddy &lt;<A HREF="http://lists.ocaml.org/listinfo/platform">anil at recoil.org</A>&gt;:
&gt;<i> On 12 Feb 2013, at 15:23, Sylvain Le Gall &lt;<A HREF="http://lists.ocaml.org/listinfo/platform">sylvain+ocaml at le-gall.net</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In the case of Lwt, the solution is pretty straight forward, you just
</I>&gt;&gt;<i> use a thread (Thread) to wrap 1. and produce 2.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think the overall question is &quot;do we wish to have a common style for
</I>&gt;&gt;<i> non-stdlib features&quot;, e.g. monads, file descriptor et al. I don't
</I>&gt;&gt;<i> think this is mandatory but can be a nice long term goal.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> But maybe I am going too far, and the point of OCaml Platform is just
</I>&gt;&gt;<i> to have  a &quot;set of libraries&quot;, tested, packaged together and released
</I>&gt;&gt;<i> every 6 months (which is already an ambitious goal). If this is the
</I>&gt;&gt;<i> case, please ignore my question -- I'll be already extermly happy to
</I>&gt;&gt;<i> see an OCaml Platform in 6 months.
</I>&gt;<i>
</I>&gt;<i> You raise a good question, but there's no easy answer without basics
</I>&gt;<i> in place first. After a discussion with JSC/Citrix folks, the very first
</I>&gt;<i> focus of the platform is on filling in the blanks on some basic things:
</I>&gt;<i>
</I>&gt;<i> - unified documentation: a cross-referenced documentation set across
</I>&gt;<i> multiple libraries, that can be output in different formats. Leo has a
</I>&gt;<i> prototype for this based on the new bin-annot files, and will release
</I>&gt;<i> it shortly.
</I>
Please coordinate with OASIS project, if we need to generate this
bin-annot file, this is just a matter of changing 2 options and re-run
&quot;oasis setup&quot; before building.

&gt;<i>
</I>&gt;<i> - test harness: something that combines unit tests (oUnit) with coverage
</I>&gt;<i> and fuzz tests (QuickCheck), and benchmarks (like Criterion in Haskell).
</I>&gt;<i> This is something we hope to work with Xavier Clerc on, as he has made
</I>&gt;<i> some excellent contributions here.  The test harness should also encode
</I>&gt;<i> dependencies on an environment, so that we can run them automatically
</I>&gt;<i> in a virtual environment (absolutely required by Citrix, who have an
</I>&gt;<i> incredible test suite for Xen that they want to extend to the OCaml code).
</I>&gt;<i>
</I>
Quick note on this point (oUnit):
I am currently working on OUnit 2.0, which will feature:
- HTML output of tests
- JUnit output of tests
- parrallel run of tests (up to your number of core)
- timing...

One of the goal is to integrate well with Jenkins, so that you can
seee the reason why your test is failing directly in the artifact
generated by a test run.

&gt;<i> - build: most of the existing build solutions only scale up to small
</I>&gt;<i> code bases, so investigating a more unified approach based on compiler-libs
</I>&gt;<i> to write an integrated compiler front end that can auto-download
</I>&gt;<i> dependencies at the configuration phase, do smart incremental build,
</I>&gt;<i> and hook in the test frameworks.
</I>&gt;<i>
</I>
I would dare to say on this point, that you should focus on &quot;breaking
the longest path&quot;. This is an issue we have dealt with since a number
of years in Debian. (each new version of OCaml require to recompile
all packages on all architecture of debian).

Have a look at that:
<A HREF="http://pkg-ocaml-maint.alioth.debian.org/build_order.txt">http://pkg-ocaml-maint.alioth.debian.org/build_order.txt</A>

Each package of a level can be build in parallel. So the compilation
time is roughly the sum of the longest package to build in each level.

The first level is &quot;ocaml', which is among one of the longest step. I
would say that the full set can be build in ~2h on a recent computer.

It is pretty straightforward to write a makefile that will do all this
compilation for you (and it will take you ~30 min to do so). I would
recommed you to start by this very simple solution, that will probably
scale to ~100 packages with no problem.

Knowing the time it takes to compile Haskell or C++, I would say that
we are already pretty good at that -- no need to put it as a top
priority.

&gt;<i> This is all tooling, and can be done independently of the process of
</I>&gt;<i> selecting libraries.  For that selection, we need to think of this a bit
</I>&gt;<i> like a microkernel: pick the absolute smallest set of libraries we need
</I>&gt;<i> (including stripping down the OCaml standard library), and then working
</I>&gt;<i> our way up from there into a usable set of package.  Along the way, we'll
</I>&gt;<i> need to define 'platform tiers' to determine which ones absolutely have
</I>&gt;<i> to supported.
</I>&gt;<i>
</I>&gt;<i> An important note is that there'll be a reward for adapting your code
</I>&gt;<i> to run on the Platform.  The test system will regularly run *your* unit
</I>&gt;<i> tests on all the support platforms and send you reports.  Don't have a
</I>&gt;<i> FreeBSD/mips box, or a Raspberry Pi?  Opamalot will take care of that
</I>&gt;<i> for you and let you know if it comes and passes tests.
</I>&gt;<i>
</I>&gt;<i> Amir and Leo are currently writing up the results of the various recent
</I>&gt;<i> meetings and will publish it soon.
</I>&gt;<i>
</I>&gt;<i> -anil
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000012.html">[ocaml-platform] The OCaml Platform
</A></li>
	<LI>Next message: <A HREF="000014.html">[ocaml-platform] The OCaml Platform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13">[ date ]</a>
              <a href="thread.html#13">[ thread ]</a>
              <a href="subject.html#13">[ subject ]</a>
              <a href="author.html#13">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ocaml.org/listinfo/platform">More information about the Platform
mailing list</a><br>
</body></html>
