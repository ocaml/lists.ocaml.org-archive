<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ocaml-platform] The OCaml Platform
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:platform%40lists.ocaml.org?Subject=Re%3A%20%5Bocaml-platform%5D%20The%20OCaml%20Platform&In-Reply-To=%3CCAPFanBGPydLt7iJKhkUj5rZywfNAq_QPz5zzQQBtWU7usGUC0g%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000013.html">
   <LINK REL="Next"  HREF="000015.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ocaml-platform] The OCaml Platform</H1>
    <B>Gabriel Scherer</B> 
    <A HREF="mailto:platform%40lists.ocaml.org?Subject=Re%3A%20%5Bocaml-platform%5D%20The%20OCaml%20Platform&In-Reply-To=%3CCAPFanBGPydLt7iJKhkUj5rZywfNAq_QPz5zzQQBtWU7usGUC0g%40mail.gmail.com%3E"
       TITLE="[ocaml-platform] The OCaml Platform">gabriel.scherer at gmail.com
       </A><BR>
    <I>Wed Feb 13 13:13:46 GMT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="000013.html">[ocaml-platform] The OCaml Platform
</A></li>
        <LI>Next message: <A HREF="000015.html">[ocaml-platform] The OCaml Platform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Putting my &quot;Community&quot; and &quot;Free Software&quot; hats on, I wonder about
what the contribution and management process for this &quot;Platform&quot; will
look like. Who exactly is in charge of the project? Who owns the code
it distributes, takes the responsability to react to issues, fix bugs
and evolves the software?

Aiming at &quot;coherence&quot; means having a higher coupling between provided
code than what exists in the community at large (where &quot;community&quot;
here means the wide set of people that publicly releases FLOSS OCaml
software). Is the Platform considered to be a single, unified software
project, or a bundle of several independent software projects?

I know of several models to handle such sort of &quot;starting component of
a programming language ecosystem&quot; (at various degrees of Scale):
- single ownership: a single entity owns and maintains the code: this
is the case of Core, maintained by Jane Street (with an internal
development process), and a well-defined boundary between maintainers
and external contributors (who sign a Contributor License Agreement);
this is also the setting of the &quot;standard library&quot; of most programming
languages (say Scala, Python, or most languages with a distinguished
canonical implementation; also the case of OCaml, but the scope of the
stdlib is much narrower in this case)
- multiple ownership: it is a bundle of individually-owned packages,
the platform mostly choosing to distribute them or not and providing
quality control; my understanding is that this is typically the model
of the Perl CPAN, Haskell's Hackage, etc.; these projects usually have
a wider scope and weaker consistency goals than what seems aimed at
here
- shared ownership: the code ownership is loosely shared between the
various contributors to the project; this is the case of the Linux
kernel, the standard libraries of some languages with strong
contribution dynamics (possibly GHC's library), Batteries, and most
projects that use a Wiki model to build code (eg. Rosetta Code)

What kind of contribution dynamics are you aiming for? When the works
starts to take a shape that is visible to the outside, should I start
telling people &quot;if you have loose time, please consider contributing
to the Platform&quot;?

On Tue, Feb 12, 2013 at 7:01 PM, Sylvain Le Gall
&lt;<A HREF="http://lists.ocaml.org/listinfo/platform">sylvain+ocaml at le-gall.net</A>&gt; wrote:
&gt;<i> 2013/2/12 Anil Madhavapeddy &lt;<A HREF="http://lists.ocaml.org/listinfo/platform">anil at recoil.org</A>&gt;:
</I>&gt;&gt;<i> On 12 Feb 2013, at 15:23, Sylvain Le Gall &lt;<A HREF="http://lists.ocaml.org/listinfo/platform">sylvain+ocaml at le-gall.net</A>&gt; wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> In the case of Lwt, the solution is pretty straight forward, you just
</I>&gt;&gt;&gt;<i> use a thread (Thread) to wrap 1. and produce 2.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think the overall question is &quot;do we wish to have a common style for
</I>&gt;&gt;&gt;<i> non-stdlib features&quot;, e.g. monads, file descriptor et al. I don't
</I>&gt;&gt;&gt;<i> think this is mandatory but can be a nice long term goal.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> But maybe I am going too far, and the point of OCaml Platform is just
</I>&gt;&gt;&gt;<i> to have  a &quot;set of libraries&quot;, tested, packaged together and released
</I>&gt;&gt;&gt;<i> every 6 months (which is already an ambitious goal). If this is the
</I>&gt;&gt;&gt;<i> case, please ignore my question -- I'll be already extermly happy to
</I>&gt;&gt;&gt;<i> see an OCaml Platform in 6 months.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You raise a good question, but there's no easy answer without basics
</I>&gt;&gt;<i> in place first. After a discussion with JSC/Citrix folks, the very first
</I>&gt;&gt;<i> focus of the platform is on filling in the blanks on some basic things:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - unified documentation: a cross-referenced documentation set across
</I>&gt;&gt;<i> multiple libraries, that can be output in different formats. Leo has a
</I>&gt;&gt;<i> prototype for this based on the new bin-annot files, and will release
</I>&gt;&gt;<i> it shortly.
</I>&gt;<i>
</I>&gt;<i> Please coordinate with OASIS project, if we need to generate this
</I>&gt;<i> bin-annot file, this is just a matter of changing 2 options and re-run
</I>&gt;<i> &quot;oasis setup&quot; before building.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - test harness: something that combines unit tests (oUnit) with coverage
</I>&gt;&gt;<i> and fuzz tests (QuickCheck), and benchmarks (like Criterion in Haskell).
</I>&gt;&gt;<i> This is something we hope to work with Xavier Clerc on, as he has made
</I>&gt;&gt;<i> some excellent contributions here.  The test harness should also encode
</I>&gt;&gt;<i> dependencies on an environment, so that we can run them automatically
</I>&gt;&gt;<i> in a virtual environment (absolutely required by Citrix, who have an
</I>&gt;&gt;<i> incredible test suite for Xen that they want to extend to the OCaml code).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Quick note on this point (oUnit):
</I>&gt;<i> I am currently working on OUnit 2.0, which will feature:
</I>&gt;<i> - HTML output of tests
</I>&gt;<i> - JUnit output of tests
</I>&gt;<i> - parrallel run of tests (up to your number of core)
</I>&gt;<i> - timing...
</I>&gt;<i>
</I>&gt;<i> One of the goal is to integrate well with Jenkins, so that you can
</I>&gt;<i> seee the reason why your test is failing directly in the artifact
</I>&gt;<i> generated by a test run.
</I>&gt;<i>
</I>&gt;&gt;<i> - build: most of the existing build solutions only scale up to small
</I>&gt;&gt;<i> code bases, so investigating a more unified approach based on compiler-libs
</I>&gt;&gt;<i> to write an integrated compiler front end that can auto-download
</I>&gt;&gt;<i> dependencies at the configuration phase, do smart incremental build,
</I>&gt;&gt;<i> and hook in the test frameworks.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I would dare to say on this point, that you should focus on &quot;breaking
</I>&gt;<i> the longest path&quot;. This is an issue we have dealt with since a number
</I>&gt;<i> of years in Debian. (each new version of OCaml require to recompile
</I>&gt;<i> all packages on all architecture of debian).
</I>&gt;<i>
</I>&gt;<i> Have a look at that:
</I>&gt;<i> <A HREF="http://pkg-ocaml-maint.alioth.debian.org/build_order.txt">http://pkg-ocaml-maint.alioth.debian.org/build_order.txt</A>
</I>&gt;<i>
</I>&gt;<i> Each package of a level can be build in parallel. So the compilation
</I>&gt;<i> time is roughly the sum of the longest package to build in each level.
</I>&gt;<i>
</I>&gt;<i> The first level is &quot;ocaml', which is among one of the longest step. I
</I>&gt;<i> would say that the full set can be build in ~2h on a recent computer.
</I>&gt;<i>
</I>&gt;<i> It is pretty straightforward to write a makefile that will do all this
</I>&gt;<i> compilation for you (and it will take you ~30 min to do so). I would
</I>&gt;<i> recommed you to start by this very simple solution, that will probably
</I>&gt;<i> scale to ~100 packages with no problem.
</I>&gt;<i>
</I>&gt;<i> Knowing the time it takes to compile Haskell or C++, I would say that
</I>&gt;<i> we are already pretty good at that -- no need to put it as a top
</I>&gt;<i> priority.
</I>&gt;<i>
</I>&gt;&gt;<i> This is all tooling, and can be done independently of the process of
</I>&gt;&gt;<i> selecting libraries.  For that selection, we need to think of this a bit
</I>&gt;&gt;<i> like a microkernel: pick the absolute smallest set of libraries we need
</I>&gt;&gt;<i> (including stripping down the OCaml standard library), and then working
</I>&gt;&gt;<i> our way up from there into a usable set of package.  Along the way, we'll
</I>&gt;&gt;<i> need to define 'platform tiers' to determine which ones absolutely have
</I>&gt;&gt;<i> to supported.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> An important note is that there'll be a reward for adapting your code
</I>&gt;&gt;<i> to run on the Platform.  The test system will regularly run *your* unit
</I>&gt;&gt;<i> tests on all the support platforms and send you reports.  Don't have a
</I>&gt;&gt;<i> FreeBSD/mips box, or a Raspberry Pi?  Opamalot will take care of that
</I>&gt;&gt;<i> for you and let you know if it comes and passes tests.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Amir and Leo are currently writing up the results of the various recent
</I>&gt;&gt;<i> meetings and will publish it soon.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -anil
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Platform mailing list
</I>&gt;<i> <A HREF="http://lists.ocaml.org/listinfo/platform">Platform at lists.ocaml.org</A>
</I>&gt;<i> <A HREF="http://lists.ocaml.org/listinfo/platform">http://lists.ocaml.org/listinfo/platform</A>
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000013.html">[ocaml-platform] The OCaml Platform
</A></li>
	<LI>Next message: <A HREF="000015.html">[ocaml-platform] The OCaml Platform
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ocaml.org/listinfo/platform">More information about the Platform
mailing list</a><br>
</body></html>
