From wojciech.meyer at gmail.com  Fri Mar  1 01:17:56 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Fri, 01 Mar 2013 01:17:56 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512FD793.30208@inria.fr> (Didier Remy's message of "Thu, 28 Feb
 2013 23:17:55 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
Message-ID: <wftxovex4r.fsf@gmail.com>

So we have two problems related to the order of the namespaces being open:

1. when merging namespaces, the order is important because of the
   possible overrides of the names
2. when opening namespaces order is important because of the order side
   effects modules might have.

The merging happens in two cases:
. when namespaces is being open in the OCaml code, withing the `open';
. in .ns file as explicitly when constructing namespaces.

The side effects happen in just single case, when the namespace is
brought to the scope - so that means this is only known when everything
is already properly merged, so it's not a problem.

Let's say for this hierarchy of namespaces:

Core
      Pervasive
      Std
      Extras
        Async
        TypeConv

but apart from that we could also have:

CorePkgs
      Pervasive
      Std
      TypeConv
      Async

we can easily predict how the modules will be open, assuming all the
namespaces below Core are auto-opened, however we could equally say:

  namespace alias Core = Core # { Pervasive, Std, Extras }
  open Core

  open Core # *

  open Core # **

  open Core # Extras # *

  open CorePkgs
  open CorePkgs # *

which roughly equals the syntax:
  use core.ns

Then with this syntax we are able to open Core and bring it to scope
with all the side effects we would expect.

Given all the facts and considerations about auto-opens, I'd suggest the
alternative to have just more expressive syntax for opening namespaces.

Didier Remy <Didier.Remy at inria.fr> writes:

>> I agree with your point about settilng deep semantic issues ahead of
>> syntactic one.  I would however submit that the question of whether
>> you should:
>>
>> - Have opens in the language proper, including local opens
>> - Have renames for namespaces in the language proper
>
> Yes, this is  the minimal, and probably agreed on.
>
> The main question whether namespaces are hierarchical or flat is still not
> answered, Flat namespaces are not much of an extension to OCaml and do not
> raise many questions about their semantics.  This is the benefit of Alain's
> proposal---but also its weakness to be limited in expressiveness.
>
> If namespaces are hierarchical, the simplest model is that of a graph where
> inner nodes are namespaces, leave nodes are module objects, edges are
> names (and directed).
>
> One question raised is whether edges should also carry auto-open flags, so
> that whenever a node is opened all other nodes reachable by auto-open edges
> are also opened.  This feature is strongly desired by Yaron, but it raises
> further issues...
>
> There is no reason for having just one such edge. Indeed, the idea is to
> break big modules into smaller ones so that only actually used modules need
> to be linked. The same should hold for auto-open modules.
>
> However, since opening modules is not commutative, auto-open edges must be
> ordered.  This means that the mental model to give to the user is not just
> a directed graph with label edges whose leaves are module objects, as
> described above, but whose edges (at least those flagged auto-opened) are
> also ordered.  I think this is a bit more complicated and not so nice that
> edges need to be both ordered and named...
>
> The problem comes from module leaves.  For inner nodes one could check the
> absence of conflicting names at the end of auto-open edges when building
> namespaces so that the order of opens would not matter.  But one cannot do
> so for leaves, because modules should remain opaque to namespaces (I think),
> hence conflicts cannot be detected when building the namespace,
>
> Yet another question raised by auto-open flags, which Gabriel and I
> discussed  today is how auto-open behaves on access paths.  Assume,
> for instance, a namespace containing:
>
>         ROOT . --Core--> C --Pervasives*--> M
>                           \
>                             --Std*--> S
>
> and that the module M contains a submodule List.  Should the user always
> write Core#Pervasives#List or could he simply write Core#List, since given
> that Pervasives is auto-open it could have just written
>
>            open Core
>            List
>
> to designate module M.List. Indeed, one could expect that both
>
>         let open path in Name
> and
>         path#Name
>
> return the same object.  This way, the ordinary user would not need to know
> about the Pervasives module.  Only the expert user who wishes to open just
> the Pervasives module and not its parent will have to know its existence and
> write
>
>         open Core#Pervasive
>
> Unfortunately, this choice of semantics implies that paths must be
> interpreted in a much more complex way: path#name need not only look at the
> node at path for an edge labeled Name but also at all nodes (recursively)
> reachable by auto-open edges!
>
> With these (small) complications in mind, do we still wish to have
> auto-open edges? It this the good model?
>
> ----------------
>
> In their absence, one would have to perform the auto-opens manually, and
> the order of opens would therefore be given by the user.
>
> The reason for auto-opens is to allow the user to just write
>
>         open Core
>
> instead of
>
>         open Core
>         open Pervasive
>         open Std
>
> Perhaps, an alternative to auto-open would be to allow one to write open
> directives in .ns files as well. Then, a file myenv.ns could both build a
> namespace and pre-open some of the nodes, including some of its leaves.  The
> user could then just put something as concise as
>
>         use myenv.ns
>
> at the top of his *.ml files. And if he opens myenv.ns he will have a very
> clear idea of what names should be visible.
>
> Just an idea, which I don't like so much either.  But is shows that there
> are still important details to be thought of and choices to be made.
>
> ----------------
>
> Notice that the problem comes from the fact that leaves of namespaces are
> opaque modules (and I think modules should remain opaque to namespaces), and
> as a result conflicting interfaces of modules cannot be detected when
> building a namespace, combined with the fact that the open construct of the
> module language is not itself strict (i.e. it may override bindings) and
> thus does not commute.
>
>         Didier
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

--
Wojciech Meyer
http://danmey.org

From yminsky at janestreet.com  Fri Mar  1 04:52:29 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 28 Feb 2013 23:52:29 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512FD793.30208@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
Message-ID: <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>

On Thu, Feb 28, 2013 at 5:17 PM, Didier Remy <Didier.Remy at inria.fr> wrote:
>> I agree with your point about settilng deep semantic issues ahead of
>> syntactic one.  I would however submit that the question of whether
>> you should:
>>
>> - Have opens in the language proper, including local opens
>> - Have renames for namespaces in the language proper
>
> Yes, this is  the minimal, and probably agreed on.

Lovely!

> The main question whether namespaces are hierarchical or flat is still not
> answered, Flat namespaces are not much of an extension to OCaml and do not
> raise many questions about their semantics.  This is the benefit of Alain's
> proposal---but also its weakness to be limited in expressiveness.

I don't really understand the goal of full hierarchical models.  I
would have thought that flat namespaces that include auto-open modules
would be quite sufficient.

One difference of opinion that I do have is that my intuition about
shadowing and dependencies on orders of opens is the opposite of
yours.  In particular, shadowing of names seems quite ordinary in
OCaml, it's an expected part of the language, and I would prefer for
namespaces to share that property.  Indeed, places where shadowing of
names is not possible (modules, in particular) have been a point of
frustration for us.

My inclination is that if you have two namespaces that define the same
module, and you open them in sequence, the second should simply shadow
the first.  Thus, I would expect to be able to write:

   open namespace Core#Std   (* defines a UNIX module *)

   ... some code that uses Core's UNIX ....

   open namespace Async#Std  (* defines a different UNIX module *)

   ... some code that uses Async's UNIX ....

I would be quite distressed to find that the namespace system
prevented the second open on the ground that it shadowed something in
the first.  This is precisely the behavior I would want and expect!

> If namespaces are hierarchical, the simplest model is that of a graph where
> inner nodes are namespaces, leave nodes are module objects, edges are
> names (and directed).
>
> One question raised is whether edges should also carry auto-open flags, so
> that whenever a node is opened all other nodes reachable by auto-open edges
> are also opened.  This feature is strongly desired by Yaron, but it raises
> further issues...
>
> There is no reason for having just one such edge. Indeed, the idea is to
> break big modules into smaller ones so that only actually used modules need
> to be linked. The same should hold for auto-open modules.
>
> However, since opening modules is not commutative, auto-open edges must be
> ordered.  This means that the mental model to give to the user is not just
> a directed graph with label edges whose leaves are module objects, as
> described above, but whose edges (at least those flagged auto-opened) are
> also ordered.  I think this is a bit more complicated and not so nice that
> edges need to be both ordered and named...
>
> The problem comes from module leaves.  For inner nodes one could check the
> absence of conflicting names at the end of auto-open edges when building
> namespaces so that the order of opens would not matter.  But one cannot do
> so for leaves, because modules should remain opaque to namespaces (I think),
> hence conflicts cannot be detected when building the namespace,
>
> Yet another question raised by auto-open flags, which Gabriel and I
> discussed  today is how auto-open behaves on access paths.  Assume,
> for instance, a namespace containing:
>
>         ROOT . --Core--> C --Pervasives*--> M
>                           \
>                             --Std*--> S

I apologize, but I just don't understand the example.  Is Pervasives a
module or a namespace?  I would assume it would be a module, since
I thought only modules are auto-open.  And what is the * for after Std
and Pervasives?

> and that the module M contains a submodule List.  Should the user always
> write Core#Pervasives#List or could he simply write Core#List, since given
> that Pervasives is auto-open it could have just written
>
>            open Core
>            List
>
> to designate module M.List. Indeed, one could expect that both
>
>         let open path in Name
> and
>         path#Name
>
> return the same object.  This way, the ordinary user would not need to know
> about the Pervasives module.  Only the expert user who wishes to open just
> the Pervasives module and not its parent will have to know its existence and
> write
>
>         open Core#Pervasive
>
> Unfortunately, this choice of semantics implies that paths must be
> interpreted in a much more complex way: path#name need not only look at the
> node at path for an edge labeled Name but also at all nodes (recursively)
> reachable by auto-open edges!
>
> With these (small) complications in mind, do we still wish to have
> auto-open edges? It this the good model?

As I said earlier, I'm pretty confused about the example above, so I
can't quite comment!

> ----------------
>
> In their absence, one would have to perform the auto-opens manually, and
> the order of opens would therefore be given by the user.
>
> The reason for auto-opens is to allow the user to just write
>
>         open Core
>
> instead of
>
>         open Core
>         open Pervasive
>         open Std
>
> Perhaps, an alternative to auto-open would be to allow one to write open
> directives in .ns files as well. Then, a file myenv.ns could both build a
> namespace and pre-open some of the nodes, including some of its leaves.  The
> user could then just put something as concise as
>
>         use myenv.ns
>
> at the top of his *.ml files. And if he opens myenv.ns he will have a very
> clear idea of what names should be visible.
>
> Just an idea, which I don't like so much either.  But is shows that there
> are still important details to be thought of and choices to be made.

How would the declaration "use myenv.ns" differ from "open namespace
Myenv"?  Are you proposing two different primitives, or would one only
have the "use" declaration?

I think my mental model of how namespaces should work is quite similar
to what you described above.  In particular, I would think that
opening a namespace would be the equivalent of adding a collection of
module aliases (possibly shadowing existing module names), and opening
some collection of modules (possible shadowing yet more module names
and other values).  All this should happen in whatever order is
described in the namespace definition file.

And in all of this, I view the dependency on order to be a feature,
not a bug.  OCaml is through and through full of this kind of
dependency, and I can see no justification for breaking that property
specifically with namespaces.  We like the behavior for values and
types, after all.  Why should namespaces be different?

> ----------------
>
> Notice that the problem comes from the fact that leaves of namespaces are
> opaque modules (and I think modules should remain opaque to namespaces), and
> as a result conflicting interfaces of modules cannot be detected when
> building a namespace, combined with the fact that the open construct of the
> module language is not itself strict (i.e. it may override bindings) and
> thus does not commute.

From alain.frisch at lexifi.com  Fri Mar  1 08:27:39 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 09:27:39 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <512FD793.30208@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
Message-ID: <5130667B.3050105@lexifi.com>

On 02/28/2013 11:17 PM, Didier Remy wrote:
>> I agree with your point about settilng deep semantic issues ahead of
>> syntactic one.  I would however submit that the question of whether
>> you should:
>>
>> - Have opens in the language proper, including local opens
>> - Have renames for namespaces in the language proper
>
> Yes, this is  the minimal, and probably agreed on.

I agree with the first point, but not the second one.  In my proposal, 
the only place where a ".ns" mapping file is referred to is the (local) 
open/using statement:

    open namespace Core  (* --->  loads core.ns *)

In this proposal, I don't think it is important to allow writing 
Core#List.map, since Core_List.map is always available.  Since .ns files 
are only "opened", I don't see the point of renaming them:

   alias namespace C = Core
   ...
   open namespace C


What would be useful is an aliasing feature for modules (which could 
serve to explain the meaning of .ns files in my proposal).

> The main question whether namespaces are hierarchical or flat is still not
> answered

I think the question itself assumes that namespaces are a new kind of 
objects (and then we can discuss what is their structure, flat or 
hierarchical, graph with ordered edges, etc).  But again, there are some 
ways to address the needs expressed in this discussion without 
introducing such a notion.  In my proposal, there is one single "space 
of names" for modules and compilation units plus a feature to control 
the mapping of module references to compilation units.  In this context, 
I don't even know how to interpret the question of whether namespaces 
are hierarchical or flat.  This does not mean that this question is 
pointless, only that it pertains only to a given category of solutions 
for the problems we are trying to solve.



Alain

From Didier.Remy at inria.fr  Fri Mar  1 09:56:31 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Fri, 01 Mar 2013 10:56:31 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
Message-ID: <51307B4F.4040006@inria.fr>

>> The main question whether namespaces are hierarchical or flat is still not
>> answered, Flat namespaces are not much of an extension to OCaml and do not
>> raise many questions about their semantics.  This is the benefit of Alain's
>> proposal---but also its weakness to be limited in expressiveness.
>
> I don't really understand the goal of full hierarchical models.  I
> would have thought that flat namespaces that include auto-open modules
> would be quite sufficient.

I thought you wanted a hierarchical model!
And you keep using hierarchical notation in your examples.

         open Core
         open Std
or
         open Core#Std

Isn't this hierarchical?
Do you mean hierarchical with just two levels?
If this what you mean by not being fully hierarchical?

But I don't think two levels or unbounded makes a significant difference,
technically.

> One difference of opinion that I do have is that my intuition about
> shadowing and dependencies on orders of opens is the opposite of
> yours.  In particular, shadowing of names seems quite ordinary in
> OCaml, it's an expected part of the language, and I would prefer for
> namespaces to share that property.  Indeed, places where shadowing of
> names is not possible (modules, in particular) have been a point of
> frustration for us.
>
> My inclination is that if you have two namespaces that define the same
> module, and you open them in sequence, the second should simply shadow
> the first.
>
>     open namespace Core#Std   (* defines a UNIX module *)
>
>     ... some code that uses Core's UNIX ....
>
>     open namespace Async#Std  (* defines a different UNIX module *)
>
>     ... some code that uses Async's UNIX ....
>
> I would be quite distressed to find that the namespace system
> prevented the second open on the ground that it shadowed something in
> the first.  This is precisely the behavior I would want and expect!

I am not sure of what you exactly want.

In the simplest hierarchical model, namespaces are nodes of a graph whose
directed edges are names to access sub-namespaces (internal nodes)
or module objects (leaves).

In this model namespaces are not ordered, i.e. edges leaving from one node
are not ordered.

This is, I think, an easier model, because you can populate a namespace by
listing available module objects in a directory---which is not ordered.

In this model:

1) you can open a node, with either a strict semantics (detecting overrides)
    or an overriding semantics (given priority to the names coming from the
    open).

2) However, you cannot open several nodes at the same time without
    specifying an ordering between those nodes.

3) Hence, you cannot do auto-open if you have several auto-open edges
    leaving from the same node unless auto-open edges are ordered.

If wish to do (3) you would need to order edges (at least auto-open ones) in
the namespace. You may then wish all edges to be ordered.  However, I think
this is not a good model.  An intermediate option is to just order auto-open
nodes when you declare them.  This is better than ordering all nodes---we
may assume that auto-open nodes are few.  But this mixed model is more
complicated for the user.  (See at the end of this message while the fully
ordered model is not good in my opinion.)

>>          ROOT . --Core--> C --Pervasives*--> M
>>                            \
>>                              --Std*--> S
>
> I apologize, but I just don't understand the example.  Is Pervasives a
> module or a namespace?  I would assume it would be a module, since
> I thought only modules are auto-open.  And what is the * for after Std
> and Pervasives?

Here Pervasives is the name of the edge that goes from namespace C to the
module object M.  Core is the name of the edge that goes from the toplevel
name space to the sub-namespace C.  You have to distinct the name and the
object in the model.  You could have several paths leading to the same
object.

The * is the auto-open flag, as used in Gabriel's description.
Sorry for leaving this implicit.

>> Perhaps, an alternative to auto-open would be to allow one to write open
>> directives in .ns files as well. Then, a file myenv.ns could both build a
>> namespace and pre-open some of the nodes, including some of its leaves.  The
>> user could then just put something as concise as
>>
>>          use myenv.ns
>>
>> at the top of his *.ml files. And if he opens myenv.ns he will have a very
>> clear idea of what names should be visible.
>>
>> Just an idea, which I don't like so much either.  But is shows that there
>> are still important details to be thought of and choices to be made.
>
> How would the declaration "use myenv.ns" differ from "open namespace
> Myenv"?

Here Myenv is not a namespace but a file containing namespaces commands.
Some of the commands would build the environment, and my proposal is that
namespace file could also contain open commands.  (opening a name space can
be seen as the construction of a namespace, but opening a module cannot.)

> Are you proposing two different primitives, or would one only
> have the "use" declaration?

This is syntax. The point is that auto-open complicates things and if the
only reason to have it is that you do not wish to repeat or have every user
write the sequence

         open Core (* that contains Pervasives, Std, etc. *)
         open Pervasives
         open Std

then you could disallow auto-opens and instead allow a namespace file
myenv.ns to also contain commands that open modules. They you would only
invoke this file (with whatever syntax to be chosen) at the beginning of
your .ml source files.

> I think my mental model of how namespaces should work is quite similar
> to what you described above.  In particular, I would think that
> opening a namespace would be the equivalent of adding a collection of
> module aliases (possibly shadowing existing module names), and opening
> some collection of modules (possible shadowing yet more module names
> and other values).  All this should happen in whatever order is
> described in the namespace definition file.

The last sentence means that namespaces objects are ordered in your mind.
Not in mine. In my (simplest) model, namespace objects are not ordered,
but open (module) directives are ordered.

> And in all of this, I view the dependency on order to be a feature,
> not a bug.   OCaml is through and through full of this kind of
> dependency, and I can see no justification for breaking that property
> specifically with namespaces.  We like the behavior for values and
> types, after all.  Why should namespaces be different?

I think you are talking about dependency on on the order when you open
things.  This need does not imply a dependency on the order or edges in the
namespace structure.  If you open things (namespaces or modules) one by one,
you need not order edges in the namespace structure.

----------------

I think namespaces should be unordered to scale up.

You would like to be able to represent all available libraries in the OCaml
world as a namespace, with libraries coming from many different sources and
there is no natural order on these, i.e. no order that could be given a
meaningful semantics.  Would you put World#JaneStreet before World#Lexify or
the other way round?

If name spaces are unordered, it is also easy to populate them by reading
and merging different sources in a strict way: name spaces are meant to
avoid conflicting names to start with, so if a merge introduces conflicts,
this is really the right place to fix it by renaming one side or
reorganizing the hierarchy rather than do some silent overriding.

When getting closer to the leaves, the situation is a bit different, because
nodes may all come from the same source/library.  Here, it may be desirable
(yet to be confirmed) to have auto-opens and thus introduce some ordering.
Ordering towards the leaves is less of a problem in practice and those name
spaces may be built by explicitly listing all components---rather than
scanning and merging different sources. So it seems ok in practice.  Still,
it implies optional ordering of edges and slightly complicates the mental
model.

Hope this helps,

     Didier

From yminsky at janestreet.com  Fri Mar  1 11:53:51 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 1 Mar 2013 06:53:51 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <51307B4F.4040006@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
Message-ID: <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>

On Fri, Mar 1, 2013 at 4:56 AM, Didier Remy <Didier.Remy at inria.fr> wrote:
>>> The main question whether namespaces are hierarchical or flat is still
>>> not
>>> answered, Flat namespaces are not much of an extension to OCaml and do
>>> not
>>> raise many questions about their semantics.  This is the benefit of
>>> Alain's
>>> proposal---but also its weakness to be limited in expressiveness.
>>
>>
>> I don't really understand the goal of full hierarchical models.  I
>> would have thought that flat namespaces that include auto-open modules
>> would be quite sufficient.
>
>
> I thought you wanted a hierarchical model!
> And you keep using hierarchical notation in your examples.
>
>         open Core
>         open Std
> or
>         open Core#Std
>
> Isn't this hierarchical?
> Do you mean hierarchical with just two levels?
> If this what you mean by not being fully hierarchical?
>
> But I don't think two levels or unbounded makes a significant difference,
> technically.

I see how I've given that impression.  I've sometimes used the
hierarchical # notation that others have mooted, but it does not seem
necessary to me.  Core definitely needs multiple overlapping
namespaces, but I don't know that any hierarchy is required.  I think
if they were called Core_Std and Core_Stable, I think I would be quite
happy.

(That said, hierarchy in such things is often natural, and if it
didn't present technical difficulties to have the namespaces be
hierarchical in some sense, I wouldn't object.  But I don't yet know
what I'd use it for in practice.)

>> One difference of opinion that I do have is that my intuition about
>> shadowing and dependencies on orders of opens is the opposite of
>> yours.  In particular, shadowing of names seems quite ordinary in
>> OCaml, it's an expected part of the language, and I would prefer for
>> namespaces to share that property.  Indeed, places where shadowing of
>> names is not possible (modules, in particular) have been a point of
>> frustration for us.
>>
>> My inclination is that if you have two namespaces that define the same
>> module, and you open them in sequence, the second should simply shadow
>> the first.
>>
>>     open namespace Core#Std   (* defines a UNIX module *)
>>
>>     ... some code that uses Core's UNIX ....
>>
>>     open namespace Async#Std  (* defines a different UNIX module *)
>>
>>     ... some code that uses Async's UNIX ....
>>
>> I would be quite distressed to find that the namespace system
>> prevented the second open on the ground that it shadowed something in
>> the first.  This is precisely the behavior I would want and expect!
>
>
> I am not sure of what you exactly want.
>
> In the simplest hierarchical model, namespaces are nodes of a graph whose
> directed edges are names to access sub-namespaces (internal nodes)
> or module objects (leaves).
>
> In this model namespaces are not ordered, i.e. edges leaving from one node
> are not ordered.
>
> This is, I think, an easier model, because you can populate a namespace by
> listing available module objects in a directory---which is not ordered.
>
> In this model:
>
> 1) you can open a node, with either a strict semantics (detecting overrides)
>    or an overriding semantics (given priority to the names coming from the
>    open).
>
> 2) However, you cannot open several nodes at the same time without
>    specifying an ordering between those nodes.

What does it mean to open several nodes "at the same time"?  I would
have thought that opening of nodes would always be ordered, since the
open statements would need to be written in some order.

> 3) Hence, you cannot do auto-open if you have several auto-open edges
>    leaving from the same node unless auto-open edges are ordered.

I agree that the module opens assocaited with a namespace must be
ordered.  I'm not sure why that's problematic, though.  It just seems
like the right design decision.

> If wish to do (3) you would need to order edges (at least auto-open ones) in
> the namespace. You may then wish all edges to be ordered.  However, I think
> this is not a good model.  An intermediate option is to just order auto-open
> nodes when you declare them.  This is better than ordering all nodes---we
> may assume that auto-open nodes are few.  But this mixed model is more
> complicated for the user.  (See at the end of this message while the fully
> ordered model is not good in my opinion.)

I would have assumed that one would order all nodes, and I don't see
the downsides of this, actually.  Why would one prefer an unordered
semantics?  All of the rest of OCaml's namespace manipulations
(variable bindings, module opens, module bindings) are order
dependent.  Why make namespaces different?

>
>>>          ROOT . --Core--> C --Pervasives*--> M
>>>                            \
>>>                              --Std*--> S
>>
>>
>> I apologize, but I just don't understand the example.  Is Pervasives a
>> module or a namespace?  I would assume it would be a module, since
>> I thought only modules are auto-open.  And what is the * for after Std
>> and Pervasives?
>
>
> Here Pervasives is the name of the edge that goes from namespace C to the
> module object M.  Core is the name of the edge that goes from the toplevel
> name space to the sub-namespace C.  You have to distinct the name and the
> object in the model.  You could have several paths leading to the same
> object.
>
> The * is the auto-open flag, as used in Gabriel's description.
> Sorry for leaving this implicit.

Got it.  That's quite helpful, though I'm still a little lost about
the problem you're describing.  It sounds to me like the issue dervies
from the fact that you're proposing opening up a parent namespace as
an operation that opens all children as well.  Is that right?  I
hadn't even begun to imagine wanting that feature, so maybe that isn't
a real issue at all?  Or perhaps I'm just confused....

>>> Perhaps, an alternative to auto-open would be to allow one to write open
>>> directives in .ns files as well. Then, a file myenv.ns could both build a
>>> namespace and pre-open some of the nodes, including some of its leaves.
>>> The
>>> user could then just put something as concise as
>>>
>>>          use myenv.ns
>>>
>>> at the top of his *.ml files. And if he opens myenv.ns he will
>>> have a very clear idea of what names should be visible.
>>>
>>> Just an idea, which I don't like so much either.  But is shows
>>> that there are still important details to be thought of and
>>> choices to be made.
>>
>>
>> How would the declaration "use myenv.ns" differ from "open namespace
>> Myenv"?
>
>
> Here Myenv is not a namespace but a file containing namespaces commands.
> Some of the commands would build the environment, and my proposal is that
> namespace file could also contain open commands.  (opening a name space can
> be seen as the construction of a namespace, but opening a module cannot.)
>
>
>> Are you proposing two different primitives, or would one only
>> have the "use" declaration?
>
>
> This is syntax. The point is that auto-open complicates things and if the
> only reason to have it is that you do not wish to repeat or have every user
> write the sequence
>
>         open Core (* that contains Pervasives, Std, etc. *)
>         open Pervasives
>         open Std
>
> then you could disallow auto-opens and instead allow a namespace file
> myenv.ns to also contain commands that open modules. They you would only
> invoke this file (with whatever syntax to be chosen) at the beginning of
> your .ml source files.

I had thought that in Alain's world, namespaces are almost nothing
more than sequences of module aliases, to which I was proposing adding
module opens.  We do need more than this structure in order to get
error messages and documentation right, so that model is somewhat too
impoverished, no doubt.

>> I think my mental model of how namespaces should work is quite similar
>> to what you described above.  In particular, I would think that
>> opening a namespace would be the equivalent of adding a collection of
>> module aliases (possibly shadowing existing module names), and opening
>> some collection of modules (possible shadowing yet more module names
>> and other values).  All this should happen in whatever order is
>> described in the namespace definition file.
>
>
> The last sentence means that namespaces objects are ordered in your mind.
> Not in mine. In my (simplest) model, namespace objects are not ordered,
> but open (module) directives are ordered.
>
>> And in all of this, I view the dependency on order to be a feature,
>> not a bug.   OCaml is through and through full of this kind of
>> dependency, and I can see no justification for breaking that property
>> specifically with namespaces.  We like the behavior for values and
>> types, after all.  Why should namespaces be different?
>
>
> I think you are talking about dependency on on the order when you open
> things.  This need does not imply a dependency on the order or edges in the
> namespace structure.  If you open things (namespaces or modules) one by one,
> you need not order edges in the namespace structure.
>
> ----------------
>
> I think namespaces should be unordered to scale up.
>
> You would like to be able to represent all available libraries in the OCaml
> world as a namespace, with libraries coming from many different sources and
> there is no natural order on these, i.e. no order that could be given a
> meaningful semantics.  Would you put World#JaneStreet before World#Lexify or
> the other way round?
>
> If name spaces are unordered, it is also easy to populate them by reading
> and merging different sources in a strict way: name spaces are meant to
> avoid conflicting names to start with, so if a merge introduces conflicts,
> this is really the right place to fix it by renaming one side or
> reorganizing the hierarchy rather than do some silent overriding.

I wonder if this all comes down to different thoughts about hierarchy.
I guess I wouldn't think the namespace World#JaneStreet would be
ordered compared to World#Lexify, but the module aliases and opens
contained in a namespace would, I thought, have been ordered.  And
surely, when you open multiple namespaces in your environment, you can
be including the same name multiple times, at which point I believe
the proper semantics is shadowing.

Again, my feeling about this is that we should to the degree possible
stick to the way OCaml behaves now, and now, non-commutative
declarations with shadowing is the norm.  Deviating from this would I
think only confuse developers.

> When getting closer to the leaves, the situation is a bit different, because
> nodes may all come from the same source/library.  Here, it may be desirable
> (yet to be confirmed) to have auto-opens and thus introduce some ordering.
> Ordering towards the leaves is less of a problem in practice and those name
> spaces may be built by explicitly listing all components---rather than
> scanning and merging different sources. So it seems ok in practice.  Still,
> it implies optional ordering of edges and slightly complicates the mental
> model.
>
> Hope this helps,

I think what I'm mostly confused about is what is the nature of the
hierarchical namespace system you're thinking about. What are the
operations available?  Do you intend to have namespace opens also
recursively open all children?  Is there an operation for merging
namespaces?  Aliasing upper namespaces?  Right now, I lack both a
precise mental model of what you mean by hierarchical namespaces, and
an understanding of the language features that motivate this
hierarchy.


>     Didier

From yminsky at janestreet.com  Fri Mar  1 11:59:45 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 1 Mar 2013 06:59:45 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130667B.3050105@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr> <5130667B.3050105@lexifi.com>
Message-ID: <CACLX4jTizzRQNAXCPkq=K_FKQjijr-Be0YAhEBD=g4wm5NzuXA@mail.gmail.com>

On Fri, Mar 1, 2013 at 3:27 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/28/2013 11:17 PM, Didier Remy wrote:
>>>
>>> I agree with your point about settilng deep semantic issues ahead of
>>> syntactic one.  I would however submit that the question of whether
>>> you should:
>>>
>>> - Have opens in the language proper, including local opens
>>> - Have renames for namespaces in the language proper
>>
>>
>> Yes, this is  the minimal, and probably agreed on.
>
>
> I agree with the first point, but not the second one.  In my proposal, the
> only place where a ".ns" mapping file is referred to is the (local)
> open/using statement:
>
>    open namespace Core  (* --->  loads core.ns *)
>
> In this proposal, I don't think it is important to allow writing
> Core#List.map, since Core_List.map is always available.  Since .ns files are
> only "opened", I don't see the point of renaming them:
>
>   alias namespace C = Core
>   ...
>   open namespace C
>
>
> What would be useful is an aliasing feature for modules (which could serve
> to explain the meaning of .ns files in my proposal).

Aha!  We uncover another difference of opinion!  I wouldn't have
thought that namespaces are "only opened".  I would have thought one
could use namespaces as qualifiers as well.  In other words, were I to
write:

   open namespace Core
   open namespace Async

where the second open shadows some elements of the first (like the
Unix module), I'd still like to be able to explicitly reach in, and
write something like

   Core#Unix

to access Core's Unix library.   Given the desire to use namespaces as
explicit qualifiers, aliasing becomes obviously useful as well, since
you may want to use the qualifier over and over in a small chunk of
code, at which point a short name becomes useful.

so, I think my list of required namespace operations is:

- module-level namespace opens
- local namespace opens
- explicit qualification by namespace
- namespace aliases

y

>> The main question whether namespaces are hierarchical or flat is still not
>> answered
>
>
> I think the question itself assumes that namespaces are a new kind of
> objects (and then we can discuss what is their structure, flat or
> hierarchical, graph with ordered edges, etc).  But again, there are some
> ways to address the needs expressed in this discussion without introducing
> such a notion.  In my proposal, there is one single "space of names" for
> modules and compilation units plus a feature to control the mapping of
> module references to compilation units.  In this context, I don't even know
> how to interpret the question of whether namespaces are hierarchical or
> flat.  This does not mean that this question is pointless, only that it
> pertains only to a given category of solutions for the problems we are
> trying to solve.
>
>
>
> Alain

From gabriel.scherer at gmail.com  Fri Mar  1 12:13:49 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 1 Mar 2013 13:13:49 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
Message-ID: <CAPFanBHL2h6e3juA8367-Yqag24v01Vxrj2Yf-oa3+qjbQP2sQ@mail.gmail.com>

> I think what I'm mostly confused about is what is the nature of the
> hierarchical namespace system you're thinking about. What are the
> operations available?  Do you intend to have namespace opens also
> recursively open all children?  Is there an operation for merging
> namespaces?  Aliasing upper namespaces?  Right now, I lack both a
> precise mental model of what you mean by hierarchical namespaces, and
> an understanding of the language features that motivate this
> hierarchy.

I recommend that you have a look at the document I posted as the
starting point for the discussion:
  http://gallium.inria.fr/~scherer/namespaces/spec.pdf

It is not monolithic in the sense that it must be understood as
describing the problem space and possible design choices.

It does not mention the "flat access" feature (the auto-open for
Pervasives, etc.) which comes from an older, more advanced (and less
pertinent for now) document. (A previous mail by Didier explained the
design issues around auto-open well. Regarding the compromises to
make, I would tend to slightly diverge by accepting a fully ordered
model and giving up on the robustness of strict merging on leaves. I
disagree, however, with the liking you have for name shadowing at
large scales and think this should be restricted as much as possible,
but it's a rather orthogonal aspect that's best left for another
discussion.).

Another distinct aspect of the proposal is its insistence on
introducing a difference between internal compilation unit names (as
used by the linker) and external compilation unit names (as seen by
the programmer), currently both derived from the filename. That's a
gray part of the design discussion that has seen little contributions,
and Alain's suggestion to just do nothing at all there is probably a
reasonable basis for experimentation. In this light, the "Compilation
unit information" part of the document may be ignored.

Regarding "features that motivate a hierarchy": 'open'. Alain's
proposal is a hierarchy with only two levels, the names of the .ns
files (first level) and the compilation unit names and their aliases
(second level). In your examples both are apparent in source code and
have distinct semantics properties (leaves are modules, non-leaves
("namespace names") are not). As Didier said, I believe there is
little technical difference between two-levels hierarchies and a full
hierarchical model (in particular believing that it makes design
problems simpler is delusive), but I don't have a particular opinion
on what should end up in an actual implementation, other than a desire
for a solution that *can* gracefully scale towards a full hierarchy if
we start needing it in the future.

On Fri, Mar 1, 2013 at 12:53 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Fri, Mar 1, 2013 at 4:56 AM, Didier Remy <Didier.Remy at inria.fr> wrote:
>>>> The main question whether namespaces are hierarchical or flat is still
>>>> not
>>>> answered, Flat namespaces are not much of an extension to OCaml and do
>>>> not
>>>> raise many questions about their semantics.  This is the benefit of
>>>> Alain's
>>>> proposal---but also its weakness to be limited in expressiveness.
>>>
>>>
>>> I don't really understand the goal of full hierarchical models.  I
>>> would have thought that flat namespaces that include auto-open modules
>>> would be quite sufficient.
>>
>>
>> I thought you wanted a hierarchical model!
>> And you keep using hierarchical notation in your examples.
>>
>>         open Core
>>         open Std
>> or
>>         open Core#Std
>>
>> Isn't this hierarchical?
>> Do you mean hierarchical with just two levels?
>> If this what you mean by not being fully hierarchical?
>>
>> But I don't think two levels or unbounded makes a significant difference,
>> technically.
>
> I see how I've given that impression.  I've sometimes used the
> hierarchical # notation that others have mooted, but it does not seem
> necessary to me.  Core definitely needs multiple overlapping
> namespaces, but I don't know that any hierarchy is required.  I think
> if they were called Core_Std and Core_Stable, I think I would be quite
> happy.
>
> (That said, hierarchy in such things is often natural, and if it
> didn't present technical difficulties to have the namespaces be
> hierarchical in some sense, I wouldn't object.  But I don't yet know
> what I'd use it for in practice.)
>
>>> One difference of opinion that I do have is that my intuition about
>>> shadowing and dependencies on orders of opens is the opposite of
>>> yours.  In particular, shadowing of names seems quite ordinary in
>>> OCaml, it's an expected part of the language, and I would prefer for
>>> namespaces to share that property.  Indeed, places where shadowing of
>>> names is not possible (modules, in particular) have been a point of
>>> frustration for us.
>>>
>>> My inclination is that if you have two namespaces that define the same
>>> module, and you open them in sequence, the second should simply shadow
>>> the first.
>>>
>>>     open namespace Core#Std   (* defines a UNIX module *)
>>>
>>>     ... some code that uses Core's UNIX ....
>>>
>>>     open namespace Async#Std  (* defines a different UNIX module *)
>>>
>>>     ... some code that uses Async's UNIX ....
>>>
>>> I would be quite distressed to find that the namespace system
>>> prevented the second open on the ground that it shadowed something in
>>> the first.  This is precisely the behavior I would want and expect!
>>
>>
>> I am not sure of what you exactly want.
>>
>> In the simplest hierarchical model, namespaces are nodes of a graph whose
>> directed edges are names to access sub-namespaces (internal nodes)
>> or module objects (leaves).
>>
>> In this model namespaces are not ordered, i.e. edges leaving from one node
>> are not ordered.
>>
>> This is, I think, an easier model, because you can populate a namespace by
>> listing available module objects in a directory---which is not ordered.
>>
>> In this model:
>>
>> 1) you can open a node, with either a strict semantics (detecting overrides)
>>    or an overriding semantics (given priority to the names coming from the
>>    open).
>>
>> 2) However, you cannot open several nodes at the same time without
>>    specifying an ordering between those nodes.
>
> What does it mean to open several nodes "at the same time"?  I would
> have thought that opening of nodes would always be ordered, since the
> open statements would need to be written in some order.
>
>> 3) Hence, you cannot do auto-open if you have several auto-open edges
>>    leaving from the same node unless auto-open edges are ordered.
>
> I agree that the module opens assocaited with a namespace must be
> ordered.  I'm not sure why that's problematic, though.  It just seems
> like the right design decision.
>
>> If wish to do (3) you would need to order edges (at least auto-open ones) in
>> the namespace. You may then wish all edges to be ordered.  However, I think
>> this is not a good model.  An intermediate option is to just order auto-open
>> nodes when you declare them.  This is better than ordering all nodes---we
>> may assume that auto-open nodes are few.  But this mixed model is more
>> complicated for the user.  (See at the end of this message while the fully
>> ordered model is not good in my opinion.)
>
> I would have assumed that one would order all nodes, and I don't see
> the downsides of this, actually.  Why would one prefer an unordered
> semantics?  All of the rest of OCaml's namespace manipulations
> (variable bindings, module opens, module bindings) are order
> dependent.  Why make namespaces different?
>
>>
>>>>          ROOT . --Core--> C --Pervasives*--> M
>>>>                            \
>>>>                              --Std*--> S
>>>
>>>
>>> I apologize, but I just don't understand the example.  Is Pervasives a
>>> module or a namespace?  I would assume it would be a module, since
>>> I thought only modules are auto-open.  And what is the * for after Std
>>> and Pervasives?
>>
>>
>> Here Pervasives is the name of the edge that goes from namespace C to the
>> module object M.  Core is the name of the edge that goes from the toplevel
>> name space to the sub-namespace C.  You have to distinct the name and the
>> object in the model.  You could have several paths leading to the same
>> object.
>>
>> The * is the auto-open flag, as used in Gabriel's description.
>> Sorry for leaving this implicit.
>
> Got it.  That's quite helpful, though I'm still a little lost about
> the problem you're describing.  It sounds to me like the issue dervies
> from the fact that you're proposing opening up a parent namespace as
> an operation that opens all children as well.  Is that right?  I
> hadn't even begun to imagine wanting that feature, so maybe that isn't
> a real issue at all?  Or perhaps I'm just confused....
>
>>>> Perhaps, an alternative to auto-open would be to allow one to write open
>>>> directives in .ns files as well. Then, a file myenv.ns could both build a
>>>> namespace and pre-open some of the nodes, including some of its leaves.
>>>> The
>>>> user could then just put something as concise as
>>>>
>>>>          use myenv.ns
>>>>
>>>> at the top of his *.ml files. And if he opens myenv.ns he will
>>>> have a very clear idea of what names should be visible.
>>>>
>>>> Just an idea, which I don't like so much either.  But is shows
>>>> that there are still important details to be thought of and
>>>> choices to be made.
>>>
>>>
>>> How would the declaration "use myenv.ns" differ from "open namespace
>>> Myenv"?
>>
>>
>> Here Myenv is not a namespace but a file containing namespaces commands.
>> Some of the commands would build the environment, and my proposal is that
>> namespace file could also contain open commands.  (opening a name space can
>> be seen as the construction of a namespace, but opening a module cannot.)
>>
>>
>>> Are you proposing two different primitives, or would one only
>>> have the "use" declaration?
>>
>>
>> This is syntax. The point is that auto-open complicates things and if the
>> only reason to have it is that you do not wish to repeat or have every user
>> write the sequence
>>
>>         open Core (* that contains Pervasives, Std, etc. *)
>>         open Pervasives
>>         open Std
>>
>> then you could disallow auto-opens and instead allow a namespace file
>> myenv.ns to also contain commands that open modules. They you would only
>> invoke this file (with whatever syntax to be chosen) at the beginning of
>> your .ml source files.
>
> I had thought that in Alain's world, namespaces are almost nothing
> more than sequences of module aliases, to which I was proposing adding
> module opens.  We do need more than this structure in order to get
> error messages and documentation right, so that model is somewhat too
> impoverished, no doubt.
>
>>> I think my mental model of how namespaces should work is quite similar
>>> to what you described above.  In particular, I would think that
>>> opening a namespace would be the equivalent of adding a collection of
>>> module aliases (possibly shadowing existing module names), and opening
>>> some collection of modules (possible shadowing yet more module names
>>> and other values).  All this should happen in whatever order is
>>> described in the namespace definition file.
>>
>>
>> The last sentence means that namespaces objects are ordered in your mind.
>> Not in mine. In my (simplest) model, namespace objects are not ordered,
>> but open (module) directives are ordered.
>>
>>> And in all of this, I view the dependency on order to be a feature,
>>> not a bug.   OCaml is through and through full of this kind of
>>> dependency, and I can see no justification for breaking that property
>>> specifically with namespaces.  We like the behavior for values and
>>> types, after all.  Why should namespaces be different?
>>
>>
>> I think you are talking about dependency on on the order when you open
>> things.  This need does not imply a dependency on the order or edges in the
>> namespace structure.  If you open things (namespaces or modules) one by one,
>> you need not order edges in the namespace structure.
>>
>> ----------------
>>
>> I think namespaces should be unordered to scale up.
>>
>> You would like to be able to represent all available libraries in the OCaml
>> world as a namespace, with libraries coming from many different sources and
>> there is no natural order on these, i.e. no order that could be given a
>> meaningful semantics.  Would you put World#JaneStreet before World#Lexify or
>> the other way round?
>>
>> If name spaces are unordered, it is also easy to populate them by reading
>> and merging different sources in a strict way: name spaces are meant to
>> avoid conflicting names to start with, so if a merge introduces conflicts,
>> this is really the right place to fix it by renaming one side or
>> reorganizing the hierarchy rather than do some silent overriding.
>
> I wonder if this all comes down to different thoughts about hierarchy.
> I guess I wouldn't think the namespace World#JaneStreet would be
> ordered compared to World#Lexify, but the module aliases and opens
> contained in a namespace would, I thought, have been ordered.  And
> surely, when you open multiple namespaces in your environment, you can
> be including the same name multiple times, at which point I believe
> the proper semantics is shadowing.
>
> Again, my feeling about this is that we should to the degree possible
> stick to the way OCaml behaves now, and now, non-commutative
> declarations with shadowing is the norm.  Deviating from this would I
> think only confuse developers.
>
>> When getting closer to the leaves, the situation is a bit different, because
>> nodes may all come from the same source/library.  Here, it may be desirable
>> (yet to be confirmed) to have auto-opens and thus introduce some ordering.
>> Ordering towards the leaves is less of a problem in practice and those name
>> spaces may be built by explicitly listing all components---rather than
>> scanning and merging different sources. So it seems ok in practice.  Still,
>> it implies optional ordering of edges and slightly complicates the mental
>> model.
>>
>> Hope this helps,
>
> I think what I'm mostly confused about is what is the nature of the
> hierarchical namespace system you're thinking about. What are the
> operations available?  Do you intend to have namespace opens also
> recursively open all children?  Is there an operation for merging
> namespaces?  Aliasing upper namespaces?  Right now, I lack both a
> precise mental model of what you mean by hierarchical namespaces, and
> an understanding of the language features that motivate this
> hierarchy.
>
>
>>     Didier
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From Didier.Remy at inria.fr  Fri Mar  1 13:18:12 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Fri, 01 Mar 2013 14:18:12 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
Message-ID: <5130AA94.9070008@inria.fr>

>> 2) However, you cannot open several nodes at the same time without
>>     specifying an ordering between those nodes.
>
> What does it mean to open several nodes "at the same time"?  I would
> have thought that opening of nodes would always be ordered, since the
> open statements would need to be written in some order.

If Core has two auto-open subnodes (e.g Std and Pervasives), then opening
core will open the two auto-open subnodes at the same time. This is what I
meant.

In this case, you write with the auto-open semantics

         open Core

and what happens is equivalent to (without the auto-open semantics)

         open Core
         open Std
         open Pervasives
or
         open Core
         open Std
         open Pervasives

So the edges Std and Pervasives need both leaving from Core need to be
ordered in the namespace.

>> The * is the auto-open flag, as used in Gabriel's description.
>> Sorry for leaving this implicit.
>
> Got it.  That's quite helpful, though I'm still a little lost about
> the problem you're describing.  It sounds to me like the issue dervies
> from the fact that you're proposing opening up a parent namespace as
> an operation that opens all children as well.  Is that right?

Yes, an operation that opens all children marked auto-open.

> I hadn't even begun to imagine wanting that feature, so maybe that isn't a
> real issue at all?  Or perhaps I'm just confused....

I thought this is what you where asked for when saying that you want

         open Core

to behaves as

         open Core
         open Std
         open Pervasives

because you have marked Std and Pervasives as auto-open.

>> I think namespaces should be unordered to scale up.
>>
>> You would like to be able to represent all available libraries in the OCaml
>> world as a namespace, with libraries coming from many different sources and
>> there is no natural order on these, i.e. no order that could be given a
>> meaningful semantics.  Would you put World#JaneStreet before World#Lexify or
>> the other way round?
>>
>> If name spaces are unordered, it is also easy to populate them by reading
>> and merging different sources in a strict way: name spaces are meant to
>> avoid conflicting names to start with, so if a merge introduces conflicts,
>> this is really the right place to fix it by renaming one side or
>> reorganizing the hierarchy rather than do some silent overriding.
>
> I wonder if this all comes down to different thoughts about hierarchy.
> I guess I wouldn't think the namespace World#JaneStreet would be
> ordered compared to World#Lexify, but the module aliases and opens
> contained in a namespace would, I thought, have been ordered.  And
> surely, when you open multiple namespaces in your environment, you can
> be including the same name multiple times, at which point I believe
> the proper semantics is shadowing.

Here, you are reasoning in Alain's model where a namespace file is just a
sequence of operations (alias or open).  So you don't have a proper notion
of namespace model and instead understand a namespace file as its immediate
action on the current scope.

This is find to reason in the small, to reason about the imports of a
module source file.

But I don't think this is a good model that would scale to providing a
unified view of all available libraries where you wish to construct
namespaces a posteriori by combining existing ones.

>> Hope this helps,
>
> I think what I'm mostly confused about is what is the nature of the
> hierarchical namespace system you're thinking about. What are the
> operations available?

The model is what has been described by Gabriel:

   http://gallium.inria.fr/~scherer/namespaces/spec.pdf

and

   http://gallium.inria.fr/~scherer/namespaces/pack_et_functor_pack.html

> Do you intend to have namespace opens also recursively open all children?

I thought this was your wish.
But I think it is more a drawback than a convenience.

> Is there an operation for merging namespaces?

Yes.

> Aliasing upper namespaces?

Yes, you can have several paths leading to the same module object.

> Right now, I lack both a precise mental model of what you mean by
> hierarchical namespaces,

   http://gallium.inria.fr/~scherer/namespaces/spec.pdf

> and an understanding of the language features that motivate this
> hierarchy.

Although you do not say it clearly, I think you wish at least Alain's
2-level hierarchal model.

This may be fine from your point of view:

         level 1 is for JaneStreet different libraries
         level 2 is for the modules of each library

Most of your libraries are for internal use. So in a way you do not have to
share your namespaces with the rest of the world. I think the problem comes
when people want to share the namespaces.

For instance, there could be two actors Foo and Bar proposing complementary
set of libraries for programming the web.

When doing web programming I may wish to use parts of both providers
Then, I may wish to structure names as

         Web
             Foo
                 Lib1
                    <list of modules>
                 Lib2
                    <list of modules>
             Bar

In the 2-level model I would be forced to rename namespace files
to avoid clashes and get some long list of namespace_files that would look
like:

         Web_Foo_Lib1
         Web_Foo_Lib2
         Web_Bar

In this model, the reorganization of namespaces exported by users Foo and
Bar has into my own view has to be done manually.  The fact that names carry
some implicit structure is an indication that one has some hierarchy in
mind.

In the hierachical view, it would suffice to assemble them within the
language of namespaces, using operations like merge, perhaps pruning, etc..

Besides, I do not think that a 2-level model is so much simpler than a
hierarchical one.  The apparent simplificty of Alain's proposal is more I
think in the fact that he does not manipulate namespaces explicitly (such as
pruning, merging, etc.)

     Didier

From Didier.Remy at inria.fr  Fri Mar  1 13:38:29 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Fri, 01 Mar 2013 14:38:29 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130667B.3050105@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr> <5130667B.3050105@lexifi.com>
Message-ID: <5130AF55.4060905@inria.fr>

>> The main question whether namespaces are hierarchical or flat is still not
>> answered
>
> I think the question itself assumes that namespaces are a new kind of objects
> (and then we can discuss what is their structure, flat or hierarchical, graph
> with ordered edges, etc).  But again, there are some ways to address the needs
> expressed in this discussion without introducing such a notion.  In my proposal,
> there is one single "space of names" for modules and compilation units plus a
> feature to control the mapping of module references to compilation units.

Alain,

Yes, your proposal is minimalistic and does not require many changes. And
I've described it as such, I think.  So you do not have to keep repeating
this in almost every other message...

However, in order to understand what people need, it is better to leave the
implementation impact aside at this stage.  I think the simplicity of your
proposal is orthogonal to the model and has more to do with leaving
namespace manipulation outside of the world.

> In this context, I don't even know how to interpret the question of
> whether namespaces are hierarchical or flat.

But I think it would help to understand each other if you accepted to view
your proposal as a restriction of the hierarchical model, as I think it is
one---or tells us why it does not fit in this model.

Here is my attempt:

It is rather a 2-level model than a flat one, where namespace filenames are
the first level and the content of namespaces are the second level.

- You have a single operation to create namespaces the module alias
   construct.

- My understanding is that you would not support auto-open, but you would
   allow open commands in namespace files, which was my alternative proposal
   to avoid auto-opens.

- Your filename is a list of aliases, which is thus understood as its action
   on the current scope rather than as namespace object itself. This way all
   operations are ordered.

- I assume you silently allow overriding of names, but I am not sure.

Is this a correct view for you?

Another orthogonal part of your proposal is to have original long unique
names for modules (which looks like a tree like hierarchy, but independent of
namespaces), which seems close to what Fabrice wished (up to whether
canonical names have a tree-like structure or are flat.)

The hierarchical model also requires module to have unique identifiers but
is relative agnostic on how this is achieved. (Gabriel has described several
solutions, but yours is one that fits in the model.)

So, in my current understanding, your proposal is more restrictive, has a
more operational mental model, and mainly leaves the manipulation of
namespaces (creating, merging, etc.) other than an explicit listing out of
the proposal.

         Didier


From alain.frisch at lexifi.com  Fri Mar  1 14:01:22 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 15:01:22 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130AA94.9070008@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
Message-ID: <5130B4B2.2050003@lexifi.com>

On 03/01/2013 02:18 PM, Didier Remy wrote:
> But I don't think this is a good model that would scale to providing a
> unified view of all available libraries where you wish to construct
> namespaces a posteriori by combining existing ones.

I'm really not convinced that this corresponds to a real need.  In 
particular, I don't believe that hierarchical namespaces is a good way 
to "organize the world of all available libraries", for the following 
reasons:

  - A good hierarchy requires some thinking, and I don't think a good 
hierarchy can be achieved in a decentralized way.

  - There are many ways to think about "domains" and fixing a hierarchy 
of names picks a single, inflexible vision of how domains are related to 
each other.  It has been mentioned that "tags" might be more relevant to 
look up things in a big universe; I agree, and I don't believe this 
needs to be reflected in the language itself.

  - A hierarchy necessarily leads to very long fully qualified names. 
At the end, nobody uses those names, because they are impractical, so 
the potential interest of the hierarchy (giving a good idea, locally, 
which feature is used, even for a reader not familiar with a specific 
library) does not work.


An example of a bad use of namespaces: in .Net, the Process class, used 
in particular to spawn or stop processes (but also to get information 
about existing ones, although I've never to this purpose) is located in 
the System.Diagnostics namespace.  This strikes me as completely bogus, 
and I think we won't avoid such errors if we let users create 
hieararchies of namespaces with associated powerful operators.

Alain

From alain.frisch at lexifi.com  Fri Mar  1 14:34:08 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 15:34:08 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130AF55.4060905@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr> <5130667B.3050105@lexifi.com>
 <5130AF55.4060905@inria.fr>
Message-ID: <5130BC60.9030006@lexifi.com>

On 03/01/2013 02:38 PM, Didier Remy wrote:
> But I think it would help to understand each other if you accepted to view
> your proposal as a restriction of the hierarchical model, as I think it is
> one---or tells us why it does not fit in this model.

Short summary: I don't think it fits in this model, but I'd love to be 
proven wrong.

> Here is my attempt:
>
> It is rather a 2-level model than a flat one, where namespace filenames are
> the first level and the content of namespaces are the second level.

The content of a namespace files is a mapping between references and 
compilation units.  If one wants to see this as a tree, one would draw 
something like:


  Core
   |
   |--->  (List => Core_list)
   |--->  (String => Core_string)

But I don't really see the value of considering this as a tree: there 
can only be two levels and they are of a very different nature (nodes of 
the first level are names; nodes of the second level are pairs of 
names).  To be noted: the same reference name (List, String) can be 
appear in several leaves, of course, but so do unit names (Core_list, 
Core_string).  You could have for instance:

  Core
   |
   |--->  (List => Core_list)
   |--->  (String => Core_string)
   |--->  (Unix => Core_unix)

  UCore
   |
   |--->  (List => Core_list)
   |--->  (String => Core_string)


How does this fit into the hierarchical model?


Alain

From thelema314 at gmail.com  Fri Mar  1 14:58:56 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Fri, 1 Mar 2013 09:58:56 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130BC60.9030006@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr> <5130667B.3050105@lexifi.com>
 <5130AF55.4060905@inria.fr> <5130BC60.9030006@lexifi.com>
Message-ID: <CAL-jcAnOK+=FV=b6PC3WDLamTxd42GJ8Mg+6dmMMEc_vRT2PGg@mail.gmail.com>

It sounds to me like Alain and Yaron's model of namespaces is one where
namespaces are (a form of) restricted modules, able to declare module
aliases (the core namespace behavior) and module includes ("auto-open").
 At the risk of complicating things, I suggest that namespaces also be able
to do namespace includes, which would basically be namespace dependencies.
 As described in the latest Core release thread, it is expected to have
Ucore a subset of Core.Stable, which is itself a subset of Core.Std.  To
eliminate the obvious repetition of every declaration in Ucore 3 times,
Core.Stable would simply include UCore.

I'm not proposing the fourth corner of the square, declaring namespace
aliases, but adding this would make the proposal fully hierarchical in what
seems to me a natural way.

E.


On Fri, Mar 1, 2013 at 9:34 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 03/01/2013 02:38 PM, Didier Remy wrote:
>
>> But I think it would help to understand each other if you accepted to view
>> your proposal as a restriction of the hierarchical model, as I think it is
>> one---or tells us why it does not fit in this model.
>>
>
> Short summary: I don't think it fits in this model, but I'd love to be
> proven wrong.
>
>
>  Here is my attempt:
>>
>> It is rather a 2-level model than a flat one, where namespace filenames
>> are
>> the first level and the content of namespaces are the second level.
>>
>
> The content of a namespace files is a mapping between references and
> compilation units.  If one wants to see this as a tree, one would draw
> something like:
>
>
>  Core
>   |
>   |--->  (List => Core_list)
>   |--->  (String => Core_string)
>
> But I don't really see the value of considering this as a tree: there can
> only be two levels and they are of a very different nature (nodes of the
> first level are names; nodes of the second level are pairs of names).  To
> be noted: the same reference name (List, String) can be appear in several
> leaves, of course, but so do unit names (Core_list, Core_string).  You
> could have for instance:
>
>  Core
>   |
>   |--->  (List => Core_list)
>   |--->  (String => Core_string)
>   |--->  (Unix => Core_unix)
>
>  UCore
>   |
>   |--->  (List => Core_list)
>   |--->  (String => Core_string)
>
>
> How does this fit into the hierarchical model?
>
>
> Alain
>
> ______________________________**_________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/platform<http://lists.ocaml.org/listinfo/platform>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130301/64d8368f/attachment.html>

From yminsky at janestreet.com  Fri Mar  1 15:28:44 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 1 Mar 2013 10:28:44 -0500
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130AA94.9070008@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
Message-ID: <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>

On Fri, Mar 1, 2013 at 8:18 AM, Didier Remy <Didier.Remy at inria.fr> wrote:
>>> 2) However, you cannot open several nodes at the same time without
>>>     specifying an ordering between those nodes.
>>
>>
>> What does it mean to open several nodes "at the same time"?  I would
>> have thought that opening of nodes would always be ordered, since the
>> open statements would need to be written in some order.
>
>
> If Core has two auto-open subnodes (e.g Std and Pervasives), then opening
> core will open the two auto-open subnodes at the same time. This is what I
> meant.

Got it.  In my thinking, these auto-opens could only be modules, to be
clear, not namespaces.  So i'm thinking about this all as very flat,
much as Alain is.

> In this case, you write with the auto-open semantics
>
>         open Core
>
> and what happens is equivalent to (without the auto-open semantics)
>
>         open Core
>         open Std
>         open Pervasives
> or
>         open Core
>         open Std
>         open Pervasives
>
> So the edges Std and Pervasives need both leaving from Core need to be
> ordered in the namespace.

Yup.

>>> The * is the auto-open flag, as used in Gabriel's description.
>>> Sorry for leaving this implicit.
>>
>>
>> Got it.  That's quite helpful, though I'm still a little lost about
>> the problem you're describing.  It sounds to me like the issue dervies
>> from the fact that you're proposing opening up a parent namespace as
>> an operation that opens all children as well.  Is that right?
>
>
> Yes, an operation that opens all children marked auto-open.
>
>> I hadn't even begun to imagine wanting that feature, so maybe that isn't a
>> real issue at all?  Or perhaps I'm just confused....
>
>
> I thought this is what you where asked for when saying that you want
>
>         open Core
>
> to behaves as
>
>         open Core
>         open Std
>         open Pervasives
>
> because you have marked Std and Pervasives as auto-open.

Maybe the difference is, I was only imagining this one level deep:
single-level namespaces, and namespaces contain list of module
aliases, plus a list of module opens, all of which are in a single
total order.

>>> I think namespaces should be unordered to scale up.
>>>
>>> You would like to be able to represent all available libraries in
>>> the OCaml world as a namespace, with libraries coming from many
>>> different sources and there is no natural order on these, i.e. no
>>> order that could be given a meaningful semantics.  Would you put
>>> World#JaneStreet before World#Lexify or the other way round?
>>>
>>> If name spaces are unordered, it is also easy to populate them by
>>> reading and merging different sources in a strict way: name spaces
>>> are meant to avoid conflicting names to start with, so if a merge
>>> introduces conflicts, this is really the right place to fix it by
>>> renaming one side or reorganizing the hierarchy rather than do
>>> some silent overriding.
>>
>>
>> I wonder if this all comes down to different thoughts about hierarchy.
>> I guess I wouldn't think the namespace World#JaneStreet would be
>> ordered compared to World#Lexify, but the module aliases and opens
>> contained in a namespace would, I thought, have been ordered.  And
>> surely, when you open multiple namespaces in your environment, you can
>> be including the same name multiple times, at which point I believe
>> the proper semantics is shadowing.
>
>
> Here, you are reasoning in Alain's model where a namespace file is
> just a sequence of operations (alias or open).  So you don't have a
> proper notion of namespace model and instead understand a namespace
> file as its immediate action on the current scope.

Correct.

> This is find to reason in the small, to reason about the imports of a
> module source file.
>
> But I don't think this is a good model that would scale to providing a
> unified view of all available libraries where you wish to construct
> namespaces a posteriori by combining existing ones.

Like Alain, I'm not convinced that hierarchy materially helps matters,
though it doesn't seem implausible either.

As a separate note, especially for a first version, but perhaps
forever, it seems to me preferable to have /building/ of namespaces
happen at the build-system level, and /references/ to namespaces
happen at the soruce level.  In other words, being able to explicitly
do things like open, alias, and qualify expressions using namespaces
seem essential at the source level.  But constructing them at the
source seems less important.

It's possible that a language like the one you and Gabriel propose for
manipulating namespaces is important.  I just don't see the full
detail.


>>> Hope this helps,
>>
>>
>> I think what I'm mostly confused about is what is the nature of the
>> hierarchical namespace system you're thinking about. What are the
>> operations available?
>
>
> The model is what has been described by Gabriel:
>
>   http://gallium.inria.fr/~scherer/namespaces/spec.pdf

Yes!  I somehow missed this earlier, but read it over this morning.  I
now have a better sense of what you mean, but it would be even more
instructive to have some examples.  Would it be possible to put
together some source examples on github (or wherever) that we could
look over?  I find it quite helpful to see examples, rather than just
the grammar of the DSL.

> and
>
>   http://gallium.inria.fr/~scherer/namespaces/pack_et_functor_pack.html
>
>
>> Do you intend to have namespace opens also recursively open all children?
>
>
> I thought this was your wish.
> But I think it is more a drawback than a convenience.

I was thinking of something that only went one-level down: opening a
namespace can open a module, never opening a namespace causing another
namespace to be opened.

That said, in constructing namespaces, I would very much want an
include-like functionality, so that the Core namespace would include
the mappings in the Ucore namespace.  That, however, seems doable at
the build-system level

>
>> Is there an operation for merging namespaces?
>
>
> Yes.
>
>> Aliasing upper namespaces?
>
>
> Yes, you can have several paths leading to the same module object.
>
>
>> Right now, I lack both a precise mental model of what you mean by
>> hierarchical namespaces,
>
>
>   http://gallium.inria.fr/~scherer/namespaces/spec.pdf
>
>
>> and an understanding of the language features that motivate this
>> hierarchy.
>
>
> Although you do not say it clearly, I think you wish at least Alain's
> 2-level hierarchal model.
>
> This may be fine from your point of view:
>
>         level 1 is for JaneStreet different libraries
>         level 2 is for the modules of each library
>
> Most of your libraries are for internal use. So in a way you do not have to
> share your namespaces with the rest of the world. I think the problem comes
> when people want to share the namespaces.
>
> For instance, there could be two actors Foo and Bar proposing complementary
> set of libraries for programming the web.
>
> When doing web programming I may wish to use parts of both providers
> Then, I may wish to structure names as
>
>         Web
>             Foo
>                 Lib1
>                    <list of modules>
>                 Lib2
>                    <list of modules>
>             Bar
>
> In the 2-level model I would be forced to rename namespace files
> to avoid clashes and get some long list of namespace_files that would look
> like:
>
>         Web_Foo_Lib1
>         Web_Foo_Lib2
>         Web_Bar
>
> In this model, the reorganization of namespaces exported by users Foo and
> Bar has into my own view has to be done manually.  The fact that names carry
> some implicit structure is an indication that one has some hierarchy in
> mind.
>
> In the hierachical view, it would suffice to assemble them within the
> language of namespaces, using operations like merge, perhaps pruning, etc..
>
> Besides, I do not think that a 2-level model is so much simpler than a
> hierarchical one.  The apparent simplificty of Alain's proposal is more I
> think in the fact that he does not manipulate namespaces explicitly (such as
> pruning, merging, etc.)

I have no real objection at a technical level to hierarchy (though it
sounds like some difficulty has been introduced by the combination of
auto-open and hierarchy's.  I'm not sure if my proposal that auto-open
only applies to modules is helpful here.).

I'm not sure as a social matter that hierarchy helps, really.  I
roughly think that picking unique names for every module is a little
crazy, but picking unique names for larger packages seems reasonable.
After all, Debian manages to get away with doing this for every
software package they release, without hierearch.

We would surely be happy to adjust our internal package names to avoid
clashes with external projects, and certainly as we release more and
more software to the world, that becomes clearer.  I'd be happier to
do that than to have every refernce to an internal package be prefixed
by "com.janestreet".

That said, I have no strong objections to hierarchy, and I'm sure it
would be helpful in some cases.  I'm just not particularly in favor.

y

From Didier.Remy at inria.fr  Fri Mar  1 15:33:19 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Fri, 01 Mar 2013 16:33:19 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130BC60.9030006@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512BD679.4010501@lexifi.com>
 <CACLX4jQ_pdViqn6r_VJ+9ndjE3ycN2aQqJfqAV+g+cgoG3MoAw@mail.gmail.com>
 <512CB286.8000501@lexifi.com>
 <CACLX4jRR6wQ4xEjosZBjNxjNqZSQgZZonorz17xKOYgr4H0cNQ@mail.gmail.com>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr> <5130667B.3050105@lexifi.com>
 <5130AF55.4060905@inria.fr> <5130BC60.9030006@lexifi.com>
Message-ID: <5130CA3F.7070009@inria.fr>

> The content of a namespace files is a mapping between references and
> compilation units.

>   Core
>    |
>    |--->  (List => Core_list)
>    |--->  (String => Core_string)

This describes the content of the file, not a namespace.
These are commands in a very simple namespace language that creates a
namespace by action on the current OCaml compilation environment.
After execution of these commands you would rather get something like

>   Core
>    |
>    |--->  List =>  <Core_list>
>    |--->  String ==> <Core_string>

where <Internal_name> is the module object that has Internal_name as its
long name.  This is a indeed one-level name space.

>  If one wants to see this as a tree, one would draw something like:

One reason to see it as a tree is that you may use several namespaces in the
same compilation step.  In your compilation environment, you now have
namespace file names mapping to level-1 namespaces.  This defines a 2-level
namespace, which can be represented as:

     ROOT
       |
       |--->  Core
       |         |
       |         |--->  (List => Core_list)
       |         |--->  (String => Core_string)
       |         |--->  (Unix => Core_unix)
       |
       |--->   UCore
              |
              |--->  (List => Core_list)
              |--->  (String => Core_string)


> But I don't really see the value of considering this as a tree: there can only
> be two levels

Understood, but it is now easy to add another level such as JaneStreet
between Root and Core. (I know you don't think it is useful, but
if we do so, then you just have hierachical namespaces.)

> and they are of a very different nature (nodes of the first level
> are names; nodes of the second level are pairs of names).

Now, the second level are no more pair of names but mapping from names to
module object. So its exaectly a hierachical namespace where leaves are
module objects.

> To be noted: the same
> reference name (List, String) can be appear in several leaves, of course, but so
> do unit names (Core_list, Core_string).  You could have for instance:

Yes, indeed.  This would also be the case with hierachical namespaces since
these names are under different prefix.

(The only reason to rule this out would be that edges 1-level below would be
"auto-open" and unorered, but for comparisson, let's say we don't have
auto-open edges, since you don't.)

> How does this fit into the hierarchical model?

I think it does very much.  At this point I am not trying to say that the
model should be hierachical, just that our two models are compatible
similar.

The misunderstanding was I think that a namespace file is for you a
sequence of (your unique) namespace command.

         List => Core_list
         String => Core_string
         ...

For us (Gabriel and i) a namespace is a small program that builds a
namespace.  A name space object is the result of executing this program
in the current environment.

I can see your command

         List => Core_list

as
         let x = <Core_list> in    (1)
         List -> x                 (2)

(1) find the module object with the internal name Core_listl binds it to x.
(2) map List to x

Then each line is a merge, and you end up building the namespace I described
above. Then, because you do not combine existing namespaces, you may not
need to have a model of what a namespace object is, and just reason at the
program (sequence of namespace command) level.

One simplification in your 2-level model that makes it look as a 1-level
model is that you use the name of the namespace file as name of the
namespace it defines, while for us the name of a namespace file
would just be used to lead the file and the nema of the namespace would
have to be written in the file itself.  This is really a minor difference.

                               ----------------

I think making this connection helps understanding one another.  In
particular, I now see that your proposal to add open commands in namespace
files is the same as mine, and they both avoid the need for auto-opens.
(Whether this is a good thing is another question---but the answer should be
the same in both cases.)

It also helps understanding how your 2-level model could be later extended
to an arbitrary level model if need be.

It should helps transfer ideas from one view to the other:

For exemple, in the hierachical model, a namespace can be defined in a
single namespace file, because the syntax of our namespace files is not
restricted to building 1-level only namespaces.  So even if we restrict our
model to 2-level namespaces, we could keep the freedom to build either
1-level or 2-level namespaces in namespace files.  On the contrary, in your
setting, a source file using dozens of libraries will have to use dozens of
namespace files, either imported in the header or passed on the command
line, while we can concatenate them into a single namespace file.  Probably
a minor difference, but good enough for illustration.

         Didier


From Didier.Remy at inria.fr  Fri Mar  1 16:04:22 2013
From: Didier.Remy at inria.fr (Didier Remy)
Date: Fri, 01 Mar 2013 17:04:22 +0100
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
Message-ID: <5130D186.5040704@inria.fr>

> As a separate note, especially for a first version, but perhaps
> forever, it seems to me preferable to have /building/ of namespaces
> happen at the build-system level, and /references/ to namespaces
> happen at the soruce level.  In other words, being able to explicitly
> do things like open, alias, and qualify expressions using namespaces
> seem essential at the source level.  But constructing them at the
> source seems less important.

That's is again independent of being of fully hierarchical or just have
2-levels.

Most projects could use the same namespace describing the imports to the
project. This it could be built once for the project: our syntax of
namespaces is rich enough to describe commands that create namespace values
but also to describe namespace values explicitly. So the rich namespace
description that scans the environment merge several inputs could be dumped
into an concrete namespace value that is then used for compiling all files
of the project.  This would avoid repeatedly rescanning directories of the
library paths searching for .cmi files.  This is a minor issue, though.

Even is building namespace values can be done outside of the language, (and
perhaps should even be done so), I think it is good to have a clear model of
what they are and of the operations used to build and use them.

     Didier

From yminsky at janestreet.com  Sun Mar  3 14:30:49 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 3 Mar 2013 09:30:49 -0500
Subject: [ocaml-platform] Unique file names
Message-ID: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>

As I understand it, Alain's proposal requires naming all files
uniquely.  i.e., within a library called Foo, we'd call functions
foo_this.ml and foo_that.ml.

Alain, is this part of your proposal really necessary?  i.e., is there
any barrier with having the ability in the build system to specify the
effective prefix at once for a given directory, rather than literally
naming the files in this way?  It seems like developers' lives would
be simpler (and their ls output full of less repetitive noise) if we
don't literally need to name files in this way.

y

From daniel.buenzli at erratique.ch  Sun Mar  3 15:17:33 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Sun, 3 Mar 2013 16:17:33 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
Message-ID: <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>

Le dimanche, 3 mars 2013 ? 15:30, Yaron Minsky a ?crit :
> It seems like developers' lives would
> be simpler (and their ls output full of less repetitive noise) if we
> don't literally need to name files in this way.

Agreed, if we need to convince him, we could try to quantify the loss of productivity due to editor open/switch buffer completion not being unique while working on a library...

Daniel



From gabriel.scherer at gmail.com  Sun Mar  3 15:59:50 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Sun, 3 Mar 2013 16:59:50 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
Message-ID: <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>

The filenames are important for two distinct reasons now:
1. they determine the "internal name" of the compilation unit (the one
stored in the .cmo/.cmi data); this one must absolutely be unique for
linking to work: you cannot link together two modules of the same
internal name
2. with the current implementation, they determine the mapping from
compilation unit names to compilation units: the current "namespace"
semantics is to map the compunit-name Foo to a file foo.cmi or Foo.cmi
in the search path

Regarding aspect (2), having filename conflicts is not an issue if
your namespace language is rich enough to let you map two different
identifiers to two compunits of the same filename. As far as I
understand, this is currently not the case of Alain's proposal (which
rebinds compunits names to compunits names, still search within the
search-path so not conflict-robust), but some transformations of it
may make it possible (eg. specifying that the compunits specified in a
.ns file are only looked up in the .ns directory, rather than all the
search-path, so that same-filename compunits in distinct repositories
do not conflict); in the general case, a mapping from compilation unit
names to compilation unit paths avoid this issue (but how path are
specified remain to be fully fleshed out: absolute paths, relative to
stdlib, ocamlfind queries...).

Note that Alain's proposal also map the namespace names to .ns
filenames. My guess would be that if we today recognize that binding
compunit source-names to their filenames is a mistake, we may regret
making the exact same choice for the upper-level construct in the
future.

Regarding aspect (1), we discussed enriching the compilation unit with
information not coming from the filename itself (eg. the "provenance
field" in spec.pdf). The most general situation is to consider that an
internal prefix (or suffix) can be passed to the compiler at
invocation time, as is currently used -for-pack (you're then free to
express directory-local policies, random choices, interface hashes or
whatever on top of this very primitive idea).

This however opens the door for more things to work out that Alain's
minimalistic proposal avoided. One aspect is the way modules are
referred to in tools output (ocamldoc, ocamldep, etc.). My source my
refer to the compilation unit Foo, which through the compilation
environment resolves to the compilation unit /foo/bar.cm[io]. In
Alain's proposal, ocamldoc would return a reference to the module Bar,
that is the "authoritative" compilation unit name, obtained through
following the namespace rebindings. But if you allow to mix
same-filename compilation units in a project, there is no such
"authoritative" compilation unit name. Ocamldoc output must either
mention the compilation unit path ("/foo/bar") or enhanced internal
name ("janestreet.core.bar.h2d846sc"), which are not very nice, or
refer to the compilation unit name used in the original source file,
Foo, which makes its output relative to the compilation environment
used at invocation time. I personally think this last option is the
way to go (I already consider compilation to be dependent on the
compilation environment, that is the search path filesystem state),
but that is one more subtlety that Alain was happy to avoid.

On Sun, Mar 3, 2013 at 4:17 PM, Daniel B?nzli
<daniel.buenzli at erratique.ch> wrote:
> Le dimanche, 3 mars 2013 ? 15:30, Yaron Minsky a ?crit :
>> It seems like developers' lives would
>> be simpler (and their ls output full of less repetitive noise) if we
>> don't literally need to name files in this way.
>
> Agreed, if we need to convince him, we could try to quantify the loss of productivity due to editor open/switch buffer completion not being unique while working on a library...
>
> Daniel
>
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From nanaki at gmail.com  Sun Mar  3 21:34:58 2013
From: nanaki at gmail.com (Jeff Meister)
Date: Sun, 3 Mar 2013 13:34:58 -0800
Subject: [ocaml-platform] Unique file names
Message-ID: <CAHaHOqSD14gWPtCR6nFQNy4h28YdPRJfNY8rpc2KtQ8nYUKGFg@mail.gmail.com>

I apologize in advance if this message reflects a basic misunderstanding of
Alain's proposal.

I've been following this thread for the most part, and I keep seeing
references to a detail of Alain's proposal: that source file names must be
unique across projects. The OCaml compiler and other build tools
(ocamldep?) require this, and Alain proposes that programmers simply follow
a "long filename" convention. But this seems to defeat the purpose of
adding namespaces.

Indeed, the main (and perhaps only) problem I encounter where namespaces
would be useful is filename conflicts. For example, I might want to use
both packages foo and bar in my project, from different authors. Currently
I'd use ocamlfind to build against the packages, but since the compiler
doesn't know anything about packages, the source files they contain must
still have unique names. So, if foo has some utility functions in its
util.ml, and bar also has its own util.ml, my project won't compile.

Using Alain's proposal, how would I solve this conflict, where developers
have chosen not to follow the long filename convention? If I actually need
functions from both Util modules, am I expected to rename one of them to
Packagename_util.ml and refactor all module references in the third-party
codebase? This seems like exactly the situation we have now.

I think I have a similar view of namespaces as Didier (although I'm
certainly not as informed on the theory). A module in OCaml acts like a
namespace for the types/values/modules it contains, so developers of a
module don't hesitate to name their type "t", or their function "parse".
Contrast with C, where the language has no module support, so developers
must use long names like "yojson_parse" or "xmlm_parse" to avoid name
conflicts. It seems to me that requiring long filenames simply lifts this
restriction to the filename (top-level module) level. Surely we can do
better than C!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130303/46a2402e/attachment.html>

From alain.frisch at lexifi.com  Mon Mar  4 12:19:41 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 13:19:41 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
Message-ID: <5134915D.5060100@lexifi.com>

On 03/03/2013 04:59 PM, Gabriel Scherer wrote:
> Regarding aspect (2), having filename conflicts is not an issue if
> your namespace language is rich enough to let you map two different
> identifiers to two compunits of the same filename.

I did not really specify this part.  As you mention, one can decide that 
.ns files maps names to filenames (probably using relative path to the 
.ns file).

That said, I see it as an advantage to have globally unique filenames, 
for various reasons.  I admit it is an annoyance for library writers, 
but I believe it is a tiny one compared to the benefits of this 
solution.  (As a minor point, my emacs is perfectly fine with 
autocompleting filename based on a suffix following an underscore 
character; e.g. if if type Ctrl-X-F, then "_pricing", then TAB, it 
autocompletes it to apropos_pricing_result.ml.  I don't know if this is 
the default behavior of requires custom configuration, though.)

Some benefits of globally unique filenames:

  - Provide an unambiguous way to refer to a specific compilation unit, 
in a way which only depends on the search path.  While I agree that 
having shorter names "by default" in the documentation or error messages 
is nice, it is also good to support fully explicit outputs, and it is 
better if it does not depend too much on the environment.

  - A corollary to the previous point is to simplify the interface 
between "ocamldep -modules" and the build system.

  - Avoid the need to open compiled files to see "in which namespace" 
they are -- or what their internal name is -- and related problems, 
which we have discussed on this list.

  - Support a deployment scenario where files from many libraries are 
installed in a single directory.

  - Never force library users to use namespaces if they are fine with 
using long names (maybe with the help of a local manual renaming feature).

> Note that Alain's proposal also map the namespace names to .ns
> filenames. My guess would be that if we today recognize that binding
> compunit source-names to their filenames is a mistake, we may regret
> making the exact same choice for the upper-level construct in the
> future.

An alternative could be to specify on the command-line a set of .ns 
files, each of them containing a definition of the "namespace" it 
defines (the name used in the source code).  This would also support 
defining several "namespaces" in a single .ns file.  There was a strong 
resistance to specifying .ns files to be "opened" on the command-line, 
but here we're not talking about opening namespaces, just specifying 
them to the compiler.

In this variant of the proposal, we could almost get rid of -I flags for 
deployed libraries.



Alain

From thelema314 at gmail.com  Mon Mar  4 14:21:57 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Mon, 4 Mar 2013 09:21:57 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <5134915D.5060100@lexifi.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
Message-ID: <CAL-jcA=t6i9T4aQN6WiEcYLYm3c5PKocQWDAUDxbeAdOywuGOg@mail.gmail.com>

On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> An alternative could be to specify on the command-line a set of .ns files,
> each of them containing a definition of the "namespace" it defines (the
> name used in the source code).
>

How about having a namespace include path?  If a namespace Foo were
referenced in the source code, the file foo.ns would be searched for and
used to define the Foo namespace.  Maybe even the corresponding compiled
library could be in the subdirectory foo/ adjacent to the .ns file.  This
could be made hierarchical later by looking for Foo#Bar as foo/bar.ns.

In this world, library installation would be similar to how findlib works,
with each project installing a namespace file and a bunch of program
objects.


> In this variant of the proposal, we could almost get rid of -I flags for
> deployed libraries.
>
> The idea of getting rid of -I (for the common case) is one I'm strongly
behind.  There's no good reason to make it hard to use external libraries.

This way of using namespaces may even allow something unexpected: private
modules.  When a namespace provides the "interface" to a library, it might
avoid specifying certain modules implemented by that library.  These
compunits would still be linked in because of dependencies from other
compunits in the project, but would not be made available to the
namespace-using program because the environment modification caused by the
namespace doesn't make them available.

>
>
> Alain
>
> ______________________________**_________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/platform<http://lists.ocaml.org/listinfo/platform>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130304/ead80759/attachment.html>

From romain.bardou at inria.fr  Mon Mar  4 14:28:45 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Mon, 04 Mar 2013 15:28:45 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <5134915D.5060100@lexifi.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
Message-ID: <5134AF9D.9090800@inria.fr>

Hello,

It seems to me that long names break modularity. By modularity I mean 
the ability to name a unit (a file, a value...) with no knowledge of its 
environment.

Let's say I am developing project "Video3D" for which I developed a 
"Quadtree" module. I name it "Video3D_Quadtree". Now, let's say that 
Batteries and Core want to integrate my quadtree implementation. They 
will rename the module as "Batteries_Quadtree" and "Core_Quadtree".

There is no way to chose a name that does not depend on the environment 
if I use long unique names. Long unique names are explicitely giving up 
on modularity.

Long names feel like having to write code like this:

type 'list_t_a list_t =
   | List_empty
   | List_cons of 'list_t_a * 'list_t_a list_t

let rec list_map list_map_f list_map_l =
   match list_map_l with
     | List_empty ->
         List_empty
     | List_cons (list_map_value, list_map_tail) ->
         let list_map_value = list_map_f list_map_value in
         let list_map_tail = list_map list_map_f list_map_tail in
         List_cons (list_map_value, list_map_tail)

Everything which is defined in unit U is prefixed by "U_". Here, I have 
the "list" unit (the module) and the "list_map" unit. But thanks to 
modularity I can choose any name for "list_map_f" and "list_map_l". 
Because I am inside unit "list_map", these names are redundant and I can 
use "f" and "l" instead.

It should be the same for compilation units: I should be able to name my 
module "Quadtree". Namespaces should then provide a way to integrate 
this name in another environment, if needed.

Cheers,

-- 
Romain Bardou

From thelema314 at gmail.com  Mon Mar  4 14:49:28 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Mon, 4 Mar 2013 09:49:28 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <5134AF9D.9090800@inria.fr>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com> <5134AF9D.9090800@inria.fr>
Message-ID: <CAL-jcAnqA8K3BL30a60p10UdW201cmsNdHFyNmZt6ocDEV_33A@mail.gmail.com>

Romain,

The way I see your example working out is something like:

video3D.ns:  module Quadtree = Video3D_Quadtree
batteries.ns: require video3D <other declarations>
core.ns: require video3D <other declarations>

Then the client code would be something like:

foo.ml:
require Core
let _ = Quadtree.do_operation x y z

The client just sees a Quadtree module for them to use, because the
compiler reads the core.ns file, finds its 'require', reads the video3D.ns
file, and puts a module Quadtree into the environment that's connected to
the Video3D_quadtree compunit.

E.


On Mon, Mar 4, 2013 at 9:28 AM, Romain Bardou <romain.bardou at inria.fr>wrote:

> Hello,
>
> It seems to me that long names break modularity. By modularity I mean the
> ability to name a unit (a file, a value...) with no knowledge of its
> environment.
>
> Let's say I am developing project "Video3D" for which I developed a
> "Quadtree" module. I name it "Video3D_Quadtree". Now, let's say that
> Batteries and Core want to integrate my quadtree implementation. They will
> rename the module as "Batteries_Quadtree" and "Core_Quadtree".
>
> There is no way to chose a name that does not depend on the environment if
> I use long unique names. Long unique names are explicitely giving up on
> modularity.
>
> Long names feel like having to write code like this:
>
> type 'list_t_a list_t =
>   | List_empty
>   | List_cons of 'list_t_a * 'list_t_a list_t
>
> let rec list_map list_map_f list_map_l =
>   match list_map_l with
>     | List_empty ->
>         List_empty
>     | List_cons (list_map_value, list_map_tail) ->
>         let list_map_value = list_map_f list_map_value in
>         let list_map_tail = list_map list_map_f list_map_tail in
>         List_cons (list_map_value, list_map_tail)
>
> Everything which is defined in unit U is prefixed by "U_". Here, I have
> the "list" unit (the module) and the "list_map" unit. But thanks to
> modularity I can choose any name for "list_map_f" and "list_map_l". Because
> I am inside unit "list_map", these names are redundant and I can use "f"
> and "l" instead.
>
> It should be the same for compilation units: I should be able to name my
> module "Quadtree". Namespaces should then provide a way to integrate this
> name in another environment, if needed.
>
> Cheers,
>
> --
> Romain Bardou
>
> ______________________________**_________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/platform<http://lists.ocaml.org/listinfo/platform>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130304/0254ef28/attachment.html>

From gabriel.scherer at gmail.com  Mon Mar  4 14:56:52 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 4 Mar 2013 15:56:52 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CAL-jcA=t6i9T4aQN6WiEcYLYm3c5PKocQWDAUDxbeAdOywuGOg@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CAL-jcA=t6i9T4aQN6WiEcYLYm3c5PKocQWDAUDxbeAdOywuGOg@mail.gmail.com>
Message-ID: <CAPFanBHOigKP=i0Kc3E5cXBmgXSh--Lw-_4hMD8BX-Opb2S71Q@mail.gmail.com>

Regardless of which actual command-line-argument interface we pick for
namespaces, I expect realistic end-users to think in term of ocamlfind
packages, that is

  ocamlfind -package foo,bar,baz,blah source.ml ...

I expect ocamlfind to be updated to support per-library namespaces if
we pick a semantics that allows that (as opposed to namespace choices
being fixed on the code-provider side by a source file header, and
un-changeable after compilation of the compilation unit), so as to
provide a default compilation environment as specified by each package
individually. If the semantics support that, the user could still
refine the compilation environment with private aliases or
hierarchies, and the project-local namespace.

Note that this does not require any automatic discovery feature for
namespaces (or compilation units in fact: we could already get rid of
-I by asking ocamlfind to provide to the compiler the paths to the
compilation units it knows about). Note that I think automatic
discovery is a dubious idea (for name conflicts for compilation units,
it's part of the problem), but would rather keep a single search-path
(for both compilation units and namespaces) if really want some, for
simplicity.

We still need to design an underlying semantics that is more
fine-grained, to be general enough to cover for specific use-cases out
of the ocamlfind-happy world, such as big companies/projects with a
single code hierarchy (JaneStreet, Mirage), or Alain's "everything in
a single big directory" world.

On Mon, Mar 4, 2013 at 3:21 PM, Edgar Friendly <thelema314 at gmail.com> wrote:
> On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com>
> wrote:
>>
>> An alternative could be to specify on the command-line a set of .ns files,
>> each of them containing a definition of the "namespace" it defines (the name
>> used in the source code).
>
>
> How about having a namespace include path?  If a namespace Foo were
> referenced in the source code, the file foo.ns would be searched for and
> used to define the Foo namespace.  Maybe even the corresponding compiled
> library could be in the subdirectory foo/ adjacent to the .ns file.  This
> could be made hierarchical later by looking for Foo#Bar as foo/bar.ns.
>
> In this world, library installation would be similar to how findlib works,
> with each project installing a namespace file and a bunch of program
> objects.
>
>>
>> In this variant of the proposal, we could almost get rid of -I flags for
>> deployed libraries.
>>
> The idea of getting rid of -I (for the common case) is one I'm strongly
> behind.  There's no good reason to make it hard to use external libraries.
>
> This way of using namespaces may even allow something unexpected: private
> modules.  When a namespace provides the "interface" to a library, it might
> avoid specifying certain modules implemented by that library.  These
> compunits would still be linked in because of dependencies from other
> compunits in the project, but would not be made available to the
> namespace-using program because the environment modification caused by the
> namespace doesn't make them available.
>>
>>
>>
>> Alain
>>
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>
>

From romain.bardou at inria.fr  Mon Mar  4 15:18:16 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Mon, 04 Mar 2013 16:18:16 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CAL-jcAnqA8K3BL30a60p10UdW201cmsNdHFyNmZt6ocDEV_33A@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com> <5134AF9D.9090800@inria.fr>
 <CAL-jcAnqA8K3BL30a60p10UdW201cmsNdHFyNmZt6ocDEV_33A@mail.gmail.com>
Message-ID: <5134BB38.6030104@inria.fr>

Hello,

This seems reasonable.

But I would still prefer to name my file "quadtree". I'm sure the 
possibility of a "-unit-name-prefix video3d" compilation flag has been 
discussed already. I'll go read and see what are the counter-arguments...

Cheers,

-- 
Romain

Le 04/03/2013 15:49, Edgar Friendly a ?crit :
> Romain,
>
> The way I see your example working out is something like:
>
> video3D.ns:  module Quadtree = Video3D_Quadtree
> batteries.ns: require video3D <other declarations>
> core.ns: require video3D <other declarations>
>
> Then the client code would be something like:
>
> foo.ml <http://foo.ml>:
> require Core
> let _ = Quadtree.do_operation x y z
>
> The client just sees a Quadtree module for them to use, because the
> compiler reads the core.ns file, finds its 'require', reads the
> video3D.ns file, and puts a module Quadtree into the environment that's
> connected to the Video3D_quadtree compunit.
>
> E.
>
>
> On Mon, Mar 4, 2013 at 9:28 AM, Romain Bardou <romain.bardou at inria.fr
> <mailto:romain.bardou at inria.fr>> wrote:
>
>     Hello,
>
>     It seems to me that long names break modularity. By modularity I
>     mean the ability to name a unit (a file, a value...) with no
>     knowledge of its environment.
>
>     Let's say I am developing project "Video3D" for which I developed a
>     "Quadtree" module. I name it "Video3D_Quadtree". Now, let's say that
>     Batteries and Core want to integrate my quadtree implementation.
>     They will rename the module as "Batteries_Quadtree" and "Core_Quadtree".
>
>     There is no way to chose a name that does not depend on the
>     environment if I use long unique names. Long unique names are
>     explicitely giving up on modularity.
>
>     Long names feel like having to write code like this:
>
>     type 'list_t_a list_t =
>        | List_empty
>        | List_cons of 'list_t_a * 'list_t_a list_t
>
>     let rec list_map list_map_f list_map_l =
>        match list_map_l with
>          | List_empty ->
>              List_empty
>          | List_cons (list_map_value, list_map_tail) ->
>              let list_map_value = list_map_f list_map_value in
>              let list_map_tail = list_map list_map_f list_map_tail in
>              List_cons (list_map_value, list_map_tail)
>
>     Everything which is defined in unit U is prefixed by "U_". Here, I
>     have the "list" unit (the module) and the "list_map" unit. But
>     thanks to modularity I can choose any name for "list_map_f" and
>     "list_map_l". Because I am inside unit "list_map", these names are
>     redundant and I can use "f" and "l" instead.
>
>     It should be the same for compilation units: I should be able to
>     name my module "Quadtree". Namespaces should then provide a way to
>     integrate this name in another environment, if needed.
>
>     Cheers,
>
>     --
>     Romain Bardou
>
>     _________________________________________________
>     Platform mailing list
>     Platform at lists.ocaml.org <mailto:Platform at lists.ocaml.org>
>     http://lists.ocaml.org/__listinfo/platform
>     <http://lists.ocaml.org/listinfo/platform>
>
>


From thelema314 at gmail.com  Mon Mar  4 18:18:29 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Mon, 4 Mar 2013 13:18:29 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CAPFanBHOigKP=i0Kc3E5cXBmgXSh--Lw-_4hMD8BX-Opb2S71Q@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CAL-jcA=t6i9T4aQN6WiEcYLYm3c5PKocQWDAUDxbeAdOywuGOg@mail.gmail.com>
 <CAPFanBHOigKP=i0Kc3E5cXBmgXSh--Lw-_4hMD8BX-Opb2S71Q@mail.gmail.com>
Message-ID: <CAL-jcAmmY3pY2+cPGz=CnbwQ_tQH25+AwQ300rSbJUcmxVi8xA@mail.gmail.com>

On Mon, Mar 4, 2013 at 9:56 AM, Gabriel Scherer
<gabriel.scherer at gmail.com>wrote:

> Regardless of which actual command-line-argument interface we pick for
> namespaces, I expect realistic end-users to think in term of ocamlfind
> packages, that is
>
>   ocamlfind -package foo,bar,baz,blah source.ml ...
>
> Why not:

source.ml: require Foo require Bar require Baz require Blah <rest of source>

    ocamlc source.ml

and have the compiler process any namespace files that source.ml depends
on?  Findlib could still be used to manage camlp4 and


> Note that I think automatic
> discovery is a dubious idea (for name conflicts for compilation units,
> it's part of the problem),


I'd argue that it's not the automatic discovery that is the problem, but
the "internal name" conflict problem.  Even totally manual addition of
package directories triggers conflicts.  If we had complete automatic
discovery, the internal name conflict problem would

We still need to design an underlying semantics that is more
> fine-grained, to be general enough to cover for specific use-cases out
> of the ocamlfind-happy world, such as big companies/projects with a
> single code hierarchy (JaneStreet, Mirage), or Alain's "everything in
> a single big directory" world.
>
>
I propose using restricted module semantics for namespaces; they're well
understood, powerful and should be easy to implement.

E.



> On Mon, Mar 4, 2013 at 3:21 PM, Edgar Friendly <thelema314 at gmail.com>
> wrote:
> > On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com>
> > wrote:
> >>
> >> An alternative could be to specify on the command-line a set of .ns
> files,
> >> each of them containing a definition of the "namespace" it defines (the
> name
> >> used in the source code).
> >
> >
> > How about having a namespace include path?  If a namespace Foo were
> > referenced in the source code, the file foo.ns would be searched for and
> > used to define the Foo namespace.  Maybe even the corresponding compiled
> > library could be in the subdirectory foo/ adjacent to the .ns file.  This
> > could be made hierarchical later by looking for Foo#Bar as foo/bar.ns.
> >
> > In this world, library installation would be similar to how findlib
> works,
> > with each project installing a namespace file and a bunch of program
> > objects.
> >
> >>
> >> In this variant of the proposal, we could almost get rid of -I flags for
> >> deployed libraries.
> >>
> > The idea of getting rid of -I (for the common case) is one I'm strongly
> > behind.  There's no good reason to make it hard to use external
> libraries.
> >
> > This way of using namespaces may even allow something unexpected: private
> > modules.  When a namespace provides the "interface" to a library, it
> might
> > avoid specifying certain modules implemented by that library.  These
> > compunits would still be linked in because of dependencies from other
> > compunits in the project, but would not be made available to the
> > namespace-using program because the environment modification caused by
> the
> > namespace doesn't make them available.
> >>
> >>
> >>
> >> Alain
> >>
> >> _______________________________________________
> >> Platform mailing list
> >> Platform at lists.ocaml.org
> >> http://lists.ocaml.org/listinfo/platform
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130304/1406f8f9/attachment.html>

From thelema314 at gmail.com  Mon Mar  4 18:18:30 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Mon, 4 Mar 2013 13:18:30 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CAPFanBHOigKP=i0Kc3E5cXBmgXSh--Lw-_4hMD8BX-Opb2S71Q@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CAL-jcA=t6i9T4aQN6WiEcYLYm3c5PKocQWDAUDxbeAdOywuGOg@mail.gmail.com>
 <CAPFanBHOigKP=i0Kc3E5cXBmgXSh--Lw-_4hMD8BX-Opb2S71Q@mail.gmail.com>
Message-ID: <CAL-jcAn05qKabnJ0JfYhOqMqZRebnqgKJ=E-3B5kM9j4ikiE9Q@mail.gmail.com>

On Mon, Mar 4, 2013 at 9:56 AM, Gabriel Scherer
<gabriel.scherer at gmail.com>wrote:

> Regardless of which actual command-line-argument interface we pick for
> namespaces, I expect realistic end-users to think in term of ocamlfind
> packages, that is
>
>   ocamlfind -package foo,bar,baz,blah source.ml ...
>
> Why not:

source.ml: require Foo require Bar require Baz require Blah <rest of source>

    ocamlc source.ml

and have the compiler process any namespace files that source.ml depends
on?  Findlib could still be used to manage camlp4 and


> Note that I think automatic
> discovery is a dubious idea (for name conflicts for compilation units,
> it's part of the problem),


I'd argue that it's not the automatic discovery that is the problem, but
the "internal name" conflict problem.  Even totally manual addition of
package directories triggers conflicts.  If we had complete automatic
discovery, the internal name conflict problem would

We still need to design an underlying semantics that is more
> fine-grained, to be general enough to cover for specific use-cases out
> of the ocamlfind-happy world, such as big companies/projects with a
> single code hierarchy (JaneStreet, Mirage), or Alain's "everything in
> a single big directory" world.
>
>
I propose using restricted module semantics for namespaces; they're well
understood, powerful and should be easy to implement.

E.



> On Mon, Mar 4, 2013 at 3:21 PM, Edgar Friendly <thelema314 at gmail.com>
> wrote:
> > On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com>
> > wrote:
> >>
> >> An alternative could be to specify on the command-line a set of .ns
> files,
> >> each of them containing a definition of the "namespace" it defines (the
> name
> >> used in the source code).
> >
> >
> > How about having a namespace include path?  If a namespace Foo were
> > referenced in the source code, the file foo.ns would be searched for and
> > used to define the Foo namespace.  Maybe even the corresponding compiled
> > library could be in the subdirectory foo/ adjacent to the .ns file.  This
> > could be made hierarchical later by looking for Foo#Bar as foo/bar.ns.
> >
> > In this world, library installation would be similar to how findlib
> works,
> > with each project installing a namespace file and a bunch of program
> > objects.
> >
> >>
> >> In this variant of the proposal, we could almost get rid of -I flags for
> >> deployed libraries.
> >>
> > The idea of getting rid of -I (for the common case) is one I'm strongly
> > behind.  There's no good reason to make it hard to use external
> libraries.
> >
> > This way of using namespaces may even allow something unexpected: private
> > modules.  When a namespace provides the "interface" to a library, it
> might
> > avoid specifying certain modules implemented by that library.  These
> > compunits would still be linked in because of dependencies from other
> > compunits in the project, but would not be made available to the
> > namespace-using program because the environment modification caused by
> the
> > namespace doesn't make them available.
> >>
> >>
> >>
> >> Alain
> >>
> >> _______________________________________________
> >> Platform mailing list
> >> Platform at lists.ocaml.org
> >> http://lists.ocaml.org/listinfo/platform
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130304/d1868d42/attachment-0001.html>

From yminsky at janestreet.com  Tue Mar  5 02:48:34 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 4 Mar 2013 21:48:34 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <5134915D.5060100@lexifi.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
Message-ID: <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>

On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/03/2013 04:59 PM, Gabriel Scherer wrote:
>>
>> Regarding aspect (2), having filename conflicts is not an issue if
>> your namespace language is rich enough to let you map two different
>> identifiers to two compunits of the same filename.
>
>
> I did not really specify this part.  As you mention, one can decide that .ns
> files maps names to filenames (probably using relative path to the .ns
> file).
>
> That said, I see it as an advantage to have globally unique filenames, for
> various reasons.  I admit it is an annoyance for library writers, but I
> believe it is a tiny one compared to the benefits of this solution.  (As a
> minor point, my emacs is perfectly fine with autocompleting filename based
> on a suffix following an underscore character; e.g. if if type Ctrl-X-F,
> then "_pricing", then TAB, it autocompletes it to apropos_pricing_result.ml.
> I don't know if this is the default behavior of requires custom
> configuration, though.)
>
> Some benefits of globally unique filenames:
>
>  - Provide an unambiguous way to refer to a specific compilation unit, in a
> way which only depends on the search path.  While I agree that having
> shorter names "by default" in the documentation or error messages is nice,
> it is also good to support fully explicit outputs, and it is better if it
> does not depend too much on the environment.
>
>  - A corollary to the previous point is to simplify the interface between
> "ocamldep -modules" and the build system.
>
>  - Avoid the need to open compiled files to see "in which namespace" they
> are -- or what their internal name is -- and related problems, which we have
> discussed on this list.
>
>  - Support a deployment scenario where files from many libraries are
> installed in a single directory.
>
>  - Never force library users to use namespaces if they are fine with using
> long names (maybe with the help of a local manual renaming feature).

Could all of these benefits be obtained by having longer names for
files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
but keep the source file names short?  i.e., one could imagine that if
you put "-put-in-namespace core" on the command-line to ocamlc, it
would generate "core_list.ml" when given the file "list.ml".  The onus
would be on the build system to provide said flags, but it would seem
to simplify things thereupon.

>> Note that Alain's proposal also map the namespace names to .ns
>> filenames. My guess would be that if we today recognize that binding
>> compunit source-names to their filenames is a mistake, we may regret
>> making the exact same choice for the upper-level construct in the
>> future.
>
>
> An alternative could be to specify on the command-line a set of .ns files,
> each of them containing a definition of the "namespace" it defines (the name
> used in the source code).  This would also support defining several
> "namespaces" in a single .ns file.  There was a strong resistance to
> specifying .ns files to be "opened" on the command-line, but here we're not
> talking about opening namespaces, just specifying them to the compiler.

As one of the people who objected to "opening" from the command line,
I have no objection to this.

> In this variant of the proposal, we could almost get rid of -I flags for
> deployed libraries.
>
>
>
> Alain
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Tue Mar  5 02:50:56 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 4 Mar 2013 21:50:56 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
Message-ID: <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>

On Mon, Mar 4, 2013 at 9:48 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> On 03/03/2013 04:59 PM, Gabriel Scherer wrote:
>>>
>>> Regarding aspect (2), having filename conflicts is not an issue if
>>> your namespace language is rich enough to let you map two different
>>> identifiers to two compunits of the same filename.
>>
>>
>> I did not really specify this part.  As you mention, one can decide that .ns
>> files maps names to filenames (probably using relative path to the .ns
>> file).
>>
>> That said, I see it as an advantage to have globally unique filenames, for
>> various reasons.  I admit it is an annoyance for library writers, but I
>> believe it is a tiny one compared to the benefits of this solution.  (As a
>> minor point, my emacs is perfectly fine with autocompleting filename based
>> on a suffix following an underscore character; e.g. if if type Ctrl-X-F,
>> then "_pricing", then TAB, it autocompletes it to apropos_pricing_result.ml.
>> I don't know if this is the default behavior of requires custom
>> configuration, though.)
>>
>> Some benefits of globally unique filenames:
>>
>>  - Provide an unambiguous way to refer to a specific compilation unit, in a
>> way which only depends on the search path.  While I agree that having
>> shorter names "by default" in the documentation or error messages is nice,
>> it is also good to support fully explicit outputs, and it is better if it
>> does not depend too much on the environment.
>>
>>  - A corollary to the previous point is to simplify the interface between
>> "ocamldep -modules" and the build system.
>>
>>  - Avoid the need to open compiled files to see "in which namespace" they
>> are -- or what their internal name is -- and related problems, which we have
>> discussed on this list.
>>
>>  - Support a deployment scenario where files from many libraries are
>> installed in a single directory.
>>
>>  - Never force library users to use namespaces if they are fine with using
>> long names (maybe with the help of a local manual renaming feature).
>
> Could all of these benefits be obtained by having longer names for
> files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
> but keep the source file names short?  i.e., one could imagine that if
> you put "-put-in-namespace core" on the command-line to ocamlc, it
> would generate "core_list.ml" when given the file "list.ml".  The onus
> would be on the build system to provide said flags, but it would seem
> to simplify things thereupon.

Apologies: Catching up on the thread, this seems essentially the same
as the -unit-name-prefix proposal that Romain mentions.

>>> Note that Alain's proposal also map the namespace names to .ns
>>> filenames. My guess would be that if we today recognize that binding
>>> compunit source-names to their filenames is a mistake, we may regret
>>> making the exact same choice for the upper-level construct in the
>>> future.
>>
>>
>> An alternative could be to specify on the command-line a set of .ns files,
>> each of them containing a definition of the "namespace" it defines (the name
>> used in the source code).  This would also support defining several
>> "namespaces" in a single .ns file.  There was a strong resistance to
>> specifying .ns files to be "opened" on the command-line, but here we're not
>> talking about opening namespaces, just specifying them to the compiler.
>
> As one of the people who objected to "opening" from the command line,
> I have no objection to this.
>
>> In this variant of the proposal, we could almost get rid of -I flags for
>> deployed libraries.
>>
>>
>>
>> Alain
>>
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From nanaki at gmail.com  Tue Mar  5 05:32:59 2013
From: nanaki at gmail.com (Jeff Meister)
Date: Mon, 4 Mar 2013 21:32:59 -0800
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>
Message-ID: <CAHaHOqSa_a7Hx5Pu7dgxRDqwaa+sDi9BQ_Kb0BH+sTHi_ZCubg@mail.gmail.com>

On the contrary, I'm very glad to hear your support for this feature as
well! My needs are not as complex as yours, but this is a major issue for
me.

If I may state the problem more strongly: plenty of programmers have
already created independent packages with a file named list.ml, or
something similarly conflict-prone, and I see no reason why they will (or
should) stop doing so in the future. If this namespace proposal is intended
to serve the greater OCaml community, then I consider the globally unique
filename requirement such a serious problem that any proposal which fails
to solve it does not provide namespaces in a sense I find meaningful.

No offense intended here, but I am highly disturbed that Alain sees
globally unique filenames as a potential solution, when to me it is a
fundamental part of the problem.

On Mon, Mar 4, 2013 at 6:50 PM, Yaron Minsky <yminsky at janestreet.com> wrote:

> > Could all of these benefits be obtained by having longer names for
> > files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
> > but keep the source file names short?  i.e., one could imagine that if
> > you put "-put-in-namespace core" on the command-line to ocamlc, it
> > would generate "core_list.ml" when given the file "list.ml".  The onus
> > would be on the build system to provide said flags, but it would seem
> > to simplify things thereupon.
>
> Apologies: Catching up on the thread, this seems essentially the same
> as the -unit-name-prefix proposal that Romain mentions.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130304/95c0afa4/attachment.html>

From gabriel.scherer at gmail.com  Tue Mar  5 07:16:35 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 5 Mar 2013 08:16:35 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>
Message-ID: <CAPFanBE_1oV4WLrsbfd6h4L4LS_V=xN6V7GCtP2qqXyiER0yuw@mail.gmail.com>

On Sun, Mar 3, 2013 at 4:59 PM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
> Regarding aspect (1), we discussed enriching the compilation unit with
> information not coming from the filename itself (eg. the "provenance
> field" in spec.pdf). The most general situation is to consider that an
> internal prefix (or suffix) can be passed to the compiler at
> invocation time, as is currently used -for-pack (you're then free to
> express directory-local policies, random choices, interface hashes or
> whatever on top of this very primitive idea).
>
> This however opens the door for more things to work out that Alain's
> minimalistic proposal avoided. [...]

On Mon, Mar 4, 2013 at 4:18 PM, Romain Bardou <romain.bardou at inria.fr> wrote:
> I'm sure the possibility of a "-unit-name-prefix video3d"
> compilation flag has been discussed already. I'll go read and see
> what are the counter-arguments...

On Tue, Mar 5, 2013 at 3:48 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Could all of these benefits be obtained by having longer names for
> files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
> but keep the source file names short?  i.e., one could imagine that if
> you put "-put-in-namespace core" on the command-line to ocamlc, it
> would generate "core_list.ml" when given the file "list.ml".  The onus
> would be on the build system to provide said flags, but it would seem
> to simplify things thereupon.

This idea of enriching internal module names with a suffix passed at
compilation time is discussed in the
http://gallium.inria.fr/~scherer/namespaces/spec.pdf document, in the
"Compilation unit information" section:

> The changes proposed so far essentially allow to solve the problems
> evoked in the introduction, under the assumption that programmers
> were to use long, hopefully-unique module names. We are not
> satisfied with this as the only way to avoid name clashes for two
> different reasons:
>
>   - It does not coincide with the development techniques of most
>   OCaml users right now, which prefer small, readable source file
>   names. Helping users to refer to two different modules compiled
>   from the same filename doesn't actually do any good if the OCaml
>   linker rejects them.
>
>   - A naming strategy is not enough to ensure uniqueness in some
>   fairly realistic scenarios, for example if an user needs to use
>   two different versions of the same library in the same program. We
>   hinted at this use case with our Jenny#List and Jenny#ListDev
>   example: it is a very plausible need, and the "long fillenames"
>   approach to avoid clashes would impose to rename all the files of
>   one of the version, which is impractical.
>
> We therefore suggest the addition of two different information
> fields to the meta-data of compiled units:
>
>   - An additional suffix field that would be part of the identity of
>   the compilation unit along with the original file name (in compiled
>   object code), and could be arbitrary data (for example a hash, or
>   randomly-generated unique identifier) with strong unicity
>   guarantees.
>
>   - An additional provenance field that would provide provenance
>   information to help humans distinguish two compilation units
>   (coming from sources with the same lename).
>
>  Our suggestion for the suffix field would be to let the user
> optionally force its value, and otherwise pick a reasonable strategy
> that tries to ensure that two independent developers choosing the
> same le name do not result in a module identity clash situation at
> link-time. For example, [..]

Several ways to choose this suffix (or prefix) are discussed in the
document, notably using interface hashes and random seed generation --
Leo's original "in Foo.Bar" in-source construct would be another way
to do that. None of the proposals are convincing enough to be
specified as the "only way to do it", so manual specification of
suffixes still needs to be possible.

The "provenance" field originally comes from a design of Fabrice Le
Fessant, where a java-like ownership URL, eg. janestreet.core.foo or
ocamlpro.opam.blah, would be used *both* as more-unique information in
the internal name, and as a directive of how to populate the initial
namespace (Janestreet#Core#Foo) to be respected by whatever default
namespace construction choice is made (eg. put it in the right
directory if we choose recursive directory scanning).

I personally suspect it's better in the long run to separate the
internal name and linking aspect on one hand, and the in-source
compilation unit name on the other, and this is reflected in the way
provenance is described in spec.pdf. But of course this has drawbacks
already mentioned here that justify Alain's insistence on
hopefully-unique filenames as the mechanism to avoid internal name
conflicts.

On Tue, Mar 5, 2013 at 3:50 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Mon, Mar 4, 2013 at 9:48 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> On Mon, Mar 4, 2013 at 7:19 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>> On 03/03/2013 04:59 PM, Gabriel Scherer wrote:
>>>>
>>>> Regarding aspect (2), having filename conflicts is not an issue if
>>>> your namespace language is rich enough to let you map two different
>>>> identifiers to two compunits of the same filename.
>>>
>>>
>>> I did not really specify this part.  As you mention, one can decide that .ns
>>> files maps names to filenames (probably using relative path to the .ns
>>> file).
>>>
>>> That said, I see it as an advantage to have globally unique filenames, for
>>> various reasons.  I admit it is an annoyance for library writers, but I
>>> believe it is a tiny one compared to the benefits of this solution.  (As a
>>> minor point, my emacs is perfectly fine with autocompleting filename based
>>> on a suffix following an underscore character; e.g. if if type Ctrl-X-F,
>>> then "_pricing", then TAB, it autocompletes it to apropos_pricing_result.ml.
>>> I don't know if this is the default behavior of requires custom
>>> configuration, though.)
>>>
>>> Some benefits of globally unique filenames:
>>>
>>>  - Provide an unambiguous way to refer to a specific compilation unit, in a
>>> way which only depends on the search path.  While I agree that having
>>> shorter names "by default" in the documentation or error messages is nice,
>>> it is also good to support fully explicit outputs, and it is better if it
>>> does not depend too much on the environment.
>>>
>>>  - A corollary to the previous point is to simplify the interface between
>>> "ocamldep -modules" and the build system.
>>>
>>>  - Avoid the need to open compiled files to see "in which namespace" they
>>> are -- or what their internal name is -- and related problems, which we have
>>> discussed on this list.
>>>
>>>  - Support a deployment scenario where files from many libraries are
>>> installed in a single directory.
>>>
>>>  - Never force library users to use namespaces if they are fine with using
>>> long names (maybe with the help of a local manual renaming feature).
>>
>> Could all of these benefits be obtained by having longer names for
>> files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
>> but keep the source file names short?  i.e., one could imagine that if
>> you put "-put-in-namespace core" on the command-line to ocamlc, it
>> would generate "core_list.ml" when given the file "list.ml".  The onus
>> would be on the build system to provide said flags, but it would seem
>> to simplify things thereupon.
>
> Apologies: Catching up on the thread, this seems essentially the same
> as the -unit-name-prefix proposal that Romain mentions.
>
>>>> Note that Alain's proposal also map the namespace names to .ns
>>>> filenames. My guess would be that if we today recognize that binding
>>>> compunit source-names to their filenames is a mistake, we may regret
>>>> making the exact same choice for the upper-level construct in the
>>>> future.
>>>
>>>
>>> An alternative could be to specify on the command-line a set of .ns files,
>>> each of them containing a definition of the "namespace" it defines (the name
>>> used in the source code).  This would also support defining several
>>> "namespaces" in a single .ns file.  There was a strong resistance to
>>> specifying .ns files to be "opened" on the command-line, but here we're not
>>> talking about opening namespaces, just specifying them to the compiler.
>>
>> As one of the people who objected to "opening" from the command line,
>> I have no objection to this.
>>
>>> In this variant of the proposal, we could almost get rid of -I flags for
>>> deployed libraries.
>>>
>>>
>>>
>>> Alain
>>>
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform

From daniel.buenzli at erratique.ch  Tue Mar  5 08:32:08 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 5 Mar 2013 09:32:08 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CAPFanBE_1oV4WLrsbfd6h4L4LS_V=xN6V7GCtP2qqXyiER0yuw@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>
 <CAPFanBE_1oV4WLrsbfd6h4L4LS_V=xN6V7GCtP2qqXyiER0yuw@mail.gmail.com>
Message-ID: <ABE4038DB7C24DCA8D9830C860F68152@erratique.ch>



Le mardi, 5 mars 2013 ? 08:16, Gabriel Scherer a ?crit :

> The "provenance" field originally comes from a design of Fabrice Le
> Fessant, where a java-like ownership URL, eg. janestreet.core.foo or
> ocamlpro.opam.blah, would be used *both* as more-unique information in
> the internal name, and as a directive of how to populate the initial
> namespace (Janestreet#Core#Foo) to be respected by whatever default
> namespace construction choice is made (eg. put it in the right
> directory if we choose recursive directory scanning).

Juste a remark on provenance and java-like URL ownership. I understand companies are keen on these things for self-building pride and branding purposes. However it seems software has a much longer life-span than companies and especially company names. As such I'd prefer them to find a good company-invariant library/namespace name and use that rather than make sources dependent on a name that will have to be renamed once they have been acquired by some other company.  

In the same vein it would be absurd to publish my own libraries under ch.erratique as if one changes maintainer, there would be no point in this new maintainer having to keep that name. This would entail that library maintainer change entails source-level change in dependent code which is completely absurd and pointless.

Daniel





From alain.frisch at lexifi.com  Tue Mar  5 10:10:39 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Mar 2013 11:10:39 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
Message-ID: <5135C49F.4020103@lexifi.com>

On 03/05/2013 03:48 AM, Yaron Minsky wrote:
> Could all of these benefits be obtained by having longer names for
> files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
> but keep the source file names short?  i.e., one could imagine that if
> you put "-put-in-namespace core" on the command-line to ocamlc, it
> would generate "core_list.ml" when given the file "list.ml".  The onus
> would be on the build system to provide said flags, but it would seem
> to simplify things thereupon.

This would simplify the life of the library developer a little bit, but 
it would not really give the same benefits:

  - If you get an error message (or an output from a tool, such as 
Bisect or a dead code detector) with a long name, it's more difficult to 
find the corresponding source file (e.g. to look the .mli file).

  - You need to adapt all tools (ocamldep, ocamldoc and also third party 
tools), and this might change their interface (e.g. for ocamldoc, you 
will need to specify for each source file what's its implicit prefix).

  - Generic rules (e.g. in Makefiles) are more difficult to write.

  - You can deploy compiled files for several libraries in the same 
directory, but not the corresponding .mli files (for documentation purpose).


-- Alain

From romain.bardou at inria.fr  Tue Mar  5 10:31:09 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Tue, 05 Mar 2013 11:31:09 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <ABE4038DB7C24DCA8D9830C860F68152@erratique.ch>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <CACLX4jSezcKnA7YwMQMLFGpbNYTXTjcKbhGFBRs-wTtVm-8NjA@mail.gmail.com>
 <CAPFanBE_1oV4WLrsbfd6h4L4LS_V=xN6V7GCtP2qqXyiER0yuw@mail.gmail.com>
 <ABE4038DB7C24DCA8D9830C860F68152@erratique.ch>
Message-ID: <5135C96D.20408@inria.fr>


Le 05/03/2013 09:32, Daniel B?nzli a ?crit :
>
>
> Le mardi, 5 mars 2013 ? 08:16, Gabriel Scherer a ?crit :
>
>> The "provenance" field originally comes from a design of Fabrice Le
>> Fessant, where a java-like ownership URL, eg. janestreet.core.foo or
>> ocamlpro.opam.blah, would be used *both* as more-unique information in
>> the internal name, and as a directive of how to populate the initial
>> namespace (Janestreet#Core#Foo) to be respected by whatever default
>> namespace construction choice is made (eg. put it in the right
>> directory if we choose recursive directory scanning).
>
> Juste a remark on provenance and java-like URL ownership. I understand companies are keen on these things for self-building pride and branding purposes. However it seems software has a much longer life-span than companies and especially company names. As such I'd prefer them to find a good company-invariant library/namespace name and use that rather than make sources dependent on a name that will have to be renamed once they have been acquired by some other company.
>
> In the same vein it would be absurd to publish my own libraries under ch.erratique as if one changes maintainer, there would be no point in this new maintainer having to keep that name. This would entail that library maintainer change entails source-level change in dependent code which is completely absurd and pointless.

I agree: should a hierarchical naming scheme be used, I would prefer if 
library developpers did not put their brand in the names of their 
libraries. I've always been confused by the Java library names because 
of this. "core" is fine ("jane-street" is not), "stdlib" is fine 
("inria" is not), "batteries" is fine.

If a company name is used, I feel like the library is not free and that 
I should not use it. I don't no why :)

Btw, thanks to Gabriel for the summary (I had read the proposals but 
already had the time to forget them...)

Cheers,

-- 
Romain Bardou

From romain.bardou at inria.fr  Tue Mar  5 10:51:19 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Tue, 05 Mar 2013 11:51:19 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <5135C49F.4020103@lexifi.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <5135C49F.4020103@lexifi.com>
Message-ID: <5135CE27.7090409@inria.fr>

Le 05/03/2013 11:10, Alain Frisch a ?crit :
> On 03/05/2013 03:48 AM, Yaron Minsky wrote:
>> Could all of these benefits be obtained by having longer names for
>> files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
>> but keep the source file names short? i.e., one could imagine that if
>> you put "-put-in-namespace core" on the command-line to ocamlc, it
>> would generate "core_list.ml" when given the file "list.ml". The onus
>> would be on the build system to provide said flags, but it would seem
>> to simplify things thereupon.
>
> This would simplify the life of the library developer a little bit, but
> it would not really give the same benefits:
>
> - If you get an error message (or an output from a tool, such as Bisect
> or a dead code detector) with a long name, it's more difficult to find
> the corresponding source file (e.g. to look the .mli file).
>
> - You need to adapt all tools (ocamldep, ocamldoc and also third party
> tools), and this might change their interface (e.g. for ocamldoc, you
> will need to specify for each source file what's its implicit prefix).
>
> - Generic rules (e.g. in Makefiles) are more difficult to write.
>
> - You can deploy compiled files for several libraries in the same
> directory, but not the corresponding .mli files (for documentation
> purpose).

Is there a character which is not valid in module names, but which is 
valid in all file systems on all platforms, without the risk of being 
understood as a special shell character?

Let's assume '@' has this property. (Now that I think about it, '-' is 
probably a good candidate as well.) If unit "quadtree" is compiled with 
prefix "video", one could name the .cmx "video at quadtree". Then it should 
not be too hard to remove what's before the '@' in documentation and 
errors, but keep it everywhere as the internal name. To find the file, 
one would search for "*@quadtree.cmx".

You do need to adapt all tools though:
- (mandatory) check that the separator character is accepted by the tool;
- (optional) look for "*@quadtree.cmx" if "quadtree.cmx" cannot be found 
(useful for Makefiles, see below);
- (optional) change error and documentation pretty-printers.
If the latter is not done, the tools should still work, but it would 
print the long names and it might confuse the user slightly.

The Makefile issue has several solutions:
- for Makefiles which call OCamlbuild: nothing to do if OCamlbuild is 
adapted to look for prefixed files;
- for Makefiles which call ocamlfind: nothing to do if ocamlfind knows 
the actual prefixed names;
- for generic Makefiles which do not use any tool except ocamldep: maybe 
the user would have to add prefixes to dependencies, or maybe ocamldep 
or even ocaml could be adapted to make it so it is not even needed.

I'm sure there are issues with this though. In particular, searching for 
"*@quadtree.cmx" may lead to problems (takes time if there are too many 
files? what if there are several candidates?).

Cheers,

-- 
Romain Bardou

From yminsky at janestreet.com  Tue Mar  5 14:06:21 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 5 Mar 2013 09:06:21 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <5135C49F.4020103@lexifi.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <5135C49F.4020103@lexifi.com>
Message-ID: <CACLX4jQHS0h4z_bhzNSwMXD2uYjAbxGR+Zxyo1cKa1jroyV-UA@mail.gmail.com>

On Tue, Mar 5, 2013 at 5:10 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/05/2013 03:48 AM, Yaron Minsky wrote:
>>
>> Could all of these benefits be obtained by having longer names for
>> files generated as part of the compilation (.cmx, .cmo, .cmi, etc.),
>> but keep the source file names short?  i.e., one could imagine that if
>> you put "-put-in-namespace core" on the command-line to ocamlc, it
>> would generate "core_list.ml" when given the file "list.ml".  The onus
>> would be on the build system to provide said flags, but it would seem
>> to simplify things thereupon.
>
>
> This would simplify the life of the library developer a little bit, but it
> would not really give the same benefits:
>
>  - If you get an error message (or an output from a tool, such as Bisect or
> a dead code detector) with a long name, it's more difficult to find the
> corresponding source file (e.g. to look the .mli file).
>
>  - You need to adapt all tools (ocamldep, ocamldoc and also third party
> tools), and this might change their interface (e.g. for ocamldoc, you will
> need to specify for each source file what's its implicit prefix).

I agree that this would have to be solved, though I think this is
worth doing.  You'd need some kind of lookup from the easy to find
file (e.g., core_list.cmi) to the hard-to-find file (list.ml).

But I think this is work worth doing.

>  - Generic rules (e.g. in Makefiles) are more difficult to write.

This doesn't seem like much of an issue, since you can feel free to
simply use unique file-names if you'd like to.  This is merely an
option for developers who want to organize things in this way.  In the
end, I think it won't matter most of the time, because I hope that as
we develop better build tools, they will handle this stuff
automatically.

But if people want, they can name things uniquely and use simple
Makefiles.

>  - You can deploy compiled files for several libraries in the same
> directory, but not the corresponding .mli files (for documentation purpose).

I think this is fairly poor practice.  Directory structures are useful
anyway, and one might as well encourage their use.

And again, the fully-qualified names would be available, if people
wanted to use them.  But I think OPAM should organize things into
directories, and keep the names of the files in those directories
short.

y

From alain.frisch at lexifi.com  Tue Mar  5 16:07:34 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Mar 2013 17:07:34 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jQHS0h4z_bhzNSwMXD2uYjAbxGR+Zxyo1cKa1jroyV-UA@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <5135C49F.4020103@lexifi.com>
 <CACLX4jQHS0h4z_bhzNSwMXD2uYjAbxGR+Zxyo1cKa1jroyV-UA@mail.gmail.com>
Message-ID: <51361846.1020202@lexifi.com>

On 03/05/2013 03:06 PM, Yaron Minsky wrote:
> On Tue, Mar 5, 2013 at 5:10 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>   - You need to adapt all tools (ocamldep, ocamldoc and also third party
>> tools), and this might change their interface (e.g. for ocamldoc, you will
>> need to specify for each source file what's its implicit prefix).
>
> I agree that this would have to be solved, though I think this is
> worth doing.  You'd need some kind of lookup from the easy to find
> file (e.g., core_list.cmi) to the hard-to-find file (list.ml).

Do you agree that this requires not only a lookup algorithm, but also a 
way to specify to ocamldoc, file per file on its command-line, which 
"prefix" to use?  At least this is required if you want to allow using 
ocamldoc to generate a single documentation for module spanning several 
"namespaces" at once.

> This doesn't seem like much of an issue, since you can feel free to
> simply use unique file-names if you'd like to.  This is merely an
> option for developers who want to organize things in this way.  In the
> end, I think it won't matter most of the time, because I hope that as
> we develop better build tools, they will handle this stuff
> automatically.
 > But if people want, they can name things uniquely and use simple
 > Makefiles.

Again, I'm going to illustrate that we do crazy and non-standard stuffs 
here, but the way we integrate third-party libraries into our project is 
to take their source files and create an very simple OMakefile (usually 
2 or 3 lines) to integrate them in our global tree.  I understand this 
is a rather uncommon scenario, but it is a useful one, at least in our 
context because (i) we want everything to be under the control of our 
revision system so that we can very simply extract a full source tree 
corresponding to a distributed version of our application; (ii) we 
regularly rebuild the whole tree (e.g. as soon as we do a release, we 
recompile everything from sources) and being able to benefit from global 
parallel build is nice; (iii) released build specifications don't always 
work nicely under Windows and/or don't allow to inject custom 
compilation flags (e.g. to enable new warnings); (iv) having everything 
under the control of the same build system makes it easy to insert debug 
statement in the middle of a library and recompile (only) the necessary 
dependencies; (v) we don't use ocamlfind but recreated something similar 
within omake, but this assumes that everything is under the control of 
omake.

Anyway, I'm not trying to convince anyone else that this is a good 
strategy, only that it is currently in use in a least one non-trivial 
code base.  So the assumption that the choice of filenames for source 
code is purely on the developer side does not completely hold (I admit 
it will not be very difficult to rename files upon import if we need to).

>>   - You can deploy compiled files for several libraries in the same
>> directory, but not the corresponding .mli files (for documentation purpose).
>
> I think this is fairly poor practice.  Directory structures are useful
> anyway, and one might as well encourage their use.

I'm not claiming this is good practice in general (and I don't think we 
do that, specifically), but people should realize that some proposals 
will put pressure on many tools and will disallow some usage scenario 
currently in use and which they are not even aware of.  Just as an 
example, we have developed a simple IDE for OCaml code to be embedded in 
our application; it assumes that ocamldoc has been applied at once to 
all distributed libraries and that all the resulting HTML files are in a 
single directory.  I guess this is a rather non-standard use of 
ocamldoc, but it works quite well for us.  We will update our IDE and 
our use of ocamldoc if required, but when evaluating the respective pros 
and cons of various proposals, the cost of adapting all existing tools / 
usage scenarios should not be neglected (and people have little way to 
know about the amount of work required for those adaptations).


Alain

From yminsky at janestreet.com  Tue Mar  5 17:36:07 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 5 Mar 2013 12:36:07 -0500
Subject: [ocaml-platform] Unique file names
In-Reply-To: <51361846.1020202@lexifi.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <5135C49F.4020103@lexifi.com>
 <CACLX4jQHS0h4z_bhzNSwMXD2uYjAbxGR+Zxyo1cKa1jroyV-UA@mail.gmail.com>
 <51361846.1020202@lexifi.com>
Message-ID: <CACLX4jT4C_Fh2_T_b1WSdXJJK2Jar=qaAvH6xrU+gVkpUmQQGw@mail.gmail.com>

On Tue, Mar 5, 2013 at 11:07 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/05/2013 03:06 PM, Yaron Minsky wrote:
>>
>> On Tue, Mar 5, 2013 at 5:10 AM, Alain Frisch <alain.frisch at lexifi.com>
>> wrote:
>>>
>>>   - You need to adapt all tools (ocamldep, ocamldoc and also third party
>>> tools), and this might change their interface (e.g. for ocamldoc, you
>>> will
>>> need to specify for each source file what's its implicit prefix).
>>
>>
>> I agree that this would have to be solved, though I think this is
>> worth doing.  You'd need some kind of lookup from the easy to find
>> file (e.g., core_list.cmi) to the hard-to-find file (list.ml).
>
>
> Do you agree that this requires not only a lookup algorithm, but
> also a way to specify to ocamldoc, file per file on its
> command-line, which "prefix" to use?  At least this is required if
> you want to allow using ocamldoc to generate a single documentation
> for module spanning several "namespaces" at once.

I would think you'd need to get the information to ocamldoc, I'm not
really sure how.  I'm actually quite fond of your proposal for
ocamldoc, which is to have ocamldoc information come not from the
source but from annotations of the files that are generated by the
compilation tools.  That would presumably make this question largely
go away, since you would have named those files (cmo,cmx,cmi) uniquely
anyway.

>> This doesn't seem like much of an issue, since you can feel free to
>> simply use unique file-names if you'd like to.  This is merely an
>> option for developers who want to organize things in this way.  In the
>> end, I think it won't matter most of the time, because I hope that as
>> we develop better build tools, they will handle this stuff
>> automatically.
>
>> But if people want, they can name things uniquely and use simple
>> Makefiles.
>
> Again, I'm going to illustrate that we do crazy and non-standard stuffs
> here, but the way we integrate third-party libraries into our project is to
> take their source files and create an very simple OMakefile (usually 2 or 3
> lines) to integrate them in our global tree.

Us too!

> I understand this is a rather uncommon scenario, but it is a useful
> one, at least in our context because
> (i) we want everything to be under the control of our revision system so
> that we can very simply extract a full source tree corresponding to a
> distributed version of our application; (ii) we regularly rebuild the whole
> tree (e.g. as soon as we do a release, we recompile everything from sources)
> and being able to benefit from global parallel build is nice; (iii) released
> build specifications don't always work nicely under Windows and/or don't
> allow to inject custom compilation flags (e.g. to enable new warnings); (iv)
> having everything under the control of the same build system makes it easy
> to insert debug statement in the middle of a library and recompile (only)
> the necessary dependencies; (v) we don't use ocamlfind but recreated
> something similar within omake, but this assumes that everything is under
> the control of omake.

Indeed, all the same reasons apply here for us.

> Anyway, I'm not trying to convince anyone else that this is a good strategy,
> only that it is currently in use in a least one non-trivial code base.  So
> the assumption that the choice of filenames for source code is purely on the
> developer side does not completely hold (I admit it will not be very
> difficult to rename files upon import if we need to).

Right, and that's exactly what I would propose you would do if that's
how you want to deploy.  From my perspective, I'd like to keep the
ability to have short filenames (and therefore filename clashes), but
entirely within the kind of solution you describe.

>>>   - You can deploy compiled files for several libraries in the same
>>> directory, but not the corresponding .mli files (for documentation
>>> purpose).
>>
>>
>> I think this is fairly poor practice.  Directory structures are useful
>> anyway, and one might as well encourage their use.
>
>
> I'm not claiming this is good practice in general (and I don't think we do
> that, specifically), but people should realize that some proposals will put
> pressure on many tools and will disallow some usage scenario currently in
> use and which they are not even aware of.

But, if people who demand this use-case simply rename files to
explicitly include the namespace as a prefix, then aren't we
guaranteeing they can continue as they were?  The only real issue is
that they may have a little more work to import external libraries,
which seems a smallish price to pay.

> Just as an example, we have developed a simple IDE for OCaml code to
> be embedded in our application; it assumes that ocamldoc has been
> applied at once to all distributed libraries and that all the
> resulting HTML files are in a single directory.  I guess this is a
> rather non-standard use of ocamldoc, but it works quite well for us.
> We will update our IDE and our use of ocamldoc if required, but when
> evaluating the respective pros and cons of various proposals, the
> cost of adapting all existing tools / usage scenarios should not be
> neglected (and people have little way to know about the amount of
> work required for those adaptations).

Again, I think my proposal allows what you want without forcing the
entire world to use painfully long filenames.

y

From alain.frisch at lexifi.com  Wed Mar  6 09:15:43 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 10:15:43 +0100
Subject: [ocaml-platform] Unique file names
In-Reply-To: <CACLX4jT4C_Fh2_T_b1WSdXJJK2Jar=qaAvH6xrU+gVkpUmQQGw@mail.gmail.com>
References: <CACLX4jQHw7K_QiAe1zXEaNkWfNi+RHM5Ja9e2u0vMA-3osC4nQ@mail.gmail.com>
 <154C83854D7A44878B3462ABCE11D1D4@erratique.ch>
 <CAPFanBEy5K8AQb3fxbzjOb7gNrBXNN+f95OA=HS_QPbRdFrOrA@mail.gmail.com>
 <5134915D.5060100@lexifi.com>
 <CACLX4jRe6v=4tuu=JgHf50tJohLtYK=1VqtUzUef4OnMp_VqyQ@mail.gmail.com>
 <5135C49F.4020103@lexifi.com>
 <CACLX4jQHS0h4z_bhzNSwMXD2uYjAbxGR+Zxyo1cKa1jroyV-UA@mail.gmail.com>
 <51361846.1020202@lexifi.com>
 <CACLX4jT4C_Fh2_T_b1WSdXJJK2Jar=qaAvH6xrU+gVkpUmQQGw@mail.gmail.com>
Message-ID: <5137093F.3010904@lexifi.com>

On 03/05/2013 06:36 PM, Yaron Minsky wrote:
>> Again, I'm going to illustrate that we do crazy and non-standard stuffs
>> here, but the way we integrate third-party libraries into our project is to
>> take their source files and create an very simple OMakefile (usually 2 or 3
>> lines) to integrate them in our global tree.
>
> Us too!

Good to know!

>> (I admit it will not be very
>> difficult to rename files upon import if we need to).
>
> Right, and that's exactly what I would propose you would do if that's
> how you want to deploy.  From my perspective, I'd like to keep the
> ability to have short filenames (and therefore filename clashes), but
> entirely within the kind of solution you describe.

Ok, it's fair to assume that most library developers and users (in 
particular those relying on OPAM and ocamlfind) won't be in the same 
situation and it makes sense to simplify their lives as much as 
possible; and that larger projects can accept some small extra burden 
such as renaming files.



Alain

From amc79 at cam.ac.uk  Wed Mar  6 17:17:18 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Wed, 6 Mar 2013 17:17:18 +0000
Subject: [ocaml-platform] Reminder of OCaml Labs-related mailing lists
Message-ID: <7B2B1F92-FA0B-4D82-A0CC-7C9064031608@cam.ac.uk>

Dear all,

I thought it would be useful to point out the range of mailing lists that OCaml Labs is involved in.  Most of these have public archives and if you're interested in any of the topics, please feel free to sign-up.  I'm sending this message to each list, so apologies if you receive it multiple times.

cl-ocamllabs at lists.cam.ac.uk
Mostly used for announcements and updates. Discussions take place elsewhere.
Join: https://lists.cam.ac.uk/mailman/listinfo/cl-ocamllabs

cl-mirage at lists.cam.ac.uk
Day to day development talk on Mirage [1] and related projects.
Archive: https://lists.cam.ac.uk/pipermail/cl-mirage/
Join: https://lists.cam.ac.uk/mailman/listinfo/cl-mirage

platform at lists.ocaml.org
Discussions on aspects of the OCaml Platform and things that pertain to it.
Archive: http://lists.ocaml.org/pipermail/platform/
Join: http://lists.ocaml.org/listinfo/platform

infrastructure at lists.ocaml.org
Discussions on continuous integration infrastructure, ocaml.org and other things supporting OCaml.
Archive: http://lists.ocaml.org/pipermail/infrastructure
Join: http://lists.ocaml.org/listinfo/infrastructure

wg-camlp4 at lists.ocaml.org
Community working group on the future of syntax extensions to OCaml.
Archive: http://lists.ocaml.org/pipermail/wg-camlp4/
Join: http://lists.ocaml.org/listinfo/wg-camlp4

[1] mirage - http://openmirage.org and http://www.cl.cam.ac.uk/projects/ocamllabs/projects/mirage.html

Best wishes,
Amir

From thomas at ocamlpro.com  Fri Mar  8 16:30:29 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Fri, 8 Mar 2013 17:30:29 +0100
Subject: [ocaml-platform] OPAM 0.9.5 released
Message-ID: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>

Hi,

I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.

For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to continue using OPAM as before.

One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development version of OPAM, it is still recommended to use ocp-build (as it is much faster). 

The changelog:
* If necessary, apply patches and substitute files before removing a package
* Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
* Add build and install rules using ocamlbuild to help distro packagers
* Support arbitrary level of nested subdirectories in packages repositories
* Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
* Improve the behaviour of `opam update` wrt. pinned packages
* Change the default external solver criteria (only useful if you have aspcud installed on your machine)
* Add support for global and user configuration for OPAM (`opam config setup`)
* Stop yelling when OPAM is not up-to-date
* Update or generate `~/.ocamlinit` when running `opam init`
* Fix tests on *BSD (thx Arnaud Degroote)
* Fix compilation for the source archive

The files:
[OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
[OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz

Best,
Thomas


From roberto at dicosmo.org  Fri Mar  8 19:30:00 2013
From: roberto at dicosmo.org (Roberto Di Cosmo)
Date: Fri, 8 Mar 2013 20:30:00 +0100
Subject: [ocaml-platform] [opam-devel] OPAM 0.9.5 released
In-Reply-To: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
References: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
Message-ID: <20130308193000.GC11970@voyager>

Thanks Thomas for all this work! I'll be upgrading in the
classroom and see what the feedback is over the next weeks.

Speaking about auto-setup, a sizable part of the students
are still working on csh/tcsh, while opam is more bash oriented.
Is there any autodetection magic to adapt the configuration
to the kind of shell used?

--
Roberto

On Fri, Mar 08, 2013 at 05:30:29PM +0100, Thomas Gazagnaire wrote:
> Hi,
> 
> I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.
> 
> For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to continue using OPAM as before.
> 
> One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development version of OPAM, it is still recommended to use ocp-build (as it is much faster). 
> 
> The changelog:
> * If necessary, apply patches and substitute files before removing a package
> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
> * Add build and install rules using ocamlbuild to help distro packagers
> * Support arbitrary level of nested subdirectories in packages repositories
> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
> * Improve the behaviour of `opam update` wrt. pinned packages
> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
> * Add support for global and user configuration for OPAM (`opam config setup`)
> * Stop yelling when OPAM is not up-to-date
> * Update or generate `~/.ocamlinit` when running `opam init`
> * Fix tests on *BSD (thx Arnaud Degroote)
> * Fix compilation for the source archive
> 
> The files:
> [OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
> [OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz
> 
> Best,
> Thomas
> 
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel

-- 
Roberto Di Cosmo
 
------------------------------------------------------------------
Professeur               En delegation a l'INRIA
PPS                      E-mail: roberto at dicosmo.org
Universite Paris Diderot WWW  : http://www.dicosmo.org
Case 7014                Tel  : ++33-(0)1-57 27 92 20
5, Rue Thomas Mann       
F-75205 Paris Cedex 13   Identica: http://identi.ca/rdicosmo
FRANCE.                  Twitter: http://twitter.com/rdicosmo
------------------------------------------------------------------
Attachments:
MIME accepted, Word deprecated
      http://www.gnu.org/philosophy/no-word-attachments.html
------------------------------------------------------------------
Office location:
 
Bureau 320 (3rd floor)
Batiment Sophie Germain
Avenue de France
Metro Bibliotheque Francois Mitterrand, ligne 14/RER C
-----------------------------------------------------------------
GPG fingerprint 2931 20CE 3A5A 5390 98EC 8BFC FCCA C3BE 39CB 12D3                        

From mmatalka at gmail.com  Fri Mar  8 22:18:33 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Fri, 08 Mar 2013 17:18:33 -0500
Subject: [ocaml-platform] [opam-devel] OPAM 0.9.5 released
In-Reply-To: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com> (Thomas
 Gazagnaire's message of "Fri, 8 Mar 2013 17:30:29 +0100")
References: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
Message-ID: <871ubph6x2.fsf@li195-236.members.linode.com>

For the 5 of you out there, I have added 0.9.5 to Nix:

https://github.com/NixOS/nixpkgs/commit/66ad1658292f6923f6866f81a9d285b4ffa5b8a0

You can install by pulling nixpkgs off github and installing with:

sudo nix-env -f /path/to/nixpkgs -i opam

It should be pulled into nixpkgs channel soon.

I will do my best to keep opam updated on nixpkgs, let me know if you
have any questions, concerns, or comments.

/M

Thomas Gazagnaire <thomas at ocamlpro.com> writes:

> Hi,
>
> I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.
>
> For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local
> configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to
> continue using OPAM as before.
>
> One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make
> install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development
> version of OPAM, it is still recommended to use ocp-build (as it is much faster).
>
> The changelog:
> * If necessary, apply patches and substitute files before removing a package
> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
> * Add build and install rules using ocamlbuild to help distro packagers
> * Support arbitrary level of nested subdirectories in packages repositories
> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
> * Improve the behaviour of `opam update` wrt. pinned packages
> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
> * Add support for global and user configuration for OPAM (`opam config setup`)
> * Stop yelling when OPAM is not up-to-date
> * Update or generate `~/.ocamlinit` when running `opam init`
> * Fix tests on *BSD (thx Arnaud Degroote)
> * Fix compilation for the source archive
>
> The files:
> [OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
> [OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz
>
> Best,
> Thomas
>
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel

From thomas at ocamlpro.com  Fri Mar  8 23:39:00 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Sat, 9 Mar 2013 00:39:00 +0100
Subject: [ocaml-platform] [opam-devel] OPAM 0.9.5 released
In-Reply-To: <20130308193000.GC11970@voyager>
References: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
 <20130308193000.GC11970@voyager>
Message-ID: <3A762469-9147-4A11-B8E8-DBB564CFFEB7@ocamlpro.com>

> Speaking about auto-setup, a sizable part of the students
> are still working on csh/tcsh, while opam is more bash oriented.
> Is there any autodetection magic to adapt the configuration
> to the kind of shell used?

Yes, there is some shell autodection magic and normally bash/sh/csh/tcsh/zsh should work fine, but I did a limited amount of testing so it might be a bit broken.
You can overwrite the autodection logic using --sh, --zsh or --csh when doing `opam init` or `opam config setup`.

Thomas

> 
> --
> Roberto
> 
> On Fri, Mar 08, 2013 at 05:30:29PM +0100, Thomas Gazagnaire wrote:
>> Hi,
>> 
>> I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.
>> 
>> For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to continue using OPAM as before.
>> 
>> One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development version of OPAM, it is still recommended to use ocp-build (as it is much faster). 
>> 
>> The changelog:
>> * If necessary, apply patches and substitute files before removing a package
>> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
>> * Add build and install rules using ocamlbuild to help distro packagers
>> * Support arbitrary level of nested subdirectories in packages repositories
>> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
>> * Improve the behaviour of `opam update` wrt. pinned packages
>> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
>> * Add support for global and user configuration for OPAM (`opam config setup`)
>> * Stop yelling when OPAM is not up-to-date
>> * Update or generate `~/.ocamlinit` when running `opam init`
>> * Fix tests on *BSD (thx Arnaud Degroote)
>> * Fix compilation for the source archive
>> 
>> The files:
>> [OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
>> [OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz
>> 
>> Best,
>> Thomas
>> 
>> _______________________________________________
>> opam-devel mailing list
>> opam-devel at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/opam-devel
> 
> -- 
> Roberto Di Cosmo
> 
> ------------------------------------------------------------------
> Professeur               En delegation a l'INRIA
> PPS                      E-mail: roberto at dicosmo.org
> Universite Paris Diderot WWW  : http://www.dicosmo.org
> Case 7014                Tel  : ++33-(0)1-57 27 92 20
> 5, Rue Thomas Mann       
> F-75205 Paris Cedex 13   Identica: http://identi.ca/rdicosmo
> FRANCE.                  Twitter: http://twitter.com/rdicosmo
> ------------------------------------------------------------------
> Attachments:
> MIME accepted, Word deprecated
>      http://www.gnu.org/philosophy/no-word-attachments.html
> ------------------------------------------------------------------
> Office location:
> 
> Bureau 320 (3rd floor)
> Batiment Sophie Germain
> Avenue de France
> Metro Bibliotheque Francois Mitterrand, ligne 14/RER C
> -----------------------------------------------------------------
> GPG fingerprint 2931 20CE 3A5A 5390 98EC 8BFC FCCA C3BE 39CB 12D3                        


From thomas at ocamlpro.com  Sun Mar 10 16:17:33 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Sun, 10 Mar 2013 17:17:33 +0100
Subject: [ocaml-platform] OPAM 0.9.5 released
In-Reply-To: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
References: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
Message-ID: <50FFDD1F-112D-4D5C-B764-CD927AF4C8EF@ocamlpro.com>

Just a remark for the packagers of OPAM. 0.9.5 is broken for packages using symbolic links[1]. If possible, please apply the following patch on the version you are distributing:

https://github.com/OCamlPro/opam/commit/db5129d42fd70cb80ee33040d42f0103d9cc51ea.diff

Best,
Thomas

[1] https://github.com/OCamlPro/opam/issues/520


On Mar 8, 2013, at 5:30 PM, Thomas Gazagnaire wrote:

> Hi,
> 
> I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.
> 
> For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to continue using OPAM as before.
> 
> One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development version of OPAM, it is still recommended to use ocp-build (as it is much faster). 
> 
> The changelog:
> * If necessary, apply patches and substitute files before removing a package
> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
> * Add build and install rules using ocamlbuild to help distro packagers
> * Support arbitrary level of nested subdirectories in packages repositories
> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
> * Improve the behaviour of `opam update` wrt. pinned packages
> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
> * Add support for global and user configuration for OPAM (`opam config setup`)
> * Stop yelling when OPAM is not up-to-date
> * Update or generate `~/.ocamlinit` when running `opam init`
> * Fix tests on *BSD (thx Arnaud Degroote)
> * Fix compilation for the source archive
> 
> The files:
> [OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
> [OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz
> 
> Best,
> Thomas
> 


From anil at recoil.org  Sun Mar 10 16:46:20 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Sun, 10 Mar 2013 16:46:20 +0000
Subject: [ocaml-platform] [opam-devel] OPAM 0.9.5 released
In-Reply-To: <50FFDD1F-112D-4D5C-B764-CD927AF4C8EF@ocamlpro.com>
References: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
 <50FFDD1F-112D-4D5C-B764-CD927AF4C8EF@ocamlpro.com>
Message-ID: <3C8A9B7E-9BB7-4751-A871-A8EFE8310144@recoil.org>

I've opened a Homebrew pull request at:
https://github.com/mxcl/homebrew/pull/18376

-anil

On 10 Mar 2013, at 16:17, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:

> Just a remark for the packagers of OPAM. 0.9.5 is broken for packages using symbolic links[1]. If possible, please apply the following patch on the version you are distributing:
> 
> https://github.com/OCamlPro/opam/commit/db5129d42fd70cb80ee33040d42f0103d9cc51ea.diff
> 
> Best,
> Thomas
> 
> [1] https://github.com/OCamlPro/opam/issues/520
> 
> 
> On Mar 8, 2013, at 5:30 PM, Thomas Gazagnaire wrote:
> 
>> Hi,
>> 
>> I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.
>> 
>> For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to continue using OPAM as before.
>> 
>> One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development version of OPAM, it is still recommended to use ocp-build (as it is much faster). 
>> 
>> The changelog:
>> * If necessary, apply patches and substitute files before removing a package
>> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
>> * Add build and install rules using ocamlbuild to help distro packagers
>> * Support arbitrary level of nested subdirectories in packages repositories
>> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
>> * Improve the behaviour of `opam update` wrt. pinned packages
>> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
>> * Add support for global and user configuration for OPAM (`opam config setup`)
>> * Stop yelling when OPAM is not up-to-date
>> * Update or generate `~/.ocamlinit` when running `opam init`
>> * Fix tests on *BSD (thx Arnaud Degroote)
>> * Fix compilation for the source archive
>> 
>> The files:
>> [OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
>> [OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz
>> 
>> Best,
>> Thomas
>> 
> 
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel
> 


From lpw25 at cam.ac.uk  Sun Mar 10 22:55:48 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 10 Mar 2013 22:55:48 +0000
Subject: [ocaml-platform] on the need and design of OCaml namespaces
In-Reply-To: <5130D186.5040704@inria.fr>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jRVuiXjAU56p3-H_uXzkZ03wjfzezvsqZue2WR5gS+zOg@mail.gmail.com>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
Message-ID: <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>

I've written a blog post about namespaces, summarising the design issues 
that have been discussed so far and outlining a proposal that I think 
addresses most of the issues that have been raised.

http://www.lpw25.net/2013/03/10/ocaml-namespaces.html

Please respond to the post on this list rather than in the comments section 
of the post.

Regards,

Leo

From thomas at ocamlpro.com  Mon Mar 11 10:01:33 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Mon, 11 Mar 2013 11:01:33 +0100
Subject: [ocaml-platform] OPAM 0.9.5 released
In-Reply-To: <50FFDD1F-112D-4D5C-B764-CD927AF4C8EF@ocamlpro.com>
References: <5A92BC9D-0A67-49BA-9CB8-CD8E76F210D1@ocamlpro.com>
 <50FFDD1F-112D-4D5C-B764-CD927AF4C8EF@ocamlpro.com>
Message-ID: <2D7C7994-EF62-4D19-93CE-5490444D84E0@ocamlpro.com>

So I've started to get some feedback to the auto-setup step and it seems to be broken under debian/ubuntu.

The symptom: gnome is not starting
The cure: open a textual console and add " > /dev/null 2> /dev/null || true" to the line ". ~/.opam/opam-int/init.sh" in your ~/.profile
The cause: some starting scripts use dash which is quite limited

For the linux packagers the fixing patches:
https://github.com/OCamlPro/opam/commit/93cf842464589d1e479072d7aeb76d94537facfe.diff
https://github.com/OCamlPro/opam/commit/8ca0faa4df701e0e15e26681ad3fbc9c5fa44780.diff

--
Thomas

On Mar 10, 2013, at 5:17 PM, Thomas Gazagnaire wrote:

> Just a remark for the packagers of OPAM. 0.9.5 is broken for packages using symbolic links[1]. If possible, please apply the following patch on the version you are distributing:
> 
> https://github.com/OCamlPro/opam/commit/db5129d42fd70cb80ee33040d42f0103d9cc51ea.diff
> 
> Best,
> Thomas
> 
> [1] https://github.com/OCamlPro/opam/issues/520
> 
> 
> On Mar 8, 2013, at 5:30 PM, Thomas Gazagnaire wrote:
> 
>> Hi,
>> 
>> I'm pleased to announce the release 0.9.5 of OPAM.  All the features that I though are important for the first releases are in, so you can consider 0.9.5 to be something like 1.0-rc1.
>> 
>> For this release, I'm particularly keen on getting people feebdack on the new auto-setup thing: OPAM now asks the user if he wants his local configuration upgraded to fully use OPAM (including installation auto-completion scripts). Use `opam init --no-setup` if you want to continue using OPAM as before.
>> 
>> One notable change which will please packagers of OPAM for OS distributions: I've added a `make with-ocamlbuild` and `make install-with-ocamlbuild` targets to not depend on the unreleased (and thus unpackaged) ocp-build. Otherwise, when using the development version of OPAM, it is still recommended to use ocp-build (as it is much faster). 
>> 
>> The changelog:
>> * If necessary, apply patches and substitute files before removing a package
>> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
>> * Add build and install rules using ocamlbuild to help distro packagers
>> * Support arbitrary level of nested subdirectories in packages repositories
>> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
>> * Improve the behaviour of `opam update` wrt. pinned packages
>> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
>> * Add support for global and user configuration for OPAM (`opam config setup`)
>> * Stop yelling when OPAM is not up-to-date
>> * Update or generate `~/.ocamlinit` when running `opam init`
>> * Fix tests on *BSD (thx Arnaud Degroote)
>> * Fix compilation for the source archive
>> 
>> The files:
>> [OPAM] https://github.com/OCamlPro/opam/archive/latest.tar.gz
>> [OPAM+depends] http://www.ocamlpro.com/pub/opam-latest-full.tar.gz
>> 
>> Best,
>> Thomas
>> 
> 


From yminsky at gmail.com  Tue Mar 12 01:51:59 2013
From: yminsky at gmail.com (Yaron Minsky)
Date: Mon, 11 Mar 2013 21:51:59 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
Message-ID: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>

Some thoughts spurred by reading Leo's proposal:

- AUTO-OPENS ARE NOT JUST FOR CORE.  Leo proposes not having
  auto-opened modules associated with namespaces, and instead allowing
  opens to be set at the commandline.  This would not solve our
  problem, and we would not use them if they were available.

  It's important to understand Core.Std is not the only example.
  Another example among our publically released libraries is
  Async. All Async programs should open Async.Std, which adds a number
  of important values to the namespace, not just modules.  Indeed,
  there are many different application frameworks we have where there
  are a default set of libraries that should be opened as part of
  opening the namespace.

  This is a common and highly useful idiom, and one that is well
  supported by -pack, and I think it should be supported by namespaces
  as well.  Providing module opens as part of namespaces is both
  natural from the user perspective (both module opens and and module
  aliases are namespace manipulations, and thus naturally go
  together), and important from a usability perspective.

- TRUSTING NAMESPACES.  When thinking about whether files should be
  able to declare their namespaces, one thing that's worth considering
  is the notion of trust.  The Core library is a particularly closely
  code-reviewed and tested collection of code, and one can feel pretty
  safe that if you use anything inside of Core.Std, you're using a
  pretty trustworthy piece of code.

  On the other hand, Core_extended.Std is less closely reviewed, and
  I would want to avoid it for many trusted applications.  Within Jane
  Street, this is easy for us to manage: we have clear control at the
  build-system level of what goes into Core.Std, and we can enforce
  standards of testing and code review on it.

  If one allows completely free specification of namespaces from
  within a file, this could undermine that sense of trust.  I'd like
  to make sure that we don't undermine the ability to enforce in the
  build system that all files for a given namespace come, say, from a
  certain directory.

From nanaki at gmail.com  Tue Mar 12 04:21:56 2013
From: nanaki at gmail.com (Jeff Meister)
Date: Mon, 11 Mar 2013 21:21:56 -0700
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
Message-ID: <CAHaHOqQ06Aq3YKotoutm94v3aTPnNfqZwhXvQEuCYCAJe-OiWw@mail.gmail.com>

I concur with Yaron on his first point, but I disagree with his second
point.

In support of the idea that Core.Std or Async.Std might include some
modules to automatically open, consider that the default namespace
currently provided in OCaml automatically opens the module Pervasives... to
the OCaml developers, this auto-open feature was clearly valuable. Surely,
third-party libraries may have their own notion of "pervasives", right?
Moreover, as Yaron states, packed modules already support this idiom... it
would be an awful shame if some OCaml users ignored the new namespace
features in favor of packed modules, willing to deal with their
shortcomings to gain their advantages, when these advantages could also be
added to namespaces.

As to the second point: personally, I believe it is more important for the
OCaml community to provide free specification of namespaces within a file
(possibly constructed by the user and not the library author). Part of the
utility of namespaces that I see is the ability to use the author's modules
in a way beyond what he originally intended for his purpose. As you said,
your requirements are easy to control within Jane Street... I don't think
it's important to export these requirements outside Jane Street, unless
other OCaml users have similar needs. I would rather that my build system
do exactly as I specify, rather than try to enforce some namespace-based
security guarantees (in a way that likely would not stand up to malicious
circumvention).


On Mon, Mar 11, 2013 at 6:51 PM, Yaron Minsky <yminsky at gmail.com> wrote:

> Some thoughts spurred by reading Leo's proposal:
>
> - AUTO-OPENS ARE NOT JUST FOR CORE.  Leo proposes not having
>   auto-opened modules associated with namespaces, and instead allowing
>   opens to be set at the commandline.  This would not solve our
>   problem, and we would not use them if they were available.
>
>   It's important to understand Core.Std is not the only example.
>   Another example among our publically released libraries is
>   Async. All Async programs should open Async.Std, which adds a number
>   of important values to the namespace, not just modules.  Indeed,
>   there are many different application frameworks we have where there
>   are a default set of libraries that should be opened as part of
>   opening the namespace.
>
>   This is a common and highly useful idiom, and one that is well
>   supported by -pack, and I think it should be supported by namespaces
>   as well.  Providing module opens as part of namespaces is both
>   natural from the user perspective (both module opens and and module
>   aliases are namespace manipulations, and thus naturally go
>   together), and important from a usability perspective.
>
> - TRUSTING NAMESPACES.  When thinking about whether files should be
>   able to declare their namespaces, one thing that's worth considering
>   is the notion of trust.  The Core library is a particularly closely
>   code-reviewed and tested collection of code, and one can feel pretty
>   safe that if you use anything inside of Core.Std, you're using a
>   pretty trustworthy piece of code.
>
>   On the other hand, Core_extended.Std is less closely reviewed, and
>   I would want to avoid it for many trusted applications.  Within Jane
>   Street, this is easy for us to manage: we have clear control at the
>   build-system level of what goes into Core.Std, and we can enforce
>   standards of testing and code review on it.
>
>   If one allows completely free specification of namespaces from
>   within a file, this could undermine that sense of trust.  I'd like
>   to make sure that we don't undermine the ability to enforce in the
>   build system that all files for a given namespace come, say, from a
>   certain directory.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130311/74fa03aa/attachment.html>

From anil at recoil.org  Tue Mar 12 09:55:19 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 12 Mar 2013 09:55:19 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
Message-ID: <20130312095519.GG29372@dark.recoil.org>

On Mon, Mar 11, 2013 at 09:51:59PM -0400, Yaron Minsky wrote:
> Some thoughts spurred by reading Leo's proposal:
> 
> - AUTO-OPENS ARE NOT JUST FOR CORE.  Leo proposes not having
>   auto-opened modules associated with namespaces, and instead allowing
>   opens to be set at the commandline.  This would not solve our
>   problem, and we would not use them if they were available.
> 
>   It's important to understand Core.Std is not the only example.
>   Another example among our publically released libraries is
>   Async. All Async programs should open Async.Std, which adds a number
>   of important values to the namespace, not just modules.  Indeed,
>   there are many different application frameworks we have where there
>   are a default set of libraries that should be opened as part of
>   opening the namespace.
> 
>   This is a common and highly useful idiom, and one that is well
>   supported by -pack, and I think it should be supported by namespaces
>   as well.  Providing module opens as part of namespaces is both
>   natural from the user perspective (both module opens and and module
>   aliases are namespace manipulations, and thus naturally go
>   together), and important from a usability perspective.

I think our goal should be to eliminate the need for manual open
statements at the top of every file that uses Core or Async.  We've
already seen several cases where people simply forget.  There's also the
important ordering:

open Async.Std
open Core.Std

...is entirely wrong, and is another potential mistake that should be
avoided by removing this boilerplate.

Leo's model allows the build system to precisely set the order of default
opens, and tools such as ocamlfind could support this just as they do
include and link directives at the moment.  I know JS doesn't use
ocamlfind, but the moral equivalent could inject the command-line
directives very easily.

This does make it harder for people using Makefiles directly.  I'm not
sure how much that matters in the case of libraries such as Core, since
all tutorials refer to either OASIS or ocamlfind at the moment.  Of
course, the option to do a manual 'open' is still available in this case.

> - TRUSTING NAMESPACES.  When thinking about whether files should be
>   able to declare their namespaces, one thing that's worth considering
>   is the notion of trust.  The Core library is a particularly closely
>   code-reviewed and tested collection of code, and one can feel pretty
>   safe that if you use anything inside of Core.Std, you're using a
>   pretty trustworthy piece of code.
> 
>   On the other hand, Core_extended.Std is less closely reviewed, and
>   I would want to avoid it for many trusted applications.  Within Jane
>   Street, this is easy for us to manage: we have clear control at the
>   build-system level of what goes into Core.Std, and we can enforce
>   standards of testing and code review on it.

I agree with Jeff here.  You can still maintain this guarantee at the
build system level, and it cripples namespaces if I *cant* extend them in
ways that the original library author didn't want (for example, by
injecting a new module).  This is, after all, what Core does by shadowing
most of the Pervasives module.

-- 
Anil Madhavapeddy                                 http://anil.recoil.org

From lpw25 at cam.ac.uk  Tue Mar 12 10:57:31 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 12 Mar 2013 10:57:31 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <20130312095519.GG29372@dark.recoil.org> (Anil Madhavapeddy's
 message of "Tue, 12 Mar 2013 09:55:19 +0000")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
Message-ID: <87k3pc997o.fsf@kingston.cl.cam.ac.uk>

> Leo's model allows the build system to precisely set the order of default
> opens, and tools such as ocamlfind could support this just as they do
> include and link directives at the moment.  I know JS doesn't use
> ocamlfind, but the moral equivalent could inject the command-line
> directives very easily.

To expand on what Anil said, under my proposed system the idea is to push the
problem of providing "pervasive" modules into the build or package system.

For example, I would expect Core to provide some kind of package description
for OCamlFind or similar tool including something like (using made up
syntax):

    path := ./core.mlpath
    open := Core#Common

where "core.mlpath" is a search path description file.

Then Async would include a description including something like:

    path := ./async.mlpath
    path-depends := core
    open := Async#Common
    open-depends := core

where "async.mlpath" is a search path description file that includes:

    Core#Original#*: Core#*
    Core#Gc: Async#Gc
    Core#Condition: Async#Condition

where "Gc" and "Condition" are the components of Core that Async
re-implements.

This would mean that commands equivalent to any of the following would all
produce the correct default environment for using Async:

    ocamlc -package async
    ocamlc -package async -package core
    ocamlc -package core -package async

I think this is preferable to requiring all users of Async to start their
files with:

    open Core.Std
    open Async.Std

which is not something that a user might naturally assume was required.

From yminsky at gmail.com  Tue Mar 12 11:32:38 2013
From: yminsky at gmail.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 07:32:38 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>

I have no objection to specifying that Core#Common should be connected
to the Core package within the build system.  But it's important to us
that namespace manipulations be observable by the programmer by
reading the code.  If I understand correctly, Leo's proposal involves
stashing that away in the build system, which undermines that goal.

Another thing which may not be obvious is that one sometimes in the
same file wants to access just Core.Std in some scopes in the file,
and Async.Std in other scopes.  Full control of the namespace is
important, and something we do at multiple scopes within a file.
Being able to control this only at the file level, and only from
within the build system, is a poor match for our needs.

The fact that one should write:

open Core.Std
open Async.Std

in a specific order does not strike me as a particular problem, and
even if it were, the solution I think would not be to stuff it into
the build system, but to build a single namespace that opened both
Core and Async.

If the proposal lands in the way Leo describes, I would think we would
write a ppx extension that, for a certain whitelist of namespaces,
would convert:

   open namespace Core

into

   open namespace Core
   open Core#Common

Given that this is easy enough to do at the ppx level, I find it hard
to see what difficulties would be raised by integrating this with the
namespace system.  I understand that it feels mildly unsanitary
because on the implementation end the two things are quite different,
but from a user point of view, I think it's very much the right thing.

y


On Tue, Mar 12, 2013 at 6:57 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> Leo's model allows the build system to precisely set the order of default
>> opens, and tools such as ocamlfind could support this just as they do
>> include and link directives at the moment.  I know JS doesn't use
>> ocamlfind, but the moral equivalent could inject the command-line
>> directives very easily.
>
> To expand on what Anil said, under my proposed system the idea is to push the
> problem of providing "pervasive" modules into the build or package system.
>
> For example, I would expect Core to provide some kind of package description
> for OCamlFind or similar tool including something like (using made up
> syntax):
>
>     path := ./core.mlpath
>     open := Core#Common
>
> where "core.mlpath" is a search path description file.
>
> Then Async would include a description including something like:
>
>     path := ./async.mlpath
>     path-depends := core
>     open := Async#Common
>     open-depends := core
>
> where "async.mlpath" is a search path description file that includes:
>
>     Core#Original#*: Core#*
>     Core#Gc: Async#Gc
>     Core#Condition: Async#Condition
>
> where "Gc" and "Condition" are the components of Core that Async
> re-implements.
>
> This would mean that commands equivalent to any of the following would all
> produce the correct default environment for using Async:
>
>     ocamlc -package async
>     ocamlc -package async -package core
>     ocamlc -package core -package async
>
> I think this is preferable to requiring all users of Async to start their
> files with:
>
>     open Core.Std
>     open Async.Std
>
> which is not something that a user might naturally assume was required.

From yminsky at janestreet.com  Tue Mar 12 12:27:34 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 08:27:34 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <20130312095519.GG29372@dark.recoil.org>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
Message-ID: <CACLX4jSSykBer78scjZSma0-akknzuF-Hu8-J+PzGgC=CRcVNg@mail.gmail.com>

On Tue, Mar 12, 2013 at 5:55 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On Mon, Mar 11, 2013 at 09:51:59PM -0400, Yaron Minsky wrote:
>> - TRUSTING NAMESPACES.  When thinking about whether files should be
>>   able to declare their namespaces, one thing that's worth considering
>>   is the notion of trust.  The Core library is a particularly closely
>>   code-reviewed and tested collection of code, and one can feel pretty
>>   safe that if you use anything inside of Core.Std, you're using a
>>   pretty trustworthy piece of code.
>>
>>   On the other hand, Core_extended.Std is less closely reviewed, and
>>   I would want to avoid it for many trusted applications.  Within Jane
>>   Street, this is easy for us to manage: we have clear control at the
>>   build-system level of what goes into Core.Std, and we can enforce
>>   standards of testing and code review on it.
>
> I agree with Jeff here.  You can still maintain this guarantee at the
> build system level, and it cripples namespaces if I *cant* extend them in
> ways that the original library author didn't want (for example, by
> injecting a new module).  This is, after all, what Core does by shadowing
> most of the Pervasives module.

I wasn't meaning to make an argument against Leo's design here.  I
just wanted to raise an issue about namespaces which other people may
not have considered.  As long as the proposal allows us to from the
build system enforce rules on what gets into a namespace, I'm happy.

y

From yminsky at janestreet.com  Tue Mar 12 12:30:09 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 08:30:09 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jSSykBer78scjZSma0-akknzuF-Hu8-J+PzGgC=CRcVNg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <CACLX4jSSykBer78scjZSma0-akknzuF-Hu8-J+PzGgC=CRcVNg@mail.gmail.com>
Message-ID: <CACLX4jRTdV287whXepWxJqNLf8Kn3wGkXamXO6QwLkABYUP9Hw@mail.gmail.com>

On Tue, Mar 12, 2013 at 8:27 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Tue, Mar 12, 2013 at 5:55 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> On Mon, Mar 11, 2013 at 09:51:59PM -0400, Yaron Minsky wrote:
>>> - TRUSTING NAMESPACES.  When thinking about whether files should be
>>>   able to declare their namespaces, one thing that's worth considering
>>>   is the notion of trust.  The Core library is a particularly closely
>>>   code-reviewed and tested collection of code, and one can feel pretty
>>>   safe that if you use anything inside of Core.Std, you're using a
>>>   pretty trustworthy piece of code.
>>>
>>>   On the other hand, Core_extended.Std is less closely reviewed, and
>>>   I would want to avoid it for many trusted applications.  Within Jane
>>>   Street, this is easy for us to manage: we have clear control at the
>>>   build-system level of what goes into Core.Std, and we can enforce
>>>   standards of testing and code review on it.
>>
>> I agree with Jeff here.  You can still maintain this guarantee at the
>> build system level, and it cripples namespaces if I *cant* extend them in
>> ways that the original library author didn't want (for example, by
>> injecting a new module).  This is, after all, what Core does by shadowing
>> most of the Pervasives module.
>
> I wasn't meaning to make an argument against Leo's design here.  I
> just wanted to raise an issue about namespaces which other people may
> not have considered.  As long as the proposal allows us to from the
> build system enforce rules on what gets into a namespace, I'm happy.

One clarification on what you said earlier: I do think that this
feature is not strictly necessary to do what we did with Core vs the
OCaml stdlib.  We created a /new/ namespace that included things from
an existing namespace.  That's clearly necessary.  It's less obvious
to me that injecting things into a namespace that someone else created
is as important.

That said, I have no objections to the feature, as long as I can
prevent it from being used willy nilly within our own code.  (Thus, I
think I would object to source-level namespace declarations that the
build system had no say over.)

From gabriel.scherer at gmail.com  Tue Mar 12 12:39:24 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 12 Mar 2013 13:39:24 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
Message-ID: <CAPFanBHb0CTwYufbYHNwtqqnW1qUATw1h7Y77pg3phke_VgWPQ@mail.gmail.com>

One aspect of Leo's proposition that I found lacking is the absence of
a precise framework that could explain the semantics of the proposed
features and study their combination.

In our spec.pdf document, we have a single namespace description
language that is specified rather precisely, and is used to explain
all the semantic phenomenons that are currently scattered in
documentation about "where the compiler looks for compilation units".
We capture this precisely as a "compilation environment": whatever
conventions we adopt for namespace lookup is explained as producing a
namespace description that is taken as the compilation environment in
which the program's semantics is understood. The current command-line
argument -I, for example, is explained in term of the "scan" primitive
(scanning the filesystem for compilation units in a precisely
explained filename-dependent way) and the "merge" primitive (combining
two compilation environments again in a precisely specified way).

(Note that this doesn't mean that the whole namespace description
language has to be exposed to end-users. Some parts of it can be
referred to only internally to explain built-in conventions and
features.)

Concretely, the proposal as it is currently phrased left me wondering:
- how to compose different "search path files" (by concatenation, I
assume; I regret the absence of any conflict handling considerations)
- whether "-open" arguments would still be opened in absence of the
corresponding "open namespace Core" (it looks like "yes", and that
would be a semantics change wrt. the discussed flat-access feature)
- what happens when you write "open namespace Croe", making a typo
- whether each build system would have to implement its own way to
describe which -name option are supposed to be passed to which files;
it would be natural to pass them a description of the expected final
compilation environment (mapping module names to compilation units),
but in presence of -name you need to provide another mapping from
needed-.cmi names to corresponding-.ml names, and each build system
would need to come with its own description language for these "send
all foo/<bar>.ml to foo-<bar>.cmi" (which looks awfully like a
namespace description language)

On a rather orthogonal point, the proposal doesn't explicitly mention
the problem of internal module name conflicts. I assume that the
solution is "-name", meaning that the library authors must make sure
that the -name option they pass (or the source filename) will be
unique among all modules used by their downstream users. As it is an
important responsibility, I think this should be emphasized.

On Tue, Mar 12, 2013 at 12:32 PM, Yaron Minsky <yminsky at gmail.com> wrote:
> I have no objection to specifying that Core#Common should be connected
> to the Core package within the build system.  But it's important to us
> that namespace manipulations be observable by the programmer by
> reading the code.  If I understand correctly, Leo's proposal involves
> stashing that away in the build system, which undermines that goal.
>
> Another thing which may not be obvious is that one sometimes in the
> same file wants to access just Core.Std in some scopes in the file,
> and Async.Std in other scopes.  Full control of the namespace is
> important, and something we do at multiple scopes within a file.
> Being able to control this only at the file level, and only from
> within the build system, is a poor match for our needs.
>
> The fact that one should write:
>
> open Core.Std
> open Async.Std
>
> in a specific order does not strike me as a particular problem, and
> even if it were, the solution I think would not be to stuff it into
> the build system, but to build a single namespace that opened both
> Core and Async.
>
> If the proposal lands in the way Leo describes, I would think we would
> write a ppx extension that, for a certain whitelist of namespaces,
> would convert:
>
>    open namespace Core
>
> into
>
>    open namespace Core
>    open Core#Common
>
> Given that this is easy enough to do at the ppx level, I find it hard
> to see what difficulties would be raised by integrating this with the
> namespace system.  I understand that it feels mildly unsanitary
> because on the implementation end the two things are quite different,
> but from a user point of view, I think it's very much the right thing.
>
> y
>
>
> On Tue, Mar 12, 2013 at 6:57 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>>> Leo's model allows the build system to precisely set the order of default
>>> opens, and tools such as ocamlfind could support this just as they do
>>> include and link directives at the moment.  I know JS doesn't use
>>> ocamlfind, but the moral equivalent could inject the command-line
>>> directives very easily.
>>
>> To expand on what Anil said, under my proposed system the idea is to push the
>> problem of providing "pervasive" modules into the build or package system.
>>
>> For example, I would expect Core to provide some kind of package description
>> for OCamlFind or similar tool including something like (using made up
>> syntax):
>>
>>     path := ./core.mlpath
>>     open := Core#Common
>>
>> where "core.mlpath" is a search path description file.
>>
>> Then Async would include a description including something like:
>>
>>     path := ./async.mlpath
>>     path-depends := core
>>     open := Async#Common
>>     open-depends := core
>>
>> where "async.mlpath" is a search path description file that includes:
>>
>>     Core#Original#*: Core#*
>>     Core#Gc: Async#Gc
>>     Core#Condition: Async#Condition
>>
>> where "Gc" and "Condition" are the components of Core that Async
>> re-implements.
>>
>> This would mean that commands equivalent to any of the following would all
>> produce the correct default environment for using Async:
>>
>>     ocamlc -package async
>>     ocamlc -package async -package core
>>     ocamlc -package core -package async
>>
>> I think this is preferable to requiring all users of Async to start their
>> files with:
>>
>>     open Core.Std
>>     open Async.Std
>>
>> which is not something that a user might naturally assume was required.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Tue Mar 12 13:13:03 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 12 Mar 2013 14:13:03 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
Message-ID: <513F29DF.3000104@lexifi.com>

I support the idea of specifying implicit module opens on the 
command-line.  It is useful independently of the whole namespace 
discussion.  LexiFi has a similar local patch; this allows us to provide 
a "default environment" (basically, a DSL) for user code to be injected 
in the application on the fly (the application manages the compilation 
itself).  I expect this could also be useful to Ocisgen (I don't know if 
it automatically manages compilation of "user code", but if it does, it 
probably make sense to open automatically from infrastructure modules). 
  Of course, it is trivial to rewrite the source file to add an "open 
..." statement at the beginning, but I don't see why the official 
standard library should be the only one which can be used without any 
special directive in the source code.


-- Alain

From yminsky at janestreet.com  Tue Mar 12 13:29:50 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 09:29:50 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <513F29DF.3000104@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
Message-ID: <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>

On Tue, Mar 12, 2013 at 9:13 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> I support the idea of specifying implicit module opens on the command-line.
> It is useful independently of the whole namespace discussion.  LexiFi has a
> similar local patch; this allows us to provide a "default environment"
> (basically, a DSL) for user code to be injected in the application on the
> fly (the application manages the compilation itself).  I expect this could
> also be useful to Ocisgen (I don't know if it automatically manages
> compilation of "user code", but if it does, it probably make sense to open
> automatically from infrastructure modules).  Of course, it is trivial to
> rewrite the source file to add an "open ..." statement at the beginning, but
> I don't see why the official standard library should be the only one which
> can be used without any special directive in the source code.

I agree this would be useful for many uses --- the DSL case is a
particularly important one.  My only point is that it does not in my
mind obviate the need to have auto-opens attached to namespaces.

y

From yminsky at janestreet.com  Tue Mar 12 13:30:58 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 09:30:58 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
Message-ID: <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>

On Tue, Mar 12, 2013 at 9:29 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Tue, Mar 12, 2013 at 9:13 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> I support the idea of specifying implicit module opens on the command-line.
>> It is useful independently of the whole namespace discussion.  LexiFi has a
>> similar local patch; this allows us to provide a "default environment"
>> (basically, a DSL) for user code to be injected in the application on the
>> fly (the application manages the compilation itself).  I expect this could
>> also be useful to Ocisgen (I don't know if it automatically manages
>> compilation of "user code", but if it does, it probably make sense to open
>> automatically from infrastructure modules).  Of course, it is trivial to
>> rewrite the source file to add an "open ..." statement at the beginning, but
>> I don't see why the official standard library should be the only one which
>> can be used without any special directive in the source code.
>
> I agree this would be useful for many uses --- the DSL case is a
> particularly important one.  My only point is that it does not in my
> mind obviate the need to have auto-opens attached to namespaces.

Oh, and to say the obvious: you may well want to specify opens of
namespaces too (not just modules).  Indeed, if we support specifying
opens of namespaces, and namespaces can have auto-open modules, one
feature supports both use-cases.

From gabriel.scherer at gmail.com  Tue Mar 12 17:37:02 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 12 Mar 2013 18:37:02 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
 <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>
Message-ID: <CAPFanBFUes1BOb9F_11yTBK=-m8w_==7u2F8DX3=msmxoGYR+g@mail.gmail.com>

I think if auto-open is a hard requirement there is no good way around
moving to an ordered model as Didier explained would be needed.

In this semantics, a namespace an ordered mapping from names to
subnamespaces or compilation units, with either (you can choose two
different, equivalent representations)
- some of them marked "flat-access" (the star in the graphical representation)
- an additional stack of unnamed subnamespaces and modules to auto-open

This makes the semantics less simple and elegant, but there is no way
around it we fundamentally on "open" as having a side-effect on the
environment. Ordering matters.

I think name shadowing through "open" is a very bad feature to abuse.
There are some cases where I don't see how to do without it (in
particular the Float.(a + b / c) style of local overloading of infix
operators is a sorely needed feature), but I think that it is wrong to
use it as a general organization principle?, and that we should
instead promote ways to restrict the signature of a module or
namespace at open time (in particular substracting some names from it,
which cannot be expressed by the current signature language), and have
a stricter default policy regarding open shadowing. Ideally I'd like
something like Haskell's or Agda's "lazy conflict failure", that by
default raises an error as soon as an ambiguous/shadowed name is
*used* in the program.
Note that the rant in this paragraph is not in contradiction with
using an ordered semantics to support the user bases that abuse name
shadowing.

?: any unrestricted "open" of a third-party library makes the code in
scope not robust to extension of this library, shadowing names from
the outer context. To support upward-compatibility we should strive to
remain monotonic with respect to external code.

On Tue, Mar 12, 2013 at 2:30 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On Tue, Mar 12, 2013 at 9:29 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> On Tue, Mar 12, 2013 at 9:13 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>> I support the idea of specifying implicit module opens on the command-line.
>>> It is useful independently of the whole namespace discussion.  LexiFi has a
>>> similar local patch; this allows us to provide a "default environment"
>>> (basically, a DSL) for user code to be injected in the application on the
>>> fly (the application manages the compilation itself).  I expect this could
>>> also be useful to Ocisgen (I don't know if it automatically manages
>>> compilation of "user code", but if it does, it probably make sense to open
>>> automatically from infrastructure modules).  Of course, it is trivial to
>>> rewrite the source file to add an "open ..." statement at the beginning, but
>>> I don't see why the official standard library should be the only one which
>>> can be used without any special directive in the source code.
>>
>> I agree this would be useful for many uses --- the DSL case is a
>> particularly important one.  My only point is that it does not in my
>> mind obviate the need to have auto-opens attached to namespaces.
>
> Oh, and to say the obvious: you may well want to specify opens of
> namespaces too (not just modules).  Indeed, if we support specifying
> opens of namespaces, and namespaces can have auto-open modules, one
> feature supports both use-cases.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Tue Mar 12 18:41:56 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 12 Mar 2013 19:41:56 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
Message-ID: <513F76F4.1080800@lexifi.com>

On 3/12/2013 2:29 PM, Yaron Minsky wrote:
> I agree this would be useful for many uses --- the DSL case is a
> particularly important one.  My only point is that it does not in my
> mind obviate the need to have auto-opens attached to namespaces.

Agreed.  I believe those are two independent features.  I'm in favor of 
allowing auto-open on the command-line; and I don't really mind about 
having auto-opens attached to namespaces. That said, as Gabriel, I 
really don't like the idea of relying on shadowing to hide/redefine some 
declarations; and I'd actually like to have warnings when I use such 
ambiguous identifiers whose resolution depend on the ordering of opens 
(implicit or not).  (For the case of shadowing local identifiers, I'm 
less sure...)

Instead of hiding some identifiers from the stdlib, wouldn't it be more 
robust to compile all your code with -nostdlib and expose in Core.Std 
all identifiers which you allow to use?


Alain

From daniel.buenzli at erratique.ch  Tue Mar 12 19:01:33 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 12 Mar 2013 20:01:33 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CAPFanBFUes1BOb9F_11yTBK=-m8w_==7u2F8DX3=msmxoGYR+g@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
 <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>
 <CAPFanBFUes1BOb9F_11yTBK=-m8w_==7u2F8DX3=msmxoGYR+g@mail.gmail.com>
Message-ID: <C19EEF95310B49F7B3770AC308E6F3D0@erratique.ch>

Le mardi, 12 mars 2013 ? 18:37, Gabriel Scherer a ?crit :
> I think if auto-open is a hard requirement there is no good way around
> moving to an ordered model as Didier explained would be needed.
>  
> In this semantics, a namespace an ordered mapping from names to
> subnamespaces or compilation units, with either (you can choose two
> different, equivalent representations)
> - some of them marked "flat-access" (the star in the graphical representation)
> - an additional stack of unnamed subnamespaces and modules to auto-open

I don't really like the concept of auto-open which looks really ad-hoc to me. Did anybody investigate the idea of being:  

1) able to attach values and types to namespaces instead of just modules  
2) being able to open a namespace, bringing in scope the names it has attached to.  

Would it maybe help clear up some semantics issues ? For me 1) + 2) better matches the already existing concept of opening a module: this may bring new value, type, module names in your scope, but there's nothing that is "auto-opened".
  
And (aside from the problem of how this would be concretely expressed) would that actually satisfy the proponents of "auto-open"s. Or is there something else I miss in the concept of "auto-open" ?  

Daniel




From yminsky at janestreet.com  Tue Mar 12 20:28:09 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 16:28:09 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <513F76F4.1080800@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
 <513F76F4.1080800@lexifi.com>
Message-ID: <CACLX4jSLiJzXaM0w+kgc-SLZg79Uy2G3TNaNwLVmEB9Dj4uZaQ@mail.gmail.com>

On Tue, Mar 12, 2013 at 2:41 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 3/12/2013 2:29 PM, Yaron Minsky wrote:
>>
>> I agree this would be useful for many uses --- the DSL case is a
>> particularly important one.  My only point is that it does not in my
>> mind obviate the need to have auto-opens attached to namespaces.
>
>
> Agreed.  I believe those are two independent features.  I'm in favor of
> allowing auto-open on the command-line; and I don't really mind about having
> auto-opens attached to namespaces. That said, as Gabriel, I really don't
> like the idea of relying on shadowing to hide/redefine some declarations;
> and I'd actually like to have warnings when I use such ambiguous identifiers
> whose resolution depend on the ordering of opens (implicit or not).  (For
> the case of shadowing local identifiers, I'm less sure...)
>
> Instead of hiding some identifiers from the stdlib, wouldn't it be more
> robust to compile all your code with -nostdlib and expose in Core.Std all
> identifiers which you allow to use?

I agree that would be better for the stdlib case, and in some other
cases as well.  I suspect once we have namespaces, we may do just
what you propose.

But sometimes, shadowing is just what the doctor ordered.  For
example, I very much like the idiom of doing:


   let open Result.Monad_infix in
   ....

as a way of changing the monadic operators in force in some local
scope.  And I think there's something to be said for uniformity.
Shadowing is the order of the day in OCaml, and having namespaces
behave materially differently in this regard is going to be
surprising.

My primary point isn't that shadowing is good, though.  I do
understand the problems of shadowing, and having warnings for
shadowing seems reasonable.

My main point is that namespace control should by and large be
explicit in the source --- e.g., choosing whether or not you open the
Async#Common module in the build system is problematic, because it
hides this very salient semantic fact from the reader of the program.

y

From lpw25 at cam.ac.uk  Tue Mar 12 21:26:47 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 12 Mar 2013 21:26:47 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 (Yaron Minsky's message of "Tue, 12 Mar 2013 07:32:38 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
Message-ID: <87li9sl36w.fsf@study.localdomain>

> I have no objection to specifying that Core#Common should be connected
> to the Core package within the build system.  But it's important to us
> that namespace manipulations be observable by the programmer by
> reading the code.  If I understand correctly, Leo's proposal involves
> stashing that away in the build system, which undermines that goal.

To be clear, I'm only proposing to stash default opens in the build
system, as oposed to stashing them in the namespace system. I think this
makes sense since it is about controlling the initial naming environment
of a program, just like the search path.

> Another thing which may not be obvious is that one sometimes in the
> same file wants to access just Core.Std in some scopes in the file,
> and Async.Std in other scopes.  

Do any of the values or types opened automatically by Async conflict
with those opened automatically by Core? If there aren't then opening
the default modules globally shouldn't be a problem. 

> Full control of the namespace is
> important, and something we do at multiple scopes within a file.
> Being able to control this only at the file level, and only from
> within the build system, is a poor match for our needs.

You can always control it more explcitly by using Core#Common and
Async#Common directly to ensure that the right values are used in the
right scopes.

> If the proposal lands in the way Leo describes, I would think we would
> write a ppx extension that, for a certain whitelist of namespaces,
> would convert:
>
>    open namespace Core
>
> into
>
>    open namespace Core
>    open Core#Common

That seems reasonable. 

> Given that this is easy enough to do at the ppx level, I find it hard
> to see what difficulties would be raised by integrating this with the
> namespace system.  

I think the awkwardness is more related to how you treat things like:

   Core#Foo

where Foo might be a sub-module of Core#Common. 

From lpw25 at cam.ac.uk  Tue Mar 12 21:50:37 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 12 Mar 2013 21:50:37 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CAPFanBHb0CTwYufbYHNwtqqnW1qUATw1h7Y77pg3phke_VgWPQ@mail.gmail.com>
 (Gabriel Scherer's message of "Tue, 12 Mar 2013 13:39:24 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <CAPFanBHb0CTwYufbYHNwtqqnW1qUATw1h7Y77pg3phke_VgWPQ@mail.gmail.com>
Message-ID: <87fw00l236.fsf@study.localdomain>

Gabriel Scherer <gabriel.scherer at gmail.com> writes:

> One aspect of Leo's proposition that I found lacking is the absence of
> a precise framework that could explain the semantics of the proposed
> features and study their combination.

Certainly, before any final proposal, a precise semantics should be
worked out.

> - how to compose different "search path files" (by concatenation, I
> assume; I regret the absence of any conflict handling considerations)

Essentially, yes they are concatenated. In more detail:

When looking for a module, the compiler should work through each search
path and search path file (using the order they were given to the
compiler). It should work through each individual search path file
backwards, checking each mapping. If it finds a mapping for the module
of the form:

  Foo: "filename"

then it should use that filename. If it finds a mapping for the module
of the form:

  Foo: Bar

Then it should continue its search, but looking for Bar instead of Foo.

> - whether "-open" arguments would still be opened in absence of the
> corresponding "open namespace Core" (it looks like "yes", and that
> would be a semantics change wrt. the discussed flat-access feature)

Yes, the "-open" argument is basically unrelated to namespaces. It
simply specifies a module that should be opened in the initial
environment (just like Pervasives).

> - what happens when you write "open namespace Croe", making a typo

I think that the compiler should look in its search path for any
mappings like "Croe#Foo: 'foo.cmi'" or any files croe-foo.cmi. If it
doesn't find any then it should give an error or a warning.

> - whether each build system would have to implement its own way to
> describe which -name option are supposed to be passed to which files;
> it would be natural to pass them a description of the expected final
> compilation environment (mapping module names to compilation units),
> but in presence of -name you need to provide another mapping from
> needed-.cmi names to corresponding-.ml names, and each build system
> would need to come with its own description language for these "send
> all foo/<bar>.ml to foo-<bar>.cmi" (which looks awfully like a
> namespace description language)

I would have thought a simple variable or switch to indicate which
naming scheme was being used would suffice. I suppose some build systems
might like to support more complex name mappings using some kind of
description file. 

The important point is that if we devise some official naming
description that is in some way supported by the compiler then every
build system must be updated to support it. If we simply provide a
command-line argument then we allow the build systems to decide what and
how to support themselves.

> On a rather orthogonal point, the proposal doesn't explicitly mention
> the problem of internal module name conflicts. I assume that the
> solution is "-name", meaning that the library authors must make sure
> that the -name option they pass (or the source filename) will be
> unique among all modules used by their downstream users. As it is an
> important responsibility, I think this should be emphasized.

I agree that this is important, and should be made clear in any final
proposal.

> On Tue, Mar 12, 2013 at 12:32 PM, Yaron Minsky <yminsky at gmail.com> wrote:
>> I have no objection to specifying that Core#Common should be connected
>> to the Core package within the build system.  But it's important to us
>> that namespace manipulations be observable by the programmer by
>> reading the code.  If I understand correctly, Leo's proposal involves
>> stashing that away in the build system, which undermines that goal.
>>
>> Another thing which may not be obvious is that one sometimes in the
>> same file wants to access just Core.Std in some scopes in the file,
>> and Async.Std in other scopes.  Full control of the namespace is
>> important, and something we do at multiple scopes within a file.
>> Being able to control this only at the file level, and only from
>> within the build system, is a poor match for our needs.
>>
>> The fact that one should write:
>>
>> open Core.Std
>> open Async.Std
>>
>> in a specific order does not strike me as a particular problem, and
>> even if it were, the solution I think would not be to stuff it into
>> the build system, but to build a single namespace that opened both
>> Core and Async.
>>
>> If the proposal lands in the way Leo describes, I would think we would
>> write a ppx extension that, for a certain whitelist of namespaces,
>> would convert:
>>
>>    open namespace Core
>>
>> into
>>
>>    open namespace Core
>>    open Core#Common
>>
>> Given that this is easy enough to do at the ppx level, I find it hard
>> to see what difficulties would be raised by integrating this with the
>> namespace system.  I understand that it feels mildly unsanitary
>> because on the implementation end the two things are quite different,
>> but from a user point of view, I think it's very much the right thing.
>>
>> y
>>
>>
>> On Tue, Mar 12, 2013 at 6:57 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>>>> Leo's model allows the build system to precisely set the order of default
>>>> opens, and tools such as ocamlfind could support this just as they do
>>>> include and link directives at the moment.  I know JS doesn't use
>>>> ocamlfind, but the moral equivalent could inject the command-line
>>>> directives very easily.
>>>
>>> To expand on what Anil said, under my proposed system the idea is to push the
>>> problem of providing "pervasive" modules into the build or package system.
>>>
>>> For example, I would expect Core to provide some kind of package description
>>> for OCamlFind or similar tool including something like (using made up
>>> syntax):
>>>
>>>     path := ./core.mlpath
>>>     open := Core#Common
>>>
>>> where "core.mlpath" is a search path description file.
>>>
>>> Then Async would include a description including something like:
>>>
>>>     path := ./async.mlpath
>>>     path-depends := core
>>>     open := Async#Common
>>>     open-depends := core
>>>
>>> where "async.mlpath" is a search path description file that includes:
>>>
>>>     Core#Original#*: Core#*
>>>     Core#Gc: Async#Gc
>>>     Core#Condition: Async#Condition
>>>
>>> where "Gc" and "Condition" are the components of Core that Async
>>> re-implements.
>>>
>>> This would mean that commands equivalent to any of the following would all
>>> produce the correct default environment for using Async:
>>>
>>>     ocamlc -package async
>>>     ocamlc -package async -package core
>>>     ocamlc -package core -package async
>>>
>>> I think this is preferable to requiring all users of Async to start their
>>> files with:
>>>
>>>     open Core.Std
>>>     open Async.Std
>>>
>>> which is not something that a user might naturally assume was required.
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From thomas at ocamlpro.com  Tue Mar 12 22:17:30 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 12 Mar 2013 23:17:30 +0100
Subject: [ocaml-platform] OPAM 0.9.6 released
Message-ID: <854C6D14-01C1-4626-A261-CD0FE6101B4B@ocamlpro.com>

Hi,

I've just released 0.9.6. This version is a bug-fix version:
* Fix configuration for zsh users (feature introduced in 0.9.5)
* Fix loading of `~/.profile` when using dash (eg. in Debian/Ubuntu) (feature introduced in 0.9.5)
* Fix installation of packages with symbolic links (regression introduced in 0.9.5)

If I don't have news bad bugs tomorrow, I plan to release 1.0 on thursday.

The links:
* I've updated the x86_64 binaries for the binary installer: http://www.ocamlpro.com/pub/opam_installer.sh
* source archive: https://github.com/OCamlPro/opam/archive/latest.tar.gz
* full archive (eg. with all the dependencies): http://www.ocamlpro.com/pub/opam-full-latest.tar.gz

Best,
Thomas

From yminsky at janestreet.com  Tue Mar 12 22:19:10 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 12 Mar 2013 18:19:10 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87li9sl36w.fsf@study.localdomain>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
Message-ID: <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>

On Tue, Mar 12, 2013 at 5:26 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>> I have no objection to specifying that Core#Common should be connected
>> to the Core package within the build system.  But it's important to us
>> that namespace manipulations be observable by the programmer by
>> reading the code.  If I understand correctly, Leo's proposal involves
>> stashing that away in the build system, which undermines that goal.
>
> To be clear, I'm only proposing to stash default opens in the build
> system, as oposed to stashing them in the namespace system. I think this
> makes sense since it is about controlling the initial naming environment
> of a program, just like the search path.
>
>> Another thing which may not be obvious is that one sometimes in the
>> same file wants to access just Core.Std in some scopes in the file,
>> and Async.Std in other scopes.
>
> Do any of the values or types opened automatically by Async conflict
> with those opened automatically by Core? If there aren't then opening
> the default modules globally shouldn't be a problem.

There are conflicts.  Core exposes blocking operations, and Async.Std
hides them.

But shadowing and conflicts are a distraction.  The main issue is that
we want namespaces to be explicit in the source, and possibly
explicitly different in different sub-bits of the same file.  Having
namespace opening be a special-case thing that only happens on the
file level and that is hidden from the source3 just seems like an
unfortunate special-casing of a namespace manipulation tool (like let
and open) that should be available generally.

>> Full control of the namespace is
>> important, and something we do at multiple scopes within a file.
>> Being able to control this only at the file level, and only from
>> within the build system, is a poor match for our needs.
>
> You can always control it more explcitly by using Core#Common and
> Async#Common directly to ensure that the right values are used in the
> right scopes.

Just to be clear: we will not use auto-opens driven from the build
system.  They undermine our ability to understand the code from
reading the source.  So, yeah, we can open Async#Common explicitly,
but that means lots of files will start with

   open namespace Core
   open Core#Common

and others will start with

   open namespace Core
   open Core#Common
   open namespace Async
   open Async#Common

and yet others will start with

   open namespace Core
   open Core#Common
   open namespace Async
   open Async#Common
   open namespace My_framework_namespace
   open My_framework_namespace#Common

I'd rather these read like this:

   open namespace Core
   open namespace Async
   open namespace My_framework_namespace

>> If the proposal lands in the way Leo describes, I would think we would
>> write a ppx extension that, for a certain whitelist of namespaces,
>> would convert:
>>
>>    open namespace Core
>>
>> into
>>
>>    open namespace Core
>>    open Core#Common
>
> That seems reasonable.

It's reasonable, but fairly depressing.  I feel like we're proposing a
new namespace system that from the get-go doesn't satisfy the needs of
some of the major users, and needs to be hacked around to get it
there.

>> Given that this is easy enough to do at the ppx level, I find it hard
>> to see what difficulties would be raised by integrating this with the
>> namespace system.
>
> I think the awkwardness is more related to how you treat things like:
>
>    Core#Foo
>
> where Foo might be a sub-module of Core#Common.

Can you elaborate a bit?  Why is this case problematic?  I can kind of
see why this is weird, but other than making an explicit requirement
of having an ordered semantics (which to me seems like the right
answer anyway, since it's more in tune with how OCaml's other
namespace manipulation operators work), it seems fairly
straight-ahead.  But I'm probably missing something important.

y

From anil at recoil.org  Tue Mar 12 23:40:44 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 12 Mar 2013 23:40:44 +0000
Subject: [ocaml-platform] [opam-devel] OPAM 0.9.6 released
In-Reply-To: <854C6D14-01C1-4626-A261-CD0FE6101B4B@ocamlpro.com>
References: <854C6D14-01C1-4626-A261-CD0FE6101B4B@ocamlpro.com>
Message-ID: <9730DAB1-7F8B-4C1A-A2C7-595DB0B80ABC@recoil.org>

Homebrew pull req:
https://github.com/mxcl/homebrew/pull/18443

I've manually updated the Debian binary packages to 0.9.6 too.

-anil

On 12 Mar 2013, at 22:17, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:

> Hi,
> 
> I've just released 0.9.6. This version is a bug-fix version:
> * Fix configuration for zsh users (feature introduced in 0.9.5)
> * Fix loading of `~/.profile` when using dash (eg. in Debian/Ubuntu) (feature introduced in 0.9.5)
> * Fix installation of packages with symbolic links (regression introduced in 0.9.5)
> 
> If I don't have news bad bugs tomorrow, I plan to release 1.0 on thursday.
> 
> The links:
> * I've updated the x86_64 binaries for the binary installer: http://www.ocamlpro.com/pub/opam_installer.sh
> * source archive: https://github.com/OCamlPro/opam/archive/latest.tar.gz
> * full archive (eg. with all the dependencies): http://www.ocamlpro.com/pub/opam-full-latest.tar.gz
> 
> Best,
> Thomas
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel
> 


From mmatalka at gmail.com  Wed Mar 13 08:51:59 2013
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Wed, 13 Mar 2013 04:51:59 -0400
Subject: [ocaml-platform] [opam-devel] OPAM 0.9.6 released
In-Reply-To: <9730DAB1-7F8B-4C1A-A2C7-595DB0B80ABC@recoil.org> (Anil
 Madhavapeddy's message of "Tue, 12 Mar 2013 23:40:44 +0000")
References: <854C6D14-01C1-4626-A261-CD0FE6101B4B@ocamlpro.com>
 <9730DAB1-7F8B-4C1A-A2C7-595DB0B80ABC@recoil.org>
Message-ID: <87boanfzrk.fsf@li195-236.members.linode.com>

I am going to wait for 1.0 on Thursday before pushing to NixPkgs.

Anil Madhavapeddy <anil at recoil.org> writes:

> Homebrew pull req:
> https://github.com/mxcl/homebrew/pull/18443
>
> I've manually updated the Debian binary packages to 0.9.6 too.
>
> -anil
>
> On 12 Mar 2013, at 22:17, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:
>
>> Hi,
>> 
>> I've just released 0.9.6. This version is a bug-fix version:
>> * Fix configuration for zsh users (feature introduced in 0.9.5)
>> * Fix loading of `~/.profile` when using dash (eg. in Debian/Ubuntu) (feature introduced in 0.9.5)
>> * Fix installation of packages with symbolic links (regression introduced in 0.9.5)
>> 
>> If I don't have news bad bugs tomorrow, I plan to release 1.0 on thursday.
>> 
>> The links:
>> * I've updated the x86_64 binaries for the binary installer: http://www.ocamlpro.com/pub/opam_installer.sh
>> * source archive: https://github.com/OCamlPro/opam/archive/latest.tar.gz
>> * full archive (eg. with all the dependencies): http://www.ocamlpro.com/pub/opam-full-latest.tar.gz
>> 
>> Best,
>> Thomas
>> _______________________________________________
>> opam-devel mailing list
>> opam-devel at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/opam-devel
>> 
>
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel

From lpw25 at cam.ac.uk  Wed Mar 13 11:44:27 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 13 Mar 2013 11:44:27 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 (Yaron Minsky's message of "Tue, 12 Mar 2013 18:19:10 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
Message-ID: <87txof8qxw.fsf@kingston.cl.cam.ac.uk>

> Having
> namespace opening be a special-case thing that only happens on the
> file level and that is hidden from the source just seems like an
> unfortunate special-casing of a namespace manipulation tool (like let
> and open) that should be available generally.

Just to be clear I'm not proposing to have namespace opening at file
level, just the hidden opening of modules.

>>
>> I think the awkwardness is more related to how you treat things like:
>>
>>    Core#Foo
>>
>> where Foo might be a sub-module of Core#Common.
>
> Can you elaborate a bit?  Why is this case problematic?  I can kind of
> see why this is weird, but other than making an explicit requirement
> of having an ordered semantics (which to me seems like the right
> answer anyway, since it's more in tune with how OCaml's other
> namespace manipulation operators work), it seems fairly
> straight-ahead.  But I'm probably missing something important.

We should propbably stop calling this idea "auto-opening" because it is
really about allowing modules to be "included" within a namespace. This
is not a small change to the semantics. Without "auto-opens" namespaces
are simply a mechanism for controlling the names of compilation units,
with them they become a partial replacement modules: able to contain
values, types, exception, etc. Having two different features that
substantially overlap is normally a bad idea since it can cause a lot of
confusion.

Without auto-opens the namespace system is completely oblivious to the
actual contents of modules. With auto-opens the compiler must look
inside modules to work out whether "Core#Foo" refers to a member of Core
or a sub-module of one of its auto-opened modules.

Also, an ordered semantics is not for free. It makes having a
namespace defined in multiple places (as with users adding to existing
namespaces) much more fragile.

I think this is why people are reluctent to include automatically opened
modules in the namespaces proposal: it is quite a large change to the
semantics to handle a problem that is only likely to affect a few
libraries.

However, I think that I can see a way to avoid the problems of an ordered
semantics and possible "Core#Foo" conflicts.

The basic idea is to define a module named "Core" containing the values
that you would like automatically opened, as well as a namespace named
"Core". Then you provide some kind of opening operation that opens both
the namespace and the module named "Core".

This avoids the problem of ordering members of namespaces, since there
should only be one module called "Core". Technically there could be
multiple "Core" modules in the search path, but we simply use the first
one we find just like normal modules.

It also avoids the issue of "Core#Foo" conflicts, since "Core#Foo" must
refer to the "Foo" member of the "Core" namespace, while "Core.Foo"
would refer to the "Foo" sub-module of the "Core" module.

This could be added to a namespaces proposal in a number of ways. For
example we could allow modules named "Core#_" (or core-_.ml) to be
defined. These modules could be refered to directly in programs as
"Core". When the compiler encouters a "open namespace Core" construct it
first opens the "Core" namespace, and then it searches for a module
named "Core#_" and opens that as well.

Regards,

Leo

From alain.frisch at lexifi.com  Wed Mar 13 12:19:39 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Mar 2013 13:19:39 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51406EDB.6090603@lexifi.com>

On 03/13/2013 12:44 PM, Leo White wrote:
> Without auto-opens the namespace system is completely oblivious to the
> actual contents of modules. With auto-opens the compiler must look
> inside modules to work out whether "Core#Foo" refers to a member of Core
> or a sub-module of one of its auto-opened modules.

My understanding of Yaron's proposal was that automatically opened 
modules would only be opened when the namespace is, not in case of 
explicit qualification.

-- Alain

From alain.frisch at lexifi.com  Wed Mar 13 12:28:35 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Mar 2013 13:28:35 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
Message-ID: <514070F3.1040505@lexifi.com>

I'm still unconvinced about the need of hierarchical namespaces and the 
fact that they don't introduce extra complexity.

One point I'd like to understand better in Leo's proposal (and related 
ones) in particular is how the following code would be interpreted:


   open namespace N1
   open namespace N2
   open namespace N3

   module X = Foo

In which namespaces would module Foo be looked up for?  One possibility 
would be to look it in:

    N1
    N2
    N1#N2
    N3
    N1#N3
    N1#N2#N3

If this is the case, what would be the priority?

Another possibility would be to decide upon the "open namespace N2" what 
N2 refers to (a toplevel namespace or a sub-namespace of N1).  Is it the 
intention?  What would be the criterion?



Alain

From yminsky at janestreet.com  Wed Mar 13 12:56:18 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 13 Mar 2013 08:56:18 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>

On Wed, Mar 13, 2013 at 7:44 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> Having
>> namespace opening be a special-case thing that only happens on the
>> file level and that is hidden from the source just seems like an
>> unfortunate special-casing of a namespace manipulation tool (like let
>> and open) that should be available generally.
>
> Just to be clear I'm not proposing to have namespace opening at file
> level, just the hidden opening of modules.

Sorry, my terminology is perhaps a bit confusing.  The way I'm talking
about it, opening a module, opening a namespace and let bindings are
all manipulations of the program's name-space.  I guess that's a
terrible way of saying it.  Should I call those manipulations of the
naming enviroment?

In any case, I want to do as many environment manipulations in the
source as possible, and moving module opens to the build system seems
like a regression for our use-case.

>>>
>>> I think the awkwardness is more related to how you treat things like:
>>>
>>>    Core#Foo
>>>
>>> where Foo might be a sub-module of Core#Common.
>>
>> Can you elaborate a bit?  Why is this case problematic?  I can kind of
>> see why this is weird, but other than making an explicit requirement
>> of having an ordered semantics (which to me seems like the right
>> answer anyway, since it's more in tune with how OCaml's other
>> namespace manipulation operators work), it seems fairly
>> straight-ahead.  But I'm probably missing something important.
>
> We should propbably stop calling this idea "auto-opening" because it is
> really about allowing modules to be "included" within a namespace. This
> is not a small change to the semantics. Without "auto-opens" namespaces
> are simply a mechanism for controlling the names of compilation units,
> with them they become a partial replacement modules: able to contain
> values, types, exception, etc. Having two different features that
> substantially overlap is normally a bad idea since it can cause a lot of
> confusion.
>
> Without auto-opens the namespace system is completely oblivious to the
> actual contents of modules. With auto-opens the compiler must look
> inside modules to work out whether "Core#Foo" refers to a member of Core
> or a sub-module of one of its auto-opened modules.
>
> Also, an ordered semantics is not for free. It makes having a
> namespace defined in multiple places (as with users adding to existing
> namespaces) much more fragile.
>
> I think this is why people are reluctent to include automatically opened
> modules in the namespaces proposal: it is quite a large change to the
> semantics to handle a problem that is only likely to affect a few
> libraries.
>
> However, I think that I can see a way to avoid the problems of an ordered
> semantics and possible "Core#Foo" conflicts.
>
> The basic idea is to define a module named "Core" containing the values
> that you would like automatically opened, as well as a namespace named
> "Core". Then you provide some kind of opening operation that opens both
> the namespace and the module named "Core".
>
> This avoids the problem of ordering members of namespaces, since there
> should only be one module called "Core". Technically there could be
> multiple "Core" modules in the search path, but we simply use the first
> one we find just like normal modules.
>
> It also avoids the issue of "Core#Foo" conflicts, since "Core#Foo" must
> refer to the "Foo" member of the "Core" namespace, while "Core.Foo"
> would refer to the "Foo" sub-module of the "Core" module.
>
> This could be added to a namespaces proposal in a number of ways. For
> example we could allow modules named "Core#_" (or core-_.ml) to be
> defined. These modules could be refered to directly in programs as
> "Core". When the compiler encouters a "open namespace Core" construct it
> first opens the "Core" namespace, and then it searches for a module
> named "Core#_" and opens that as well.

I think what you've come around to is pretty similar to what I had
intended in the first place when I was saying "auto-open modules".  In
particular, you're proposing having a module "Core" associated with
the namespace "Core", and that the two are automatically opened
together.  My thought was to do something that is only slightly
different from that: to be able to associated a list of modules L with
a namespace N, such that opening N automatically opens L.  That seems
broadly speaking less confusing and more flexible, rather than relying
on name collisions.

I think this specifies the role of modules in "open namespace N" and
"let open namespace N in expr".  What seems to be in contention is the
semantics of N#M.  I think Leo and Alain are proposing that this be
limited to M being another module or namespace, and that it would
ignore the module opens.  I would have thought it more natural for N#M
to translate to "let open namespace N in M", so that M could be either
a module or a value, and could be present in the namespace N or in the
list of modules that is auto-opened with N.

What is the argument in favor of the semantic distinction between N#M
and "let open namespace N in M"?

y

From lpw25 at cam.ac.uk  Wed Mar 13 13:53:53 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 13 Mar 2013 13:53:53 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <514070F3.1040505@lexifi.com> (Alain Frisch's message of "Wed, 13
 Mar 2013 13:28:35 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com>
Message-ID: <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>

> One point I'd like to understand better in Leo's proposal (and related ones) in particular is how the following code
> would be interpreted:
>
>
>   open namespace N1
>   open namespace N2
>   open namespace N3
>
>   module X = Foo
>
> In which namespaces would module Foo be looked up for?  One possibility would be to look it in:
>
>    N1
>    N2
>    N1#N2
>    N3
>    N1#N3
>    N1#N2#N3
>
> If this is the case, what would be the priority?
>
> Another possibility would be to decide upon the "open namespace N2" what N2 refers to (a toplevel namespace or a
> sub-namespace of N1).  Is it the intention?  What would be the criterion?

I think that there are two sane semantics for "open namespace
N". Using the description language from Gabriel's proposal, they are:

   E' := E shallow merge right N

or 

   E' := E deep merge right N

where E is the old environment and E' is the new environment.

The first semantics corresponds to deciding upon the "open namespace N2"
which namespace N2 refers to and then only open that one. The second
semantics corresponds to searching for the "Foo" in your example by
looking for:

  N1#N2#N3#Foo
  N2#N3#Foo
  N1#N3#Foo
  N3#Foo
  N1#N2#Foo
  N2#Foo
  N1#Foo
  Foo

Note that modules must use the first semantics because their definitions
are closed, but since namespaces are open they are free to choose either
semantics.

I think that the best choice is to use the first semantics since it is
simpler. This is equivalent to closing the definitions of namespaces
within a particular source file. This makes sense since there is no real
benefit to leaving them open.

From jdimino at janestreet.com  Wed Mar 13 14:25:21 2013
From: jdimino at janestreet.com (Jeremie Dimino)
Date: Wed, 13 Mar 2013 14:25:21 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <C19EEF95310B49F7B3770AC308E6F3D0@erratique.ch>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
 <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>
 <CAPFanBFUes1BOb9F_11yTBK=-m8w_==7u2F8DX3=msmxoGYR+g@mail.gmail.com>
 <C19EEF95310B49F7B3770AC308E6F3D0@erratique.ch>
Message-ID: <CANhEzE7MuN+FttcpM-bUFNXfepa2AuMJhBCi89OifeFPHqHmKg@mail.gmail.com>

On Tue, Mar 12, 2013 at 7:01 PM, Daniel B?nzli
<daniel.buenzli at erratique.ch> wrote:
> I don't really like the concept of auto-open which looks really ad-hoc to me. Did anybody investigate the idea of being:
>
> 1) able to attach values and types to namespaces instead of just modules
> 2) being able to open a namespace, bringing in scope the names it has attached to.
>
> Would it maybe help clear up some semantics issues ? For me 1) + 2) better matches the already existing concept of opening a module: this may bring new value, type, module names in your scope, but there's nothing that is "auto-opened".
>
> And (aside from the problem of how this would be concretely expressed) would that actually satisfy the proponents of "auto-open"s. Or is there something else I miss in the concept of "auto-open" ?

It makes sense to me.  At least it seems to be what we want for core/async/...

Another advantage I can see over auto-opening modules is that as soon
as someone will use one of the function of a "main/std/common"
auto-opened module, it will pull the whole module with all its maybe
unused dependencies into the final executable.

From thelema314 at gmail.com  Wed Mar 13 14:36:47 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Wed, 13 Mar 2013 07:36:47 -0700
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CANhEzE7MuN+FttcpM-bUFNXfepa2AuMJhBCi89OifeFPHqHmKg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
 <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>
 <CAPFanBFUes1BOb9F_11yTBK=-m8w_==7u2F8DX3=msmxoGYR+g@mail.gmail.com>
 <C19EEF95310B49F7B3770AC308E6F3D0@erratique.ch>
 <CANhEzE7MuN+FttcpM-bUFNXfepa2AuMJhBCi89OifeFPHqHmKg@mail.gmail.com>
Message-ID: <CAL-jcAnNou=GPzcb_T3LhqijdXbGgE0_Y4BdaOkTB8Q9zxbZ7w@mail.gmail.com>

On Wed, Mar 13, 2013 at 7:25 AM, Jeremie Dimino <jdimino at janestreet.com>wrote:

> Another advantage I can see over auto-opening modules is that as soon
> as someone will use one of the function of a "main/std/common"
> auto-opened module, it will pull the whole module with all its maybe
> unused dependencies into the final executable.
>
> Won't any auto-opened modules (plus any compilation unit dependencies)
have to be already linked in even if not referenced from outside the
namespace?

E.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130313/5d6b8604/attachment-0001.html>

From jdimino at janestreet.com  Wed Mar 13 14:45:18 2013
From: jdimino at janestreet.com (Jeremie Dimino)
Date: Wed, 13 Mar 2013 14:45:18 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CAL-jcAnNou=GPzcb_T3LhqijdXbGgE0_Y4BdaOkTB8Q9zxbZ7w@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <513F29DF.3000104@lexifi.com>
 <CACLX4jTUUWUa5m-HwaoMtEwjxN-ZfHTGzB5qKu9C7cAAczM_kg@mail.gmail.com>
 <CACLX4jSi=b0qZkwEFX7ARvqr_KZSizMNSTfAsRhCiW7ysWogJg@mail.gmail.com>
 <CAPFanBFUes1BOb9F_11yTBK=-m8w_==7u2F8DX3=msmxoGYR+g@mail.gmail.com>
 <C19EEF95310B49F7B3770AC308E6F3D0@erratique.ch>
 <CANhEzE7MuN+FttcpM-bUFNXfepa2AuMJhBCi89OifeFPHqHmKg@mail.gmail.com>
 <CAL-jcAnNou=GPzcb_T3LhqijdXbGgE0_Y4BdaOkTB8Q9zxbZ7w@mail.gmail.com>
Message-ID: <CANhEzE5teE6qp8GWU02xn0Md_jbFQBnYkQ3+eTQW0Z+WAc_eDQ@mail.gmail.com>

On Wed, Mar 13, 2013 at 2:36 PM, Edgar Friendly <thelema314 at gmail.com> wrote:
> Won't any auto-opened modules (plus any compilation unit dependencies) have
> to be already linked in even if not referenced from outside the namespace?

I don't think so.  Unless I am missing something it would be the same
as for regular opens.  Opening a module does not add a reference to
its implementation if it is not used.

From alain.frisch at lexifi.com  Wed Mar 13 15:16:23 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Mar 2013 16:16:23 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51409847.6000205@lexifi.com>

On 03/13/2013 02:53 PM, Leo White wrote:
> I think that the best choice is to use the first semantics since it is
> simpler. This is equivalent to closing the definitions of namespaces
> within a particular source file. This makes sense since there is no real
> benefit to leaving them open.

The problem is that this potentially recreates part of the 
name-collision problem we are trying to avoid.  Doing:

open namespace Core
open namespace Xml

becomes risky because Core might decide to include an Xml sub-namespace 
in the future.  And once it does, one cannot access the toplevel Xml 
namespace anymore in the scope where Core is opened.

Are the limited benefits of hierarchical namespaces worth the trouble?


Also, I still don't see clearly how ocamldep (with and without modules) 
will work with your proposal.  In particular, will "ocamldep -modules" 
still have the property to not do any access to the filesystem except 
for the files explicitly passed to it?  I don't see how to preserve this 
important property without returning only bare module names (with no 
namespace information) as today.  Which means that the resolution logic 
(from module names to files) will have to be redone in the build system 
(as today), but this logic would be much more complex.  Moreover, since 
different namespaces can be opened in different contexts of the source 
code, this information should be reported by ocamldep as well (and 
interpreted by the build system).


Alain

From lpw25 at cam.ac.uk  Wed Mar 13 15:18:56 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 13 Mar 2013 15:18:56 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>
 (Yaron Minsky's message of "Wed, 13 Mar 2013 08:56:18 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>
Message-ID: <871ubj8h0f.fsf@kingston.cl.cam.ac.uk>

> I think what you've come around to is pretty similar to what I had
> intended in the first place when I was saying "auto-open modules".  In
> particular, you're proposing having a module "Core" associated with
> the namespace "Core", and that the two are automatically opened
> together.  My thought was to do something that is only slightly
> different from that: to be able to associated a list of modules L with
> a namespace N, such that opening N automatically opens L.  That seems
> broadly speaking less confusing and more flexible, rather than relying
> on name collisions.

The problem with having a list of auto-opens is that definitions in one
open may conflict with definitions in another open. This forces us to
give an ordering to the list. If the namespace is defined across
multiple parts of the search path then this ordering will be quite
fragile. The fragility of this ordering will probably go unnoticed until
there is a mysterious bug/compilation error. By relying on name
collisions, it makes it clear to people that there should only be a
single such module (just like other modules), and any conflict is likely
to become apparent immediately.

> I think this specifies the role of modules in "open namespace N" and
> "let open namespace N in expr".  What seems to be in contention is the
> semantics of N#M.  I think Leo and Alain are proposing that this be
> limited to M being another module or namespace, and that it would
> ignore the module opens.  I would have thought it more natural for N#M
> to translate to "let open namespace N in M", so that M could be either
> a module or a value, and could be present in the namespace N or in the
> list of modules that is auto-opened with N.
>
> What is the argument in favor of the semantic distinction between N#M
> and "let open namespace N in M"?

I'd think of it more as keeping the distinction between "N#M" and
"N.M". 

If you allow the M in N#M to be a value or type then namespaces go from
being a simple system for naming compilation units to being a partial
replacement for modules. This overlap will cause confusion, users should
never be in a position of wondering whether they should make something a
module or a namespace; it should be obvious from what that thing
contains.

Currently, given an environment and a module expression (e.g. N#M or
N.M) the compiler knows exactly where to find the module (e.g. as member
M of the N namespace). If you allow N#M to mean both a sub-module of an
auto-opened module in N and a member of N then the compiler must look
inside any auto-opened modules of N to figure out where the module
is. This also adds a dependency on the auto-opened module even if it
isn't used.

Another possible benefit of using name collisions to associate the
"Core" module with the "Core" namespace, is that it could be used to do
"auto-opens" as syntactic sugar. For example we could allow something
equivalent to:

  open Core   (* opens the Core module *)

  open namespace Core (* opens the Core namespace *)

  open namespace and module Core  
             (* equivalent to open namespace Core;; open Core *)

Obviously the syntax should be less verbose, but the point is that this
could make the "auto-open" explicit in the source while still keeping a
convenient syntax.

From alain.frisch at lexifi.com  Wed Mar 13 15:39:53 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Mar 2013 16:39:53 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>
Message-ID: <51409DC9.5070604@lexifi.com>

On 03/13/2013 01:56 PM, Yaron Minsky wrote:
> I would have thought it more natural for N#M
> to translate to "let open namespace N in M"

Well, "let open namespace N in M" does not force M to be found in 
namespace N (except if we get a nice warning for unused namespace opens 
and you turn it into an error :-)).

I was thinking that the "N#..." notation would not be allowed for 
accessing "toplevel values" in namespace N (i.e. values in module 
automatically opened in N).  Same for types.  By the way, note that "N # 
x" is already a syntactically valid (but always ill-typed) expression.
To be coherent with that, we should similarly disallow N#M to refer to a 
sub-module M of an automatically opened module.  I'd strongly prefer, 
even if automatic open is supported, that N#M can only refer to a 
compilation unit M.

So I wouldn't find it shocking if "open namespace N" brought some more 
values/types/modules in scope (by automatically opening some modules), 
but those components could not be accessing simply with the N#... 
notation (one would have to write something like N#Std.x).


Alain

From lpw25 at cam.ac.uk  Wed Mar 13 16:29:11 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 13 Mar 2013 16:29:11 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <51409847.6000205@lexifi.com> (Alain Frisch's message of "Wed, 13
 Mar 2013 16:16:23 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com>
Message-ID: <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>

> The problem is that this potentially recreates part of the name-collision problem we are trying to avoid.  Doing:
>
> open namespace Core
> open namespace Xml
>
> becomes risky because Core might decide to include an Xml sub-namespace in the future.  And once it does, one cannot
> access the toplevel Xml namespace anymore in the scope where Core is opened.

In the unlikely event that there is a conflict, a simple namespace alias
like:

   open namespace Xml as BaseXml
   [...]
   open namespace Core
   open namespace BaseXml

or a user-written search path file that doesn't define the Xml
sub-namespace of Core would solve the problem.

Of course, we could also just use the "deep" merging semantics for
open. It is possible that this may fit better with how people expect
namespaces to behave.

> Are the limited benefits of hierarchical namespaces worth the trouble?

I really don't think that the benefits of hierarchical namespaces are
that limited.

> Also, I still don't see clearly how ocamldep (with and without modules) will work with your proposal.  In particular,
> will "ocamldep -modules" still have the property to not do any access to the filesystem except for the files explicitly
> passed to it?  I don't see how to preserve this important property without returning only bare module names (with no
> namespace information) as today.  Which means that the resolution logic (from module names to files) will have to be
> redone in the build system (as today), but this logic would be much more complex.  Moreover, since different namespaces
> can be opened in different contexts of the source code, this information should be reported by ocamldep as well (and
> interpreted by the build system).

Actually, I think that "ocamldep -modules" has the property that it will
return the full module name of any possible dependency that the file
could have under any possible search path. By default I would leave this
as it is so that:

    open namespace Foo
    Bar.use

would produce "Foo#Bar" and "Bar" as possible dependencies. This is the
same as it currently does for sub-modules of opened modules.

As you say, it is then the job of the build system to translate these
names into possible file names using the search path. For directories in
the search path this remains simple -- just look for "foo-bar.ml". 

To assist with search path files I would add a new mode for ocamldep (or
maybe a new tool) to support the following call:

    ocamldep -lookup Foo#Bar foo.mlpath

This would one of the following:

- The filename for Foo#Bar found in the path file "foo.mlpath"

- The new module name that Foo#Bar is aliased to in the path file
  "foo.mlpath"

- Some indication that "foo.mlpath" says nothing of Foo#Bar.

This should be sufficient to allow build systems to continue to use
"ocamldep -modules" if they wish. However, a side-effect of adding
search path files is a dramatic improvement in the usability of regular
"ocamldep".

When given a search path file, rather than a directory, ocamldep does
not need to look in the actual directory to check for the existence of a
possible dependency. This means that it can base its dependency
calculation on the files that *will* exist rather than the files that
already do exist.

This means that a build system can produce a search path file containing
mappings for all the files that it could produce (this mapping can
also take account of uses of the "-name" argument). Then it would pass
this search path to ocamldep and get an accurate list of dependencies,
including those on files that have not yet been produced.

From alain.frisch at lexifi.com  Wed Mar 13 17:03:34 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Mar 2013 18:03:34 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com> <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5140B166.90903@lexifi.com>

On 03/13/2013 05:29 PM, Leo White wrote:
> In the unlikely event that there is a conflict, a simple namespace alias
> like:
>
>     open namespace Xml as BaseXml
>     [...]
>     open namespace Core
>     open namespace BaseXml
>
> or a user-written search path file that doesn't define the Xml
> sub-namespace of Core would solve the problem.

Since I've not seen a convincing case where hierarchical namespaces 
actually bring something useful, I maintain that the risk of having 
situations as above is sufficient to reject them.

If Core needs to be extendef with a Xml "sub-namespace", let's use the 
flat name "Core_Xml".  If people want to open them, they have "open 
namespace Core_xml".  If they need to occasionally access components of 
this namespace, they can write "Core_xml#Parser.run".  If they don't 
want to open it but still is use frequently, they can alias it "open 
namespace Core_xml as Xml".  (Btw, I find it ugly to use "open" for an 
aliasing feature.  We need a better syntax!)


> Actually, I think that "ocamldep -modules" has the property that it will
> return the full module name of any possible dependency that the file
> could have under any possible search path. By default I would leave this
> as it is so that:
>
>      open namespace Foo
>      Bar.use
>
> would produce "Foo#Bar" and "Bar" as possible dependencies. This is the
> same as it currently does for sub-modules of opened modules.

What about:

  open namespace M1
  open namespace M2
  Bar.use

?

Even with the "shallow" semantics, "ocamldep -modules" cannot know if 
there is (or will be) a namespace M2.  So do we get "M1#Bar", "M2#Bar", 
"M1#M2#Bar" and "Bar" as possible dependencies?   The size of the output 
grows exponentially in the number of "open namespace"!



Alain

From lpw25 at cam.ac.uk  Thu Mar 14 10:02:39 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 14 Mar 2013 10:02:39 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <5140B166.90903@lexifi.com> (Alain Frisch's message of "Wed, 13
 Mar 2013 18:03:34 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com> <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>
 <5140B166.90903@lexifi.com>
Message-ID: <87ip4uti2o.fsf@kingston.cl.cam.ac.uk>

> Since I've not seen a convincing case where hierarchical namespaces
> actually bring something useful, 

http://www.lpw25.net/2013/03/10/ocaml-namespaces.html#Flat+or+hierarchical?

> I maintain that the
> risk of having situations as above is sufficient to reject them.

If we use the "deep merging" semantics then that situation can't even
happen.

>> Actually, I think that "ocamldep -modules" has the property that it will
>> return the full module name of any possible dependency that the file
>> could have under any possible search path. By default I would leave this
>> as it is so that:
>>
>>      open namespace Foo
>>      Bar.use
>>
>> would produce "Foo#Bar" and "Bar" as possible dependencies. This is the
>> same as it currently does for sub-modules of opened modules.
>
> What about:
>
>  open namespace M1
>  open namespace M2
>  Bar.use
>
> ?
>
> Even with the "shallow" semantics, "ocamldep -modules" cannot know if there is (or will be) a namespace M2.  So do we
> get "M1#Bar", "M2#Bar", "M1#M2#Bar" and "Bar" as possible dependencies?   The size of the output grows exponentially in
> the number of "open namespace"!

Yes but, as I thought was clear in my last post, the correct solution is
to use regular ocamldep with search path files.

We could also add support for search path files to "ocamldep -modules"
but it seems against of the spirit of it. Or we could have "ocamldep
-modules" only produce module names, and have "ocamldep -namespaces"
give a list of namespaces used. Or we could have "ocamldep -modules"
produce something like "(M1,M2)Bar" for your example.

From xavier.clerc at inria.fr  Thu Mar 14 10:14:40 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Thu, 14 Mar 2013 11:14:40 +0100 (CET)
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87ip4uti2o.fsf@kingston.cl.cam.ac.uk>
Message-ID: <916887658.5897610.1363256080681.JavaMail.root@inria.fr>

----- Mail original -----

(...)

> > What about:
> >
> >  open namespace M1
> >  open namespace M2
> >  Bar.use
> >
> > ?
> >
> > Even with the "shallow" semantics, "ocamldep -modules" cannot know
> > if there is (or will be) a namespace M2.  So do we
> > get "M1#Bar", "M2#Bar", "M1#M2#Bar" and "Bar" as possible
> > dependencies?   The size of the output grows exponentially in
> > the number of "open namespace"!

Just for the record, Java has hierarchical namespace, but opening
one package does not give accesses to its sub-packages.

However, I acknowledge that having "open" for both modules and
namespaces with such a difference would be quite a problem.
Maybe we could have "open" for modules and "import" for namespaces
for example?

With such a semantics, the number of possible dependencies
is kept linear in the number of "import" directives.


Xavier

From yminsky at janestreet.com  Thu Mar 14 10:46:17 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 14 Mar 2013 06:46:17 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <51409DC9.5070604@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>
 <51409DC9.5070604@lexifi.com>
Message-ID: <CACLX4jTDRkejQz2AEsbcpNBkgvS2KLap6Sk_U0Go0iChr=rkLQ@mail.gmail.com>

On Wed, Mar 13, 2013 at 11:39 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/13/2013 01:56 PM, Yaron Minsky wrote:
>>
>> I would have thought it more natural for N#M
>> to translate to "let open namespace N in M"
>
> Well, "let open namespace N in M" does not force M to be found in namespace
> N (except if we get a nice warning for unused namespace opens and you turn
> it into an error :-)).

You're clearly right.

> I was thinking that the "N#..." notation would not be allowed for accessing
> "toplevel values" in namespace N (i.e. values in module automatically opened
> in N).  Same for types.  By the way, note that "N # x" is already a
> syntactically valid (but always ill-typed) expression.
> To be coherent with that, we should similarly disallow N#M to refer to a
> sub-module M of an automatically opened module.  I'd strongly prefer, even
> if automatic open is supported, that N#M can only refer to a compilation
> unit M.

I don't fully understand why you want N#M to refer only to compilation
units --- I suspect it's connected to implementation issues around
things like ocamldep --- but it's livable.  In this case, as a
namespace author I would make sure that any auto-opened modules
contained no sub-modules, to avoid confusion on that point.

> So I wouldn't find it shocking if "open namespace N" brought some more
> values/types/modules in scope (by automatically opening some modules), but
> those components could not be accessing simply with the N#... notation (one
> would have to write something like N#Std.x).

y

From anil at recoil.org  Thu Mar 14 10:48:57 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 14 Mar 2013 10:48:57 +0000
Subject: [ocaml-platform] Benchmarking in OPAM
In-Reply-To: <CAPFanBEDMRZg9vxS3YXufmVaeymVLO8eABTvMzK60o4kb1XM8Q@mail.gmail.com>
References: <CAPFanBHx2=BegghyiPbcY39Tr2pXVASNtoNOsZoZKcCHt-0SiA@mail.gmail.com>
 <wfppz7cb0k.fsf@gmail.com>
 <CAPFanBGJkzuP=GnGywPSF152+3mC-M_Dg6UTaE=3TKRdReJjgQ@mail.gmail.com>
 <8ABBBECB-F78E-491F-BBC0-6C524F3BBFEA@recoil.org>
 <CAPFanBEDMRZg9vxS3YXufmVaeymVLO8eABTvMzK60o4kb1XM8Q@mail.gmail.com>
Message-ID: <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>


[+CC platform@]
On 10 Mar 2013, at 21:45, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> More precisely, what I've been trying to do this week-end is to find
> the right structure to use the benchmarks that I received from users
> after
>  http://gallium.inria.fr/~scherer/gagallium/we-need-a-representative-benchmark-suite/
> 
> I worked on this a bit yesterday with Simon Castellan and Fr?d?ric
> Bour, and for now we decided to reuse code from Edwin T?r?k, that
> itself relies on Edgar Friendly Bench's library, that has some
> similarities with Criterion -- I'm not really familiar with the
> internals of either of those three libs, but they try to impress users
> with statistics, confidence internal etc.
> 
> The focus is to be able to get quick yet reliable feedback on the
> interest of some compiler optimization among representative OCaml
> programs. That is fairly different from the classic use cases of
> continuous integration (CI) of improving the libraries themselves,
> monitoring correctness (through test batteries) and portability among
> architectures.
> 
> To get lots of short-lived opam compiler switches corresponding to SVN
> or git development branches of the compiler (to be reinstalled each
> time you make a change to the branch, that is quite often), I've
> tested the use of "preinstalled" but got some feedback from Thomas on
> better ways to do it (
> https://github.com/OCamlPro/opam/pull/519#issuecomment-14682101 ),
> using secret OPAM features. To get quick feedback it is rather
> important to minimize a package's dependencies.
> 
> Finally, we realized that we really need two distinct kinds of
> benchmarking software:
> - one "benchmark library" that is solely meant to run performance
> tests and return the results (will be used by and linked with the
> benchmark programs, so recompiled at each compiler change, so should
> be rather light if possible)
> - one "benchmark manager" that compares results between different
> runs, plots nice graphics, stores results over time or send them to a
> CI server, format them in XML or what not. This one is run from the
> system compiler and can have arbitrarily large feature sets and
> dependencies.
> 
> I believe a similar split would be meaningful for unit testing as
> well. Of course, if you're considering daily automated large-scale
> package building and checking, instead of tight feedback loops, it is
> much less compelling to force a split, you can just bundle the two
> kind of features under the same package.

The split you describe is generally good discipline, as it encourages
library authors to encode more small benchmarks that can be called from
larger tools.

The benchmark manager is definitely something we want to have in the
OPAM hosted test system.  It's very difficult to get representative
benchmark results without a good mix of architectures and operating
systems, and we're going to pepper lots of odd setups into OPAM (and
eventually have the facility to crowdsource other people's machines
into the build pool, to make it easier to contribute resources).

So for the moment, focussing on the benchmark library would seem to
be the best thing to do: I've not really used any of them, and would
be interested in knowing what I ought to adopt for (e.g.) the Mirage
protocol libraries.  Once we have that in place, the OPAM test integration
should be much more straightforward.

-anil

PS: We've been building up interesting IPC test data for about a year
now: http://www.cl.cam.ac.uk/research/srg/netos/ipc-bench/results.html
and obtaining results from different architectures has been consistently
puzzling and illuminating at the same time.  See my FOSDEM talk on how
complex IO can be: http://anil.recoil.org/talks/fosdem-io-2012.pdf

From alain.frisch at lexifi.com  Thu Mar 14 10:55:00 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 14 Mar 2013 11:55:00 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <87ip4uti2o.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com> <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>
 <5140B166.90903@lexifi.com> <87ip4uti2o.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5141AC84.3040803@lexifi.com>

On 03/14/2013 11:02 AM, Leo White wrote:
> http://www.lpw25.net/2013/03/10/ocaml-namespaces.html#Flat+or+hierarchical?

The only use case you mention in this document is "A library may wish to 
provide multiple versions of some of its components".  I still don't see 
why this use case is better treated with hierarchical namespaces than 
flat ones.  One could write Core_testing.  Or one could also support # 
as a valid character in namespace names (i.e. accept Core#Testing 
directly).  The benefit of a hierarchical system would be to support 
writing:

   open namespace Core
   ...
   .... Testing#Mutex ...

With flat namespace, one can do (assuming '#' is a valid character in 
namespace names):

   open namespace Core#Testing
   ...
   .... Mutex ...

or:

   using namespace Core#Testing as Testing
   ...
   .... Testing#Mutex ...


The semantics is simpler to define with flat namespaces and it makes
a qualified reference (Foo#M) very explicit, without having to know 
which namespaces exist, without having to read external files, etc.  You 
only have to look for "using namespace ... as ..." statements in scope 
to know which actual namespace Foo refers to, and ocamldep can trivially 
do it.  In other words, ocamldep can return an exact result (a pair of 
fully resolved namespace name + module name) for qualified references, 
without looking at the file system (for "namespace through filenames") 
or parsing "search path files".  For unqualified references, it needs to 
report for each module name the list of possible (fully resolved) 
namespaces (i.e. the "open namespace" statements in scope).  Again, this 
can be done just by looking at the source code.

I'm thus not convinced by your argument that "none of the systems of 
namespaces that have been proposed have any additional cost for 
supporting hierarchical namespaces".


Having a new mode where ocamldep would do the resolution to actual file 
names (based on search path files) is nice as well, but my understanding 
is that:

   - This does not work with "simple namespaces through filenames" (in 
case of generated source files).

   - This does not play well with the idea of generating the search path 
files themselves during the build (or you need explicit staging).  In my 
experience, such limitations always end up creating tedious problems in 
large code base, even if they look quite minor at first.


Alain

From yminsky at janestreet.com  Thu Mar 14 10:55:24 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 14 Mar 2013 06:55:24 -0400
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <5140B166.90903@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com>
 <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com>
 <87ppz36z6w.fsf@kingston.cl.cam.ac.uk> <5140B166.90903@lexifi.com>
Message-ID: <CACLX4jTTeXgLtD_J552_Jx+HavcH43pqeTNr8uX8L9Fc92Ljig@mail.gmail.com>

On Wed, Mar 13, 2013 at 1:03 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/13/2013 05:29 PM, Leo White wrote:
>>
>> In the unlikely event that there is a conflict, a simple namespace alias
>> like:
>>
>>     open namespace Xml as BaseXml
>>     [...]
>>     open namespace Core
>>     open namespace BaseXml
>>
>> or a user-written search path file that doesn't define the Xml
>> sub-namespace of Core would solve the problem.
>
>
> Since I've not seen a convincing case where hierarchical namespaces actually
> bring something useful, I maintain that the risk of having situations as
> above is sufficient to reject them.
>
> If Core needs to be extendef with a Xml "sub-namespace", let's use the flat
> name "Core_Xml".  If people want to open them, they have "open namespace
> Core_xml".  If they need to occasionally access components of this
> namespace, they can write "Core_xml#Parser.run".  If they don't want to open
> it but still is use frequently, they can alias it "open namespace Core_xml
> as Xml".

I agree that I see no big advantage to hierarchical namespaces.  But
most of the problems that show up here seem to be related to trying to
keep an unordered semantics, which to me seems like a mistake.

OCaml's environment-manipulating operations by and large have an
ordered semantics, and I think it's a mistake to make namespaces
different.  People seem very afraid of shadowning, but OCaml already
has shadowing in the module language, and our experience as very heavy
users of the module system is that judicious use of shadowing is very
useful.  For example, the ability to extend modules using `include`
and shadowing is highly convenient, i.e.:

    include List
    let map ~f x = ...

We'll combine this shadowing with a similar version at the package
level, by writing this:

   open Core.Std
   open Core_extended.Std

where Core_extended shadows Core.Std.List with Core_extended.Std.List,
where the latter is an extended version of the former.

My basic feeling is that ordering and shadowing is a feature, not a
bug.

To be clear: opens have serious downsides.  They should be legal, but
rare.  But when they do show up, their semantics should be ordered.

> (Btw, I find it ugly to use "open" for an aliasing feature.  We
> need a better syntax!)

Indeed!

>> Actually, I think that "ocamldep -modules" has the property that it will
>> return the full module name of any possible dependency that the file
>> could have under any possible search path. By default I would leave this
>> as it is so that:
>>
>>      open namespace Foo
>>      Bar.use
>>
>> would produce "Foo#Bar" and "Bar" as possible dependencies. This is the
>> same as it currently does for sub-modules of opened modules.
>
>
> What about:
>
>  open namespace M1
>  open namespace M2
>  Bar.use
>
> ?
>
> Even with the "shallow" semantics, "ocamldep -modules" cannot know if there
> is (or will be) a namespace M2.  So do we get "M1#Bar", "M2#Bar",
> "M1#M2#Bar" and "Bar" as possible dependencies?   The size of the output
> grows exponentially in the number of "open namespace"!
>
>
>
> Alain
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Thu Mar 14 11:17:11 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 14 Mar 2013 12:17:11 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <CACLX4jTDRkejQz2AEsbcpNBkgvS2KLap6Sk_U0Go0iChr=rkLQ@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <20130312095519.GG29372@dark.recoil.org>
 <87k3pc997o.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJOVopdM3s5Wpor3dJz0L8riLh2QBjZcrNmL60ciS5EBg@mail.gmail.com>
 <87li9sl36w.fsf@study.localdomain>
 <CACLX4jQz53MQPpGOR_NKPGaggdENa57NDSQR98-i3=LpVOqA4g@mail.gmail.com>
 <87txof8qxw.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jQO=uOx=t9GA-zBRP53hMLcSTCrGgK7Wy_C6RZWgORmqQ@mail.gmail.com>
 <51409DC9.5070604@lexifi.com>
 <CACLX4jTDRkejQz2AEsbcpNBkgvS2KLap6Sk_U0Go0iChr=rkLQ@mail.gmail.com>
Message-ID: <5141B1B7.9090208@lexifi.com>

On 03/14/2013 11:46 AM, Yaron Minsky wrote:
> I don't fully understand why you want N#M to refer only to compilation
> units --- I suspect it's connected to implementation issues around
> things like ocamldep

That's one reason, but more fundamentally: namespaces are attached to 
compilation unit (you can define what the namespace of a compilation 
unit is) not to inner modules (you cannot put an inner module in a 
namespace) or other components of units (there is no namespace attached 
to a type or value declaration).  And it seems quite natural to me that 
the notation N#M resolves to something whose local name is M and whose 
namespace is N.  I think it's good to keep the qualified syntax very 
explicit and simple.  I'm less shocked if "open namespace N" brings in 
scope other modules and values by automatically opening some modules 
declared as "auto-open" in the definition of N.

In a previous post, I've mentioned a different approach of attaching 
namespaces not (only) to compilation units, but also to all declared 
components (i.e. make the "namespace" a property of local names).  This 
would allow writing things like:

module Baz#M = struct
   let Foo#x = 3

   let Bar#x = 2

   let Baz#x =
     let open namespace Foo in
     x + Bar#x
end

let a = Baz#M.Baz#x + Baz#M.Foo#x
let b = let open namespace Baz in M.x + M.Foo#x

(with some syntax to automatically put all declarations under a given 
scope into a given namespace)

What I like with this approach is that it makes namespaces appear more 
orthogonal to the module system (but since we would also need to attach 
namespace to compilation units, this does not solve any problem by 
itself).  And I don't see any practical use for this system either!


-- Alain

From lpw25 at cam.ac.uk  Thu Mar 14 11:47:00 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 14 Mar 2013 11:47:00 +0000
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <5141AC84.3040803@lexifi.com> (Alain Frisch's message of "Thu, 14
 Mar 2013 11:55:00 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com> <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>
 <5140B166.90903@lexifi.com> <87ip4uti2o.fsf@kingston.cl.cam.ac.uk>
 <5141AC84.3040803@lexifi.com>
Message-ID: <871ubitd8r.fsf@kingston.cl.cam.ac.uk>

> The semantics is simpler to define with flat namespaces and it makes
> a qualified reference (Foo#M) very explicit, without having to know which namespaces exist, without having to read
> external files, etc.  You only have to look for "using namespace ... as ..." statements in scope to know which actual
> namespace Foo refers to, and ocamldep can trivially do it.

Actually, you would still need to look in search path files for
aliases. This would be true for any proposal that allows users to create
their own namespaces from existing modules.

>  In other words, ocamldep can return an exact result (a pair
> of fully resolved namespace name + module name) for qualified references, without looking at the file system (for
> "namespace through filenames") or parsing "search path files".

It would still need to parse search path files.

>  For unqualified references, it needs to report for each
> module name the list of possible (fully resolved) namespaces (i.e. the "open namespace" statements in scope).  Again,
> this can be done just by looking at the source code.

It could do that with hierarchical namespaces, there would just be more
of them. Or it could use a different output format, and then there would
be the same amount of output for flat or hierarchical namespaces.

> Having a new mode where ocamldep would do the resolution to actual file names (based on search path files) is nice as
> well, but my understanding is that:
>
>   - This does not work with "simple namespaces through filenames" (in case of generated source files).

The idea is that the build system would produce a search path file
including mappings for these generated files. So it would work perfectly
fine for generated files that specify their namespace through their
filename. It would also work for generated files whose name will be
defined by a "-name" argument.

>   - This does not play well with the idea of generating the search path files themselves during the build (or you need
> explicit staging).  In my experience, such limitations always end up creating tedious problems in large code base, even
> if they look quite minor at first.

I'm talking about generating a search path file that is just passed to
ocamldep. So rather than running "ocamldep -modules" and then using
information from the build system to interpret it, that information is
encoded as a search path file, and regular ocamldep does the work for
you.

From alain.frisch at lexifi.com  Thu Mar 14 12:12:04 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 14 Mar 2013 13:12:04 +0100
Subject: [ocaml-platform] Followup to Leo's proposal
In-Reply-To: <871ubitd8r.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <514070F3.1040505@lexifi.com> <87hakf8ky6.fsf@kingston.cl.cam.ac.uk>
 <51409847.6000205@lexifi.com> <87ppz36z6w.fsf@kingston.cl.cam.ac.uk>
 <5140B166.90903@lexifi.com> <87ip4uti2o.fsf@kingston.cl.cam.ac.uk>
 <5141AC84.3040803@lexifi.com> <871ubitd8r.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5141BE94.3060303@lexifi.com>

On 03/14/2013 12:47 PM, Leo White wrote:
> Actually, you would still need to look in search path files for
> aliases. This would be true for any proposal that allows users to create
> their own namespaces from existing modules.

I don't understand, because I don't see why aliases are required to let 
users create their own namespaces.  It is just a convenience, and since 
I assume that only advanced users will tweak "default" namespaces, I 
don't think we need this aliasing feature.  (Or we could provide a tool 
to resolve aliases... Already an example of generated search path file!)

>>   In other words, ocamldep can return an exact result (a pair
>> of fully resolved namespace name + module name) for qualified references, without looking at the file system (for
>> "namespace through filenames") or parsing "search path files".
>
> It would still need to parse search path files.

If we remove aliasing from search path files, this is no longer the 
case.  Since search path files are likely to be parsed by build systems 
anyway, it's better to leave their semantics as simple as possible.


-- Alain

From amc79 at cam.ac.uk  Thu Mar 14 16:53:47 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Thu, 14 Mar 2013 16:53:47 +0000
Subject: [ocaml-platform] Wireframe demo of OCaml.og
Message-ID: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>

Dear all,

I've been working on putting together wireframes to demonstrate aspects of the design and functionality we'd like to introduce into the OCaml.org website.  Today, I published a blog post summarising this work, which includes screencasts and a link to a clickable demo you can play with.

http://amirchaudhry.com/wireframe-demos-for-ocamlorg

I'd be keen to know what you think so please send any feedback via the infrastructure mailing list (infrastructure at lists.ocaml.org).

Best wishes,
Amir

From sebastien.mondet at gmail.com  Thu Mar 14 18:45:08 2013
From: sebastien.mondet at gmail.com (Sebastien Mondet)
Date: Thu, 14 Mar 2013 14:45:08 -0400
Subject: [ocaml-platform] [ocaml-infra] Wireframe demo of OCaml.og
In-Reply-To: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
Message-ID: <CALScVYniQw9822rt1KR4-WHC2atkBddjVTZPFYH59dOeK6oXUQ@mail.gmail.com>

Hi

Very impressive work!!

One question:
even without fonts and colors, the wireframes are supposed to be about page
layout, right?
On the videos, the pseudo-browser is higher than wider while most people
seem to have nowadays w > h.
Is there a way to view how the layout is intended to adapt to other "page
geometries" (or to mobile-browsers by the way)? or is it too early in the
design?


Thanks & Cheers
Seb








On Thu, Mar 14, 2013 at 12:53 PM, Amir Chaudhry <amc79 at cam.ac.uk> wrote:

> Dear all,
>
> I've been working on putting together wireframes to demonstrate aspects of
> the design and functionality we'd like to introduce into the OCaml.org
> website.  Today, I published a blog post summarising this work, which
> includes screencasts and a link to a clickable demo you can play with.
>
> http://amirchaudhry.com/wireframe-demos-for-ocamlorg
>
> I'd be keen to know what you think so please send any feedback via the
> infrastructure mailing list (infrastructure at lists.ocaml.org).
>
> Best wishes,
> Amir
> _______________________________________________
> Infrastructure mailing list
> Infrastructure at lists.ocaml.org
> http://lists.ocaml.org/listinfo/infrastructure
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130314/d8c68966/attachment.html>

From thomas at ocamlpro.com  Thu Mar 14 20:28:32 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Thu, 14 Mar 2013 21:28:32 +0100
Subject: [ocaml-platform] OPAM 1.0.0 released !
Message-ID: <999F571F-57A2-46F0-9DA8-83DC7026363E@ocamlpro.com>

I nm *very* happy to announce the first official release of OPAM!

Many of you already know and use OPAM so I won't be long. Please read http://www.ocamlpro.com/blog/2013/01/17/opam-beta.html for a longer description.

1.0.0 fixes many bugs and add few new features to the previously announced beta-release.

The most visible new feature, which should be useful for beginners with OCaml and OPAM,  is an auto-configuration tool. This tool easily enables all the features of OPAM (auto-completion, fix the loading of scripts for the toplevel, opam-switch-eval alias, etc). This tool runs interactively on each `opam init` invocation. If you don't like OPAM to change your configuration files, use `opam init --no-setup`. If you trust the tool blindly,  use `opam init --auto-setup`. You can later review the setup by doing `opam config setup --list` and call the tool again using `opam config setup` (and you can of course manually edit your ~/.profile (or ~/.zshrc for zsh users), ~/.ocamlinit and ~/.opam/opam-init/*).

Please report:
- Bug reports and feature requests for the OPAM tool: http://github.com/OCamlPro/opam/issues
- Packaging issues or requests for a new package: http://github.com/OCamlPro/opam-repository/issues
- General queries to: http://lists.ocaml.org/listinfo/platform
- More specific queries about the internals of OPAM to: http://lists.ocaml.org/listinfo/opam-devel

On behalf on the OPAM team,
Thomas

=== Install ===

Packages for Debian and OSX (at least homebrew) should follow shortly and I'm looking for volunteers to create and maintain rpm packages. The binary installer is up-to-date for Linux and Darwin 64-bit architectures, the 32-bit version for Linux should arrive shortly.

If you want to build from sources, the full archive (including dependencies) is available here:
   
   http://www.ocamlpro.com/pub/opam-full-latest.tar.gz

=== Upgrade ===

If you are upgrading from 0.9.* you won't  have anything special to do apart installing the new binary. You can then update your package metadata by running `opam update`. If you want to use the auto-setup feature, remove the "eval `opam config env` line you have previously added in your ~/.profile and run `opam config setup --all`.

So everything should be fine. But you never know ... so if something goes horribly wrong in the upgrade process (of if your are upgrading from an old version of OPAM) you can still trash your ~/.opam, manually remove what OPAM added in  your ~/.profile (~/.zshrc for zsh users) and ~/.ocamlinit, and start again from scratch. 

=== Random stats ===

Great success on github. Thanks everybody for the great contributions!

https://github.com/OCamlPro/opam: +2000 commits, 26 contributors
https://github.com/OCamlPro/opam-repository: +1700 commits, 75 contributors, 370+ packages

on http://opam.ocamlpro.com/
+400 unique visitor per week, 15k 'opam update' per week
+1300 unique visitor per month, 55k 'opam update' per month
3815 unique visitor since the alpha release

=== Changelog ===

The full change-log since the beta release in January:

1.0.0 [Mar 2013]
* Improve the lexer performance (thx to @oandrieu)
* Fix various typos (thx to @chaudhuri)
* Fix build issue (thx to @avsm)

0.9.6 [Mar 2013]
* Fix installation of pinned packages on BSD (thx to @smondet)
* Fix configuration for zsh users (thx to @AltGr)
* Fix loading of `~/.profile` when using dash (eg. in Debian/Ubuntu)
* Fix installation of packages with symbolic links (regression introduced in 0.9.5)

0.9.5 [Mar 2013]
* If necessary, apply patches and substitute files before removing a package
* Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
* Add build and install rules using ocamlbuild to help distro packagers
* Support arbitrary level of nested subdirectories in packages repositories
* Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
* Improve the behaviour of `opam update` wrt. pinned packages
* Change the default external solver criteria (only useful if you have aspcud installed on your machine)
* Add support for global and user configuration for OPAM (`opam config setup`)
* Stop yelling when OPAM is not up-to-date
* Update or generate `~/.ocamlinit` when running `opam init`
* Fix tests on *BSD (thx Arnaud Degroote)
* Fix compilation for the source archive

0.9.4 [Feb 2013]
* Disable auto-removal of unused dependencies. This can now be enabled on-demand using `-a`
* Fix compilation and basic usage on Cygwin
* Fix BSD support (use `type` instead of `which` to detect existing commands)
* Add a way to tag external dependencies in OPAM files
* Better error messages when trying to upgrade pinned packages
* Display `depends` and `depopts` fields in `opam info`
* `opam info pkg.version` shows the metadata for this given package version
* Add missing `doc` fields in `.install` files
* `opam list` now only shows installable packages

0.9.3 [Feb 2013]
* Add system compiler constraints in OPAM files
* Better error messages in case of conflicts
* Cleaner API to install/uninstall packages
* On upgrade, OPAM now perform all the remove action first
* Use a cache for main storing OPAM metadata: this greatly speed-up OPAM invocations
* after an upgrade, propose to reinstall a pinned package only if there were some changes
* improvements to the solver heuristics
* better error messages on cyclic dependencies

0.9.2 [Jan 2013]
* Install all the API files
* Fix `opam repo remove repo-name`
* speed-up `opam config env`
* support for `opam-foo` scripts (which can be called using `opam foo`)
* 'opam update pinned-package' works
* Fix 'opam-mk-repo -a'
* Fix 'opam-mk-repo -i'
* clean-up pinned cache dir when a pinned package fails to install

0.9.1 [Jan 2013]
* Use ocaml-re 1.2.0


From amc79 at cam.ac.uk  Fri Mar 15 01:23:13 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Fri, 15 Mar 2013 01:23:13 +0000
Subject: [ocaml-platform] [ocaml-infra] Wireframe demo of OCaml.og
In-Reply-To: <CALScVYniQw9822rt1KR4-WHC2atkBddjVTZPFYH59dOeK6oXUQ@mail.gmail.com>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
 <CALScVYniQw9822rt1KR4-WHC2atkBddjVTZPFYH59dOeK6oXUQ@mail.gmail.com>
Message-ID: <94DE2397-ED49-438C-A159-A0ADB7C08A79@cam.ac.uk>

Hi Seb, Thanks for the feedback.

You're right about the width vs height and in these wireframes you're actually seeing the whole page at once.  All displays (apart from phones) should see the full width of the page but may have to scroll to see content further down the page.  People on large monitors may not have to scroll far.  I should point out that I fixed the width of these wireframes at 1024 wide, which is similar to tablet resolutions.  On wider monitors, we'd likely add more whitespace either side so as to avoid stretching the content too far.

There isn't a straightforward way to see how the site would look from a mobile without explicitly wireframing it that way, but we are conscious of it.  Since we're using the bootstrap [1] grid, we do get mobile-friendly views for free, provided we arrange the content well.  As an example, visit the bootstrap site (below) from a desktop and slowly reduce the width of your browser window.  You'll see how the content reflows to fit the window until it eventually becomes a single column (as I see it on my phone).

[1] http://twitter.github.com/bootstrap/

Best wishes,
Amir

On 14 Mar 2013, at 18:45, Sebastien Mondet <sebastien.mondet at gmail.com> wrote:

> 
> Hi
> 
> Very impressive work!!
> 
> One question: 
> even without fonts and colors, the wireframes are supposed to be about page layout, right? 
> On the videos, the pseudo-browser is higher than wider while most people seem to have nowadays w > h.
> Is there a way to view how the layout is intended to adapt to other "page geometries" (or to mobile-browsers by the way)? or is it too early in the design?
> 
> 
> Thanks & Cheers
> Seb
> 
> 
> 
> 
> 
> 
> 
> 
> On Thu, Mar 14, 2013 at 12:53 PM, Amir Chaudhry <amc79 at cam.ac.uk> wrote:
> Dear all,
> 
> I've been working on putting together wireframes to demonstrate aspects of the design and functionality we'd like to introduce into the OCaml.org website.  Today, I published a blog post summarising this work, which includes screencasts and a link to a clickable demo you can play with.
> 
> http://amirchaudhry.com/wireframe-demos-for-ocamlorg
> 
> I'd be keen to know what you think so please send any feedback via the infrastructure mailing list (infrastructure at lists.ocaml.org).
> 
> Best wishes,
> Amir
> _______________________________________________
> Infrastructure mailing list
> Infrastructure at lists.ocaml.org
> http://lists.ocaml.org/listinfo/infrastructure
> 


From daniel.buenzli at erratique.ch  Fri Mar 15 05:54:52 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 15 Mar 2013 06:54:52 +0100
Subject: [ocaml-platform] Wireframe demo of OCaml.og
In-Reply-To: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
Message-ID: <6DFACCA6E9514EE99323A21A4954F2A2@erratique.ch>

Hello,

> On wider monitors, we'd likely add more whitespace either side so as to avoid stretching the content too far.

W.r.t. page layout stretchability but on the narrower side, a good test to have in mind is to check if on a laptop you can have an 80-columns text editor and the documentation side by side without needing horizontal scrolling.

Regarding the Modules tab I'm not sure I understood you well so it may already be the idea. But if the package has a single module it would be nice if it shows directly the documentation of that module to save one useless click. 

Also, it's more a comment for opam, but it would be nice if the documentation system could do the same locally with the same experience but showing you only the documentation of your installed packages (with a landing page that lists the packages and their respective modules for direct access).

Best,

Daniel



From amc79 at cam.ac.uk  Fri Mar 15 08:48:08 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Fri, 15 Mar 2013 08:48:08 +0000
Subject: [ocaml-platform] Wireframe demo of OCaml.og
In-Reply-To: <6DFACCA6E9514EE99323A21A4954F2A2@erratique.ch>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
 <6DFACCA6E9514EE99323A21A4954F2A2@erratique.ch>
Message-ID: <0EF4ED47-02EA-4FC5-B8DC-9FD0DE023949@cam.ac.uk>


--
sent via mobile

On 15 Mar 2013, at 05:54, Daniel B?nzli <daniel.buenzli at erratique.ch> wrote:

> Hello,
> 
>> On wider monitors, we'd likely add more whitespace either side so as to avoid stretching the content too far.
> 
> W.r.t. page layout stretchability but on the narrower side, a good test to have in mind is to check if on a laptop you can have an 80-columns text editor and the documentation side by side without needing horizontal scrolling.

Hadn't thought of that so I'll bear it in mind. However, it may still depend on the resolution of the laptop in question (eg I have a 'retina' MacBook which has more horizontal space than my old laptop). 


> Regarding the Modules tab I'm not sure I understood you well so it may already be the idea. But if the package has a single module it would be nice if it shows directly the documentation of that module to save one useless click. 

Yes, that's the plan. I did mention it but probably wasn't clear enough.


> Also, it's more a comment for opam, but it would be nice if the documentation system could do the same locally with the same experience but showing you only the documentation of your installed packages (with a landing page that lists the packages and their respective modules for direct access).

Yes, this is also something we want :)  It's not just an opam thing as it involves Leo's upcoming work on documentation, as well as using packages like cow, opam2web, weberizer etc. Doing this locally, would enable the creation of properly cross-referenced docs for a particular user's environment. 

Best wishes,
Amir

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130315/44d5e9e4/attachment-0001.html>

From gabriel.scherer at gmail.com  Fri Mar 15 10:20:30 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 15 Mar 2013 11:20:30 +0100
Subject: [ocaml-platform] On "lowercase names" as part of namespaces,
 "open module" in namespace descriptions, and unordered mappings
Message-ID: <CAPFanBEiG1yiL--42n8AZn57igBnceyMz-oiM0JA+g213r=O4A@mail.gmail.com>

Yesterday I had a discussion with Didier R?my around the question of
how to deal with "open module" as part of a "namespace language" to
describe the compilation environment of OCaml programs.

# "open" explained through the namespace description language

In the model of http://gallium.inria.fr/~scherer/namespaces/spec.pdf,
"compilation environments" are maps from compilation unit names to
compilation units (as paths in the filesystem) or, in a hierarchical
setting, to subenvironments with the same structure.

As we have already remarked on this list, `open namespace Foo` can be
understood in terms of the corresponding namespace description
language. If the current environment is `E`, the environment after the
action of `open namespace Foo` is `E merge right E#Foo`; it is only
accepted if `Foo` is a subenvironment, and adds all its children to
the current mapping `E`, giving precedence over the new bindings in
case of conflict (to mimic the silent shadowing rule).

In a similar vein, one could wish to explain `open module M`
(the usual `open M` of OCaml, written `open module` to
avoid ambiguities) under the same light, turning `E` into `E merge
right E#M`.

But our specification only defines (sub)environments with
(sub)environments, not environments with modules. To model `open` in
this way we should extend the semantics of `merge`, by defining which
kind of semantic environment value the term `E merge right E#M` will
reduce to.

Methodology remark:

  There has been a discussion of how to treat "open module"
  information as part of namespace descriptions. Just having "open
  Foo" lines in the description and saying nothing else about it that
  "this means the type-checker will have to perform this open before
  running on the program" means that they are handled as
  *side-effects* of namespace descriptions. On the contrary, our
  previous models of namespaces described namespace *values*: a file
  foo.ns is semantically interpreted as building a datastructure that
  represents the namespace. I insist that this "value" model is better
  than mixing environment values (hierarchies, aliases, etc.) with
  side-effects, as this latter choice raises unpleasant design
  questions (if you include a namespace description file, does that
  also trigger its side-effects?). We're looking for a model of what
  the "environment value" are that takes `open module` seriously.

  The previous proposal was to enrich our current notion of
  environment values, namely map from names to either compunits or
  subenvironments, with "flat access" marks on some of the
  children. But then you need to have ordered mapping, or at least
  order the flat-access marks, and none of those solutions feel right.

# Values-inside-environments as a "transparent" model with some problems

A possible direction is to extend compilation environments to whole
typing environments, that can not only associate compilation unit
names to compilation units, but also usual value names (prefixed by
a compunit name) to OCaml values (or their types), types to type
definitions, etc. This has been suggested by a few people on the list
already.

For example, `Stdlib merge Stdlib#List` would result in a namespace
value of the following form

    { Array => "+array",
      List => "+list",
      ...
      ('a list) => type,
      (@) => ('a list -> 'a list -> 'a list),
      ...
    }

However, this direction appears to be in contradiction with a design
choice we made early in our work on namespaces: we will explain
namespaces as mapping to compilation units, but no further, and in
particular, it will never be necessary to "look into" .cmi files to
understand and analyze a namespace description, or reduce it to
a "value" (for some notion of environment value). In our example, we
have to inspect "+list.cmi" to even be able to list the set of names
exported by the namespace description `Stdlib merge Stdlib#List`.

This restriction is valuable in particular for tooling purposes: not
looking into the .cmi content also means that you can designate
compilation units that do not exist yet, and have a single namespace
description that ranges over both already-existing units and
yet-to-be-compiled ones.

One particular kind of tooling that does not yet exists but we took
into account in our design is tools to interpret and analyse the
namespace descriptions themselves. You want to be able to tell wether
two distinct namespace descriptions risk shadowing each other, to
reason on whether a change you made kept the namespace description
equivalent (eg. changing the order of two merges), get the list of all
names exported by a given namespace description, etc.

In this respect, the namespace description language described in
spec.pdf or much others proposals made in the thread or elsewhere are
fairly simple to analyse statically, by themselves -- except for the
"scan" primitive that explicitly depends on the state of the
filesystem at a given time, and surely its use should be considered
prudently.

Adding lowercase names to the domain of compilation environments would
(partially) break those toolability properties. If you assume you
cannot access the relevant .cmi files or want to be resilient to any
of their change, you can still tell about compilation unit name
conflicts, but basically have no idea of which lowercase names are
exported by any given namespace description that uses `open
module`. You can define fine-grained semantic operations
(restricting the set of names added by the `open`, removing some
of them), but will not be able to check for conflicts or their
absence.

We therefore think it is a dangerous direction to move towards to,
that should be discouraged. Namespaces are planned for large-scale
organization of big software systems, being able to manipulate and
analyze them *independently* of the underlying type system details is
likely to be important for robustness.

We call this model (of semantic values for namespace descriptions) the
"transparent model", because it looks through .cmi files to
incorporate values of the language into the compilation environment.


# An "opaque" model that is simpler

We propose a simpler model that can be seen as an abstraction of the
"transparent model": instead of having values be mappings with rich
domain (both compilation unit names and in-language names), we suggest
a pair of:
  - an unordered mapping of compilation unit names to compilation
units, as before
  - an ordered list of compilation units, denoting the "opened"
modules; the "open list"

The namespace descrition `Stdlib merge Stdlib#List` would for example
reduce to the following value:

    { Array => "+array",
      List => "+list",
      ...
    }, [ "+list" ]

In a sense, we went away from the distasteful "ordered mapping" model
by separating the two concerns, with a pair of the (unordered) mapping
structure and the ordered-by-nature list of module to open.

We can then define two *asymetric* merge operations:

- `(M1, O1) merge (M2, O2)` merges two (sub)environments into the
  expected `(Map.union M1 M2, O1 @ O2)`, concatenating the open lists
  (opens of the left-hand-side will be performed first, and therefore
  shadowed by opens of the right-hand-side)

- `(M, O) merge U` merge an environment and a compilation unit into
  `(M, O @ [U])`

This gives a robust semantics to both `open namespace` and `open
module` in term of transformation of environment values. When
beginning to process a given compilation unit, the type-checker has
built a compilation environment, first from the filesystem by
convention, then by possible compilation parameters, finally possibly
by inspecting the source file headers containing namespace
information, and it enters the type-checking world where opening .cmi
is a given, and can translate this compilation environment value into
an initial type-checking environment just by doing the open in
sequence, in the order you expect. If allowed by the final design,
local `open namespace` or `open module` would be understood in the
same way.

We call this the "opaque" model because, semantically, it doesn't look
into the .cmi content before type-checking time, which allows to
reason on the environment values of namespace description involving
not-yet-existing or rapidly changing compilation units. Of course, it
won't be able to tell you anything about shadowing at the value level
in the open-list part (only name conflicts and shadowing among
*compilation units*), and this is very explicit in the semantic model.

# Open lists in subenvironments

Note that subenvironments also have this pair structure, so children
of a tree may have open lists. For example, if Core provides me with
a namespace description "core.ns", and Batteries with another
"batteries.ns", and I decide to build the namespace

   { Core => include "core.ns",
     Batteries => include "batteries.ns" }

to talk about both worldviews in an explicit way, this will reduce to
a environment value of the form

   { Core => { Std => .., List => ... }, [ ".../std" ]
     Batteries => { ... }, [ ".../batPervasives" ] },
   []

Setting this as the compilation environment of a program will not
automaticaly open the "std" compilation unit provided by core: the
root open-list is empty. However, calling "open namespace Core" in
this setting will do that (as indicated by our semantics for `merge`).


# Operations on the open list

It may make sense to add some operations besides "merge" to manipulate
the open lists of namespaces, for example to empty it (I may want to
be able to denote the modules provided by Core with a short name, yet
avoid opening Std automatically, as the current -nopervasives
command-line option allows for the standard library), or explicitly
restrict its content by whitelisting or blacklisting.

Whatever choice we make in this design space, it is interesting to
consider how they project into the "transparent" semantics: we can
have a look at what in means in term of those rich, ideal but painful
to work with "transparent" environments, to make sure that all we're
doing really makes sense.

From thomas at ocamlpro.com  Fri Mar 15 11:34:42 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Fri, 15 Mar 2013 12:34:42 +0100
Subject: [ocaml-platform] [ocaml-infra] Wireframe demo of OCaml.og
In-Reply-To: <20130315103939.7b462576@alcazar>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
 <20130315103939.7b462576@alcazar>
Message-ID: <929BED6A-2B31-4ECE-8764-0C910CA5C4B8@ocamlpro.com>

Hi,

> I mean: could it be possible to create some kind of "info" packages in
> opam to indicate that a library/tool/... exists but is not packaged
> yet ? With a flag to make them appear in opam list and search ?

You can already create "empty" packages with a dummy build instruction which just display "NOT PACKAGED YET!" and exit with a non-zero code, but I doubt this would be very helpful to the user (and quite frustrating). But why not ...

> This could encourage contributors to package not yet packaged tools and
> libs.
> 
> Regarding tags, it is possible that I missed the information, but is
> opam going to handle tags associated to packages ? (I saw some
> tag-based search in packages in Amir's demos)

Yup, OPAM 1.0.0 supports tags but we haven't advertise that properly yet (the priority was to release the tool with all the rights features in). Now we can concentrate on the package metadata themselves.

If you look at section 1.2.4 of the dev-manual[1] your can see that you can add these new fields in the .opam:

homepage: "url"
authors: [ "me" "you" ]
tags: [ "foo" "bar" ]

I encourage everybody with some spare time to add these relevant fields to the existing package metadata :-) Bonus points if you come-up with some automatic tools to do this.
For the tag conventions, I'm pretty in favor of re-using the great work that has already been put in the hump. Is there a list of tags and their description available somewhere ?

You can query the tags on the command line: `opam info foo -f tags` will display the tags associated to the package foo but I just realize that the search function doesn't look at the tags yet ... I've opened [2] to to keep track of this.

> At last, I also saw in Amir's demos news feeds associated to packages.
> Will the RSS feed be indicated in opam package information ?

This is a great idea, I'm not sure how to do this properly yet but that's something what we really aim for (ie. give the user the ability to get quick feedback on a given package). This is now tracked by [3].

--
Thomas

[1] https://github.com/OCamlPro/opam/raw/master/doc/dev-manual/dev-manual.pdf
[2] https://github.com/OCamlPro/opam/issues/535
[3] https://github.com/OCamlPro/opam/issues/536


From Maxence.Guesdon at inria.fr  Fri Mar 15 12:21:05 2013
From: Maxence.Guesdon at inria.fr (Maxence Guesdon)
Date: Fri, 15 Mar 2013 13:21:05 +0100
Subject: [ocaml-platform] [ocaml-infra] Wireframe demo of OCaml.og
In-Reply-To: <929BED6A-2B31-4ECE-8764-0C910CA5C4B8@ocamlpro.com>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
 <20130315103939.7b462576@alcazar>
 <929BED6A-2B31-4ECE-8764-0C910CA5C4B8@ocamlpro.com>
Message-ID: <20130315132105.16e6d06d@alcazar>

On Fri, 15 Mar 2013 12:34:42 +0100
Thomas Gazagnaire <thomas at ocamlpro.com> wrote:

> Hi,
> 
> > I mean: could it be possible to create some kind of "info" packages in
> > opam to indicate that a library/tool/... exists but is not packaged
> > yet ? With a flag to make them appear in opam list and search ?
> 
> You can already create "empty" packages with a dummy build instruction which just display "NOT PACKAGED YET!" and exit with a non-zero code, but I doubt this would be very helpful to the user (and quite frustrating). But why not ...
> 
> > This could encourage contributors to package not yet packaged tools and
> > libs.
> > 
> > Regarding tags, it is possible that I missed the information, but is
> > opam going to handle tags associated to packages ? (I saw some
> > tag-based search in packages in Amir's demos)
> 
> Yup, OPAM 1.0.0 supports tags but we haven't advertise that properly yet (the priority was to release the tool with all the rights features in). Now we can concentrate on the package metadata themselves.
> 
> If you look at section 1.2.4 of the dev-manual[1] your can see that you can add these new fields in the .opam:
> 
> homepage: "url"
> authors: [ "me" "you" ]
> tags: [ "foo" "bar" ]
> 
> I encourage everybody with some spare time to add these relevant fields to the existing package metadata :-) Bonus points if you come-up with some automatic tools to do this.
> For the tag conventions, I'm pretty in favor of re-using the great work that has already been put in the hump. Is there a list of tags and their description available somewhere ?

I can extract it, but it may not be the best one. Some kind of merge
with oasis-db tags could be better. Of course, there should not be any
restriction on tags, but a way to list the tags used in existing
packages should be useful to choose appropriate ones for a new package.
Something like `opam tag -l`.

> You can query the tags on the command line: `opam info foo -f tags` will display the tags associated to the package foo but I just realize that the search function doesn't look at the tags yet ... I've opened [2] to to keep track of this.
> 
> > At last, I also saw in Amir's demos news feeds associated to packages.
> > Will the RSS feed be indicated in opam package information ?
> 
> This is a great idea, I'm not sure how to do this properly yet but that's something what we really aim for (ie. give the user the ability to get quick feedback on a given package). This is now tracked by [3].

I replied into [3]
> --
> Thomas
> 
> [1] https://github.com/OCamlPro/opam/raw/master/doc/dev-manual/dev-manual.pdf
> [2] https://github.com/OCamlPro/opam/issues/535
> [3] https://github.com/OCamlPro/opam/issues/536
> 

Maxence

From daniel.buenzli at erratique.ch  Fri Mar 15 13:09:41 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 15 Mar 2013 14:09:41 +0100
Subject: [ocaml-platform] [ocaml-infra] Wireframe demo of OCaml.og
In-Reply-To: <929BED6A-2B31-4ECE-8764-0C910CA5C4B8@ocamlpro.com>
References: <F31BA4AC-7B9C-491E-A133-F5D8F98AC923@cam.ac.uk>
 <20130315103939.7b462576@alcazar>
 <929BED6A-2B31-4ECE-8764-0C910CA5C4B8@ocamlpro.com>
Message-ID: <7FE2CCC895F44A5D97D8D7FD07272A38@erratique.ch>

Le vendredi, 15 mars 2013 ? 12:34, Thomas Gazagnaire a ?crit :
> I encourage everybody with some spare time to add these relevant fields to the existing package metadata :-) Bonus points if you come-up with some automatic tools to do this.

For my packages I started to generate opam files from _oasis files, some things are still missing (.install files) and the code is ad-hoc (e.g it won't handle complex dependencies specs) but it mostly works for my packages and can be used as a starting point. The relevant parts are:

https://github.com/dbuenzli/cmdliner/blob/master/build#L46
https://github.com/dbuenzli/cmdliner/blob/master/build#L122

Don't ask me what these sed invocations actually do? The results can be seen here:  

http://erratique.ch/software/opam/packages/

Daniel



From thomas at ocamlpro.com  Fri Mar 15 13:34:16 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Fri, 15 Mar 2013 14:34:16 +0100
Subject: [ocaml-platform] OPAM 1.0.0 released !
In-Reply-To: <999F571F-57A2-46F0-9DA8-83DC7026363E@ocamlpro.com>
References: <999F571F-57A2-46F0-9DA8-83DC7026363E@ocamlpro.com>
Message-ID: <B761C4CC-18EA-4A94-B6CC-A4EFE5C8746E@ocamlpro.com>

As I've received few questions related to upgrading OPAM itself, I've added Anil's response to [1] to the FAQ:

    https://github.com/OCamlPro/opam/wiki/FAQ

[1] https://github.com/OCamlPro/opam/issues/528

Best,
Thomas

On Mar 14, 2013, at 9:28 PM, Thomas Gazagnaire wrote:

> I nm *very* happy to announce the first official release of OPAM!
> 
> Many of you already know and use OPAM so I won't be long. Please read http://www.ocamlpro.com/blog/2013/01/17/opam-beta.html for a longer description.
> 
> 1.0.0 fixes many bugs and add few new features to the previously announced beta-release.
> 
> The most visible new feature, which should be useful for beginners with OCaml and OPAM,  is an auto-configuration tool. This tool easily enables all the features of OPAM (auto-completion, fix the loading of scripts for the toplevel, opam-switch-eval alias, etc). This tool runs interactively on each `opam init` invocation. If you don't like OPAM to change your configuration files, use `opam init --no-setup`. If you trust the tool blindly,  use `opam init --auto-setup`. You can later review the setup by doing `opam config setup --list` and call the tool again using `opam config setup` (and you can of course manually edit your ~/.profile (or ~/.zshrc for zsh users), ~/.ocamlinit and ~/.opam/opam-init/*).
> 
> Please report:
> - Bug reports and feature requests for the OPAM tool: http://github.com/OCamlPro/opam/issues
> - Packaging issues or requests for a new package: http://github.com/OCamlPro/opam-repository/issues
> - General queries to: http://lists.ocaml.org/listinfo/platform
> - More specific queries about the internals of OPAM to: http://lists.ocaml.org/listinfo/opam-devel
> 
> On behalf on the OPAM team,
> Thomas
> 
> === Install ===
> 
> Packages for Debian and OSX (at least homebrew) should follow shortly and I'm looking for volunteers to create and maintain rpm packages. The binary installer is up-to-date for Linux and Darwin 64-bit architectures, the 32-bit version for Linux should arrive shortly.
> 
> If you want to build from sources, the full archive (including dependencies) is available here:
> 
>   http://www.ocamlpro.com/pub/opam-full-latest.tar.gz
> 
> === Upgrade ===
> 
> If you are upgrading from 0.9.* you won't  have anything special to do apart installing the new binary. You can then update your package metadata by running `opam update`. If you want to use the auto-setup feature, remove the "eval `opam config env` line you have previously added in your ~/.profile and run `opam config setup --all`.
> 
> So everything should be fine. But you never know ... so if something goes horribly wrong in the upgrade process (of if your are upgrading from an old version of OPAM) you can still trash your ~/.opam, manually remove what OPAM added in  your ~/.profile (~/.zshrc for zsh users) and ~/.ocamlinit, and start again from scratch. 
> 
> === Random stats ===
> 
> Great success on github. Thanks everybody for the great contributions!
> 
> https://github.com/OCamlPro/opam: +2000 commits, 26 contributors
> https://github.com/OCamlPro/opam-repository: +1700 commits, 75 contributors, 370+ packages
> 
> on http://opam.ocamlpro.com/
> +400 unique visitor per week, 15k 'opam update' per week
> +1300 unique visitor per month, 55k 'opam update' per month
> 3815 unique visitor since the alpha release
> 
> === Changelog ===
> 
> The full change-log since the beta release in January:
> 
> 1.0.0 [Mar 2013]
> * Improve the lexer performance (thx to @oandrieu)
> * Fix various typos (thx to @chaudhuri)
> * Fix build issue (thx to @avsm)
> 
> 0.9.6 [Mar 2013]
> * Fix installation of pinned packages on BSD (thx to @smondet)
> * Fix configuration for zsh users (thx to @AltGr)
> * Fix loading of `~/.profile` when using dash (eg. in Debian/Ubuntu)
> * Fix installation of packages with symbolic links (regression introduced in 0.9.5)
> 
> 0.9.5 [Mar 2013]
> * If necessary, apply patches and substitute files before removing a package
> * Fix `opam remove <pkg> --keep-build-dir` keeps the folder if a source archive is extracted
> * Add build and install rules using ocamlbuild to help distro packagers
> * Support arbitrary level of nested subdirectories in packages repositories
> * Add `opam config exec "CMD ARG1 ... ARGn" --switch=SWITCH` to execute a command in a subshell
> * Improve the behaviour of `opam update` wrt. pinned packages
> * Change the default external solver criteria (only useful if you have aspcud installed on your machine)
> * Add support for global and user configuration for OPAM (`opam config setup`)
> * Stop yelling when OPAM is not up-to-date
> * Update or generate `~/.ocamlinit` when running `opam init`
> * Fix tests on *BSD (thx Arnaud Degroote)
> * Fix compilation for the source archive
> 
> 0.9.4 [Feb 2013]
> * Disable auto-removal of unused dependencies. This can now be enabled on-demand using `-a`
> * Fix compilation and basic usage on Cygwin
> * Fix BSD support (use `type` instead of `which` to detect existing commands)
> * Add a way to tag external dependencies in OPAM files
> * Better error messages when trying to upgrade pinned packages
> * Display `depends` and `depopts` fields in `opam info`
> * `opam info pkg.version` shows the metadata for this given package version
> * Add missing `doc` fields in `.install` files
> * `opam list` now only shows installable packages
> 
> 0.9.3 [Feb 2013]
> * Add system compiler constraints in OPAM files
> * Better error messages in case of conflicts
> * Cleaner API to install/uninstall packages
> * On upgrade, OPAM now perform all the remove action first
> * Use a cache for main storing OPAM metadata: this greatly speed-up OPAM invocations
> * after an upgrade, propose to reinstall a pinned package only if there were some changes
> * improvements to the solver heuristics
> * better error messages on cyclic dependencies
> 
> 0.9.2 [Jan 2013]
> * Install all the API files
> * Fix `opam repo remove repo-name`
> * speed-up `opam config env`
> * support for `opam-foo` scripts (which can be called using `opam foo`)
> * 'opam update pinned-package' works
> * Fix 'opam-mk-repo -a'
> * Fix 'opam-mk-repo -i'
> * clean-up pinned cache dir when a pinned package fails to install
> 
> 0.9.1 [Jan 2013]
> * Use ocaml-re 1.2.0
> 


From lpw25 at cam.ac.uk  Fri Mar 15 13:42:55 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Fri, 15 Mar 2013 13:42:55 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 (Yaron Minsky's message of "Mon, 11 Mar 2013 21:51:59 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
Message-ID: <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>

Following recent discussions, I would like to propose some changes to my
previous proposal:

## Flat namespaces

It has occured to me that, while I have some good use cases for
hierarchical namespaces, they are not critical for the *initial*
implementation of namespaces in OCaml. Essentially, I'm changing my
position from "We should include support for hierarchical namespaces" to
"We should make sure that we could easily add support for hierarchical
namespaces in the future".

## Pervasive modules

I think that the simplest solution to Yaron's need for "automatically
opened" modules is to say that:

    open namespace Foo

will open the namespace Foo and then, if it exists, open the module
Foo#Pervasives. 

Members of Foo#Pervasives would not be accessible directly from Foo
(i.e. Foo#id != Foo#Pervasives.id).

I think this has the following benefits:

- This is basically a syntactic solution: we don't need to "dirty" the
  semantics or specification of modules with the issue of automatically
  opening modules.

- Only one Pervasives is opened, so conflicts between separate
  specifications of a namespace should be obvious immediately. Its
  relience on a specific name also makes the potential for conflicts
  obvious to users.

- It is clearly a bit of a fudge, which will discourage its excessive
  use, and prevent any percevied overlap bewteen namespaces and
  modules. This also makes it seem less "offensive" that it slightly
  breaks the idea that "let open namespace Foo in id" should be
  basically the same as "Foo#id"

- It fits in with the standard library's use of Pervasives. You could
  consider current behaviour as simply opening the "Std" namespace
  before every program.

I think that simple solution is better than trying to find a generalised
sematics for "automatic opens" in namespaces. As Gabriel's e-mail shows,
these semantics are non-trivial. I think that it is better to solve a
specific problem with a specific solution, rather than creating a
generalised solution for its own sake.

Regards,

Leo

From yminsky at janestreet.com  Fri Mar 15 14:33:59 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 15 Mar 2013 10:33:59 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>

This proposal makes me happy.

y
On Mar 15, 2013 9:43 AM, "Leo White" <lpw25 at cam.ac.uk> wrote:

> Following recent discussions, I would like to propose some changes to my
> previous proposal:
>
> ## Flat namespaces
>
> It has occured to me that, while I have some good use cases for
> hierarchical namespaces, they are not critical for the *initial*
> implementation of namespaces in OCaml. Essentially, I'm changing my
> position from "We should include support for hierarchical namespaces" to
> "We should make sure that we could easily add support for hierarchical
> namespaces in the future".
>
> ## Pervasive modules
>
> I think that the simplest solution to Yaron's need for "automatically
> opened" modules is to say that:
>
>     open namespace Foo
>
> will open the namespace Foo and then, if it exists, open the module
> Foo#Pervasives.
>
> Members of Foo#Pervasives would not be accessible directly from Foo
> (i.e. Foo#id != Foo#Pervasives.id).
>
> I think this has the following benefits:
>
> - This is basically a syntactic solution: we don't need to "dirty" the
>   semantics or specification of modules with the issue of automatically
>   opening modules.
>
> - Only one Pervasives is opened, so conflicts between separate
>   specifications of a namespace should be obvious immediately. Its
>   relience on a specific name also makes the potential for conflicts
>   obvious to users.
>
> - It is clearly a bit of a fudge, which will discourage its excessive
>   use, and prevent any percevied overlap bewteen namespaces and
>   modules. This also makes it seem less "offensive" that it slightly
>   breaks the idea that "let open namespace Foo in id" should be
>   basically the same as "Foo#id"
>
> - It fits in with the standard library's use of Pervasives. You could
>   consider current behaviour as simply opening the "Std" namespace
>   before every program.
>
> I think that simple solution is better than trying to find a generalised
> sematics for "automatic opens" in namespaces. As Gabriel's e-mail shows,
> these semantics are non-trivial. I think that it is better to solve a
> specific problem with a specific solution, rather than creating a
> generalised solution for its own sake.
>
> Regards,
>
> Leo
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130315/84f49205/attachment-0001.html>

From gabriel.scherer at gmail.com  Sun Mar 17 10:38:31 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Sun, 17 Mar 2013 11:38:31 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
Message-ID: <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>

The problem with this fixed-syntactic choice is that it hampers
composability of namespaces.

Assume you want to work with namespaces Foo and Bar at the same time.
In a hierarchical setting you can build a namespace with two
namespaces for Foo and Bar (eg. { A => Foo, B => Bar } ) and this has
very simple properties (no conflict/shadowing involved). In a flat
setting, or if you want to avoid adding one level of depth, you will
rather use (A merge B). What happens then if both A and B have a
Pervasives module?

(The semantics model of the previous email simply says that both
compilation units referred to by A#Pervasives and B#Pervasives should
be in the open list of the namespace (A merge B).)

I think there is a subtlety at play when you say that "open namespace
Foo in id" is not the same as "Foo#id" anymore. The "id" in "Foo#id"
may only be a compilation unit name (component). If "Pervasives" is a
module rather than a subnamespace, "open Foo#Pervasives" may introduce
only OCaml values, so in particular will not introduce new compilation
units in the environments. So the purported semantics difference here
is only a syntactical ambiguity: the meaning may change if you choose
"id" in a lexical class common to compilation units and submodule
names, and you see it as an internal module name in "open namespace
Foo in id" and a compilation unit name in "Foo#id": it's actually not
the same identifier.

(I still think it would be extremely fruitful to try to remove this
syntactic ambiguity between compilation unit names and submodule
names.)

Regarding the proposal as a whole:
- I'm curious and not sure: what is the reason to remove hierarchical
namespaces from your proposal? At first I believed it was the ongoing
tooling discussion with Alain, but he actually objects to
non-canonicity of names (as permitted by aliasing) more than your
foo-bar-baz hierarchical structure. Which perceived problems are
solved by this change?
- I believe the proposal is still inadequate, or at least
underspecified, with regard to the internal name conflicts problem.
What kind of conventions do you envision around your proposal to avoid
such conflicts?

On Fri, Mar 15, 2013 at 3:33 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> This proposal makes me happy.
>
> y
>
> On Mar 15, 2013 9:43 AM, "Leo White" <lpw25 at cam.ac.uk> wrote:
>>
>> Following recent discussions, I would like to propose some changes to my
>> previous proposal:
>>
>> ## Flat namespaces
>>
>> It has occured to me that, while I have some good use cases for
>> hierarchical namespaces, they are not critical for the *initial*
>> implementation of namespaces in OCaml. Essentially, I'm changing my
>> position from "We should include support for hierarchical namespaces" to
>> "We should make sure that we could easily add support for hierarchical
>> namespaces in the future".
>>
>> ## Pervasive modules
>>
>> I think that the simplest solution to Yaron's need for "automatically
>> opened" modules is to say that:
>>
>>     open namespace Foo
>>
>> will open the namespace Foo and then, if it exists, open the module
>> Foo#Pervasives.
>>
>> Members of Foo#Pervasives would not be accessible directly from Foo
>> (i.e. Foo#id != Foo#Pervasives.id).
>>
>> I think this has the following benefits:
>>
>> - This is basically a syntactic solution: we don't need to "dirty" the
>>   semantics or specification of modules with the issue of automatically
>>   opening modules.
>>
>> - Only one Pervasives is opened, so conflicts between separate
>>   specifications of a namespace should be obvious immediately. Its
>>   relience on a specific name also makes the potential for conflicts
>>   obvious to users.
>>
>> - It is clearly a bit of a fudge, which will discourage its excessive
>>   use, and prevent any percevied overlap bewteen namespaces and
>>   modules. This also makes it seem less "offensive" that it slightly
>>   breaks the idea that "let open namespace Foo in id" should be
>>   basically the same as "Foo#id"
>>
>> - It fits in with the standard library's use of Pervasives. You could
>>   consider current behaviour as simply opening the "Std" namespace
>>   before every program.
>>
>> I think that simple solution is better than trying to find a generalised
>> sematics for "automatic opens" in namespaces. As Gabriel's e-mail shows,
>> these semantics are non-trivial. I think that it is better to solve a
>> specific problem with a specific solution, rather than creating a
>> generalised solution for its own sake.
>>
>> Regards,
>>
>> Leo
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>

From edwin at etorok.net  Sun Mar 17 11:46:48 2013
From: edwin at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Sun, 17 Mar 2013 13:46:48 +0200
Subject: [ocaml-platform] Benchmarking in OPAM
In-Reply-To: <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>
References: <CAPFanBHx2=BegghyiPbcY39Tr2pXVASNtoNOsZoZKcCHt-0SiA@mail.gmail.com>
 <wfppz7cb0k.fsf@gmail.com>
 <CAPFanBGJkzuP=GnGywPSF152+3mC-M_Dg6UTaE=3TKRdReJjgQ@mail.gmail.com>
 <8ABBBECB-F78E-491F-BBC0-6C524F3BBFEA@recoil.org>
 <CAPFanBEDMRZg9vxS3YXufmVaeymVLO8eABTvMzK60o4kb1XM8Q@mail.gmail.com>
 <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>
Message-ID: <5145AD28.7080606@etorok.net>

On 03/14/2013 12:48 PM, Anil Madhavapeddy wrote:
> 
> So for the moment, focussing on the benchmark library would seem to
> be the best thing to do: I've not really used any of them, and would
> be interested in knowing what I ought to adopt for (e.g.) the Mirage
> protocol libraries.  Once we have that in place, the OPAM test integration
> should be much more straightforward.

I don't know if Gabriel replied to you about this, but here's my take on it:

I tried both bench and benchmark (as found in opam), but I found bench to give more accurate results.
Both calculate a number of iterations for each benchmark to get significant measurements wrt to accuracy, but:

Benchmark:
 + runs Gc by default between tests
 + gives you user,sys and wall times (probably more useful for benchmarks that perform I/O)
 - if you want to take a high number of samples, your total benchmark time will be quite high
 - you have to calculate mean/stdev on your own

Bench:
 + uses gettimeofday, seems to be more accurate than utimes() (probably better for CPU-bound benchmarks)
 - no user,sys, only wall time
 * Caveat: doesn't run Gc by default between tests, but can be turned on with Bench.config.gc_between_tests
 + takes 1000 samples / benchmark by default, number of iterations calculated so each sample is at least
(1000 * clock_resolution), i.e. ~1ms on Linux
 + computes mean and stdev using the bootstrap method, and calculates 95% confidence intervals for them
 + the individual measurements are more noisy than with benchmark, but because you have a lot more of them
it can calculate a more accurate mean and stdev

So what we need is a thin layer on top of bench, which can be the stripped down version of my edobench that Gabriel mentioned last time,
i.e. something like:
    run : config -> (name * (unit -> 'a)) list -> result
    log: log_file -> result -> unit

In my lib I also calculated the median (and its confidence interval), because not all the benchmark measurements are symmetric around the mean (
i.e. they're not from a normal distribution, and calculating mean-1.96*stdev can give negative results),
but for simplicity's sake I think mean+stdev might be enough for a statistic.

I've also done some "sanity" checks in my lib, but those should probably be part of the benchmark manager, i.e.:
 - check that CPU frequency scaling is off (i.e. the governor is performance, if any)
 - check that CPU core performance boosting is not enabled
Both of these can make the benchmark results hard to compare, as even comparing the same binary on the same machine you get wildly different timings.

Best regards,
--Edwin

From gabriel.scherer at gmail.com  Sun Mar 17 18:38:40 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Sun, 17 Mar 2013 19:38:40 +0100
Subject: [ocaml-platform] A small script for compiler hackers: create
 short-lived opam switches out of any git branch
Message-ID: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>

As part of the slowly-evolving benchmark work, I have developed a
script to turn any repository that quacks like an OCaml compiler and
can run "make world.opt" into an OPAM compiler switch.

  https://github.com/gasche/opam-compiler-conf

The intended use case is to change something, recompile what need be,
get a compiler switch for that, and install one or two packages for
testing something. You could envision, for example, OPAM being used in
the internal loop of a bisection process. In this case it is important
that OPAM does not recompile the compiler on its side (so the usual
technique of making a tarball of the compiler source and letting OPAM
do its job from there is not pleasant in that situation); the scripts
makes use of voodoo OPAM compiler options (thanks to Thomas in
https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
install" each time "opam switch reinstall" is called.

This is a quick&dirty shell script that works on my machine. No
guarantee that it will work on yours. It also assumes that the
version-control system (VCS) used is git, and calls "git branch" to
infer the name of the compiler switch to use. Eventual patches to
support other VCSs (or, for example, infer the switch name from the
directory name) would be welcome.

From wojciech.meyer at gmail.com  Sun Mar 17 19:18:53 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Sun, 17 Mar 2013 19:18:53 +0000
Subject: [ocaml-platform] A small script for compiler hackers: create
	short-lived opam switches out of any git branch
In-Reply-To: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 (Gabriel Scherer's message of "Sun, 17 Mar 2013 19:38:40 +0100")
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
Message-ID: <wf620psule.fsf@gmail.com>

Hi Gabriel,

all is needed for testing ocamlbuild and local patches for the compiler,
thank you.

Other useful thing in general for OPAM would be something like:

opam patch add <ordered list_of_patches>
opam patch reset

then we are able quickly test some local patches without touching
command line and invoking makefiles.

Gabriel Scherer <gabriel.scherer at gmail.com> writes:

> As part of the slowly-evolving benchmark work, I have developed a
> script to turn any repository that quacks like an OCaml compiler and
> can run "make world.opt" into an OPAM compiler switch.
>
>   https://github.com/gasche/opam-compiler-conf
>
> The intended use case is to change something, recompile what need be,
> get a compiler switch for that, and install one or two packages for
> testing something. You could envision, for example, OPAM being used in
> the internal loop of a bisection process. In this case it is important
> that OPAM does not recompile the compiler on its side (so the usual
> technique of making a tarball of the compiler source and letting OPAM
> do its job from there is not pleasant in that situation); the scripts
> makes use of voodoo OPAM compiler options (thanks to Thomas in
> https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
> install" each time "opam switch reinstall" is called.
>
> This is a quick&dirty shell script that works on my machine. No
> guarantee that it will work on yours. It also assumes that the
> version-control system (VCS) used is git, and calls "git branch" to
> infer the name of the compiler switch to use. Eventual patches to
> support other VCSs (or, for example, infer the switch name from the
> directory name) would be welcome.

From lpw25 at cam.ac.uk  Mon Mar 18 11:38:29 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 11:38:29 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 (Gabriel Scherer's message of "Sun, 17 Mar 2013 11:38:31 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
Message-ID: <87zjy10wga.fsf@kingston.cl.cam.ac.uk>

> The problem with this fixed-syntactic choice is that it hampers
> composability of namespaces.

This is by design. This feature is only meant to provide support to
specialised libraries, like Core, that wish to provide their own
equivalent of the standard library's Pervasives module. We probably
don't want to encourage its general use. I don't think it will be a
problem that you can't easily compose the "Core" namespace with the
standard library's namespace.

> Assume you want to work with namespaces Foo and Bar at the same time.
> In a hierarchical setting you can build a namespace with two
> namespaces for Foo and Bar (eg. { A => Foo, B => Bar } ) and this has
> very simple properties (no conflict/shadowing involved). In a flat
> setting, or if you want to avoid adding one level of depth, you will
> rather use (A merge B). What happens then if both A and B have a
> Pervasives module?

This would be handled like two compilation units with the same name: one
would shadow the other and so only one would be opened. This is safer
than having both modules opened, since opening both may result in one
module partially shadowing another, which is more likely to go
unnoticed.

> Regarding the proposal as a whole:
> - I'm curious and not sure: what is the reason to remove hierarchical
> namespaces from your proposal? At first I believed it was the ongoing
> tooling discussion with Alain, but he actually objects to
> non-canonicity of names (as permitted by aliasing) more than your
> foo-bar-baz hierarchical structure. Which perceived problems are
> solved by this change?

Despite Alain's concerns, I think that it will not be too difficult to
handle the tooling for hierarchical namespaces. However, I think it will
be easier to determine this once the tools have already been updated to
support flat namespaces.

Similarly, the design choice of shallow merging vs. deep merging for
opening hierarchical namespaces may be easier to reason about once
namespaces have been included in the language.

These two issues are important, and require some thought before making a
full proposal including hierarchical namespaces. Rather than waiting for
these issues to be resolved, I would rather proceed, in the short term,
with a proposal for flat namespaces.

> - I believe the proposal is still inadequate, or at least
> underspecified, with regard to the internal name conflicts problem.
> What kind of conventions do you envision around your proposal to avoid
> such conflicts?

In my proposal modules must still have a unique name. This name will be
reflected in the filename of the ".cmi" file (e.g. Foo#Bar as
foo-bar.cmi). To avoid long source file names, the name can be specified
with the "-name" command line argument.

Since I expect people to provide a namespace for their package, I would
expect the interface for module bar from package foo to be called
"foo-bar.cmi". If people don't use the same names for their packages
then this should avoid all naming conflicts.

An alternative mechanism, also supported by my proposal and useful for
libraries that are compatible with versions of OCaml without namespaces,
is to name the module bar in the package foo "foo_bar.cmi" and then
provide a search path file "foo.mlpath" that maps "Foo#Bar" to
"foo_bar.cmi".

Note that in both these solutions the source file can be named "bar.ml",
and the "-name" argument used to add the "Foo#" or "Foo_" prefix to the
name. Build systems could easily add automatic support for these
conventions.

If people wish to be extra careful then they can use the "-name"
argument to add whatever additional data they want to the module name to
ensure that it is unique.

From yminsky at gmail.com  Mon Mar 18 12:26:17 2013
From: yminsky at gmail.com (Yaron Minsky)
Date: Mon, 18 Mar 2013 08:26:17 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>

Can the case of both Core and Async (and opening both of their pervasives
modules) be handled here?  This seems to me to be of fundamental
importance.  If that's missing, then I misunderstood the proposal.
On Mar 18, 2013 7:38 AM, "Leo White" <lpw25 at cam.ac.uk> wrote:

> > The problem with this fixed-syntactic choice is that it hampers
> > composability of namespaces.
>
> This is by design. This feature is only meant to provide support to
> specialised libraries, like Core, that wish to provide their own
> equivalent of the standard library's Pervasives module. We probably
> don't want to encourage its general use. I don't think it will be a
> problem that you can't easily compose the "Core" namespace with the
> standard library's namespace.
>
> > Assume you want to work with namespaces Foo and Bar at the same time.
> > In a hierarchical setting you can build a namespace with two
> > namespaces for Foo and Bar (eg. { A => Foo, B => Bar } ) and this has
> > very simple properties (no conflict/shadowing involved). In a flat
> > setting, or if you want to avoid adding one level of depth, you will
> > rather use (A merge B). What happens then if both A and B have a
> > Pervasives module?
>
> This would be handled like two compilation units with the same name: one
> would shadow the other and so only one would be opened. This is safer
> than having both modules opened, since opening both may result in one
> module partially shadowing another, which is more likely to go
> unnoticed.
>
> > Regarding the proposal as a whole:
> > - I'm curious and not sure: what is the reason to remove hierarchical
> > namespaces from your proposal? At first I believed it was the ongoing
> > tooling discussion with Alain, but he actually objects to
> > non-canonicity of names (as permitted by aliasing) more than your
> > foo-bar-baz hierarchical structure. Which perceived problems are
> > solved by this change?
>
> Despite Alain's concerns, I think that it will not be too difficult to
> handle the tooling for hierarchical namespaces. However, I think it will
> be easier to determine this once the tools have already been updated to
> support flat namespaces.
>
> Similarly, the design choice of shallow merging vs. deep merging for
> opening hierarchical namespaces may be easier to reason about once
> namespaces have been included in the language.
>
> These two issues are important, and require some thought before making a
> full proposal including hierarchical namespaces. Rather than waiting for
> these issues to be resolved, I would rather proceed, in the short term,
> with a proposal for flat namespaces.
>
> > - I believe the proposal is still inadequate, or at least
> > underspecified, with regard to the internal name conflicts problem.
> > What kind of conventions do you envision around your proposal to avoid
> > such conflicts?
>
> In my proposal modules must still have a unique name. This name will be
> reflected in the filename of the ".cmi" file (e.g. Foo#Bar as
> foo-bar.cmi). To avoid long source file names, the name can be specified
> with the "-name" command line argument.
>
> Since I expect people to provide a namespace for their package, I would
> expect the interface for module bar from package foo to be called
> "foo-bar.cmi". If people don't use the same names for their packages
> then this should avoid all naming conflicts.
>
> An alternative mechanism, also supported by my proposal and useful for
> libraries that are compatible with versions of OCaml without namespaces,
> is to name the module bar in the package foo "foo_bar.cmi" and then
> provide a search path file "foo.mlpath" that maps "Foo#Bar" to
> "foo_bar.cmi".
>
> Note that in both these solutions the source file can be named "bar.ml",
> and the "-name" argument used to add the "Foo#" or "Foo_" prefix to the
> name. Build systems could easily add automatic support for these
> conventions.
>
> If people wish to be extra careful then they can use the "-name"
> argument to add whatever additional data they want to the module name to
> ensure that it is unique.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130318/4ca4c6ec/attachment.html>

From lpw25 at cam.ac.uk  Mon Mar 18 12:34:14 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 12:34:14 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 (Yaron Minsky's message of "Mon, 18 Mar 2013 08:26:17 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
Message-ID: <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>

> Can the case of both Core and Async (and opening both of their pervasives modules) be handled here?? This seems to me
> to be of fundamental importance.? If that's missing, then I misunderstood the proposal.

Yes that is fine. It just means that if you made a new namespace by
merging the Core namespace with the Async namespace then the Pervasives
module of one would shadow the Pervasives module of the other.

From yminsky at janestreet.com  Mon Mar 18 12:55:52 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 18 Mar 2013 08:55:52 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>

It occurs to me I just don't understand the semantics of this.  What
happens if I do this:

    open namespace Core
    let () = printf "Hello world!\n"
    open namespace Async
    let () = printf "Hello world!\n"

or, for that matter:

    open namespace Core
    let () = printf "Hello world!\n"
    let open namespace Async in
    printf "Hello world!\n"

Async and Core have different definitions of printf, as it happens.
Which gets called in these cases?

y

On Mon, Mar 18, 2013 at 8:34 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> Can the case of both Core and Async (and opening both of their
>> pervasives modules) be handled here?  This seems to me to be of
>> fundamental importance.  If that's missing, then I misunderstood
>> the proposal.
>
> Yes that is fine. It just means that if you made a new namespace by
> merging the Core namespace with the Async namespace then the Pervasives
> module of one would shadow the Pervasives module of the other.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From gabriel.scherer at gmail.com  Mon Mar 18 13:28:45 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 18 Mar 2013 14:28:45 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
Message-ID: <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>

This is fine: it will desugar into:

  open namespace Core
  open Pervasives (* line produced only if Core#Pervasives exists *)
  let () = printf "Hello world!\n"
  open namespace Async
  open Pervasives (* line produced only if Async#Pervasives exists *)
  let () = printf "Hello world!\n"

You would be in trouble if you defined a CorePlusAsync namespace as, say
   include "core.ns"
   include "async.ns"

and then did
   open namespace CorePlusAsync

it would desugar into
   open namespace CorePlusAsync
   open Pervasives

which is equivalent to
   open namespace CorePlusAsync
   open Async#Pervasives

and not
   open namespace CorePlusAsync
   open Core#Pervasives
   open Async#Pervasives

On Mon, Mar 18, 2013 at 1:55 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> It occurs to me I just don't understand the semantics of this.  What
> happens if I do this:
>
>     open namespace Core
>     let () = printf "Hello world!\n"
>     open namespace Async
>     let () = printf "Hello world!\n"
>
> or, for that matter:
>
>     open namespace Core
>     let () = printf "Hello world!\n"
>     let open namespace Async in
>     printf "Hello world!\n"
>
> Async and Core have different definitions of printf, as it happens.
> Which gets called in these cases?
>
> y
>
> On Mon, Mar 18, 2013 at 8:34 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>>> Can the case of both Core and Async (and opening both of their
>>> pervasives modules) be handled here?  This seems to me to be of
>>> fundamental importance.  If that's missing, then I misunderstood
>>> the proposal.
>>
>> Yes that is fine. It just means that if you made a new namespace by
>> merging the Core namespace with the Async namespace then the Pervasives
>> module of one would shadow the Pervasives module of the other.
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at janestreet.com  Mon Mar 18 13:51:01 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 18 Mar 2013 09:51:01 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
Message-ID: <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>

Got it.  That matches my initial mental model.  Just to be explicit:

    open namespace Core
    open namespace Async

Will lead to separate opens of the Core and Async Pervasives modules.

I would somewhat prefer more flexibility for auto-open modules (i.e.,
allow for the specification of multiple modules to open, of arbitrary
name, and allow for merge operations to open both, in order, rather
than just one), and I don't really understand why this more limited
version is preferable; but I don't mind enough to fight.  This
solution seems like it would solve the use cases that I am aware of.

y

On Mon, Mar 18, 2013 at 9:28 AM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
> This is fine: it will desugar into:
>
>   open namespace Core
>   open Pervasives (* line produced only if Core#Pervasives exists *)
>   let () = printf "Hello world!\n"
>   open namespace Async
>   open Pervasives (* line produced only if Async#Pervasives exists *)
>   let () = printf "Hello world!\n"
>
> You would be in trouble if you defined a CorePlusAsync namespace as, say
>    include "core.ns"
>    include "async.ns"
>
> and then did
>    open namespace CorePlusAsync
>
> it would desugar into
>    open namespace CorePlusAsync
>    open Pervasives
>
> which is equivalent to
>    open namespace CorePlusAsync
>    open Async#Pervasives
>
> and not
>    open namespace CorePlusAsync
>    open Core#Pervasives
>    open Async#Pervasives
>
> On Mon, Mar 18, 2013 at 1:55 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> It occurs to me I just don't understand the semantics of this.  What
>> happens if I do this:
>>
>>     open namespace Core
>>     let () = printf "Hello world!\n"
>>     open namespace Async
>>     let () = printf "Hello world!\n"
>>
>> or, for that matter:
>>
>>     open namespace Core
>>     let () = printf "Hello world!\n"
>>     let open namespace Async in
>>     printf "Hello world!\n"
>>
>> Async and Core have different definitions of printf, as it happens.
>> Which gets called in these cases?
>>
>> y
>>
>> On Mon, Mar 18, 2013 at 8:34 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>>>> Can the case of both Core and Async (and opening both of their
>>>> pervasives modules) be handled here?  This seems to me to be of
>>>> fundamental importance.  If that's missing, then I misunderstood
>>>> the proposal.
>>>
>>> Yes that is fine. It just means that if you made a new namespace by
>>> merging the Core namespace with the Async namespace then the Pervasives
>>> module of one would shadow the Pervasives module of the other.
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform

From gabriel.scherer at gmail.com  Mon Mar 18 14:03:51 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 18 Mar 2013 15:03:51 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
Message-ID: <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>

> I would somewhat prefer more flexibility for auto-open modules (i.e.,
> allow for the specification of multiple modules to open, of arbitrary
> name, and allow for merge operations to open both, in order, rather
> than just one), and I don't really understand why this more limited
> version is preferable; but I don't mind enough to fight.

I tend to agree that the semantics I proposed in my email, that allows
arbitrary "open lists" and in particular proper merging, would be a
better choice.

Leo's main argument is that systematically using Pervasives is more
predictable for users (that may not want to have to look at namespace
descriptions to know which compilation units will be opened by
default).
I'd say in practice it's rather obvious at medium scale (for any given
software project) which module is meant to be the
Pervasives/Std/Prelude one, and large scale composability by default
could be a better choice. But for large-scale composability of
namespaces I believe more in the hierarchical model than in merging
all namespaces, anyway.

On Mon, Mar 18, 2013 at 2:51 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Got it.  That matches my initial mental model.  Just to be explicit:
>
>     open namespace Core
>     open namespace Async
>
> Will lead to separate opens of the Core and Async Pervasives modules.
>
> I would somewhat prefer more flexibility for auto-open modules (i.e.,
> allow for the specification of multiple modules to open, of arbitrary
> name, and allow for merge operations to open both, in order, rather
> than just one), and I don't really understand why this more limited
> version is preferable; but I don't mind enough to fight.  This
> solution seems like it would solve the use cases that I am aware of.
>
> y
>
> On Mon, Mar 18, 2013 at 9:28 AM, Gabriel Scherer
> <gabriel.scherer at gmail.com> wrote:
>> This is fine: it will desugar into:
>>
>>   open namespace Core
>>   open Pervasives (* line produced only if Core#Pervasives exists *)
>>   let () = printf "Hello world!\n"
>>   open namespace Async
>>   open Pervasives (* line produced only if Async#Pervasives exists *)
>>   let () = printf "Hello world!\n"
>>
>> You would be in trouble if you defined a CorePlusAsync namespace as, say
>>    include "core.ns"
>>    include "async.ns"
>>
>> and then did
>>    open namespace CorePlusAsync
>>
>> it would desugar into
>>    open namespace CorePlusAsync
>>    open Pervasives
>>
>> which is equivalent to
>>    open namespace CorePlusAsync
>>    open Async#Pervasives
>>
>> and not
>>    open namespace CorePlusAsync
>>    open Core#Pervasives
>>    open Async#Pervasives
>>
>> On Mon, Mar 18, 2013 at 1:55 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> It occurs to me I just don't understand the semantics of this.  What
>>> happens if I do this:
>>>
>>>     open namespace Core
>>>     let () = printf "Hello world!\n"
>>>     open namespace Async
>>>     let () = printf "Hello world!\n"
>>>
>>> or, for that matter:
>>>
>>>     open namespace Core
>>>     let () = printf "Hello world!\n"
>>>     let open namespace Async in
>>>     printf "Hello world!\n"
>>>
>>> Async and Core have different definitions of printf, as it happens.
>>> Which gets called in these cases?
>>>
>>> y
>>>
>>> On Mon, Mar 18, 2013 at 8:34 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>>>>> Can the case of both Core and Async (and opening both of their
>>>>> pervasives modules) be handled here?  This seems to me to be of
>>>>> fundamental importance.  If that's missing, then I misunderstood
>>>>> the proposal.
>>>>
>>>> Yes that is fine. It just means that if you made a new namespace by
>>>> merging the Core namespace with the Async namespace then the Pervasives
>>>> module of one would shadow the Pervasives module of the other.
>>>> _______________________________________________
>>>> Platform mailing list
>>>> Platform at lists.ocaml.org
>>>> http://lists.ocaml.org/listinfo/platform
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform

From lpw25 at cam.ac.uk  Mon Mar 18 15:15:19 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 15:15:19 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 (Gabriel Scherer's message of "Mon, 18 Mar 2013 15:03:51 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
Message-ID: <87mwu020zc.fsf@kingston.cl.cam.ac.uk>

> Leo's main argument is that systematically using Pervasives is more
> predictable for users (that may not want to have to look at namespace
> descriptions to know which compilation units will be opened by
> default).

That's certainly an argument, but it is not my main one.

> I'd say in practice it's rather obvious at medium scale (for any given
> software project) which module is meant to be the
> Pervasives/Std/Prelude one, and large scale composability by default
> could be a better choice.

I don't think I've actually suggested providing any means for defining a
new namespace as the composition of existing namespaces. Nor do I have
any particular use cases for that feature.

However, my proposal does allow a namespace to be specified across
multiple locations, and it is important that these specifications are
composable.

The ordering between these separate specifications will inevitably be
under-specified, depending on things like the order of command-line
arguments. That means that any semantics relying on that ordering will
be potentially fragile. The best we can hope to achieve is to make sure
that conflicts between specifications are as obvious to the user as
possible.

We are discussing two possible semantics for "automatically opened
modules":

1. Supporting a list of auto-opened modules. The automatic open of these
   modules is morally equivalent to merging their contents into a single
   "Pervasives" module and then opening that module.

2. Only supporting a single "Pervasives" module. Trying to specify two
   "Pervasives" modules will simply result in one of those modules being
   chosen ahead of the other.

Of these two semantics, the second one is much more likely to bring
conflicts to the attention of the user. The first one is more likely to
hide accidental conflicts resulting in potential bugs. 

The second semantics also ensures that conflicts between namespace
specifications only occur at the level of whole compilation units,
rather than at the level of individual values and types.

In summary, any semantics for "automatically opened modules" will not
compose well. So it would be better to provide a system that obviously
doesn't compose than to provide a system that pretends to compose, and
may hide potential bugs.

From yminsky at janestreet.com  Mon Mar 18 15:46:38 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 18 Mar 2013 11:46:38 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>

On Mon, Mar 18, 2013 at 11:15 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> Leo's main argument is that systematically using Pervasives is more
>> predictable for users (that may not want to have to look at namespace
>> descriptions to know which compilation units will be opened by
>> default).
>
> That's certainly an argument, but it is not my main one.
>
>> I'd say in practice it's rather obvious at medium scale (for any given
>> software project) which module is meant to be the
>> Pervasives/Std/Prelude one, and large scale composability by default
>> could be a better choice.
>
> I don't think I've actually suggested providing any means for defining a
> new namespace as the composition of existing namespaces. Nor do I have
> any particular use cases for that feature.
>
> However, my proposal does allow a namespace to be specified across
> multiple locations, and it is important that these specifications are
> composable.
>
> The ordering between these separate specifications will inevitably be
> under-specified, depending on things like the order of command-line
> arguments. That means that any semantics relying on that ordering will
> be potentially fragile. The best we can hope to achieve is to make sure
> that conflicts between specifications are as obvious to the user as
> possible.
>
> We are discussing two possible semantics for "automatically opened
> modules":
>
> 1. Supporting a list of auto-opened modules. The automatic open of these
>    modules is morally equivalent to merging their contents into a single
>    "Pervasives" module and then opening that module.
>
> 2. Only supporting a single "Pervasives" module. Trying to specify two
>    "Pervasives" modules will simply result in one of those modules being
>    chosen ahead of the other.
>
> Of these two semantics, the second one is much more likely to bring
> conflicts to the attention of the user. The first one is more likely to
> hide accidental conflicts resulting in potential bugs.
>
> The second semantics also ensures that conflicts between namespace
> specifications only occur at the level of whole compilation units,
> rather than at the level of individual values and types.
>
> In summary, any semantics for "automatically opened modules" will not
> compose well. So it would be better to provide a system that obviously
> doesn't compose than to provide a system that pretends to compose, and
> may hide potential bugs.

Just to be clear, do you agree with Gabriel's claim that that

open namespace A
open namespace B

will open A#Pervasives and then open B#Pervasives?

As to your larger point, I basically disagree that the possibility of
shadowing implied by (1) is something to be avoided.  Module opens
behave this way, and within Jane Street we've used them extensively,
using limited, purposeful shadowing, for a decade, and to good effect
as far as I can tell.

I basically don't see where your belief that automatically opened
modules are semantically problematic and uncomposeable arises from.
Certainly, my experience with packed modules argues in the other
direction.  Do you propose to delete the possibility of shadowing from
the module language as well?

y

From anil at recoil.org  Mon Mar 18 16:13:41 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 18 Mar 2013 11:13:41 -0500
Subject: [ocaml-platform] A small script for compiler hackers: create
	short-lived opam switches out of any git branch
In-Reply-To: <wf620psule.fsf@gmail.com>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com>
Message-ID: <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>

On 17 Mar 2013, at 14:18, Wojciech Meyer <wojciech.meyer at gmail.com> wrote:

> Hi Gabriel,
> 
> all is needed for testing ocamlbuild and local patches for the compiler,
> thank you.
> 
> Other useful thing in general for OPAM would be something like:
> 
> opam patch add <ordered list_of_patches>
> opam patch reset
> 
> then we are able quickly test some local patches without touching
> command line and invoking makefiles.

Just to clarify this, are you asking for this for the compiler switches,
or for packages, or for both?

Local patches can be made to work with packages via `opam pin`, although
supporting a patch queue model may be useful in the future.

Compiler patches don't exist at the moment within OPAM, but I like Gabriel's
approach of taking an existing tree (that's, e.g., a git repo) and moving
it into the OPAM space.  You can just use the underlying VCS to track your
patches and branches without requiring more complexity in OPAM.

-anil



> 
> Gabriel Scherer <gabriel.scherer at gmail.com> writes:
> 
>> As part of the slowly-evolving benchmark work, I have developed a
>> script to turn any repository that quacks like an OCaml compiler and
>> can run "make world.opt" into an OPAM compiler switch.
>> 
>>  https://github.com/gasche/opam-compiler-conf
>> 
>> The intended use case is to change something, recompile what need be,
>> get a compiler switch for that, and install one or two packages for
>> testing something. You could envision, for example, OPAM being used in
>> the internal loop of a bisection process. In this case it is important
>> that OPAM does not recompile the compiler on its side (so the usual
>> technique of making a tarball of the compiler source and letting OPAM
>> do its job from there is not pleasant in that situation); the scripts
>> makes use of voodoo OPAM compiler options (thanks to Thomas in
>> https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
>> install" each time "opam switch reinstall" is called.
>> 
>> This is a quick&dirty shell script that works on my machine. No
>> guarantee that it will work on yours. It also assumes that the
>> version-control system (VCS) used is git, and calls "git branch" to
>> infer the name of the compiler switch to use. Eventual patches to
>> support other VCSs (or, for example, infer the switch name from the
>> directory name) would be welcome.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
> 


From nicholas.r.lucaroni at gmail.com  Mon Mar 18 16:16:53 2013
From: nicholas.r.lucaroni at gmail.com (Nicholas Lucaroni)
Date: Mon, 18 Mar 2013 12:16:53 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
Message-ID: <CAB6W5F5GJuLMTPpVbXgtK6TuaDJyVw0owTKmdKB0TfssJDXhpQ@mail.gmail.com>

Would it make sense to issuing warnings in the case of shadowing the
Pervasives module? I agree that it makes sense to have Pervasives
opened implicitly but only in the context of stdlib-alternatives and
paradigm implementing/changing libraries.  In the small it sounds like it
could be dangerous --every project having their own library wide coding
standard/pervasive module that shadow the stdlib/paradigm shaping libraries
should be explicitly frowned upon.

Also, what happens if I have a Pervasive module in my project? Would that
be opened in each module by default?



On Mon, Mar 18, 2013 at 11:46 AM, Yaron Minsky <yminsky at janestreet.com>wrote:

> On Mon, Mar 18, 2013 at 11:15 AM, Leo White <lpw25 at cam.ac.uk> wrote:
> >> Leo's main argument is that systematically using Pervasives is more
> >> predictable for users (that may not want to have to look at namespace
> >> descriptions to know which compilation units will be opened by
> >> default).
> >
> > That's certainly an argument, but it is not my main one.
> >
> >> I'd say in practice it's rather obvious at medium scale (for any given
> >> software project) which module is meant to be the
> >> Pervasives/Std/Prelude one, and large scale composability by default
> >> could be a better choice.
> >
> > I don't think I've actually suggested providing any means for defining a
> > new namespace as the composition of existing namespaces. Nor do I have
> > any particular use cases for that feature.
> >
> > However, my proposal does allow a namespace to be specified across
> > multiple locations, and it is important that these specifications are
> > composable.
> >
> > The ordering between these separate specifications will inevitably be
> > under-specified, depending on things like the order of command-line
> > arguments. That means that any semantics relying on that ordering will
> > be potentially fragile. The best we can hope to achieve is to make sure
> > that conflicts between specifications are as obvious to the user as
> > possible.
> >
> > We are discussing two possible semantics for "automatically opened
> > modules":
> >
> > 1. Supporting a list of auto-opened modules. The automatic open of these
> >    modules is morally equivalent to merging their contents into a single
> >    "Pervasives" module and then opening that module.
> >
> > 2. Only supporting a single "Pervasives" module. Trying to specify two
> >    "Pervasives" modules will simply result in one of those modules being
> >    chosen ahead of the other.
> >
> > Of these two semantics, the second one is much more likely to bring
> > conflicts to the attention of the user. The first one is more likely to
> > hide accidental conflicts resulting in potential bugs.
> >
> > The second semantics also ensures that conflicts between namespace
> > specifications only occur at the level of whole compilation units,
> > rather than at the level of individual values and types.
> >
> > In summary, any semantics for "automatically opened modules" will not
> > compose well. So it would be better to provide a system that obviously
> > doesn't compose than to provide a system that pretends to compose, and
> > may hide potential bugs.
>
> Just to be clear, do you agree with Gabriel's claim that that
>
> open namespace A
> open namespace B
>
> will open A#Pervasives and then open B#Pervasives?
>
> As to your larger point, I basically disagree that the possibility of
> shadowing implied by (1) is something to be avoided.  Module opens
> behave this way, and within Jane Street we've used them extensively,
> using limited, purposeful shadowing, for a decade, and to good effect
> as far as I can tell.
>
> I basically don't see where your belief that automatically opened
> modules are semantically problematic and uncomposeable arises from.
> Certainly, my experience with packed modules argues in the other
> direction.  Do you propose to delete the possibility of shadowing from
> the module language as well?
>
> y
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130318/173c52da/attachment-0001.html>

From lpw25 at cam.ac.uk  Mon Mar 18 16:18:16 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 16:18:16 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 (Yaron Minsky's message of "Mon, 18 Mar 2013 11:46:38 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
Message-ID: <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>

> Just to be clear, do you agree with Gabriel's claim that that
>
> open namespace A
> open namespace B
>
> will open A#Pervasives and then open B#Pervasives?

Yes

> As to your larger point, I basically disagree that the possibility of
> shadowing implied by (1) is something to be avoided.  Module opens
> behave this way, and within Jane Street we've used them extensively,
> using limited, purposeful shadowing, for a decade, and to good effect
> as far as I can tell.

Shadowing is fine if the order of definitions is well specified. For
example, module opens are clearly ordered by their position in the
source file.

The problem is with shadowing where the order between definitions is not
well specified.

It is useful to be able to specify a namespace across multiple
locations, for instance within two separate search path files. The
ordering between "automatically opened modules" specified across these
multiple locations will not be well specified (probably depending on the
workings of your build system). This makes shadowing much riskier.

> I basically don't see where your belief that automatically opened
> modules are semantically problematic and uncomposeable arises from.
> Certainly, my experience with packed modules argues in the other
> direction. Do you propose to delete the possibility of shadowing from
> the module language as well?

Modules are defined in a single location, and can only be composed using
"include" statements. These include statements have a clearly defined
ordering.



From thomas at ocamlpro.com  Mon Mar 18 16:21:24 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Mon, 18 Mar 2013 17:21:24 +0100
Subject: [ocaml-platform] [opam-devel] A small script for compiler
	hackers: create short-lived opam switches out of any git branch
In-Reply-To: <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com> <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
Message-ID: <9669B7CC-E026-4709-9426-6697B697A118@ocamlpro.com>

> Compiler patches don't exist at the moment within OPAM, but I like Gabriel's
> approach of taking an existing tree (that's, e.g., a git repo) and moving
> it into the OPAM space.  You can just use the underlying VCS to track your
> patches and branches without requiring more complexity in OPAM.

Not true :-)

You can use

patches: [ ... ]

in your compiler files as well. See: https://github.com/OCamlPro/opam/blob/master/src/core/opamFile.ml#L1167

The patch can be local or available via HTTP.

--
Thomas


> 
> -anil
> 
> 
> 
>> 
>> Gabriel Scherer <gabriel.scherer at gmail.com> writes:
>> 
>>> As part of the slowly-evolving benchmark work, I have developed a
>>> script to turn any repository that quacks like an OCaml compiler and
>>> can run "make world.opt" into an OPAM compiler switch.
>>> 
>>> https://github.com/gasche/opam-compiler-conf
>>> 
>>> The intended use case is to change something, recompile what need be,
>>> get a compiler switch for that, and install one or two packages for
>>> testing something. You could envision, for example, OPAM being used in
>>> the internal loop of a bisection process. In this case it is important
>>> that OPAM does not recompile the compiler on its side (so the usual
>>> technique of making a tarball of the compiler source and letting OPAM
>>> do its job from there is not pleasant in that situation); the scripts
>>> makes use of voodoo OPAM compiler options (thanks to Thomas in
>>> https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
>>> install" each time "opam switch reinstall" is called.
>>> 
>>> This is a quick&dirty shell script that works on my machine. No
>>> guarantee that it will work on yours. It also assumes that the
>>> version-control system (VCS) used is git, and calls "git branch" to
>>> infer the name of the compiler switch to use. Eventual patches to
>>> support other VCSs (or, for example, infer the switch name from the
>>> directory name) would be welcome.
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>> 
> 
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel


From anil at recoil.org  Mon Mar 18 16:24:46 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 18 Mar 2013 11:24:46 -0500
Subject: [ocaml-platform] [opam-devel] A small script for compiler
	hackers: create short-lived opam switches out of any git branch
In-Reply-To: <9669B7CC-E026-4709-9426-6697B697A118@ocamlpro.com>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com> <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
 <9669B7CC-E026-4709-9426-6697B697A118@ocamlpro.com>
Message-ID: <0B0A8E91-DBC7-45ED-B75D-09B55F008B8E@recoil.org>

On 18 Mar 2013, at 11:21, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:

>> Compiler patches don't exist at the moment within OPAM, but I like Gabriel's
>> approach of taking an existing tree (that's, e.g., a git repo) and moving
>> it into the OPAM space.  You can just use the underlying VCS to track your
>> patches and branches without requiring more complexity in OPAM.
> 
> Not true :-)
> 
> You can use
> 
> patches: [ ... ]
> 
> in your compiler files as well. See: https://github.com/OCamlPro/opam/blob/master/src/core/opamFile.ml#L1167
> 
> The patch can be local or available via HTTP.

Aha... I didn't realise these could be local too...very handy!

I still find it easier to work with a git repo directly, rather than having
to generate patch files (unless the branch is for 'publishing' to other people).

-anil

From wojciech.meyer at gmail.com  Mon Mar 18 16:41:24 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Mon, 18 Mar 2013 16:41:24 +0000
Subject: [ocaml-platform] A small script for compiler hackers: create
 short-lived opam switches out of any git branch
In-Reply-To: <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com>
 <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
Message-ID: <CAOg1smBmaAAOFF8NNXtwUbY9Wkm8RwKGU1bzC_Q7CCy0x-LqGw@mail.gmail.com>

So the idea here was to use command line to quick apply patches and
test the integrity them after reviewing, but do this in such way I am
not forced to make the tree full of diffs.

On other hand maybe Gabriel idea scales better, I agree as we want to
commit them eventually.

The idea came to my mind after struggling with testing my patches and
trying out ocamlbuild on OPAM repo which I did but saying just "make
world.opt opt.opt install".

So probably the shell script takes precedence.


On Mon, Mar 18, 2013 at 4:13 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On 17 Mar 2013, at 14:18, Wojciech Meyer <wojciech.meyer at gmail.com> wrote:
>
>> Hi Gabriel,
>>
>> all is needed for testing ocamlbuild and local patches for the compiler,
>> thank you.
>>
>> Other useful thing in general for OPAM would be something like:
>>
>> opam patch add <ordered list_of_patches>
>> opam patch reset
>>
>> then we are able quickly test some local patches without touching
>> command line and invoking makefiles.
>
> Just to clarify this, are you asking for this for the compiler switches,
> or for packages, or for both?
>
> Local patches can be made to work with packages via `opam pin`, although
> supporting a patch queue model may be useful in the future.
>
> Compiler patches don't exist at the moment within OPAM, but I like Gabriel's
> approach of taking an existing tree (that's, e.g., a git repo) and moving
> it into the OPAM space.  You can just use the underlying VCS to track your
> patches and branches without requiring more complexity in OPAM.
>
> -anil
>
>
>
>>
>> Gabriel Scherer <gabriel.scherer at gmail.com> writes:
>>
>>> As part of the slowly-evolving benchmark work, I have developed a
>>> script to turn any repository that quacks like an OCaml compiler and
>>> can run "make world.opt" into an OPAM compiler switch.
>>>
>>>  https://github.com/gasche/opam-compiler-conf
>>>
>>> The intended use case is to change something, recompile what need be,
>>> get a compiler switch for that, and install one or two packages for
>>> testing something. You could envision, for example, OPAM being used in
>>> the internal loop of a bisection process. In this case it is important
>>> that OPAM does not recompile the compiler on its side (so the usual
>>> technique of making a tarball of the compiler source and letting OPAM
>>> do its job from there is not pleasant in that situation); the scripts
>>> makes use of voodoo OPAM compiler options (thanks to Thomas in
>>> https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
>>> install" each time "opam switch reinstall" is called.
>>>
>>> This is a quick&dirty shell script that works on my machine. No
>>> guarantee that it will work on yours. It also assumes that the
>>> version-control system (VCS) used is git, and calls "git branch" to
>>> infer the name of the compiler switch to use. Eventual patches to
>>> support other VCSs (or, for example, infer the switch name from the
>>> directory name) would be welcome.
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
>>
>

From yminsky at janestreet.com  Mon Mar 18 16:43:49 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 18 Mar 2013 12:43:49 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>

On Mon, Mar 18, 2013 at 12:18 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>> Just to be clear, do you agree with Gabriel's claim that that
>>
>> open namespace A
>> open namespace B
>>
>> will open A#Pervasives and then open B#Pervasives?
>
> Yes
>
>> As to your larger point, I basically disagree that the possibility of
>> shadowing implied by (1) is something to be avoided.  Module opens
>> behave this way, and within Jane Street we've used them extensively,
>> using limited, purposeful shadowing, for a decade, and to good effect
>> as far as I can tell.
>
> Shadowing is fine if the order of definitions is well specified. For
> example, module opens are clearly ordered by their position in the
> source file.
>
> The problem is with shadowing where the order between definitions is not
> well specified.

I would argue that this should push us towards making namespace-opens
well-defined in order by default.  I think that opening namespaces on
the command-line should be viewed as a largely second-class operation,
and it would make sense in my mind to restrict it to a single
namespace, which goes before everything else.

> It is useful to be able to specify a namespace across multiple
> locations, for instance within two separate search path files. The
> ordering between "automatically opened modules" specified across these
> multiple locations will not be well specified (probably depending on the
> workings of your build system). This makes shadowing much riskier.

I see.  This is low on my list of priorities.  I would be happy to
require namespaces to be specified all at once in a single location.
That would ensure that namespaces always have a unique definition,
which seems to make life simpler.

But in any case, as long as namespace opens are well-defined and the
namespaces are well defined at the time of the open, I don't see the
problem.  I would be perfectly happy for all module opens to happen
after all module aliases in a namespace if that simplifies matters.

>> I basically don't see where your belief that automatically opened
>> modules are semantically problematic and uncomposeable arises from.
>> Certainly, my experience with packed modules argues in the other
>> direction. Do you propose to delete the possibility of shadowing from
>> the module language as well?
>
> Modules are defined in a single location, and can only be composed using
> "include" statements. These include statements have a clearly defined
> ordering.

Why can't we have the same clear ordering everywhere for namespaces?
What's wrong with having namespaces take on the same kind of ordered
semantics that modules have?

My main criticism of all of this line of thinking is that it seems
like we're looking for a break of semantics between namespaces and
modules, rather than accepting such a break to the degree it comes
necessary.

y

From lpw25 at cam.ac.uk  Mon Mar 18 17:07:25 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 17:07:25 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAB6W5F5GJuLMTPpVbXgtK6TuaDJyVw0owTKmdKB0TfssJDXhpQ@mail.gmail.com>
 (Nicholas Lucaroni's message of "Mon, 18 Mar 2013 12:16:53 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <CAB6W5F5GJuLMTPpVbXgtK6TuaDJyVw0owTKmdKB0TfssJDXhpQ@mail.gmail.com>
Message-ID: <87a9q01vsi.fsf@kingston.cl.cam.ac.uk>

> Would it make sense to issuing warnings in the case of shadowing the
> Pervasives module? 

Possibly, although that would prevent (or at least hinder) delibrate shadowings (as opposed to
accidental conflicts).

> Also, what happens if I have a Pervasive module in my project? Would that be opened in each module by default?

If you mean a module called simply "pervasives.ml", then I think that
this would be shadowed by the pervasives in the standard library. If you
mean a module called "foo-pervasives.ml" (for a package foo), then it
would only be opened automatically by files that included an

    open namespace Foo

statement. This includes other files within the foo package.

From lpw25 at cam.ac.uk  Mon Mar 18 17:27:57 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 17:27:57 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 (Yaron Minsky's message of "Mon, 18 Mar 2013 12:43:49 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
Message-ID: <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>

>> The problem is with shadowing where the order between definitions is not
>> well specified.
>
> I would argue that this should push us towards making namespace-opens
> well-defined in order by default.  I think that opening namespaces on
> the command-line should be viewed as a largely second-class operation,
> and it would make sense in my mind to restrict it to a single
> namespace, which goes before everything else.
>

While the order of command-line namespace opens is another area where
shadowing may be risky, they are not what I am referring to here.

>> It is useful to be able to specify a namespace across multiple
>> locations, for instance within two separate search path files. The
>> ordering between "automatically opened modules" specified across these
>> multiple locations will not be well specified (probably depending on the
>> workings of your build system). This makes shadowing much riskier.
>
> I see.  This is low on my list of priorities.  I would be happy to
> require namespaces to be specified all at once in a single location.
> That would ensure that namespaces always have a unique definition,
> which seems to make life simpler.

Only for supporting multiple "automatically opened modules".

> But in any case, as long as namespace opens are well-defined and the
> namespaces are well defined at the time of the open, I don't see the
> problem.  

Namespaces opens will be well-defined in the sense that they will have
some kind of order. But that order may well depend on the workings of
their build system, so they are not well defined in any meaningful
sense.

>>> I basically don't see where your belief that automatically opened
>>> modules are semantically problematic and uncomposeable arises from.
>>> Certainly, my experience with packed modules argues in the other
>>> direction. Do you propose to delete the possibility of shadowing from
>>> the module language as well?
>>
>> Modules are defined in a single location, and can only be composed using
>> "include" statements. These include statements have a clearly defined
>> ordering.
>
> Why can't we have the same clear ordering everywhere for namespaces?
> What's wrong with having namespaces take on the same kind of ordered
> semantics that modules have?

This would require namespaces to have closed definitions. This would
require a completely different model from the one I have proposed. It
would be less flexible, less powerful, less lightweight, and probably
harder to use. In exchange you would be able to safely define multiple
auto-opened modules for each namespace (which I don't think anyone has
actually asked for).

> My main criticism of all of this line of thinking is that it seems
> like we're looking for a break of semantics between namespaces and
> modules, rather than accepting such a break to the degree it comes
> necessary.

A closed definition is one of the constraints forced on modules by their
need to be represented at run-time as a record. One of the motivations
for namespaces is to provide a system for containing modules that is not
bound by these restrictions. I don't see it as looking for a break with
the semantics of modules, so much as implementing a more flexible
semantics than what is possible with modules.



From thelema314 at gmail.com  Mon Mar 18 17:40:00 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Mon, 18 Mar 2013 13:40:00 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CAL-jcAmypaqmXv-ujC8cYDxO0=HkTMa6V4EBOWbGMSDtmm0PEQ@mail.gmail.com>

>
> > Why can't we have the same clear ordering everywhere for namespaces?
> > What's wrong with having namespaces take on the same kind of ordered
> > semantics that modules have?
>
> This would require namespaces to have closed definitions. This would
> require a completely different model from the one I have proposed. It
> would be less flexible, less powerful, less lightweight, and probably
> harder to use.
>
...

> A closed definition is one of the constraints forced on modules by their
> need to be represented at run-time as a record. One of the motivations
> for namespaces is to provide a system for containing modules that is not
> bound by these restrictions. I don't see it as looking for a break with
> the semantics of modules, so much as implementing a more flexible
> semantics than what is possible with modules.
>
> This is one thing I don't quite understand.  Yes, modules are implemented
as records at runtime, but there's no requirement that namespaces have any
runtime representation; I don't see why they can't exist at compile time
only as something to make changes to the compilation environment when
invoked (open or # or whatever).  As far as the open/closed distinction,
hasn't gasche has gone over this; they can be treated as closed by the
compiler during compilation even if they're open all the rest of the time.

E.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130318/bb1a9a95/attachment.html>

From lpw25 at cam.ac.uk  Mon Mar 18 17:50:33 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 17:50:33 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAL-jcAmypaqmXv-ujC8cYDxO0=HkTMa6V4EBOWbGMSDtmm0PEQ@mail.gmail.com>
 (Edgar Friendly's message of "Mon, 18 Mar 2013 13:40:00 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
 <CAL-jcAmypaqmXv-ujC8cYDxO0=HkTMa6V4EBOWbGMSDtmm0PEQ@mail.gmail.com>
Message-ID: <87sj3szjfa.fsf@kingston.cl.cam.ac.uk>

> This is one thing I don't quite understand.? Yes, modules are implemented as records at runtime, but there's no
> requirement that namespaces have any runtime representation; I don't see why they can't exist at compile time only as
> something to make changes to the compilation environment when invoked
> (open or # or whatever).

Namespaces will indeed only exist at compile-time.

> As far as the open/
> closed distinction, hasn't gasche has gone over this; they can be treated as closed by the compiler during compilation
> even if they're open all the rest of the time.?

Ensuring a well-defined ordering between multiple "automatically opened
modules" would require namespaces to be closed all the time, not just
during a particular compilation.

From gabriel.scherer at gmail.com  Mon Mar 18 18:03:10 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 18 Mar 2013 19:03:10 +0100
Subject: [ocaml-platform] A small script for compiler hackers: create
 short-lived opam switches out of any git branch
In-Reply-To: <CAOg1smBmaAAOFF8NNXtwUbY9Wkm8RwKGU1bzC_Q7CCy0x-LqGw@mail.gmail.com>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com> <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
 <CAOg1smBmaAAOFF8NNXtwUbY9Wkm8RwKGU1bzC_Q7CCy0x-LqGw@mail.gmail.com>
Message-ID: <CAPFanBFgjHPk=jF8wq5RSaEeShsEnu-xbjKZzhnvRJGEhdtWWg@mail.gmail.com>

I think my approach and the "patch" feature fulfill different needs:
the point here is that opam does *not* recompile the sources when
installing the switch. If you only provide an archive and a patch,
opam will have to recompile the sources.
I see my script as useful locally for compiler hackers (make
world.opt, hack a bit, make all to recompile only what's changed, opam
install & test, hack a bit, make all, opam install & test).
On the other side, the "patch" feature is useful if you want to
distribute your patches to less savvy users ("check my new
optimization patchset against your own programs", BER-MetaOCaml,
etc...).

On Mon, Mar 18, 2013 at 5:41 PM, Wojciech Meyer
<wojciech.meyer at gmail.com> wrote:
> So the idea here was to use command line to quick apply patches and
> test the integrity them after reviewing, but do this in such way I am
> not forced to make the tree full of diffs.
>
> On other hand maybe Gabriel idea scales better, I agree as we want to
> commit them eventually.
>
> The idea came to my mind after struggling with testing my patches and
> trying out ocamlbuild on OPAM repo which I did but saying just "make
> world.opt opt.opt install".
>
> So probably the shell script takes precedence.
>
>
> On Mon, Mar 18, 2013 at 4:13 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> On 17 Mar 2013, at 14:18, Wojciech Meyer <wojciech.meyer at gmail.com> wrote:
>>
>>> Hi Gabriel,
>>>
>>> all is needed for testing ocamlbuild and local patches for the compiler,
>>> thank you.
>>>
>>> Other useful thing in general for OPAM would be something like:
>>>
>>> opam patch add <ordered list_of_patches>
>>> opam patch reset
>>>
>>> then we are able quickly test some local patches without touching
>>> command line and invoking makefiles.
>>
>> Just to clarify this, are you asking for this for the compiler switches,
>> or for packages, or for both?
>>
>> Local patches can be made to work with packages via `opam pin`, although
>> supporting a patch queue model may be useful in the future.
>>
>> Compiler patches don't exist at the moment within OPAM, but I like Gabriel's
>> approach of taking an existing tree (that's, e.g., a git repo) and moving
>> it into the OPAM space.  You can just use the underlying VCS to track your
>> patches and branches without requiring more complexity in OPAM.
>>
>> -anil
>>
>>
>>
>>>
>>> Gabriel Scherer <gabriel.scherer at gmail.com> writes:
>>>
>>>> As part of the slowly-evolving benchmark work, I have developed a
>>>> script to turn any repository that quacks like an OCaml compiler and
>>>> can run "make world.opt" into an OPAM compiler switch.
>>>>
>>>>  https://github.com/gasche/opam-compiler-conf
>>>>
>>>> The intended use case is to change something, recompile what need be,
>>>> get a compiler switch for that, and install one or two packages for
>>>> testing something. You could envision, for example, OPAM being used in
>>>> the internal loop of a bisection process. In this case it is important
>>>> that OPAM does not recompile the compiler on its side (so the usual
>>>> technique of making a tarball of the compiler source and letting OPAM
>>>> do its job from there is not pleasant in that situation); the scripts
>>>> makes use of voodoo OPAM compiler options (thanks to Thomas in
>>>> https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
>>>> install" each time "opam switch reinstall" is called.
>>>>
>>>> This is a quick&dirty shell script that works on my machine. No
>>>> guarantee that it will work on yours. It also assumes that the
>>>> version-control system (VCS) used is git, and calls "git branch" to
>>>> infer the name of the compiler switch to use. Eventual patches to
>>>> support other VCSs (or, for example, infer the switch name from the
>>>> directory name) would be welcome.
>>> _______________________________________________
>>> Platform mailing list
>>> Platform at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/platform
>>>
>>

From thelema314 at gmail.com  Mon Mar 18 18:08:55 2013
From: thelema314 at gmail.com (Edgar Friendly)
Date: Mon, 18 Mar 2013 14:08:55 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87sj3szjfa.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
 <CAL-jcAmypaqmXv-ujC8cYDxO0=HkTMa6V4EBOWbGMSDtmm0PEQ@mail.gmail.com>
 <87sj3szjfa.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CAL-jcAnxQVPdwmtXbpdmB1W+W9bTOvSmtWPYph2SmhufzGqivQ@mail.gmail.com>

On Mon, Mar 18, 2013 at 1:50 PM, Leo White <lpw25 at cam.ac.uk> wrote:

>  Ensuring a well-defined ordering between multiple "automatically opened
> modules" would require namespaces to be closed all the time, not just
> during a particular compilation.
>


The reason for this evades me; I don't see why ordering module includes
would require namespaces to be closed all the time.  Is this because the
open order of namespaces used by all compilation units of a project must
have a consistent ordering?  As far as shadowing is concerned, this
shouldn't be a problem; each module can bind to different sets of
identifiers.  As for link order, can't this just be determined by the
namespace order at link time?  What am I missing?

E.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130318/ec005a26/attachment-0001.html>

From lpw25 at cam.ac.uk  Mon Mar 18 18:28:30 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 18 Mar 2013 18:28:30 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAL-jcAnxQVPdwmtXbpdmB1W+W9bTOvSmtWPYph2SmhufzGqivQ@mail.gmail.com>
 (Edgar Friendly's message of "Mon, 18 Mar 2013 14:08:55 -0400")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
 <CAL-jcAmypaqmXv-ujC8cYDxO0=HkTMa6V4EBOWbGMSDtmm0PEQ@mail.gmail.com>
 <87sj3szjfa.fsf@kingston.cl.cam.ac.uk>
 <CAL-jcAnxQVPdwmtXbpdmB1W+W9bTOvSmtWPYph2SmhufzGqivQ@mail.gmail.com>
Message-ID: <87mwu0zho1.fsf@kingston.cl.cam.ac.uk>

>     Ensuring a well-defined ordering between multiple "automatically opened
>     modules" would require namespaces to be closed all the time, not just
>     during a particular compilation.
>
> The reason for this evades me; I don't see why ordering module includes would require namespaces to be closed all the
> time.? Is this because the open order of namespaces used by all compilation units of a project must have a consistent
> ordering?? As far as shadowing is concerned, this shouldn't be a problem; each module can bind to different sets of
> identifiers.? As for link order, can't this just be determined by the namespace order at link time?? What am I missing?

I'm afraid I don't really follow this paragraph.

When I say that a namespace must be closed I mean that it must be
defined in a single location (i.e. within a single file). 

When I say that namespaces must be closed all the time, not just during
a particular compilation, I mean that it is not sufficient for the
compiler to look up the separate parts of an open definition and then
merge them into a single closed definition to use for the duration of a
particular compilation.

From martin at mjambon.com  Mon Mar 18 19:18:14 2013
From: martin at mjambon.com (Martin Jambon)
Date: Mon, 18 Mar 2013 12:18:14 -0700
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51476876.5090104@mjambon.com>

On 03/18/2013 10:27 AM, Leo White wrote:
>>> The problem is with shadowing where the order between definitions is not
>>> well specified.
>>
>> I would argue that this should push us towards making namespace-opens
>> well-defined in order by default.  I think that opening namespaces on
>> the command-line should be viewed as a largely second-class operation,
>> and it would make sense in my mind to restrict it to a single
>> namespace, which goes before everything else.
>>
>
> While the order of command-line namespace opens is another area where
> shadowing may be risky, they are not what I am referring to here.
>
>>> It is useful to be able to specify a namespace across multiple
>>> locations, for instance within two separate search path files. The
>>> ordering between "automatically opened modules" specified across these
>>> multiple locations will not be well specified (probably depending on the
>>> workings of your build system). This makes shadowing much riskier.
>>
>> I see.  This is low on my list of priorities.  I would be happy to
>> require namespaces to be specified all at once in a single location.
>> That would ensure that namespaces always have a unique definition,
>> which seems to make life simpler.
>
> Only for supporting multiple "automatically opened modules".
>
>> But in any case, as long as namespace opens are well-defined and the
>> namespaces are well defined at the time of the open, I don't see the
>> problem.
>
> Namespaces opens will be well-defined in the sense that they will have
> some kind of order. But that order may well depend on the workings of
> their build system, so they are not well defined in any meaningful
> sense.
>
>>>> I basically don't see where your belief that automatically opened
>>>> modules are semantically problematic and uncomposeable arises from.
>>>> Certainly, my experience with packed modules argues in the other
>>>> direction. Do you propose to delete the possibility of shadowing from
>>>> the module language as well?
>>>
>>> Modules are defined in a single location, and can only be composed using
>>> "include" statements. These include statements have a clearly defined
>>> ordering.
>>
>> Why can't we have the same clear ordering everywhere for namespaces?
>> What's wrong with having namespaces take on the same kind of ordered
>> semantics that modules have?
>
> This would require namespaces to have closed definitions. This would
> require a completely different model from the one I have proposed. It
> would be less flexible, less powerful, less lightweight, and probably
> harder to use. In exchange you would be able to safely define multiple
> auto-opened modules for each namespace (which I don't think anyone has
> actually asked for).

[pardon me if this has been discussed before, I'm just jumping in the 
conversation and likely don't understand all the issues]

I don't think it would require namespaces to have closed definitions, 
which would defeat their purpose. It would only require to know which 
libraries are being *used* by the current source file (library = ordered 
collection of modules within the same namespace; different libraries can 
use the same namespace).

The following seems fairly natural to me:
1. have an "import" keyword or similar for specifying which libraries 
are being used, the order of the imports defining module order
2. open namespaces and modules at will

Point 1 defines locally the order of the visible modules without 
requiring the namespaces to be closed. Also, it makes the program's 
dependencies explicit and makes standalone programs self-buildable.

import Theirnamespace.Theirlibrary
import Othernamespace.Otherlibrary
import Theirnamespace.Somelibrary

(* assuming:
    - auto-open of the above libraries
    - no such thing as "open namespace"
*)

open ModuleA
   (* look for ModuleA it in Theirnamespace.Somelibrary,
      then in Othernamespace.Otherlibrary and finally in
      Theirnamespace.Theirlibrary *)

open Othernamespace#ModuleA
   (* open ModuleA provided by Othernamespace *)


Martin


From martin at mjambon.com  Mon Mar 18 19:28:52 2013
From: martin at mjambon.com (Martin Jambon)
Date: Mon, 18 Mar 2013 12:28:52 -0700
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <51476876.5090104@mjambon.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk> <51476876.5090104@mjambon.com>
Message-ID: <51476AF4.2040207@mjambon.com>

On Mon 18 Mar 2013 12:18:14 PM PDT, Martin Jambon wrote:
> On 03/18/2013 10:27 AM, Leo White wrote:
>>>> The problem is with shadowing where the order between definitions
>>>> is not
>>>> well specified.
>>>
>>> I would argue that this should push us towards making namespace-opens
>>> well-defined in order by default.  I think that opening namespaces on
>>> the command-line should be viewed as a largely second-class operation,
>>> and it would make sense in my mind to restrict it to a single
>>> namespace, which goes before everything else.
>>>
>>
>> While the order of command-line namespace opens is another area where
>> shadowing may be risky, they are not what I am referring to here.
>>
>>>> It is useful to be able to specify a namespace across multiple
>>>> locations, for instance within two separate search path files. The
>>>> ordering between "automatically opened modules" specified across these
>>>> multiple locations will not be well specified (probably depending
>>>> on the
>>>> workings of your build system). This makes shadowing much riskier.
>>>
>>> I see.  This is low on my list of priorities.  I would be happy to
>>> require namespaces to be specified all at once in a single location.
>>> That would ensure that namespaces always have a unique definition,
>>> which seems to make life simpler.
>>
>> Only for supporting multiple "automatically opened modules".
>>
>>> But in any case, as long as namespace opens are well-defined and the
>>> namespaces are well defined at the time of the open, I don't see the
>>> problem.
>>
>> Namespaces opens will be well-defined in the sense that they will have
>> some kind of order. But that order may well depend on the workings of
>> their build system, so they are not well defined in any meaningful
>> sense.
>>
>>>>> I basically don't see where your belief that automatically opened
>>>>> modules are semantically problematic and uncomposeable arises from.
>>>>> Certainly, my experience with packed modules argues in the other
>>>>> direction. Do you propose to delete the possibility of shadowing from
>>>>> the module language as well?
>>>>
>>>> Modules are defined in a single location, and can only be composed
>>>> using
>>>> "include" statements. These include statements have a clearly defined
>>>> ordering.
>>>
>>> Why can't we have the same clear ordering everywhere for namespaces?
>>> What's wrong with having namespaces take on the same kind of ordered
>>> semantics that modules have?
>>
>> This would require namespaces to have closed definitions. This would
>> require a completely different model from the one I have proposed. It
>> would be less flexible, less powerful, less lightweight, and probably
>> harder to use. In exchange you would be able to safely define multiple
>> auto-opened modules for each namespace (which I don't think anyone has
>> actually asked for).
>
> [pardon me if this has been discussed before, I'm just jumping in the
> conversation and likely don't understand all the issues]
>
> I don't think it would require namespaces to have closed definitions,
> which would defeat their purpose. It would only require to know which
> libraries are being *used* by the current source file (library =
> ordered collection of modules within the same namespace; different
> libraries can use the same namespace).

different libraries can *belong to* the same namespace.

> The following seems fairly natural to me:
> 1. have an "import" keyword or similar for specifying which libraries
> are being used, the order of the imports defining module order
> 2. open namespaces and modules at will

We actually wouldn't open namespaces at all, as noted in what follows.

> Point 1 defines locally the order of the visible modules without
> requiring the namespaces to be closed. Also, it makes the program's
> dependencies explicit and makes standalone programs self-buildable.
>
> import Theirnamespace.Theirlibrary
> import Othernamespace.Otherlibrary
> import Theirnamespace.Somelibrary
>
> (* assuming:
>    - auto-open of the above libraries
>    - no such thing as "open namespace"
> *)
>
> open ModuleA
>   (* look for ModuleA it in Theirnamespace.Somelibrary,
>      then in Othernamespace.Otherlibrary and finally in
>      Theirnamespace.Theirlibrary *)
>
> open Othernamespace#ModuleA
>   (* open ModuleA provided by Othernamespace *)


From daniel.buenzli at erratique.ch  Tue Mar 19 00:56:14 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 19 Mar 2013 01:56:14 +0100
Subject: [ocaml-platform] Patching packages (was Re: [opam-devel] A small
 script for compiler hackers: create short-lived opam switches out of any
 git branch)
In-Reply-To: <9669B7CC-E026-4709-9426-6697B697A118@ocamlpro.com>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com>
 <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
 <9669B7CC-E026-4709-9426-6697B697A118@ocamlpro.com>
Message-ID: <0F4674D723B446349AC4809560814966@erratique.ch>

Le lundi, 18 mars 2013 ? 17:21, Thomas Gazagnaire a ?crit :
> You can use
>  
> patches: [ ... ]
>  
> in your compiler files as well. See: https://github.com/OCamlPro/opam/blob/master/src/core/opamFile.ml#L1167
>  
> The patch can be local or available via HTTP.
Is there a way to specify patches during install ? That is patching an existing package without redoing a package.  

The use case is that I have this patch [1] on ocp-indent that seems unlikely to be integrated (cf. [2]). Now I would like to be able to benefit from ocp-indent's default package updates but just apply the patch before installing.  

Is there a simple workflow to achieve that ?

Best,

Daniel

[1] https://github.com/dbuenzli/ocp-indent/commit/8e76b83b8ee8e3c084a39b3d02c9a2f331e91dd9
[2] https://github.com/OCamlPro/ocp-indent/issues/37



From yminsky at janestreet.com  Tue Mar 19 01:14:27 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 18 Mar 2013 21:14:27 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jRf8VkQqwf4Y9dZ4U=J52gbNkCTCEvfYMqew99-ADrU_w@mail.gmail.com>
 <CAPFanBGip2OAzHk-kQtKF35ASvEmq432OtEf6K_ExfgzjxHyfQ@mail.gmail.com>
 <87zjy10wga.fsf@kingston.cl.cam.ac.uk>
 <CADKNfhJgfV6ww8wS4d=_tLWhJkPjHYWu4uccQnoEaLvDLNYHmQ@mail.gmail.com>
 <87sj3s28ft.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jS9OBz1-W7FHJLydMBt6c72QL8m+axuD41b9-vKYo8BHQ@mail.gmail.com>
 <CAPFanBFJKTNRqD0YzBvzac4-9RHsCtK5bqXFfqt0Hx+tBWvnKw@mail.gmail.com>
 <CACLX4jQHLRV4VrPKFtO4g1Pu0Fm2BiRn81pYPK2S9rPDEOHysg@mail.gmail.com>
 <CAPFanBGKMHo8buSD-qTAmPGehKMC03exUozZdewcFkeMznUeCA@mail.gmail.com>
 <87mwu020zc.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSHbJRhVXkCYLJbyvVQnegTAADVx8dTtNXtjGj9mNoMFQ@mail.gmail.com>
 <87ehfc1y2f.fsf@kingston.cl.cam.ac.uk>
 <CACLX4jSNGtx3Rh=4y_u2sUYXGh-zNgLg1y72WRVE5BPYOK3CSQ@mail.gmail.com>
 <87zjy0zkgy.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CACLX4jQQyaw-t8BdJ96QQmVtPZQy81e19Z-Gg03Af0q2oz9AcA@mail.gmail.com>

On Mon, Mar 18, 2013 at 1:27 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>>> The problem is with shadowing where the order between definitions is not
>>> well specified.
>>
>> I would argue that this should push us towards making namespace-opens
>> well-defined in order by default.  I think that opening namespaces on
>> the command-line should be viewed as a largely second-class operation,
>> and it would make sense in my mind to restrict it to a single
>> namespace, which goes before everything else.
>>
>
> While the order of command-line namespace opens is another area where
> shadowing may be risky, they are not what I am referring to here.
>
>>> It is useful to be able to specify a namespace across multiple
>>> locations, for instance within two separate search path files. The
>>> ordering between "automatically opened modules" specified across these
>>> multiple locations will not be well specified (probably depending on the
>>> workings of your build system). This makes shadowing much riskier.
>>
>> I see.  This is low on my list of priorities.  I would be happy to
>> require namespaces to be specified all at once in a single location.
>> That would ensure that namespaces always have a unique definition,
>> which seems to make life simpler.
>
> Only for supporting multiple "automatically opened modules".
>
>> But in any case, as long as namespace opens are well-defined and the
>> namespaces are well defined at the time of the open, I don't see the
>> problem.
>
> Namespaces opens will be well-defined in the sense that they will have
> some kind of order. But that order may well depend on the workings of
> their build system, so they are not well defined in any meaningful
> sense.
>
>>>> I basically don't see where your belief that automatically opened
>>>> modules are semantically problematic and uncomposeable arises from.
>>>> Certainly, my experience with packed modules argues in the other
>>>> direction. Do you propose to delete the possibility of shadowing from
>>>> the module language as well?
>>>
>>> Modules are defined in a single location, and can only be composed using
>>> "include" statements. These include statements have a clearly defined
>>> ordering.
>>
>> Why can't we have the same clear ordering everywhere for namespaces?
>> What's wrong with having namespaces take on the same kind of ordered
>> semantics that modules have?
>
> This would require namespaces to have closed definitions. This would
> require a completely different model from the one I have proposed. It
> would be less flexible, less powerful, less lightweight, and probably
> harder to use. In exchange you would be able to safely define multiple
> auto-opened modules for each namespace (which I don't think anyone has
> actually asked for).
>
>> My main criticism of all of this line of thinking is that it seems
>> like we're looking for a break of semantics between namespaces and
>> modules, rather than accepting such a break to the degree it comes
>> necessary.
>
> A closed definition is one of the constraints forced on modules by their
> need to be represented at run-time as a record. One of the motivations
> for namespaces is to provide a system for containing modules that is not
> bound by these restrictions. I don't see it as looking for a break with
> the semantics of modules, so much as implementing a more flexible
> semantics than what is possible with modules.

I think I understand your point now.  I don't have any objections
really to the semantics you propose here.

y

From alain.frisch at lexifi.com  Tue Mar 19 08:32:36 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 09:32:36 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
Message-ID: <514822A4.2040507@lexifi.com>

Consider the following piece of code:

  module X = struct let x = 1 end
  open namespace Foo
  let a = X.x

and assume that there is a module Foo#X.  Would X.x refer to this 
module, or to the one defined defined on the first line?

The least surprising semantics is probably the first one (opening a 
namespace can hide local modules), but the other one can also be 
justified by saying that namespaces only organize the lookup of 
compilation units on the filesystem, which is (currently) done only when 
modules cannot be resolved in the local environment.

Moreover, the second semantics has nice properties:

   (i) It is much easier to implement: one only needs to maintain a list 
of opened namespaces in the typing environment, to be used during lookup 
on the filesystem. I see only two ways to implement the first semantics:

     - Scan the search path for all foo-*.cmi files when processing the 
"open namespace" statement (i.e. use Sys.readdir, and not only 
Sys.file_exists as today), in addition to the search path files.  This 
would probably work ok with most current build systems, but it would 
prevent from doing "live" discovery of dependencies by instrumentation 
of system calls (I've created a few years ago a toy build tool based on 
capturing calls to open/stat though LD_PRELOAD, and it worked quite well).

     - Completely change the representation of the typing environments 
to maintain a list of "layers" made either of local scopes or namespace 
opens.

   (ii) It allows to write more robust code w.r.t. to future additions 
to namespaces.  With namespaces, library authors won't hesitate to use 
"short" names for their modules and the risk is high that a "open 
namespace" statement hide local modules when the library is extended.

   (iii) It makes dependency analysis more precise (and code easier to 
read).  In the example above, ocamldep knows (with the second semantics) 
that there is no dependency to an external unit X.


-- Alain

From alain.frisch at lexifi.com  Tue Mar 19 08:54:23 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 09:54:23 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <514822A4.2040507@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
Message-ID: <514827BF.4070901@lexifi.com>

Two more comments on Leo's proposal:

1. I think we should look for a different notation than Foo # Bar for 
namespace qualification.  "#" is already used for the method calls; it 
should be possible to implement this notation without creating conflicts 
in the grammar, but it might create confusion.  Consider the expression:

   Foo#Bar.my_object # f Foo#Bar.e

(I've been kind enough to avoid putting whitespaces around '#' when used 
for namespaces).

I haven't really thought about a good alternative, but what about using 
".." instead of "#" ?

2. I think we should get rid of the aliasing feature in search path 
files ("Foo#Baz : Foo#Bar").  I expect that only advanced users will 
write search path files, and then can do the resolution themselves (or 
this could be automated).  Aliases don't really simplify the life of 
end-users and they add complexity to the resolution mechanism (which 
might need to be re-implemented by build systems).


Alain

From lpw25 at cam.ac.uk  Tue Mar 19 10:11:58 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 19 Mar 2013 10:11:58 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <514822A4.2040507@lexifi.com> (Alain Frisch's message of "Tue, 19
 Mar 2013 09:32:36 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
Message-ID: <87li9jsnpt.fsf@kingston.cl.cam.ac.uk>

> Consider the following piece of code:
>
>  module X = struct let x = 1 end
>  open namespace Foo
>  let a = X.x
>
> and assume that there is a module Foo#X.  Would X.x refer to this module, or to the one defined defined on the first
> line?
>

While the second semantics may be easier to implement, it would be
completely counter-intuitive to OCaml programmers.

> [...] I see only two ways to implement the first semantics:
>
>     - Scan the search path for all foo-*.cmi files when processing the "open namespace" statement (i.e. use Sys.readdir,
> and not only Sys.file_exists as today), in addition to the search path files.  This would probably work ok with most
> current build systems, but it would prevent from doing "live" discovery of dependencies by instrumentation of system
> calls (I've created a few years ago a toy build tool based on capturing calls to open/stat though LD_PRELOAD, and it
> worked quite well).
>
>     - Completely change the representation of the typing environments to maintain a list of "layers" made either of
> local scopes or namespace opens.
>

Neither of these options seems particularly problematic to me. The
first one might be more in line with checking that some "foo-*.cmi"
exists when the Foo namespace is opened so that typos produce an error
or warning. But if Sys.readdir is a problem then the second option is
perfectly viable.

>   (ii) It allows to write more robust code w.r.t. to future additions to namespaces.  With namespaces, library authors
> won't hesitate to use "short" names for their modules and the risk is high that a "open namespace" statement hide local
> modules when the library is extended.

This is basically just an argument against "open namespace" shadowing
things but, as Yaron has said, OCaml uses shadowing all the time and it
doesn't seem to have caused too many problems. If in doubt use explicit
references instead of opens.

>   (iii) It makes dependency analysis more precise (and code easier to read).  In the example above, ocamldep knows (with
> the second semantics) that there is no dependency to an external unit X.

This is no worse than how ocamldep currently handles modules contained
within other modules.

From lpw25 at cam.ac.uk  Tue Mar 19 10:38:00 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 19 Mar 2013 10:38:00 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <514827BF.4070901@lexifi.com> (Alain Frisch's message of "Tue, 19
 Mar 2013 09:54:23 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com>
Message-ID: <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>

Alain Frisch <alain.frisch at lexifi.com> writes:

> Two more comments on Leo's proposal:
>
> 1. I think we should look for a different notation than Foo # Bar for namespace qualification.  "#" is already used for
> the method calls; it should be possible to implement this notation without creating conflicts in the grammar, but it
> might create confusion.  Consider the expression:
>
>   Foo#Bar.my_object # f Foo#Bar.e
>
> (I've been kind enough to avoid putting whitespaces around '#' when used for namespaces).

While I'm certainly not against a different notation, I would point out
that this example is no worse than:

    Foo.Bar.my_record . f Foo.Bar.e

which is currently a valid expression.

> I haven't really thought about a good alternative, but what about using ".." instead of "#" ?

To me Foo..Bar looks like some kind of range.

> 2. I think we should get rid of the aliasing feature in search path files ("Foo#Baz : Foo#Bar").  I expect that only
> advanced users will write search path files, and then can do the
> resolution themselves (or this could be automated).

This would prevent one package from providing aliases for modules in
another package. It is much safer to provide an alias to Core#Mutex than
to provide one to core-mutex.cmi and hope that Jane Street doesn't
change its file name.

> Aliases don't really simplify the life of end-users and they add complexity to the resolution mechanism (which might
> need to be re-implemented by build systems).

The complexity added is minuscule. 

As I have previously proposed, ocamldep (or some other tool) would
support the following use:

    ocamldep -lookup Foo#Baz foo.mlpath

This would lookup Foo#Baz within the search path file "foo.mlpath", if
it finds a mapping then it returns that mapping.

So the lookup logic is:

    name := Foo#Baz
    while there are more paths
        if !path is a directory then
            check for file named !name in !path
            if it found a file then
                return the filename
        else !path is a file
            run "ocamldep -lookup !name !path"
            if it found a mapping
                if mapping was a filename then
                    return the filename
                else mapping was an alias
                    name := !alias
            
So aliases add a single if condition.

From gabriel.scherer at gmail.com  Tue Mar 19 10:49:46 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 19 Mar 2013 11:49:46 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CAPFanBGg+UdAxQpqJaqmiDXQmMnDBOjV=xa3vSE872uHVxtnsg@mail.gmail.com>

I think that to help tooling (and programmers) we could allow explicit
disambiguation of capitalized names (as mentioned in spec.pdf).

The idea is that while "X" may refer to either an internal module
defined in the program (or introduced in scope by an "open module") or
a compilation unit name, ".X" can only be an internal module, while
"..X" (I'm reusing Alain's proposed .. notation here) can only be a
compilation unit name.

So, to reuse Alain's example,

  module X = struct let x = 1 end
  open namespace Foo
  let a = X.x

would be ambiguous, but

  module X = struct let x = 1 end
  open namespace Foo
  let a = .X.x

or

  module X = struct let x = 1 end
  open namespace Foo
  let a = ..X.x

would not.

(I'm again not talking about the concrete syntax here: . or .. would
create ambiguities, for example "Some .X.bar". But merely the idea to
get rid of the syntactic ambiguity between external and internal
modules, which allows careful users to make "ocamldep" trivially
correct without any approximation.)

On Tue, Mar 19, 2013 at 11:38 AM, Leo White <lpw25 at cam.ac.uk> wrote:
> Alain Frisch <alain.frisch at lexifi.com> writes:
>
>> Two more comments on Leo's proposal:
>>
>> 1. I think we should look for a different notation than Foo # Bar for namespace qualification.  "#" is already used for
>> the method calls; it should be possible to implement this notation without creating conflicts in the grammar, but it
>> might create confusion.  Consider the expression:
>>
>>   Foo#Bar.my_object # f Foo#Bar.e
>>
>> (I've been kind enough to avoid putting whitespaces around '#' when used for namespaces).
>
> While I'm certainly not against a different notation, I would point out
> that this example is no worse than:
>
>     Foo.Bar.my_record . f Foo.Bar.e
>
> which is currently a valid expression.
>
>> I haven't really thought about a good alternative, but what about using ".." instead of "#" ?
>
> To me Foo..Bar looks like some kind of range.
>
>> 2. I think we should get rid of the aliasing feature in search path files ("Foo#Baz : Foo#Bar").  I expect that only
>> advanced users will write search path files, and then can do the
>> resolution themselves (or this could be automated).
>
> This would prevent one package from providing aliases for modules in
> another package. It is much safer to provide an alias to Core#Mutex than
> to provide one to core-mutex.cmi and hope that Jane Street doesn't
> change its file name.
>
>> Aliases don't really simplify the life of end-users and they add complexity to the resolution mechanism (which might
>> need to be re-implemented by build systems).
>
> The complexity added is minuscule.
>
> As I have previously proposed, ocamldep (or some other tool) would
> support the following use:
>
>     ocamldep -lookup Foo#Baz foo.mlpath
>
> This would lookup Foo#Baz within the search path file "foo.mlpath", if
> it finds a mapping then it returns that mapping.
>
> So the lookup logic is:
>
>     name := Foo#Baz
>     while there are more paths
>         if !path is a directory then
>             check for file named !name in !path
>             if it found a file then
>                 return the filename
>         else !path is a file
>             run "ocamldep -lookup !name !path"
>             if it found a mapping
>                 if mapping was a filename then
>                     return the filename
>                 else mapping was an alias
>                     name := !alias
>
> So aliases add a single if condition.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at gmail.com  Tue Mar 19 10:52:52 2013
From: yminsky at gmail.com (Yaron Minsky)
Date: Tue, 19 Mar 2013 06:52:52 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <514827BF.4070901@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <514822A4.2040507@lexifi.com> <514827BF.4070901@lexifi.com>
Message-ID: <CADKNfhKXLnQ+NyU=tYcFqhHzJ5mkAmbk+JBdip4RZeOuAw7coA@mail.gmail.com>

On Tue, Mar 19, 2013 at 4:54 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> Two more comments on Leo's proposal:
>
> 1. I think we should look for a different notation than Foo # Bar for
> namespace qualification.  "#" is already used for the method calls; it
> should be possible to implement this notation without creating conflicts in
> the grammar, but it might create confusion.  Consider the expression:
>
>   Foo#Bar.my_object # f Foo#Bar.e
>
> (I've been kind enough to avoid putting whitespaces around '#' when used for
> namespaces).
>
> I haven't really thought about a good alternative, but what about using ".."
> instead of "#" ?

+1.  Syntax is annoying to argue about, but my intuition is to
strongly prefer .. to #.

> 2. I think we should get rid of the aliasing feature in search path files
> ("Foo#Baz : Foo#Bar").  I expect that only advanced users will write search
> path files, and then can do the resolution themselves (or this could be
> automated).  Aliases don't really simplify the life of end-users and they
> add complexity to the resolution mechanism (which might need to be
> re-implemented by build systems).
>
>
>
> Alain
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From yminsky at gmail.com  Tue Mar 19 10:57:49 2013
From: yminsky at gmail.com (Yaron Minsky)
Date: Tue, 19 Mar 2013 06:57:49 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87li9jsnpt.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <514822A4.2040507@lexifi.com>
 <87li9jsnpt.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CADKNfh+FuBp6WcvMAs0_dgApRfXSep+e0VZpQCmLLnOQiceSXg@mail.gmail.com>

I agree with Leo that this seems like an awkward departure from the
semantics of naming elsewhere in OCaml.

For what it's worth, most of the time, namespace declarations will
happen only at the beginning of a file, at which point Alain's
semantics don't change anything.  I think that means that the
precision he is looking for can most of the time be obtained without
changing the semantics in the way he describes.

y

On Tue, Mar 19, 2013 at 6:11 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> Consider the following piece of code:
>>
>>  module X = struct let x = 1 end
>>  open namespace Foo
>>  let a = X.x
>>
>> and assume that there is a module Foo#X.  Would X.x refer to this module, or to the one defined defined on the first
>> line?
>>
>
> While the second semantics may be easier to implement, it would be
> completely counter-intuitive to OCaml programmers.
>
>> [...] I see only two ways to implement the first semantics:
>>
>>     - Scan the search path for all foo-*.cmi files when processing the "open namespace" statement (i.e. use Sys.readdir,
>> and not only Sys.file_exists as today), in addition to the search path files.  This would probably work ok with most
>> current build systems, but it would prevent from doing "live" discovery of dependencies by instrumentation of system
>> calls (I've created a few years ago a toy build tool based on capturing calls to open/stat though LD_PRELOAD, and it
>> worked quite well).
>>
>>     - Completely change the representation of the typing environments to maintain a list of "layers" made either of
>> local scopes or namespace opens.
>>
>
> Neither of these options seems particularly problematic to me. The
> first one might be more in line with checking that some "foo-*.cmi"
> exists when the Foo namespace is opened so that typos produce an error
> or warning. But if Sys.readdir is a problem then the second option is
> perfectly viable.
>
>>   (ii) It allows to write more robust code w.r.t. to future additions to namespaces.  With namespaces, library authors
>> won't hesitate to use "short" names for their modules and the risk is high that a "open namespace" statement hide local
>> modules when the library is extended.
>
> This is basically just an argument against "open namespace" shadowing
> things but, as Yaron has said, OCaml uses shadowing all the time and it
> doesn't seem to have caused too many problems. If in doubt use explicit
> references instead of opens.
>
>>   (iii) It makes dependency analysis more precise (and code easier to read).  In the example above, ocamldep knows (with
>> the second semantics) that there is no dependency to an external unit X.
>
> This is no worse than how ocamldep currently handles modules contained
> within other modules.
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From gabriel.scherer at gmail.com  Tue Mar 19 11:29:02 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 19 Mar 2013 12:29:02 +0100
Subject: [ocaml-platform] Idea: use (possibly extended) toplevel directives
	as source headers
Message-ID: <CAPFanBGBMiT0uK8AOwCqDcfaW4PiJS9oLQrxUbRcyc2LoejgAg@mail.gmail.com>

Interleaved with the namespace discussion, there is a debate about the
amount of program semantics that should or not be encoded through
command-line options and more generally the build system.

There is currently a rather arbitrary separation between semantic
features that can be specified in one or another world. Which
compilation units are accessible can only be set on the command-line,
which ones are opened cannot (it is a mix of the Pervasives hardcoded
convention and in-program "open" statements). There are two reasons to
wish to place any aspect of a unit semantics in the source code or in
the environment, so I think language designers should support both use
cases and let users choose:
- the source code is of course the easiest place to inspect and share
to analyze or communicate a unit's semantics (plus it has a precise,
well-defined semantics)
- putting things in the environment (in the build system or in the
file system) allows factoring redundancies away;that's the very point
of using external modules (factoring common code as libraries); why
can't we "factorize" a common set of "open" present in the same order
in several source files? This could be done either by having an "open"
option on the command-line (semantics in the build system), or adding
some sort of (include open "foo.mlopen") in the source code, that
explicitly performs the open present in a file (semantics in the file
system)

We should worry whenever a semantic feature can be expressed only in a
source without being shareable through the environment (that's
currently the case of "open" and local module renaming choices, and
the namespace discussion may change that), or only through the
environment without being expressible in the source. I'm here focusing
on the latter case.

Besides some less-interesting compilation options (-inline, ...), this
is in particular the case of
- ocamlfind packages used by a given program (more generally, search
path settings)
- preprocessing settings needed to correctly parse a given program
(somehow lesser priority, not discussed in this mail)

I think we could consider extending OCaml code units with a "header"
zone that contains semantics information corresponding to this
information.

The good news is that there already exists a widely used syntax that
could be added to source code without introducing ambiguities:
toplevel directives.

   #require "foo";;
   #warnings "3,4,85";;
   #directory "/opt/unpackaged";;

  let x = ... in ...

The restriction would be that they can only be used at the very
beginning of a source file, not nested anywhere in a program (just
like build systeam features are unit-global today).

Note that "#require" is not specified in the OCaml manual, it is a
de-facto standard introduced by ocamlfind. I think have such explicit
"import" support could be fairly useful for tooling (see all the nice
things the "go" tool allows for users of the Go programming language),
but I'm not sure it should be standardized as explicitly referring to
the ocamlfind tool, or a more abstract notion of "package" that could
also please the serious industrial users that maybe don't use
ocamlfind internally (I have no idea).

From alain.frisch at lexifi.com  Tue Mar 19 11:37:26 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 12:37:26 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87li9jsnpt.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <87li9jsnpt.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51484DF6.7030608@lexifi.com>

On 03/19/2013 11:11 AM, Leo White wrote:
> Neither of these options seems particularly problematic to me. The
> first one might be more in line with checking that some "foo-*.cmi"
> exists when the Foo namespace is opened so that typos produce an error
> or warning. But if Sys.readdir is a problem then the second option is
> perfectly viable.

Sys.readdir is not currently a problem, but it might prevent alternative 
approaches to discovering dependencies.

While perfectly viable, the second option will significantly complexify 
the definition of the typing environment.  We should carefully evaluate 
the impact on the size of .cmt files and on compilation time (in 
-bin-annot mode, in particular).

If I had to choose, I'd probably use the first approach (Sys.readdir).

>>    (ii) It allows to write more robust code w.r.t. to future additions to namespaces.  With namespaces, library authors
>> won't hesitate to use "short" names for their modules and the risk is high that a "open namespace" statement hide local
>> modules when the library is extended.
>
> This is basically just an argument against "open namespace" shadowing
> things but, as Yaron has said, OCaml uses shadowing all the time and it
> doesn't seem to have caused too many problems. If in doubt use explicit
> references instead of opens.

People have carefully avoided to use common name for modules in 
libraries, in order to avoid name clashes.  With namespaces, this can 
changes.  And with the notion of namespaces being more open than module, 
it's even harder to be sure that opening a namespace will never shadow a 
local module. The same would actually apply to other units in the 
current project, not only local modules; so I'd actually propose to look 
for module in the local namespace -- whatever this means -- first.

Concretely, if Core adds a new module Foo, this will break all projects 
using a local Foo module and which "open namespace Core".  A possible 
solution would be that Core ships many .mlpath files corresponding to 
module exposed in older releases, so that there is a way to ensure that 
"open namespace Core" does not bring more modules in scope than before.


Alain

From alain.frisch at lexifi.com  Tue Mar 19 11:51:24 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 12:51:24 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5148513C.1080107@lexifi.com>

On 03/19/2013 11:38 AM, Leo White wrote:
> This would prevent one package from providing aliases for modules in
> another package.

What would be a use case for a package providing aliases for modules in 
another package?  This seems likely to create confusion.

And as said, if really required, the same effect can be achieved by 
generating the .mlpath statically (using a tool which would resolve 
aliases, using "ocamldep -lookup").

> So the lookup logic is:
>
>      name := Foo#Baz
>      while there are more paths
>          if !path is a directory then
>              check for file named !name in !path
>              if it found a file then
>                  return the filename
>          else !path is a file
>              run "ocamldep -lookup !name !path"
>              if it found a mapping
>                  if mapping was a filename then
>                      return the filename
>                  else mapping was an alias
>                      name := !alias
>
> So aliases add a single if condition.

So an alias in an .mlpath can only refer to a name defined in the 
directories and search path files that come strictly after the .mlpath 
file on the command-line?  I would have intuitively assumed that this 
would work the other way around (an alias would be interpreted in the 
current scope defined by previous -I directives).

Assuming that package B provides an alias for a module in package A, you 
need to pass "-I B.mlpath" before "-I A.mlpath".  This seems rather 
weird (and fragile).

It's also unfortunate (assuming we really want aliases) that you cannot 
resolve an alias using other lines in the same .mlpath file (this means 
that passing several .mlpath files is not the same as passing a 
concatenation of those files).  I could imagine Core coming with 
something like:

Core#List: "core_list.cmi"
Core_std#List: Core#List



Alain

From lpw25 at cam.ac.uk  Tue Mar 19 11:58:40 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 19 Mar 2013 11:58:40 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <5148513C.1080107@lexifi.com> (Alain Frisch's message of "Tue, 19
 Mar 2013 12:51:24 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com>
Message-ID: <874ng7sirz.fsf@kingston.cl.cam.ac.uk>

>> So the lookup logic is:
>>
>>      name := Foo#Baz
>>      while there are more paths
>>          if !path is a directory then
>>              check for file named !name in !path
>>              if it found a file then
>>                  return the filename
>>          else !path is a file
>>              run "ocamldep -lookup !name !path"
>>              if it found a mapping
>>                  if mapping was a filename then
>>                      return the filename
>>                  else mapping was an alias
>>                      name := !alias
>
> So an alias in an .mlpath can only refer to a name defined in the directories and search path files that come strictly
> after the .mlpath file on the command-line?  I would have intuitively assumed that this would work the other way around
> (an alias would be interpreted in the current scope defined by previous -I directives).

Sorry, the above psuedo-code is supposed to be going backwards through
the paths.

> It's also unfortunate (assuming we really want aliases) that you cannot resolve an alias using other lines in the same
> .mlpath file (this means that passing several .mlpath files is not the same as passing a concatenation of those files).
> I could imagine Core coming with something like:
>
> Core#List: "core_list.cmi"
> Core_std#List: Core#List

That is allowed. It would be resolved by the "ocamldep -lookup" call, so
the build system would not need to be aware of it.

From yminsky at gmail.com  Tue Mar 19 12:01:17 2013
From: yminsky at gmail.com (Yaron Minsky)
Date: Tue, 19 Mar 2013 08:01:17 -0400
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <51484DF6.7030608@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk>
 <514822A4.2040507@lexifi.com>
 <87li9jsnpt.fsf@kingston.cl.cam.ac.uk>
 <51484DF6.7030608@lexifi.com>
Message-ID: <CADKNfh+coqNEwJQe5A2axZQHoavjv5KpMtRxb2Eb1RFJur39kw@mail.gmail.com>

I'm not quite suggesting this seriously, because I haven't thought about
the consequences carefully, but what if there was a namespace called Local
that one could explicitly open that contained the modules in the local
directory?  Then one could write

open namespace Core
open namespace Local

to get the behavior you propose.  Or, you could do it in the other order if
that was the shadowing behavior that was preferred.

y
On Mar 19, 2013 7:37 AM, "Alain Frisch" <alain.frisch at lexifi.com> wrote:

> On 03/19/2013 11:11 AM, Leo White wrote:
>
>> Neither of these options seems particularly problematic to me. The
>> first one might be more in line with checking that some "foo-*.cmi"
>> exists when the Foo namespace is opened so that typos produce an error
>> or warning. But if Sys.readdir is a problem then the second option is
>> perfectly viable.
>>
>
> Sys.readdir is not currently a problem, but it might prevent alternative
> approaches to discovering dependencies.
>
> While perfectly viable, the second option will significantly complexify
> the definition of the typing environment.  We should carefully evaluate the
> impact on the size of .cmt files and on compilation time (in -bin-annot
> mode, in particular).
>
> If I had to choose, I'd probably use the first approach (Sys.readdir).
>
>     (ii) It allows to write more robust code w.r.t. to future additions to
>>> namespaces.  With namespaces, library authors
>>> won't hesitate to use "short" names for their modules and the risk is
>>> high that a "open namespace" statement hide local
>>> modules when the library is extended.
>>>
>>
>> This is basically just an argument against "open namespace" shadowing
>> things but, as Yaron has said, OCaml uses shadowing all the time and it
>> doesn't seem to have caused too many problems. If in doubt use explicit
>> references instead of opens.
>>
>
> People have carefully avoided to use common name for modules in libraries,
> in order to avoid name clashes.  With namespaces, this can changes.  And
> with the notion of namespaces being more open than module, it's even harder
> to be sure that opening a namespace will never shadow a local module. The
> same would actually apply to other units in the current project, not only
> local modules; so I'd actually propose to look for module in the local
> namespace -- whatever this means -- first.
>
> Concretely, if Core adds a new module Foo, this will break all projects
> using a local Foo module and which "open namespace Core".  A possible
> solution would be that Core ships many .mlpath files corresponding to
> module exposed in older releases, so that there is a way to ensure that
> "open namespace Core" does not bring more modules in scope than before.
>
>
> Alain
> ______________________________**_________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/platform<http://lists.ocaml.org/listinfo/platform>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/platform/attachments/20130319/7897082b/attachment.html>

From alain.frisch at lexifi.com  Tue Mar 19 12:14:17 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 13:14:17 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51485699.4030407@lexifi.com>

On 03/19/2013 12:58 PM, Leo White wrote:
> Sorry, the above psuedo-code is supposed to be going backwards through
> the paths.

It should be noted that this would change the current behavior (-I 
directory are scanned in the order they are provided, with a first-match 
policy).  We probably don't care too much because it is unlikely that 
the same unit will be present in several directories.

I'm more concerned with the fact that order matters even if there is no 
conflict, which, again is a departure from today's situation.  ocamlfind 
will need to pass -I flags in the correct order.  Wouldn't it be better 
to resolve aliases in the same way as references in the source code 
(i.e. using all the -I flags)?

-- Alain

From gabriel.scherer at gmail.com  Tue Mar 19 12:20:55 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 19 Mar 2013 13:20:55 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <51485699.4030407@lexifi.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com>
Message-ID: <CAPFanBHhiQmExYxgCWWswJVj0BeMDDUGEBxew+_hr-J-F5PS7Q@mail.gmail.com>

I think this whole discussion could be avoided if we took the approach
of specifying the command-line options and hardcoded conventions as
building one environment. Ordering issues, conflicts possibilities
etc. would all be explicit by the description of how this initial
environment is specified.

> I'm more concerned with the fact that order matters even if there is no
> conflict, which, again is a departure from today's situation.  ocamlfind
> will need to pass -I flags in the correct order.

I'm surprised: isn't the order of -I flags already meaningful in case
of two compilation units having the same name? It looks like this is
the exact same problem (with the difference that a flexible namespace
language could allow users to avoid any such conflict by redefining
conflict-free names in any situation).

On Tue, Mar 19, 2013 at 1:14 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/19/2013 12:58 PM, Leo White wrote:
>>
>> Sorry, the above psuedo-code is supposed to be going backwards through
>> the paths.
>
>
> It should be noted that this would change the current behavior (-I directory
> are scanned in the order they are provided, with a first-match policy).  We
> probably don't care too much because it is unlikely that the same unit will
> be present in several directories.
>
> I'm more concerned with the fact that order matters even if there is no
> conflict, which, again is a departure from today's situation.  ocamlfind
> will need to pass -I flags in the correct order.  Wouldn't it be better to
> resolve aliases in the same way as references in the source code (i.e. using
> all the -I flags)?
>
> -- Alain
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From simon.cruanes.2007 at m4x.org  Tue Mar 19 12:28:31 2013
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Tue, 19 Mar 2013 13:28:31 +0100
Subject: [ocaml-platform] Idea: use (possibly extended) toplevel
 directives as source headers
In-Reply-To: <CAPFanBGBMiT0uK8AOwCqDcfaW4PiJS9oLQrxUbRcyc2LoejgAg@mail.gmail.com>
References: <CAPFanBGBMiT0uK8AOwCqDcfaW4PiJS9oLQrxUbRcyc2LoejgAg@mail.gmail.com>
Message-ID: <514859EF.3080005@m4x.org>

On 03/19/2013 12:29 PM, Gabriel Scherer wrote:
> Note that "#require" is not specified in the OCaml manual, it is a
> de-facto standard introduced by ocamlfind. I think have such explicit
> "import" support could be fairly useful for tooling (see all the nice
> things the "go" tool allows for users of the Go programming language),
> but I'm not sure it should be standardized as explicitly referring to
> the ocamlfind tool, or a more abstract notion of "package" that could
> also please the serious industrial users that maybe don't use
> ocamlfind internally (I have no idea).

My two cents: I think it's important to settle on a given way to deal
with one library system, especially given that findlib seems to be *the*
reference in OCaml. Findlib should be shipped with ocaml, and ocamlc/opt
being aware of findlib is not only acceptable, it's a good thing.

So, allowing #require in the preamble of a source file pleases me (also
being able to specify inlining level for some functions directly in the
source ;)).

Simon


From lpw25 at cam.ac.uk  Tue Mar 19 12:51:17 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 19 Mar 2013 12:51:17 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <51485699.4030407@lexifi.com> (Alain Frisch's message of "Tue, 19
 Mar 2013 13:14:17 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com>
Message-ID: <87wqt3r1ru.fsf@kingston.cl.cam.ac.uk>

> I'm more concerned with the fact that order matters even if there is no conflict, which, again is a departure from
> today's situation.  ocamlfind will need to pass -I flags in the correct order.  

If a package wanted to have a path file "foo.mlpath":

    Foo#Mutex: Core#Mutex

then it would provide a package description for ocamlfind equivalent to
the following (using made up syntax):

    path := ./foo.mlpath
    path-depends := core

this would ensure that its -I flags were correctly ordered.

For people using a single large code base, rather than ocamlfind, then
it would be easier for them to use the file name directly rather than an alias.

> Wouldn't it be better to resolve aliases
> in the same way as references in the source code (i.e. using all the -I flags)?

This might allow loops in aliases. It would also prevent things like:

Foo_Original#* : Foo#*
Foo#Bar : new_foo_bar.cmi

which allows you to substitute a new module in a namespace, while
providing a mechanism (Foo_Original) for accessing the old version.

From alain.frisch at lexifi.com  Tue Mar 19 12:58:22 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 13:58:22 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <CAPFanBHhiQmExYxgCWWswJVj0BeMDDUGEBxew+_hr-J-F5PS7Q@mail.gmail.com>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com>
 <CAPFanBHhiQmExYxgCWWswJVj0BeMDDUGEBxew+_hr-J-F5PS7Q@mail.gmail.com>
Message-ID: <514860EE.3080903@lexifi.com>

On 03/19/2013 01:20 PM, Gabriel Scherer wrote:
>> I'm more concerned with the fact that order matters even if there is no
>> conflict, which, again is a departure from today's situation.  ocamlfind
>> will need to pass -I flags in the correct order.
>
> I'm surprised: isn't the order of -I flags already meaningful in case
> of two compilation units having the same name? It looks like this is
> the exact same problem (with the difference that a flexible namespace
> language could allow users to avoid any such conflict by redefining
> conflict-free names in any situation).

That's why I added "even if there is no conflict".  In most of the 
cases, there is no conflict, and in that case, the order does not 
matter.  With Leo's proposal, an alias in foo.mlpath would be resolved 
only using -I flags before "-I foo.mlpath".


Alain

From lpw25 at cam.ac.uk  Tue Mar 19 13:09:45 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 19 Mar 2013 13:09:45 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <514860EE.3080903@lexifi.com> (Alain Frisch's message of "Tue, 19
 Mar 2013 13:58:22 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com>
 <CAPFanBHhiQmExYxgCWWswJVj0BeMDDUGEBxew+_hr-J-F5PS7Q@mail.gmail.com>
 <514860EE.3080903@lexifi.com>
Message-ID: <87li9jr0x2.fsf@kingston.cl.cam.ac.uk>

> That's why I added "even if there is no conflict".  In most of the cases, there is no conflict, and in that case, the
> order does not matter.  With Leo's proposal, an alias in foo.mlpath would be resolved only using -I flags before "-I
> foo.mlpath".

I think that shadowing (i.e. delibrate conflicts) between names in the
search path will be more common once those names are not tied to the
unique module name. So I think that it will be important for packages to
specify the dependencies of their path files even without aliases.

Currently, shadowing a compilation unit "foo.cmi" involves creating
another unit called "foo.cmi". Since these have the same name they can't
be linked within the same program, which limits the usefulness of this
kind of shadowing. With search path files this is no longer the case.

From daniel.buenzli at erratique.ch  Tue Mar 19 13:20:22 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 19 Mar 2013 14:20:22 +0100
Subject: [ocaml-platform] Idea: use (possibly extended) toplevel
 directives as source headers
In-Reply-To: <CAPFanBGBMiT0uK8AOwCqDcfaW4PiJS9oLQrxUbRcyc2LoejgAg@mail.gmail.com>
References: <CAPFanBGBMiT0uK8AOwCqDcfaW4PiJS9oLQrxUbRcyc2LoejgAg@mail.gmail.com>
Message-ID: <4B0C65E89D924A278C691EE4981FBA65@erratique.ch>



Le mardi, 19 mars 2013 ? 12:29, Gabriel Scherer a ?crit :

> Interleaved with the namespace discussion, there is a debate about the
> amount of program semantics that should or not be encoded through
> command-line options and more generally the build system.

Sources should be reasonably self-describing, and I think we should have in source code what is needed to correctly compile the unit. Correctly in the sense with the semantics the author intended.  

A very clear example for me is non-composable camlp4-like meta-programming facilities whose final result may depend on the order they are applied. This order should be specified in the source.  

Opening a namespace, if it brings up names in your scope, seems also better to have in the module, so that the semantics of your unit doesn't change according to the order of command line arguments.  

Libraries is less clear. You can specify them in any order on the command line (except if they have dependencies among themselves), to get the same semantic result. So it seems less important to me and module usage in the unit already dictates what the environment needs to provide (as I already said a few times before systems that force you to declare every module that will be used by the unit don't bring you anything but noise).

For libraries you could tell me but then you can replace a module by another and that could potentially change the semantics so they should also be specified too according to the above principle. But I still think it's better to leave that to the environment so that you can easily swap a module implementation by another with the same semantics, which is something you will want to do at a certain point in practice (functorizing everything is not a solution, as is shown in this presentation [1]).  

In any case what I would like is not to have to repeat myself. So if we put more in the sources, I don't want to have to repeat that elsewere in the build system and/or want a way to access that information to generate the various pieces of meta-data needed by package systems.  

Daniel


[1] http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps



From alain.frisch at lexifi.com  Tue Mar 19 13:29:54 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 14:29:54 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87li9jr0x2.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com>
 <CAPFanBHhiQmExYxgCWWswJVj0BeMDDUGEBxew+_hr-J-F5PS7Q@mail.gmail.com>
 <514860EE.3080903@lexifi.com> <87li9jr0x2.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51486852.7010608@lexifi.com>

On 03/19/2013 02:09 PM, Leo White wrote:
> Currently, shadowing a compilation unit "foo.cmi" involves creating
> another unit called "foo.cmi". Since these have the same name they can't
> be linked within the same program, which limits the usefulness of this
> kind of shadowing. With search path files this is no longer the case.

I thought your proposal still required unit names to be globally unique. 
  Do you propose a way to change the internal name independently of the 
filename ?

-- Alain


From alain.frisch at lexifi.com  Tue Mar 19 13:41:55 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 19 Mar 2013 14:41:55 +0100
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <87wqt3r1ru.fsf@kingston.cl.cam.ac.uk>
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com> <87wqt3r1ru.fsf@kingston.cl.cam.ac.uk>
Message-ID: <51486B23.70906@lexifi.com>

On 03/19/2013 01:51 PM, Leo White wrote:
> This might allow loops in aliases.

They can be trivially detected, so this shouldn't be a problem.

> It would also prevent things like:
>
> Foo_Original#* : Foo#*
> Foo#Bar : new_foo_bar.cmi
>
> which allows you to substitute a new module in a namespace, while
> providing a mechanism (Foo_Original) for accessing the old version.

I don't see situations where people would actually require that kind of 
feature.

So I'm still in favor of interpreting aliases "starting again from the 
beginning".  This avoids having to deal with one more thing (ordering of 
-I flags), and, for the rare cases where it matters, this is compatible 
with the current behavior.

-- Alain

From lpw25 at cam.ac.uk  Tue Mar 19 13:42:45 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 19 Mar 2013 13:42:45 +0000
Subject: [ocaml-platform] Changes to my previous proposal for namespaces
In-Reply-To: <51486852.7010608@lexifi.com> (Alain Frisch's message of "Tue, 19
 Mar 2013 14:29:54 +0100")
References: <CADKNfhKvH5CeUShQxVwjrMgNNKH9KR9jThFdsEj9kMAVAfYubg@mail.gmail.com>
 <87zjy4ok2o.fsf@kingston.cl.cam.ac.uk> <514822A4.2040507@lexifi.com>
 <514827BF.4070901@lexifi.com> <87a9pzsmif.fsf@kingston.cl.cam.ac.uk>
 <5148513C.1080107@lexifi.com> <874ng7sirz.fsf@kingston.cl.cam.ac.uk>
 <51485699.4030407@lexifi.com>
 <CAPFanBHhiQmExYxgCWWswJVj0BeMDDUGEBxew+_hr-J-F5PS7Q@mail.gmail.com>
 <514860EE.3080903@lexifi.com> <87li9jr0x2.fsf@kingston.cl.cam.ac.uk>
 <51486852.7010608@lexifi.com>
Message-ID: <87ehfbqze2.fsf@kingston.cl.cam.ac.uk>

>> Currently, shadowing a compilation unit "foo.cmi" involves creating
>> another unit called "foo.cmi". Since these have the same name they can't
>> be linked within the same program, which limits the usefulness of this
>> kind of shadowing. With search path files this is no longer the case.
>
> I thought your proposal still required unit names to be globally unique. Do you propose a way to change the internal
> name independently of the filename ?

I think my paragraph was slightly misleading, I don't propose a way to
change the internal name independently of the compiled filename. But
even without that a search path file such as:

Foo#Bar: fb_100.cmi

means that the name "Foo#Bar" is not connected to the internal name
(which in this case would be "Fb_100"). This means that Foo#Bar can be
shadowed without causing potential linking conflicts.

As a side note, I do propose a way to change the internal name
independently of the *source* filename (the "-name" argument) but that
isn't relevant to this discussion.

From anil at recoil.org  Tue Mar 19 14:26:23 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 19 Mar 2013 09:26:23 -0500
Subject: [ocaml-platform] A small script for compiler hackers: create
	short-lived opam switches out of any git branch
In-Reply-To: <CAPFanBFgjHPk=jF8wq5RSaEeShsEnu-xbjKZzhnvRJGEhdtWWg@mail.gmail.com>
References: <CAPFanBFcpQ8t-_HGiJxzxcsOUo6KLQ3FFoKZhGAxiLqgoaU7VA@mail.gmail.com>
 <wf620psule.fsf@gmail.com> <2B25C84C-22EA-4774-879C-3F852929E47C@recoil.org>
 <CAOg1smBmaAAOFF8NNXtwUbY9Wkm8RwKGU1bzC_Q7CCy0x-LqGw@mail.gmail.com>
 <CAPFanBFgjHPk=jF8wq5RSaEeShsEnu-xbjKZzhnvRJGEhdtWWg@mail.gmail.com>
Message-ID: <4034A7F5-CFB9-4988-ADCA-C698E86511CF@recoil.org>

Yeah.  Is there any reason not to distribute your script with OPAM in a 
contrib/ directory btw?  It would be good to keep these in one place
just to make testing easier.

-anil

On 18 Mar 2013, at 13:03, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> I think my approach and the "patch" feature fulfill different needs:
> the point here is that opam does *not* recompile the sources when
> installing the switch. If you only provide an archive and a patch,
> opam will have to recompile the sources.
> I see my script as useful locally for compiler hackers (make
> world.opt, hack a bit, make all to recompile only what's changed, opam
> install & test, hack a bit, make all, opam install & test).
> On the other side, the "patch" feature is useful if you want to
> distribute your patches to less savvy users ("check my new
> optimization patchset against your own programs", BER-MetaOCaml,
> etc...).
> 
> On Mon, Mar 18, 2013 at 5:41 PM, Wojciech Meyer
> <wojciech.meyer at gmail.com> wrote:
>> So the idea here was to use command line to quick apply patches and
>> test the integrity them after reviewing, but do this in such way I am
>> not forced to make the tree full of diffs.
>> 
>> On other hand maybe Gabriel idea scales better, I agree as we want to
>> commit them eventually.
>> 
>> The idea came to my mind after struggling with testing my patches and
>> trying out ocamlbuild on OPAM repo which I did but saying just "make
>> world.opt opt.opt install".
>> 
>> So probably the shell script takes precedence.
>> 
>> 
>> On Mon, Mar 18, 2013 at 4:13 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> On 17 Mar 2013, at 14:18, Wojciech Meyer <wojciech.meyer at gmail.com> wrote:
>>> 
>>>> Hi Gabriel,
>>>> 
>>>> all is needed for testing ocamlbuild and local patches for the compiler,
>>>> thank you.
>>>> 
>>>> Other useful thing in general for OPAM would be something like:
>>>> 
>>>> opam patch add <ordered list_of_patches>
>>>> opam patch reset
>>>> 
>>>> then we are able quickly test some local patches without touching
>>>> command line and invoking makefiles.
>>> 
>>> Just to clarify this, are you asking for this for the compiler switches,
>>> or for packages, or for both?
>>> 
>>> Local patches can be made to work with packages via `opam pin`, although
>>> supporting a patch queue model may be useful in the future.
>>> 
>>> Compiler patches don't exist at the moment within OPAM, but I like Gabriel's
>>> approach of taking an existing tree (that's, e.g., a git repo) and moving
>>> it into the OPAM space.  You can just use the underlying VCS to track your
>>> patches and branches without requiring more complexity in OPAM.
>>> 
>>> -anil
>>> 
>>> 
>>> 
>>>> 
>>>> Gabriel Scherer <gabriel.scherer at gmail.com> writes:
>>>> 
>>>>> As part of the slowly-evolving benchmark work, I have developed a
>>>>> script to turn any repository that quacks like an OCaml compiler and
>>>>> can run "make world.opt" into an OPAM compiler switch.
>>>>> 
>>>>> https://github.com/gasche/opam-compiler-conf
>>>>> 
>>>>> The intended use case is to change something, recompile what need be,
>>>>> get a compiler switch for that, and install one or two packages for
>>>>> testing something. You could envision, for example, OPAM being used in
>>>>> the internal loop of a bisection process. In this case it is important
>>>>> that OPAM does not recompile the compiler on its side (so the usual
>>>>> technique of making a tarball of the compiler source and letting OPAM
>>>>> do its job from there is not pleasant in that situation); the scripts
>>>>> makes use of voodoo OPAM compiler options (thanks to Thomas in
>>>>> https://github.com/OCamlPro/opam/pull/519 ) to have it just run "make
>>>>> install" each time "opam switch reinstall" is called.
>>>>> 
>>>>> This is a quick&dirty shell script that works on my machine. No
>>>>> guarantee that it will work on yours. It also assumes that the
>>>>> version-control system (VCS) used is git, and calls "git branch" to
>>>>> infer the name of the compiler switch to use. Eventual patches to
>>>>> support other VCSs (or, for example, infer the switch name from the
>>>>> directory name) would be welcome.
>>>> _______________________________________________
>>>> Platform mailing list
>>>> Platform at lists.ocaml.org
>>>> http://lists.ocaml.org/listinfo/platform
>>>> 
>>> 
> 


From thomas at ocamlpro.com  Tue Mar 19 17:43:47 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 19 Mar 2013 18:43:47 +0100
Subject: [ocaml-platform] Benchmarking in OPAM
In-Reply-To: <20130319.180741.183612882661784889.Christophe.Troestler@umons.ac.be>
References: <8ABBBECB-F78E-491F-BBC0-6C524F3BBFEA@recoil.org>
 <CAPFanBEDMRZg9vxS3YXufmVaeymVLO8eABTvMzK60o4kb1XM8Q@mail.gmail.com>
 <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>
 <20130319.180741.183612882661784889.Christophe.Troestler@umons.ac.be>
Message-ID: <2D280D8F-7AA8-49DB-95B8-7610CA9D160A@ocamlpro.com>

>> So for the moment, focussing on the benchmark library would seem to
>> be the best thing to do: I've not really used any of them, and would
>> be interested in knowing what I ought to adopt for (e.g.) the Mirage
>> protocol libraries.  Once we have that in place, the OPAM test integration
>> should be much more straightforward.
> 
> Maybe this is also a good time to promote a single benchmarking
> framework.  As the other two libraries mentioned by T?r?k Edwin,
> Benchmark computes the mean and std deviation ? it just does not
> expose them to the user.  All these libs have a lot in common and,
> IMHO, it would be best to merge the features of the 3 libraries.  I
> agree with the proposed split.  As I understand it:
> 
> - Benchmark: type defining what is a benchmarking sample, functions to
>  write and read it to a simple format [more complex formats,
>  e.g. XML, can be supported by Benchmark_manager], functions to
>  perform tests (min number of samples, min running time).
> 
> - Benchmark_manager: all the rest. Statistical tests,... as already
>  described by Gabriel.
> 

FWI, few months ago Pierre has also started to work on a bench framework (which uses OPAM to set-up some kind of environment for the benchs):

https://github.com/chambart/ocp-bench

--
Thomas




From Christophe.Troestler at umons.ac.be  Tue Mar 19 17:07:41 2013
From: Christophe.Troestler at umons.ac.be (Christophe TROESTLER)
Date: Tue, 19 Mar 2013 18:07:41 +0100
Subject: [ocaml-platform] Benchmarking in OPAM
In-Reply-To: <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>
References: <8ABBBECB-F78E-491F-BBC0-6C524F3BBFEA@recoil.org>
 <CAPFanBEDMRZg9vxS3YXufmVaeymVLO8eABTvMzK60o4kb1XM8Q@mail.gmail.com>
 <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>
Message-ID: <20130319.180741.183612882661784889.Christophe.Troestler@umons.ac.be>

On Thu, 14 Mar 2013 10:48:57 +0000, Anil Madhavapeddy wrote:
> 
> > Finally, we realized that we really need two distinct kinds of
> > benchmarking software:
> > - one "benchmark library" that is solely meant to run performance
> > tests and return the results (will be used by and linked with the
> > benchmark programs, so recompiled at each compiler change, so should
> > be rather light if possible)
> > - one "benchmark manager" that compares results between different
> > runs, plots nice graphics, stores results over time or send them to a
> > CI server, format them in XML or what not. This one is run from the
> > system compiler and can have arbitrarily large feature sets and
> > dependencies.
> > 
> > I believe a similar split would be meaningful for unit testing as
> > well. Of course, if you're considering daily automated large-scale
> > package building and checking, instead of tight feedback loops, it is
> > much less compelling to force a split, you can just bundle the two
> > kind of features under the same package.
> 
> The split you describe is generally good discipline, as it encourages
> library authors to encode more small benchmarks that can be called from
> larger tools.
> 
> The benchmark manager is definitely something we want to have in the
> OPAM hosted test system.  It's very difficult to get representative
> benchmark results without a good mix of architectures and operating
> systems, and we're going to pepper lots of odd setups into OPAM (and
> eventually have the facility to crowdsource other people's machines
> into the build pool, to make it easier to contribute resources).
> 
> So for the moment, focussing on the benchmark library would seem to
> be the best thing to do: I've not really used any of them, and would
> be interested in knowing what I ought to adopt for (e.g.) the Mirage
> protocol libraries.  Once we have that in place, the OPAM test integration
> should be much more straightforward.

Maybe this is also a good time to promote a single benchmarking
framework.  As the other two libraries mentioned by T?r?k Edwin,
Benchmark computes the mean and std deviation ? it just does not
expose them to the user.  All these libs have a lot in common and,
IMHO, it would be best to merge the features of the 3 libraries.  I
agree with the proposed split.  As I understand it:

- Benchmark: type defining what is a benchmarking sample, functions to
  write and read it to a simple format [more complex formats,
  e.g. XML, can be supported by Benchmark_manager], functions to
  perform tests (min number of samples, min running time).

- Benchmark_manager: all the rest. Statistical tests,... as already
  described by Gabriel.

If you need the name, I agree to deprecate the Benchmark module once a
replacement following those lines has seen the light.  Also, if I can
be of some help, just let me know (just do not want to take the lead
for lack of time).

Best,
C.

From yminsky at janestreet.com  Tue Mar 19 20:18:29 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 19 Mar 2013 16:18:29 -0400
Subject: [ocaml-platform] Idea: use (possibly extended) toplevel
 directives as source headers
In-Reply-To: <4B0C65E89D924A278C691EE4981FBA65@erratique.ch>
References: <CAPFanBGBMiT0uK8AOwCqDcfaW4PiJS9oLQrxUbRcyc2LoejgAg@mail.gmail.com>
 <4B0C65E89D924A278C691EE4981FBA65@erratique.ch>
Message-ID: <CACLX4jT2uREWCyAk++2edXzReqvkXX8Ayp-Sdyn7-gHBNNwVLg@mail.gmail.com>

If we are to do this, we should make sure that the end result is not
highly verbose.  Right now, it's easy to set up your build system to
concisely specify the dependencies of a large number of files.  We
should be careful not to give that up.  In other words, if we have
require declarations, they should be first class, and we should be
able to import a whole collection of these in a single line.  Indeed,
one could argue that the namespace system should include some facility
for importing #requires in addition to module aliases.

Beyond that, I worry a bit that we're piling together too many issues
all at once.  I wonder if we should focus on namespaces first, and
address this #require question later.

y

On Tue, Mar 19, 2013 at 9:20 AM, Daniel B?nzli
<daniel.buenzli at erratique.ch> wrote:
>
>
> Le mardi, 19 mars 2013 ? 12:29, Gabriel Scherer a ?crit :
>
>> Interleaved with the namespace discussion, there is a debate about the
>> amount of program semantics that should or not be encoded through
>> command-line options and more generally the build system.
>
> Sources should be reasonably self-describing, and I think we should have in source code what is needed to correctly compile the unit. Correctly in the sense with the semantics the author intended.
>
> A very clear example for me is non-composable camlp4-like meta-programming facilities whose final result may depend on the order they are applied. This order should be specified in the source.
>
> Opening a namespace, if it brings up names in your scope, seems also better to have in the module, so that the semantics of your unit doesn't change according to the order of command line arguments.
>
> Libraries is less clear. You can specify them in any order on the command line (except if they have dependencies among themselves), to get the same semantic result. So it seems less important to me and module usage in the unit already dictates what the environment needs to provide (as I already said a few times before systems that force you to declare every module that will be used by the unit don't bring you anything but noise).
>
> For libraries you could tell me but then you can replace a module by another and that could potentially change the semantics so they should also be specified too according to the above principle. But I still think it's better to leave that to the environment so that you can easily swap a module implementation by another with the same semantics, which is something you will want to do at a certain point in practice (functorizing everything is not a solution, as is shown in this presentation [1]).
>
> In any case what I would like is not to have to repeat myself. So if we put more in the sources, I don't want to have to repeat that elsewere in the build system and/or want a way to access that information to generate the various pieces of meta-data needed by package systems.
>
> Daniel
>
>
> [1] http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps
>
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From edwin at etorok.net  Tue Mar 19 20:31:42 2013
From: edwin at etorok.net (=?windows-1252?Q?T=F6r=F6k_Edwin?=)
Date: Tue, 19 Mar 2013 22:31:42 +0200
Subject: [ocaml-platform] Benchmarking in OPAM
In-Reply-To: <2D280D8F-7AA8-49DB-95B8-7610CA9D160A@ocamlpro.com>
References: <8ABBBECB-F78E-491F-BBC0-6C524F3BBFEA@recoil.org>
 <CAPFanBEDMRZg9vxS3YXufmVaeymVLO8eABTvMzK60o4kb1XM8Q@mail.gmail.com>
 <8B4B9739-06E8-4BA2-AA8A-E68517BB1E58@recoil.org>
 <20130319.180741.183612882661784889.Christophe.Troestler@umons.ac.be>
 <2D280D8F-7AA8-49DB-95B8-7610CA9D160A@ocamlpro.com>
Message-ID: <5148CB2E.1070108@etorok.net>

On 03/19/2013 07:43 PM, Thomas Gazagnaire wrote:
>>> So for the moment, focussing on the benchmark library would seem to
>>> be the best thing to do: I've not really used any of them, and would
>>> be interested in knowing what I ought to adopt for (e.g.) the Mirage
>>> protocol libraries.  Once we have that in place, the OPAM test integration
>>> should be much more straightforward.
>>
>> Maybe this is also a good time to promote a single benchmarking
>> framework.  As the other two libraries mentioned by T?r?k Edwin,
>> Benchmark computes the mean and std deviation ? it just does not
>> expose them to the user.  All these libs have a lot in common and,
>> IMHO, it would be best to merge the features of the 3 libraries.

FWIW edobench is not a benchmarking library per se, sorry for the bad name choice.
It is the name I've given to my set of OCaml benchmarks, which includes a wrapper on top of bench,
a benchmark runner, the benchmarks themselves and a simple (text) post-processor.

It is not my intention to fork/merge bench or benchmark, but since both you and Edgar have expressed interest in merging the libraries, I can spend some time to
help towards that.

As a start I was thinking:
 - prepare a patch on top of bench that includes the minimum needed to run/store/read the benchmark data (just raw timings, not the  stats themselves)
 - prepare a patch on top of benchmark to add/move some bench features related to running/timing the benchmark (mostly the increased resolution)
 - prepare a patch on top of bench to expose its statistical computations
 - update my code to use the above, and move the statistical tests to its benchmark manager and to the layout proposed by Gabriel
 - finish the ocaml-re benchmarks that I promised
 - ... merge bench (to) benchmark eventually, but I'm probably not the right person to do that

When I have a draft of the above, should I post the git URL to the platform list, or Cc everyone individually as well?
(i.e. is everyone subscribed there?)

>  I
>> agree with the proposed split.  As I understand it:
>>
>> - Benchmark: type defining what is a benchmarking sample, functions to
>>  write and read it to a simple format [more complex formats,
>>  e.g. XML, can be supported by Benchmark_manager], functions to
>>  perform tests (min number of samples, min running time).

I was using a simple CSV-like format as it is quite simple to deal with that without additional dependencies
(i.e. Print/Scanf with %S, etc.).
Currently I'm storing the statistics, but perhaps storing the raw timings is a better idea (they don't take up that much space), as that allows
various independent post-processing to happen in the benchmark manager (like plotting raw timings, CDF, boxplot with median as well as the mean, etc.),
without having to bother the benchmark library with all those details.

>>
>> - Benchmark_manager: all the rest. Statistical tests,... as already
>>  described by Gabriel.

For a general purpose benchmark library I think that the statistics belong to the benchmark library (as is the case now with both libs),
at least as a module, but I tend to agree that for the purpose of compiler benchmarking here a separate (or at least separatable) statistical module is a good idea.
That way the choice of base benchmarking library doesn't have to mean a choice in what statistics to use, and it'd be possible
to plot the results at a later time without being limited by the statistics computed in the benchmark library.

>>
> 
> FWI, few months ago Pierre has also started to work on a bench framework (which uses OPAM to set-up some kind of environment for the benchs):
> 
> https://github.com/chambart/ocp-bench

I was not aware of that until recently, but it appears to have a tight dependency on lwt.
I do have quite a few lwt benchmarks myself, but not all benchmarks need lwt, and I think it is quite important that the benchmark library has minimal dependencies
so you can rebuild it quickly (lwt also has some optional dependencies, and enabling/disabling those would then trigger a rebuild of every benchmark).

Can the lwt dependency be turned into something optional? In that case I would definitely be interested in seeing if we can share some code
between ocp-bench and what I have currently.

Best regards,
--Edwin

From alain.frisch at lexifi.com  Wed Mar 20 09:33:44 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 20 Mar 2013 10:33:44 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
Message-ID: <51498278.5040304@lexifi.com>

Dear all,

I'd like to propose a variant of Leo's proposal ( 
http://www.lpw25.net/2013/03/10/ocaml-namespaces.html ).


1. Getting rid of "simple namespace through filenames"

Leo proposes that a file foo-bar.ml automatically creates a module Bar 
in namespace Foo.  With this approach, collecting all modules available 
in the namespace Foo requires to look for all foo-*.cmi files in the 
search path.  This is known to create problems with dependency analysis 
and generated files.  Moreover, since it is also suggested that the 
source file can be named differently from the target .cmi files, it is 
even more difficult for ocamldep to produce a good result.   Another 
problem which I raised in a previous mail is that loading the whole 
directory might prevent different kind of build systems based which 
infer dependencies by capturing system calls.

I propose to keep search path files as the only way to define 
namespaces.  For the typical user (who relies on ocamlfind), this does 
not change anything.  The overhead for library developers is minimal. 
And this could drastically improve the quality of ocamldep.  It would 
work as follow:

  - A namespace-qualified module name is looked up in search path files 
passed to ocamldep.  For those references, ocamldep can produce a 
dependency to concrete files.  This is the best of both worlds: (i) 
contrary to "ocamldep -modules", the build system does not need to 
recreate the lookup logic (in Leo's proposal, this even requires calling 
ocamldep many times in this process, which might be quite slow);  (ii) 
contrary to "ocamldep" (without -modules), this work well even with 
files to be generated (and even when the source file is named differently).

  - An unqualified module name is resolved by taking local module 
declarations and "open namespace" statement into account.  If the name 
can potentially refer to a namespaced module defined in on the search 
path files passed to ocamldep, ocamldep returns a dependency to concrete 
files as in the case above.  Otherwise, it behaves as of today 
(returning either module names in "-modules" mode or concrete files 
otherwise, by looking at the file system).  Since only non-namespaced 
module names are potentially returned as module names, the build system 
can behave as today (simply looking buildable files in -I directories).


Also, "open namespace Foo" would fail if there is no definition of 
modules under namespace "Foo" in the search path files passed to the 
compiler.  This is more robust than looking for foo-*.cmi files on the 
file system: these files might not exist yet, either because (i) 
dependency analysis is bogus or (ii) there is no actual dependency to 
any module in Foo in the current unit; or, on the contrary, there could 
be foo-*.cmi left from a previous compilation even though we have 
decided e.g. to change the name of the namespace.  It's much better, in 
my opinion, to be able to work with a "closed world" assumption w.r.t. 
namespaces while compiling a single unit.


2. Simplifying search path files

I propose to get:

   (i) rid of aliases;

   (ii) define as an error the situation where the same 
namespace-qualified name is defined twice (with different target files) 
in the set of all search path files used together.

(ii) will strongly encourage libraries to avoid stepping on each other 
feet and thus make the life of the user better.  Conflicts resolved by, 
say, a first-match policy are likely to fail at some point anyway (with 
bad error messages).  Namespaces are introduced to avoid such problems.

Complex namespace manipulation, which could benefit from aliases, are 
likely to be useful only to advanced users.  I don't see it as a 
problem that they have to resolve aliases manually or with very simple 
tools.

A nice consequence is that the ordering of search path files does not 
matter for the resolution of namespaced names to filenames, so the 
findlib package descriptions don't have to deal with it.  Also search 
path files and -I directories become independent concepts (-I 
directories are only used to resolve non-namespaced names).


3. Using search path files for reverse lookup

The information contained in search path files allows the compiler to 
map back from "compilation unit names" to namespaced names.  This 
information can be used by the compiler the produce nicer error messages 
involving namespaced names.  (This might be implicit in Leo's proposal.) 
   Here, we can define a first-match policy for this reverse lookup (if 
the same compilation unit is given several namespaced names).

The same applies for ocamldoc.


4. Replacing "-name"

Leo proposes to allow specifying the target compilation unit name 
(*.cmi/*.cmo/*.cmx/*.o) with a new compiler command-line argument.

The use case is to simplify the life of library developers so that they 
don't need to use long names for all their source files.  This should 
greatly simplify the migration of existing libraries to namespaces.
In practice, however, most the source files in such a library will need 
to include a new "open namespace" directive to make other modules from 
the same library accessible.  Also, we will need to inform the build 
system about the relation between source and target filenames.  For 
ocamlbuild, for instance, this will probably mean the creation of a new 
kind of text file to describe this mapping.

Since libraries will need to ship search path files anyway, I think we 
can reuse them to simplify further the migration to namespaces.  I 
propose to support calling the compiler with a "-namespace" argument:

   ocamlc -c mylib.mlpath -namespace Mylib bar.mli

This will do three things:

  - Lookup in mylib.mlpath for the compilation unit name corresponding 
to Mylib..Bar and use it as the target filename (if mylib.mlpath 
contains a line "Mylib..Bar:mylib_xxx", then the compiler will compile 
bar.mli to mylib_xxx.cmi).  We hard-code in particular that in this 
mode, the source filename is equal to the module name as seen by 
"clients" of the library.

  - Automatically "open namespace Mylib" for compiling bar.mli

  - Keep a reference to the "-namespace" argument in the generated .cmi 
file.

Tools could then benefit from the fact that the source file (bar.ml) can 
be retrieved mechanically from either the compilation unit name 
(mylib_xxx) or the qualified name (Mylib..Bar).  And ocamlbuild and 
other build systems don't need to introduce another way to map form 
source file names to compilation unit names.



-- Alain

From lpw25 at cam.ac.uk  Wed Mar 20 11:03:49 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 20 Mar 2013 11:03:49 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <51498278.5040304@lexifi.com> (Alain Frisch's message of "Wed, 20
 Mar 2013 10:33:44 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <Prayer.1.3.5.1302261703280.8428@hermes-1.csi.cam.ac.uk>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com>
Message-ID: <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>

> 1. Getting rid of "simple namespace through filenames"
>
> I propose to keep search path files as the only way to define namespaces.  For the typical user (who relies on
> ocamlfind), this does not change anything.  The overhead for library developers is minimal. And this could drastically
> improve the quality of ocamldep.  It would work as follow:
>
>  - A namespace-qualified module name is looked up in search path files passed to ocamldep.  For those references,
> ocamldep can produce a dependency to concrete files.  This is the best of both worlds: (i) contrary to "ocamldep
> -modules", the build system does not need to recreate the lookup logic (in Leo's proposal, this even requires calling
> ocamldep many times in this process, which might be quite slow);  (ii) contrary to "ocamldep" (without -modules), this
> work well even with files to be generated (and even when the source file is named differently).
>
>  - An unqualified module name is resolved by taking local module declarations and "open namespace" statement into
> account.  If the name can potentially refer to a namespaced module defined in on the search path files passed to
> ocamldep, ocamldep returns a dependency to concrete files as in the case above.  Otherwise, it behaves as of today
> (returning either module names in "-modules" mode or concrete files otherwise, by looking at the file system).  Since
> only non-namespaced module names are potentially returned as module names, the build system can behave as today (simply
> looking buildable files in -I directories).
>
>
> Also, "open namespace Foo" would fail if there is no definition of modules under namespace "Foo" in the search path
> files passed to the compiler.  This is more robust than looking for foo-*.cmi files on the file system: these files
> might not exist yet, either because (i) dependency analysis is bogus or (ii) there is no actual dependency to any module
> in Foo in the current unit; or, on the contrary, there could be foo-*.cmi left from a previous compilation even though
> we have decided e.g. to change the name of the namespace.  It's much better, in my opinion, to be able to work with a
> "closed world" assumption w.r.t. namespaces while compiling a single unit.

None of the above is helped by removing "simple namespaces through
filenames": it is all already supported by my proposal. If you don't
like some of the aspects of "simple namespaces through filenames" then
simply don't use them. You can always generate a search path file if you
are having strange dependency issues.

The majority of users do not require complex dependency analysis for
generated source files. I see no reason to prevent them from using a
convenient mechanism for defining namespaces. It is also the only
mechanism that is really in keeping with the current design of OCaml.

Search path files should only be necessary for unusual packages, not a
requirement for all packages.

> 2. Simplifying search path files
>
> I propose to get:
>
>   (i) rid of aliases;
>
>   (ii) define as an error the situation where the same namespace-qualified name is defined twice (with different target
> files) in the set of all search path files used together.

This should probably be a warning not an error. There is nothing wrong
with deliberately shadowing the description of a namespace.

> (ii) will strongly encourage libraries to avoid stepping on each other feet and thus make the life of the user better.
> Conflicts resolved by, say, a first-match policy are likely to fail at some point anyway (with bad error messages).
> Namespaces are introduced to avoid such problems.
>
> Complex namespace manipulation, which could benefit from aliases, are likely to be useful only to advanced users.  I
> don't see it as a problem that they have to resolve aliases manually or with very simple tools.

I don't see how they can resolve aliases manually without knowing, on
the end user's machine, the location of all packages relative to the
location of their package. This also hard codes the aliases, what if the
other package moves?

> 4. Replacing "-name"
>
> Leo proposes to allow specifying the target compilation unit name (*.cmi/*.cmo/*.cmx/*.o) with a new compiler
> command-line argument.
>
> The use case is to simplify the life of library developers so that they don't need to use long names for all their
> source files.  This should greatly simplify the migration of existing libraries to namespaces.
> In practice, however, most the source files in such a library will need to include a new "open namespace" directive to
> make other modules from the same library accessible.  Also, we will need to inform the build system about the relation
> between source and target filenames.  For ocamlbuild, for instance, this will probably mean the creation of a new kind
> of text file to describe this mapping.

The idea is that build systems like ocamlbuild do not *have* to support
the "-name" argument. It is there so that the build system *can* support
various naming conventions if it wants to. If we specify a particular
file format for specifying names then every build system *must*
recognise that format.

>  - Lookup in mylib.mlpath for the compilation unit name corresponding to Mylib..Bar and use it as the target filename
> (if mylib.mlpath contains a line "Mylib..Bar:mylib_xxx", then the compiler will compile bar.mli to mylib_xxx.cmi).  We
> hard-code in particular that in this mode, the source filename is equal to the module name as seen by "clients" of the
> library.

So either the user must write their own search path file specifying the
name of every single compilation unit, or the build system has to
generate it. If the build system has to generate it, how is that better
than using a direct argument?

From alain.frisch at lexifi.com  Wed Mar 20 11:41:02 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 20 Mar 2013 12:41:02 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5149A04E.7050109@lexifi.com>

On 03/20/2013 12:03 PM, Leo White wrote:
> None of the above is helped by removing "simple namespaces through
> filenames": it is all already supported by my proposal.

This is not true.  The good properties I list for a system without 
"simple namespaces" are lost if these "simple namespaces" are to 
supported by tools.

> If you don't
> like some of the aspects of "simple namespaces through filenames" then
> simply don't use them.

This does not work: as soon as a feature is supported by the compilers, 
the tools have to support them as well.  The fact that I don't use 
"simple namespaces through filenames" does not allow ocamldep, omake, 
ocamlbuild, ocamldoc, etc to not support them.  Extra features can have 
bad effects, even for people who do not plan to use them.

Moreover, removing the feature will also reduce the risk of weird 
behaviors of the compiler and user misunderstandings.  In particular, 
saying that "open namespace Foo" does not fail as soon as their is a 
"foo-*.cmi" file in one of the -I directories is fragile.  Concrete 
example: the library developers decides to change the name of one of his 
namespaces from Foo to Bar, but there are old foo-*.cmi files around, so 
the compiler does not complain upon a remaining "open namespace Foo" in 
one of the files.  It's better if the compiler has some explicit 
knowledge of namespaces which are really available (through search path 
files) than to rely on the existence of files.

> The majority of users do not require complex dependency analysis for
> generated source files. I see no reason to prevent them from using a
> convenient mechanism for defining namespaces. It is also the only
> mechanism that is really in keeping with the current design of OCaml.

I consider that the way OCaml interact with the file system has bad 
consequences w.r.t. to dependency analysis, which can be fixed quite 
easily by letting the compiler and tools know about which files are 
available.  Introducing namespaces is an opportunity to improve the 
situation, and it also makes it even more important to do so (because we 
want to support naming source files differently from compiled units, 
which breaks a property on which ocamldep currently relies).

> This should probably be a warning not an error. There is nothing wrong
> with deliberately shadowing the description of a namespace.

This is probably a matter of taste.  For me, if a library comes with a 
naming scheme for its modules, I really don't want another library to 
mess with it.  Shadowing is fragile and make the resolution depends on 
the ordering between command-line arguments.  Another source of 
potential problems which can be easily avoided.

> I don't see how they can resolve aliases manually without knowing, on
> the end user's machine, the location of all packages relative to the
> location of their package. This also hard codes the aliases, what if the
> other package moves?

First, I think it's a bad idea for a package to re-export module from 
another package.  This is just calling for trouble when user read the 
documentation of the respective libraries, or try to make sense of the 
error messages.  Providing several names for a module in a single 
package (e.g. Core..List and Core_std..List) can be useful, but I don't 
see any use for more complex operations.

Second, if this is really required, this can be done by generating the 
"search path file" during installation.

> The idea is that build systems like ocamlbuild do not *have* to support
> the "-name" argument. It is there so that the build system *can* support
> various naming conventions if it wants to. If we specify a particular
> file format for specifying names then every build system *must*
> recognise that format.

With -name, the mapping between source file names and compilation units 
is only local to the build system.  But this information is really 
useful for tools (like the current design of ocamldoc or Bisect).  Just 
providing a low-level feature to rename target files in an arbitrary way 
will make it harder for these tools to behave correctly.  Concretely, if 
I write a Makefile manually which uses "-name" as in your proposal, how 
do I inform ocamldoc about the mapping?  Same question for ocamldep.

Requiring that (in this "current namespace mode") the source filename 
correspond to the module name in the namespace will reduce risks of 
confusion and allow tools to use the existing "search path files" as a 
good source of information to relate source and compiled files.


> So either the user must write their own search path file specifying the
> name of every single compilation unit, or the build system has to
> generate it. If the build system has to generate it, how is that better
> than using a direct argument?

Because other tools can parse the file.  Otherwise, the information is 
left hidden in the build system.

The users already have to list all files in a library.  Currently, this 
information is specified in the build system itself.  If users directly 
write a "search path file" and the build system parses it (for instance 
to deduce automatically which modules to put in the library), there is 
no more work for the library author, and the information is directly 
made available to other tools.


Alain

From lpw25 at cam.ac.uk  Wed Mar 20 12:38:29 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 20 Mar 2013 12:38:29 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <5149A04E.7050109@lexifi.com> (Alain Frisch's message of "Wed, 20
 Mar 2013 12:41:02 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com>
Message-ID: <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>

> On 03/20/2013 12:03 PM, Leo White wrote:
>> None of the above is helped by removing "simple namespaces through
>> filenames": it is all already supported by my proposal.
>
> This is not true.  The good properties I list for a system without "simple namespaces" are lost if these "simple
> namespaces" are to supported by tools.

I don't see any properties described that would be lost by the existance
of simple namespaces. They are lost if you *use* simple namespaces, but
they aren't lost simply because the compiler supports them.

The lookup process you describe is precisely the lookup process I
described in an earlier post. It works better if you pass it a search
path (that could be generated on the fly by the build system), but it
still works fine if you pass it a search directory containing "simple
namespaces".

>> If you don't
>> like some of the aspects of "simple namespaces through filenames" then
>> simply don't use them.
>
> This does not work: as soon as a feature is supported by the
> compilers, the tools have to support them as well.

But this support does not affect any of the properties you described.

> The
> fact that I don't use "simple namespaces through filenames" does not allow ocamldep, omake, ocamlbuild, ocamldoc, etc to
> not support them.  Extra features can have bad effects, even for people who do not plan to use them.

Yes, but in this case they don't.

> Moreover, removing the feature will also reduce the risk of weird behaviors of the compiler and user misunderstandings.
> In particular, saying that "open namespace Foo" does not fail as soon as their is a "foo-*.cmi" file in one of the -I
> directories is fragile.  

This only affects whether a "Unknown Namespace" warning is
emitted, and the situation isn't improved by using search path files.

> Concrete example: the library developers decides to change the name of one of his namespaces
> from Foo to Bar, but there are old foo-*.cmi files around, so the compiler does not complain upon a remaining "open
> namespace Foo" in one of the files.  

The same thing happens if I accidently leave an old mapping in my search
path file, except that then the problem won't be fixed the next time I
run "make clean" or equivalent.

>> The majority of users do not require complex dependency analysis for
>> generated source files. I see no reason to prevent them from using a
>> convenient mechanism for defining namespaces. It is also the only
>> mechanism that is really in keeping with the current design of OCaml.
>
> I consider that the way OCaml interact with the file system has bad consequences w.r.t. to dependency analysis, which
> can be fixed quite easily by letting the compiler and tools know about which files are available.  Introducing
> namespaces is an opportunity to improve the situation, and it also makes it even more important to do so (because we
> want to support naming source files differently from compiled units, which breaks a property on which ocamldep currently
> relies).

For most projects dependency anaylisis is not a big issue, and for the
projects where it is complex we will support search path files. Just
because search path files are more appropriate for some projects doesn't
mean we should force them on all projects. You should only pay for what
you use.


>> The idea is that build systems like ocamlbuild do not *have* to support
>> the "-name" argument. It is there so that the build system *can* support
>> various naming conventions if it wants to. If we specify a particular
>> file format for specifying names then every build system *must*
>> recognise that format.
>
> With -name, the mapping between source file names and compilation units is only local to the build system.  But this
> information is really useful for tools (like the current design of
> ocamldoc or Bisect).  

When you use ocamldoc you are supposed to pass it the same arguments
that you used to compile the program. This is not particularly
difficult, and is the only way to handle syntax extensions anyway.

> Concretely,
> if I write a Makefile manually which uses "-name" as in your proposal, how do I inform ocamldoc about the mapping?  Same
> question for ocamldep.

You use the "-name" argument to tell ocamldoc. If you use a search path
file (as you suggest in your e-mail) then you don't need to tell
ocamldep. 

If you are writing a Makefile manually, how are you going to generate
rules from the search path file, as would be required under your proposal?

>> So either the user must write their own search path file specifying the
>> name of every single compilation unit, or the build system has to
>> generate it. If the build system has to generate it, how is that better
>> than using a direct argument?
>
> Because other tools can parse the file.  Otherwise, the information is left hidden in the build system.

But the information is still hidden: Which .mlpath files were used and
in what order? What "-namespace" argument was passed to the compiler?

> The users already have to list all files in a library.

That depends on your build system. Which is my point, your proposal
forces build systems to behave a certain way.

>  Currently, this information is specified in the build system
> itself.  If users directly write a "search path file" and the build system parses it (for instance to deduce
> automatically which modules to put in the library), there is no more work for the library author, and the information is
> directly made available to other tools.

So build systems should use search path files, instead of their existing
mechanisms to work out what files are part of the project?

Under my proposal, you would simply add a "use namespace Foo" option or a
"get namespaces from directory names" option to your build script. Under
yours I must maintain an up to date mapping of names to files.

From lpw25 at cam.ac.uk  Wed Mar 20 13:43:30 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 20 Mar 2013 13:43:30 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <5149A04E.7050109@lexifi.com> (Alain Frisch's message of "Wed, 20
 Mar 2013 12:41:02 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com>
Message-ID: <87boaejif1.fsf@kingston.cl.cam.ac.uk>

>> I don't see how they can resolve aliases manually without knowing, on
>> the end user's machine, the location of all packages relative to the
>> location of their package. This also hard codes the aliases, what if the
>> other package moves?
>
> First, I think it's a bad idea for a package to re-export module from another package.  This is just calling for trouble
> when user read the documentation of the respective libraries, or try to make sense of the error messages.  Providing
> several names for a module in a single package (e.g. Core..List and Core_std..List) can be useful, but I don't see any
> use for more complex operations.
>
> Second, if this is really required, this can be done by generating the "search path file" during installation.

While I think that it is useful for one package to be able to provide an
alias to a module from another package, I certainly don't consider it a
critical use case. So I could be persuaded that aliases weren't worth
the effort in the short term. On the other hand, I also don't see
supporting them causing any real problems.

However, I do think that it would be useful for users to be able to
create their own aliases for modules from packages, and aliases in
search path files provide a mechanism for these. Do you have any
suggestions for alternative mechanisms for supporting such aliases?


From gabriel.scherer at gmail.com  Wed Mar 20 14:21:30 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Wed, 20 Mar 2013 15:21:30 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <87boaejif1.fsf@kingston.cl.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512CFFEE.1010509@lexifi.com>
 <Prayer.1.3.5.1302271151010.29276@hermes-1.csi.cam.ac.uk>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87boaejif1.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CAPFanBEF1F39BLA4C5LMU9xbYEZjj8RMttkqT0crN8Pt0OdWHA@mail.gmail.com>

There are some aspects of Alain's proposal I like:

- I'm not particular fond of the foo-bar.cmi trick (yes, it extends
the current OCaml semantics, but I'm not fond of the OCaml semantics
either). I would tend to agree with Alain that having "open namespace
Foo" search through all foo-*.cmi in the search path is a bit of a
mess. On the other hand, I included a "scan" primitive in my original
namespace description language that does exactly that. I think it
could be a reasonable default for installed packages (picking
namespaces from the filesystem's /usr/lib organization), but it's a
dubious choice inside the currently-being-compiled project. So Alain's
point of view of asking that auto-discovery features ultimately
produce a namespace file, that is then used by the compiler, is maybe
a reasonable compromise. Finally, I don't think the foo-bar.cmi
solution adequately handles the semantic status of empty namespaces
vs. non-existing namespaces (that's why I think a tree model is better
than a wide mapping from paths to compunits: there is a notion of
existing but empty subnamespace)

- I also like the idea of strengthening the conflict-handling policy,
complaining by default if merging the namespace descriptions
introduces shadowing. That's was the idea of having a "strict merge"
in the namespace description language (and also a "shallow merge" when
people want quick&dirty convenience). Note that an expressive
signature language (eg. filtering some mappings out of a given
namespace description) could profitably replace cases where shadowing
is currently used. Again, if namespace are to be used in-the-large, I
think "explicit and robust" is to be preferred over "convenient but
maybe fragile".

The rest of the proposal is along the lines of "I want namespace
description to be as low-level as possible to be handled easily by any
sort of tools". I am rather pushing for the expressive side. I think
there are a lot of reasonable ways we could help arbitrary tools to
handle namespaces:
- code sharing (or linking of compiler-libs): if the namespace
description "compiler" is distributed as OCaml code under a liberal
license, not only in-the-distribution tools such that ocamldep and
ocamldoc would be encouraged to use it, bisect and what not would be
encouraged to reuse the library. Of course that may not be ideal for
tools not implemented in OCaml
- tool distribution: Leo suggested something along the names of
"ocamlns <namespace information> -resolve Foo..Bar". That's indeed an
obvious idea that would solve the issue of non-OCaml tools quite
easily. You are free to call "ocamlns <namespace information> -list"
to get the whole mapping (in the format that Alain was presenting for
his low-level, essentially compiled, description files), and cache it
just as you want

(I'm not too convinced by the efficiency argument ("calling an
external program ..."): mapping files are also not a terribly
efficient way to provide information for lookups. In the OCaml-land, a
marshalled hashtable or Map could be fairly more efficient for
example.)

On Wed, Mar 20, 2013 at 2:43 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>>> I don't see how they can resolve aliases manually without knowing, on
>>> the end user's machine, the location of all packages relative to the
>>> location of their package. This also hard codes the aliases, what if the
>>> other package moves?
>>
>> First, I think it's a bad idea for a package to re-export module from another package.  This is just calling for trouble
>> when user read the documentation of the respective libraries, or try to make sense of the error messages.  Providing
>> several names for a module in a single package (e.g. Core..List and Core_std..List) can be useful, but I don't see any
>> use for more complex operations.
>>
>> Second, if this is really required, this can be done by generating the "search path file" during installation.
>
> While I think that it is useful for one package to be able to provide an
> alias to a module from another package, I certainly don't consider it a
> critical use case. So I could be persuaded that aliases weren't worth
> the effort in the short term. On the other hand, I also don't see
> supporting them causing any real problems.
>
> However, I do think that it would be useful for users to be able to
> create their own aliases for modules from packages, and aliases in
> search path files provide a mechanism for these. Do you have any
> suggestions for alternative mechanisms for supporting such aliases?
>
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform

From alain.frisch at lexifi.com  Wed Mar 20 14:56:24 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 20 Mar 2013 15:56:24 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5149CE18.9050401@lexifi.com>

On 03/20/2013 01:38 PM, Leo White wrote:
> I don't see any properties described that would be lost by the existance
> of simple namespaces. They are lost if you *use* simple namespaces, but
> they aren't lost simply because the compiler supports them.

If simple namespaces are available, people will use them and sometimes 
encounter weird error messages or broken behavior (such as "open 
namespace Foo" not complaining because of left-overs from an old 
compilation).  It is important to design a system which reduces the risk 
of errors.

Moreover, even if you don't use simple namespaces, you will use tools 
which need to support them.  Concretely, ocamlbuild and the omake 
default rules for OCaml will have to be adapted to support them.  With 
your semantics, omake for instance will have to do a non-trivial job to 
implement the resolution strategy.  Also, the compilers will have to 
scan the directories, preventing other kinds of build systems based on 
capturing accesses to the file system to infer dependencies.   I have 
the feeling to repeat myself...  I can understand that you consider 
these drawbacks as minor, but do you agree they will apply even to users 
not using simple namespaces?


>> Moreover, removing the feature will also reduce the risk of weird behaviors of the compiler and user misunderstandings.
>> In particular, saying that "open namespace Foo" does not fail as soon as their is a "foo-*.cmi" file in one of the -I
>> directories is fragile.
>
> This only affects whether a "Unknown Namespace" warning is
> emitted, and the situation isn't improved by using search path files.

With search path files only, there is no risk to have an old foo-*.cmi 
staying around and changing the behavior of the compiler.  I really hate 
the idea that the compiler behaves differently according to the presence 
or absence on the filesystem of files which are not considered as 
dependencies by the build system!  This is really calling for 
non-reproducible behavior of your build system.

>> Concrete example: the library developers decides to change the name of one of his namespaces
>> from Foo to Bar, but there are old foo-*.cmi files around, so the compiler does not complain upon a remaining "open
>> namespace Foo" in one of the files.
>
> The same thing happens if I accidently leave an old mapping in my search
> path file, except that then the problem won't be fixed the next time I
> run "make clean" or equivalent.

Indeed, so at least you have a reproducible behavior, and the error will 
be easy enough to understand and fix.  Aren't you shocked by the idea 
that while dependencies are correct, you'd get a different behavior from 
the compiler after a "make clean" or a fresh checkout?

> When you use ocamldoc you are supposed to pass it the same arguments
> that you used to compile the program. This is not particularly
> difficult, and is the only way to handle syntax extensions anyway.

With "-name", you can choose a different naming strategy for each file 
in your project.  Ocamldoc is called once to generate the documentation 
for many files.  How do you pass the required information?  With one 
"-name" option for each module?

> But the information is still hidden: Which .mlpath files were used and
> in what order? What "-namespace" argument was passed to the compiler?

As you say, we will need to pass the .mlpath arguments to the tools. 
This is easier than passing a "-name" argument for each module.  And I 
suggested to keep the "-namespace" argument in the generated units 
precisely to avoid having to pass it again to tools.



Alain

From lpw25 at cam.ac.uk  Wed Mar 20 17:04:42 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 20 Mar 2013 17:04:42 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <5149CE18.9050401@lexifi.com> (Alain Frisch's message of "Wed, 20
 Mar 2013 15:56:24 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512E0588.3000003@lexifi.com>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com>
Message-ID: <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>

> Moreover, even if you don't use simple namespaces, you will use tools which need to support them.  Concretely,
> ocamlbuild and the omake default rules for OCaml will have to be adapted to support them.  With your semantics, omake
> for instance will have to do a non-trivial job to implement the
> resolution strategy.

The resolution of simple namespaces is much easier than the resolution
of search path files. It is fundamentally the same resolution as OCaml
uses now.

If omake continues to use "ocamldep -modules" then it will have to
implement the resolution strategy. To support *search path files* this
will involve either parsing them itself or using the proposed "ocamlns
... -resolve Foo#Bar". If it switches to using regular "ocamldep" with
generated search path files then it won't need to implement the
resolution strategy anyway.

>   Also, the compilers will have to
> scan the directories, preventing other kinds of build systems based on capturing accesses to the file system to infer
> dependencies.   

I'm not particularly worried about hypothetical build systems. If you
want to implement such a build system then you should really add hooks
into the OCaml compiler. This argument also assumes that catching
"Sys.file_exists" is fine but catching "Sys.readdir" is impossible.

> I have the feeling to repeat myself...  I can understand that you consider these drawbacks as minor, but
> do you agree they will apply even to users not using simple
> namespaces?

No, the only "problem" caused by simple namespaces is the lack of
support for a hypothetical build system based on capturing file system
accesses, and even this would work fine if you always used search path
files.

>>> Concrete example: the library developers decides to change the name of one of his namespaces
>>> from Foo to Bar, but there are old foo-*.cmi files around, so the compiler does not complain upon a remaining "open
>>> namespace Foo" in one of the files.
>>
>> The same thing happens if I accidently leave an old mapping in my search
>> path file, except that then the problem won't be fixed the next time I
>> run "make clean" or equivalent.
>
> Indeed, so at least you have a reproducible behavior, and the error will be easy enough to understand and fix.  Aren't
> you shocked by the idea that while dependencies are correct, you'd get a different behavior from the compiler after a
> "make clean" or a fresh checkout?

Not particularly, we are only talking about the lack of a warning
telling you to change the name of a namespace that the file doesn't
actually use.

The warning only exists to point you to the likely cause of a later
error, but since we are talking about precisely the case when there is
no later error then it is not particularly concerning.

We could always combine this warning with the "this namespace is unused"
warning so that the warning is raised more consistently. That might
actually make more sense anyway.

>> When you use ocamldoc you are supposed to pass it the same arguments
>> that you used to compile the program. This is not particularly
>> difficult, and is the only way to handle syntax extensions anyway.
>
> With "-name", you can choose a different naming strategy for each file in your project.  Ocamldoc is called once to
> generate the documentation for many files.  How do you pass the required information?  With one "-name" option for each
> module?
>

I happen to be writing a new version of (the front-end of) ocamldoc for
the platform, which will completely avoid this problem. In the
meantime a "-name" option for each module will work fine.

>> But the information is still hidden: Which .mlpath files were used and
>> in what order? What "-namespace" argument was passed to the compiler?

> As you say, we will need to pass the .mlpath arguments to the tools. This is easier than passing a "-name" argument for
> each module.  And I suggested to keep the "-namespace" argument in the generated units precisely to avoid having to pass
> it again to tools.

If you are going to look in the generated files anyway then why do you
need an ".mlpath" file? Obviously the source file name would be included
in the files compiled using "-name".

From alain.frisch at lexifi.com  Wed Mar 20 18:33:56 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 20 Mar 2013 19:33:56 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
Message-ID: <514A0114.1080403@lexifi.com>

On 03/20/2013 06:04 PM, Leo White wrote:
> The resolution of simple namespaces is much easier than the resolution
> of search path files. It is fundamentally the same resolution as OCaml
> uses now.
>
> If omake continues to use "ocamldep -modules" then it will have to
> implement the resolution strategy. To support *search path files* this
> will involve either parsing them itself or using the proposed "ocamlns
> ... -resolve Foo#Bar".

With my proposal, ocamldep -modules will emit two kinds of dependencies: 
file dependencies for namespaces modules (resolved by ocamldep itself, 
using search path files) and module dependencies (for non-namespaced 
modules), to be resolved by the build exactly as of today (only using -I 
directories, ignoring search path files).  Basically, we keep the legacy 
behavior (-I directories) for non-namespaced modules, and we provide a 
simpler API between ocamldep and the build system for namespaced modules 
(equivalent to "ocamldep" without -modules, but precise even in presence 
of generated source files or "renamed" units).  There will be no new 
resolution strategy to be implemented in, say, omake, just a trivial 
adaptation of the "ocamldep -module" postprocessing to accept file 
dependency directly.

> If it switches to using regular "ocamldep" with
> generated search path files then it won't need to implement the
> resolution strategy anyway.

Agreed, but this regular ocamldep does not work well with generated 
source files.  Moreover, it does at all with the proposed -name 
argument.  So I don't think that "regular ocamldep" will be an option.

> I'm not particularly worried about hypothetical build systems. If you
> want to implement such a build system then you should really add hooks
> into the OCaml compiler. This argument also assumes that catching
> "Sys.file_exists" is fine but catching "Sys.readdir" is impossible.

No, this argument does not assume that.  But catching Sys.readdir is 
useless, since you don't know which files the compiler is interested in. 
  The tool would have to assume that the dependency is on the entire 
directory, which is of course way too weak.

I've done an experiment with a build system based on capturing open/stat 
calls, and it worked really well, not only for ocaml, but also for C code.

>> I have the feeling to repeat myself...  I can understand that you consider these drawbacks as minor, but
>> do you agree they will apply even to users not using simple
>> namespaces?
>
> No, the only "problem" caused by simple namespaces is the lack of
> support for a hypothetical build system based on capturing file system
> accesses, and even this would work fine if you always used search path
> files.

Sorry, I maintain that my strategy will allow to have a better ocamldep 
which will result in simpler support in, say, omake and ocamlbuild.  I 
also maintain that people using simple namespaces could have weird 
behaviors of their build system (errors appearing or disappearing after 
a 'make clean') even though dependencies are "correct" (in fact, they 
are not, since the compiler would actually depend on the sheer presence 
of absence of some files).  And I maintain that a build system based on 
capturing file system accesses could be a viable strategy, and that this 
wouldn't work any more if the compiler starts to load whole directories.

> Not particularly, we are only talking about the lack of a warning
> telling you to change the name of a namespace that the file doesn't
> actually use.

Consider this piece of code:

  open namespace Foo
  module X = Bar

You decide to rename the namespace Foo in your project to Baz but you 
forget to update this file.  You still have a foo-bar.cmi in your 
directory, even though this file is now out of scope of your build 
system (it considers it as "source").  When you compile the wrong code 
above, the compiler does not complain, and the build system probably 
considers that foo-bar.cmi is a dependency of this code. Now you "make 
clean", and boom, the code does not compile any more.  (Or you commit 
your changes and other people from your update and get the same error.) 
  Or, even worse, you start changing some more code, and you get 
incomprehensible "Interface mismatch" because you still use the "dead" 
foo-bar.cmi.

If the namespace information is explicit described, such problems cannot 
appear.  In the example above, you will probably get a nice 
error/warning message on "open namespace", and at least an "unknown 
module" error on the reference to Bar (unless you have a local Bar unit, 
in which case you'll probably get a type error later, but still an 
unused "open namespace" warning).


Alain

From alain.frisch at lexifi.com  Wed Mar 20 18:41:31 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 20 Mar 2013 19:41:31 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <CAPFanBEF1F39BLA4C5LMU9xbYEZjj8RMttkqT0crN8Pt0OdWHA@mail.gmail.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87boaejif1.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBEF1F39BLA4C5LMU9xbYEZjj8RMttkqT0crN8Pt0OdWHA@mail.gmail.com>
Message-ID: <514A02DB.7010003@lexifi.com>

On 03/20/2013 03:21 PM, Gabriel Scherer wrote:
> - tool distribution: Leo suggested something along the names of
> "ocamlns <namespace information> -resolve Foo..Bar". That's indeed an
> obvious idea that would solve the issue of non-OCaml tools quite
> easily.

This does not really work with "simple namespaces", because "ocamlns" 
can only know which files currently exist, not which files can be built. 
  You will need to re-implement the resolution logic in omake, maybe 
calling an helper tool to parse individual .mlpath files.

> (I'm not too convinced by the efficiency argument ("calling an
> external program ..."): mapping files are also not a terribly
> efficient way to provide information for lookups. In the OCaml-land, a
> marshalled hashtable or Map could be fairly more efficient for
> example.)

I'm pretty sure that the difference between parsing a simple text file 
and loading/unmarshaling a binary hashtable is negligible compared to 
spawning a new process, at least under Windows.  And we are talking 
about doing it once for each file for which dependencies need to be 
computed *and* for each .mlpath file.  There will be a huge slowdown if 
the resolution algorithm suggested by Leo had to be implemented in 
omake.  Note that "ocamldep" would also itself be a little bit slower 
since it would have to access many directories (or do many 
Sys.file_exists) in addition to reading .mlpath files, instead of just 
reading .mlpath files.


Alain

From alain.frisch at lexifi.com  Wed Mar 20 19:01:47 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 20 Mar 2013 20:01:47 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514A0114.1080403@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com>
Message-ID: <514A079B.5010304@lexifi.com>

On 03/20/2013 07:33 PM, Alain Frisch wrote:
> And I maintain that a build system based on
> capturing file system accesses could be a viable strategy

Even if you are not convinced, the same approach could be used to check 
dynamically that the build system knew about all the dependencies, and 
thus help in debugging broken build system configurations.  I would love 
for instance omake to perform such dynamic tests to detect poorly 
written OMakefiles, and this does not seem very difficult (provided the 
compiler does not try to load whole directories or open files which are 
not reported as dependencies by ocamldep).  It could even probably be 
implemented in user-land, using strace.

-- Alain

From lpw25 at cam.ac.uk  Wed Mar 20 21:07:38 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 20 Mar 2013 21:07:38 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514A0114.1080403@lexifi.com> (Alain Frisch's message of "Wed, 20
 Mar 2013 19:33:56 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com>
Message-ID: <86li9hzso5.fsf@cam.ac.uk>

>> If omake continues to use "ocamldep -modules" then it will have to
>> implement the resolution strategy. To support *search path files* this
>> will involve either parsing them itself or using the proposed "ocamlns
>> ... -resolve Foo#Bar".
>
> With my proposal, ocamldep -modules will emit two kinds of dependencies: file dependencies for namespaces modules
> (resolved by ocamldep itself, using search path files) and module dependencies (for non-namespaced modules), to be
> resolved by the build exactly as of today (only using -I 
> directories, ignoring search path files).  Basically, we keep the legacy behavior (-I directories) for non-namespaced
> modules, and we provide a simpler API between ocamldep and the build system for namespaced modules (equivalent to
> "ocamldep" without -modules, but precise even in presence of generated source files or "renamed" units).  There will be
> no new resolution strategy to be implemented in, say, omake, just a trivial adaptation of the "ocamldep -module"
> postprocessing to accept file dependency directly.

This is the strategy I have referred to as "regular ocamldep with
generated search path files", it works just as well with simple
namespaces. The only difference is that the build system generates the
search path file to give to ocamldep, rather than making the user write
it by hand.

As a side note, I think that "ocamldep -modules" should continue to be a
purely syntactic version that ignores the search path. It is regular
ocamldep that should be used for this purpose.

>> I'm not particularly worried about hypothetical build systems. If you
>> want to implement such a build system then you should really add hooks
>> into the OCaml compiler. This argument also assumes that catching
>> "Sys.file_exists" is fine but catching "Sys.readdir" is impossible.
>
> No, this argument does not assume that.  But catching Sys.readdir is useless, since you don't know which files the
> compiler is interested in. The tool would have to assume that the dependency is on the entire directory, which is of
> course way too weak.

The tool would only have to know what files it could produce, but it
should already know that to answer Sys.file_exists queries.

> I've done an experiment with a build system based on capturing open/stat calls, and it worked really well, not only for
> ocaml, but also for C code.

This assumes that a C compiler won't read a directory (say to cache its
contents) in order to check for the existence of a file. It is not
exactly the most robust basis for a build system, which is probably why
it is only a hypothetical build system.

> Sorry, I maintain that my strategy will allow to have a better ocamldep which will result in simpler support in, say,
> omake and ocamlbuild.

It doesn't allow better ocamldep results, the results are the same. You
simply pass in a search path file, generated by the build system, that
lists all the target files.

> I also maintain that people using simple namespaces could have weird behaviors of their build
> system (errors appearing or disappearing after a 'make clean') even
> though dependencies are "correct".

Depending on how it is implemented, they *may* fail to get a warning
that they should get, but only in a situation where the warning is
irrelevant.

>  And I maintain that a
> build system based on capturing file system accesses could be a viable strategy, and that this wouldn't work any more if
> the compiler starts to load whole directories.

And I maintain that if checking for a file's existence by reading the
contents of a directory breaks it then it is not a viable build system.

> Consider this piece of code:
>
>  open namespace Foo
>  module X = Bar
>
> You decide to rename the namespace Foo in your project to Baz but you forget to update this file.  You still have a
> foo-bar.cmi in your directory, even though this file is now out of scope of your build system (it considers it as
> "source").  When you compile the wrong code above, the compiler does not complain, and the build system probably
> considers that foo-bar.cmi is a dependency of this code. Now you "make clean", and boom, the code does not compile any
> more.  (Or you commit your changes and other people from your update and get the same error.) Or, even worse, you start
> changing some more code, and you get incomprehensible "Interface mismatch" because you still use the "dead" foo-bar.cmi.

This kind of behaviour already exists in OCaml. Consider this piece of code:

    type t = Bar.t (* Bar only contains type definitions *)

If you rename bar.mli to baz.mli but don't remove bar.cmi then it will
continue to compile until you run "make clean". The moral of the story
is don't leave old .cmi files lying around.

I really don't think that preventing a very unlikely scenario, which can
already happen anyway, is a good reason to make namespaces significantly
less convenient for the average user.

From lpw25 at cam.ac.uk  Wed Mar 20 21:15:58 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 20 Mar 2013 21:15:58 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514A02DB.7010003@lexifi.com> (Alain Frisch's message of "Wed, 20
 Mar 2013 19:41:31 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jTG37iAAx1MdSNvoyHrJFw=iHK946P8vrXcKLMr_h+yOg@mail.gmail.com>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87boaejif1.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBEF1F39BLA4C5LMU9xbYEZjj8RMttkqT0crN8Pt0OdWHA@mail.gmail.com>
 <514A02DB.7010003@lexifi.com>
Message-ID: <86fvzpzsa9.fsf@cam.ac.uk>

>> (I'm not too convinced by the efficiency argument ("calling an
>> external program ..."): mapping files are also not a terribly
>> efficient way to provide information for lookups. In the OCaml-land, a
>> marshalled hashtable or Map could be fairly more efficient for
>> example.)
>
> I'm pretty sure that the difference between parsing a simple text file and loading/unmarshaling a binary hashtable is
> negligible compared to spawning a new process, at least under Windows.  And we are talking about doing it once for each
> file for which dependencies need to be computed *and* for each .mlpath file.  There will be a huge slowdown if the
> resolution algorithm suggested by Leo had to be implemented in omake.  

As I have said many times, the resolution algorithm won't have to be
implemented in omake. I only provided it to show that it could be
implemented if the maintainers of omake insisted on using "ocamldep
-modules" instead of regular ocamldep with generated search path files.

> Note that "ocamldep" would also itself be a
> little bit slower since it would have to access many directories (or do many Sys.file_exists) in addition to reading
> .mlpath files, instead of just reading .mlpath files.

As I have made clear, the build system shouldn't give ocamldep directories, it
should generate a search path file to represent the eventual contents of
those directories and give that file to ocamldep.

From alain.frisch at lexifi.com  Thu Mar 21 06:07:55 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 21 Mar 2013 07:07:55 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <86fvzpzsa9.fsf@cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87boaejif1.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBEF1F39BLA4C5LMU9xbYEZjj8RMttkqT0crN8Pt0OdWHA@mail.gmail.com>
 <514A02DB.7010003@lexifi.com> <86fvzpzsa9.fsf@cam.ac.uk>
Message-ID: <514AA3BB.90001@lexifi.com>

On 3/20/2013 10:15 PM, Leo White wrote:
> As I have made clear, the build system shouldn't give ocamldep directories, it
> should generate a search path file to represent the eventual contents of
> those directories and give that file to ocamldep.

It seems we converge.   You claim that build system should be 
responsible for generating search path files before calling ocamldep 
(and thus the compilers).  So do you agree that ocamldep does not need 
to support directories anymore?  (except for backward compatibility of 
projects not using namespaces)  It seems that the "simple namespace" 
convention can be implemented entirely in the build systems, outside the 
core toolchain (compilers, ocamldep).  Fine, people can decide to use 
this convention, or another one, or write their search path files 
manually.  So let's keep this simple namespace convention outside the 
proposal.  Do you agree?


Alain

From alain.frisch at lexifi.com  Thu Mar 21 06:42:11 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 21 Mar 2013 07:42:11 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <86li9hzso5.fsf@cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <m49y5e8stgx.fsf@coffee.modeemi.fi>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com> <86li9hzso5.fsf@cam.ac.uk>
Message-ID: <514AABC3.7040301@lexifi.com>

On 3/20/2013 10:07 PM, Leo White wrote:
> This is the strategy I have referred to as "regular ocamldep with
> generated search path files", it works just as well with simple
> namespaces. The only difference is that the build system generates the
> search path file to give to ocamldep, rather than making the user write
> it by hand.

So the "good" mode for using ocamldep would be to have the build system 
generate a big search path file for each call to ocamldep?

   - How does the build system generate this search path file?  I guess 
it has to know about the "simple namespaces" convention.  Does it?  And 
does it know about the "-name" arguments scattered around in many 
subdirectories.  Concretely, I don't see how this would work under 
omake, for instance.

   - How this would work for non-namespaced modules?  Can you represent 
them with searh path files as in your proposal.  I thought that search 
path files only defined namespaced names.

   - If you assume that the build system can generate a search path file 
to avoid calling ocamldep (and thus the compiler as well) with any -I 
directory, what's the point of supporting -I directories any more in the 
compiler and tools?

> As a side note, I think that "ocamldep -modules" should continue to be a
> purely syntactic version that ignores the search path. It is regular
> ocamldep that should be used for this purpose.

I propose that "ocamldep -modules" ignores the search path directories, 
but knows about the definition of namespaces.  Otherwise, you need to 
invent a new convention to report possible namespaces together with each 
module dependency.

>>> I'm not particularly worried about hypothetical build systems. If you
>>> want to implement such a build system then you should really add hooks
>>> into the OCaml compiler. This argument also assumes that catching
>>> "Sys.file_exists" is fine but catching "Sys.readdir" is impossible.
>>
>> No, this argument does not assume that.  But catching Sys.readdir is useless, since you don't know which files the
>> compiler is interested in. The tool would have to assume that the dependency is on the entire directory, which is of
>> course way too weak.
>
> The tool would only have to know what files it could produce, but it
> should already know that to answer Sys.file_exists queries.

That's not the way it works, Sys.file_exists returns not only files that 
the build system can produce but also files which are already here.

The build system I was referring to worked like that:

  - The project is specified by a list of build commands, each of which 
annotated with a list of target files (assumed to be created by the 
command).

  - The build is triggered by asking to build one target.

  - To build one target X, the system picks a command which lists X as a 
target.

  - If the exact same command has already been run previously (this 
information is kept in a persistent cache), the system checks that pre- 
and post-conditions attached to that run are still valid in the current 
state of the file system.  If yes, the command does not need to be run 
again.

  - The recorded conditions are:  the content (before execution) of any 
file opened for reading and the content (after execution) of any file 
opened for writing; the presence or absence (before execution) of any 
file checked for existence (stat) during the command.

  - When running a command, the tool records those conditions and if the 
command checks a file for existence or open a file for reading, the tool 
tries to build this file as a target, recursively.

The result of system calls are not modified, they are just intercepted 
to allow recording and intermediate compilation of other files.  The 
tool make the assumption that the behavior of the build commands only 
depend on the file existence/absence and content, not on extra meta-data 
(such as mtimes, environment variables, or the system date).

A simpler variant of the system was specified with an ordered set of 
commands to be executed in sequence, with the same cache behavior.  The 
benefit is that you don't need to tell the system about which files can 
be generated by each command.

And as said, even if you don't believe that is a viable approach for a 
robust build system, the same approach can be used to add extra checks 
to existing build system that they don't miss dependencies.

> This assumes that a C compiler won't read a directory (say to cache its
> contents) in order to check for the existence of a file. It is not
> exactly the most robust basis for a build system, which is probably why
> it is only a hypothetical build system.

Well, it worked very well for ocaml + gcc.  I could build non trivial 
code bases (CDuce + all its library dependencies), with extremely 
precise dynamic dependency analysis and without having to use ocamldep.

> This kind of behaviour already exists in OCaml. Consider this piece of code:
>
>      type t = Bar.t (* Bar only contains type definitions *)
>
> If you rename bar.mli to baz.mli but don't remove bar.cmi then it will
> continue to compile until you run "make clean".

Yes, and I see it as a problem.  I would actually prefer a system where 
one must pass explicitly to the compiler the list of files it can use, 
but this is not possible because of backward compatibility.  Since 
namespaces change the way OCaml interact with the file system anyway and 
we have this nice notion of explicitly listing available units in 
well-defined files (which can be used by other tools), I think it's a 
good opportunity to fix the existing problems (partially).

Moreover, since the relation between the name of compiled units and of 
source files will be less tightly coupled for namespaces files (because 
of "-name" or "-namespace"), the chances for facing difficult to track 
error messages will become higher.

> I really don't think that preventing a very unlikely scenario, which can
> already happen anyway, is a good reason to make namespaces significantly
> less convenient for the average user.

I don't think it will.  The average user who creates a library to be 
used by others will need to pick a good namespace name and list which 
files constitute the library.  At this point, writing an explicit 
.mlpath file does not add any burden (the same source of information can 
be used to define the content of the library).


-- Alain

From lpw25 at cam.ac.uk  Thu Mar 21 10:44:26 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 21 Mar 2013 10:44:26 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514AA3BB.90001@lexifi.com> (Alain Frisch's message of "Thu, 21
 Mar 2013 07:07:55 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CAPFanBFVZHZEBmC84dapWO-k0PpL-ErYvsu1WZ_irpTrq+KOUg@mail.gmail.com>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87boaejif1.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBEF1F39BLA4C5LMU9xbYEZjj8RMttkqT0crN8Pt0OdWHA@mail.gmail.com>
 <514A02DB.7010003@lexifi.com> <86fvzpzsa9.fsf@cam.ac.uk>
 <514AA3BB.90001@lexifi.com>
Message-ID: <87ip4lm3qt.fsf@kingston.cl.cam.ac.uk>

>> As I have made clear, the build system shouldn't give ocamldep directories, it
>> should generate a search path file to represent the eventual contents of
>> those directories and give that file to ocamldep.
>
> It seems we converge.   You claim that build system should be responsible for generating search path files before
> calling ocamldep (and thus the compilers).  So do you agree that
> ocamldep does not need to support directories anymore?

The build system should generate a search path file for its local files
(i.e. the files it is responsible for building) if they may contain
generated source files. It should not have to create these files for all
of the packages that are being used. Neither should all packages have to
include a file listing the contents of their directories.

Ocamldep should still support directories for those people who do not
use generated source files. Again, having this support does not prevent
you from using ocamldep as you intend to.

> (except for backward compatibility of projects not using namespaces)  It seems that the "simple namespace" convention
> can be implemented entirely in the build systems, outside the core toolchain (compilers, ocamldep).  Fine, people can
> decide to use this convention, or another one, or write their search path files manually.  So let's keep this simple
> namespace convention outside the proposal.  Do you agree?

I do not agree. The build system generating a temporary file that the user
never sees is not the same as a file that the user must be aware of and
maintain.

Your proposal amounts to saying: rather than have the compiler call
Sys.readdir, we should force all packages to include a file listing the
contents of their directories. To me this seems bizarre, and certainly
not inline with keeping things simple.

It also complicates the proposal by merging the idea of namespaces with
the idea of search path files. The intention of my proposal was for a
group of simple independent extensions. Search path files are
independent of namespaces. They happen to work well with them but they
can be explained to a beginner completely independently. The same is true
of namespaces and the "-name" argument.

There is more to backward-compatibility than ensuring that all previous
programs compile. You should also preserve the modes of operation that
people have developed and become accustomed to. While looking files up
in directories has some flaws when combined with generated source files,
it is how OCaml has always operated (and how most programming languages
operate). To force people to switch away from that to a system based
entirely on search path files, even though most of them have no reason
to, is simply not good design.

We should not be looking to design the system that is the easiest for
the maintainers of omake, we should be looking to design the system that
is best for the users of OCaml. Adding support for "simple namespaces"
to omake will be a small amount of work one time, maintaining search
path files for all OCaml projects will be a pain indefinitely.

From lpw25 at cam.ac.uk  Thu Mar 21 11:02:53 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 21 Mar 2013 11:02:53 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514AABC3.7040301@lexifi.com> (Alain Frisch's message of "Thu, 21
 Mar 2013 07:42:11 +0100")
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com> <86li9hzso5.fsf@cam.ac.uk>
 <514AABC3.7040301@lexifi.com>
Message-ID: <878v5hm2w2.fsf@kingston.cl.cam.ac.uk>

> So the "good" mode for using ocamldep would be to have the build system generate a big search path file for each call to
> ocamldep?

I would have thought that it would reuse the same search path file.

>   - How does the build system generate this search path file?  I guess it has to know about the "simple namespaces"
> convention.  Does it?  And does it know about the "-name" arguments scattered around in many subdirectories.

Yes, the build system should now about the "simple namespaces"
convention, although it is a very simple convention ("Foo#Bar :
foo-bar.cmi"). If the build system provides support for alternative
naming conventions then it must also know about them.

>   - How this would work for non-namespaced modules?  Can you represent them with searh path files as in your proposal.
> I thought that search path files only defined namespaced names.

Search path files are allowed for any compilation unit. The whole idea
is that the "search path files" extension is completely independent of
the other extensions in my proposal (and vice-versa).

>   - If you assume that the build system can generate a search path file to avoid calling ocamldep (and thus the compiler
> as well) with any -I 
> directory, what's the point of supporting -I directories any more in the compiler and tools?

For backwards compatibility and convenience. For most projects, the
search path file would simply be a list of the contents of a directory
anyway.


>> As a side note, I think that "ocamldep -modules" should continue to be a
>> purely syntactic version that ignores the search path. It is regular
>> ocamldep that should be used for this purpose.
>
> I propose that "ocamldep -modules" ignores the search path directories, but knows about the definition of namespaces.
> Otherwise, you need to invent a new convention to report possible namespaces together with each module dependency.
>

I think that "ocamldep -modules" should return possible namespaces with
each module dependency. A tool that returns every possible compilation
unit mentioned in a file independent of its search path is probably
useful in general, not just for dependency generation. We can always add
a new mode that is half-way between "ocamldep" and "ocamldep -modules"
(i.e. uses the search path but still returns module names instead of
file names). An "ocamldep -namespaces" that returns all namespaces
mentioned might also be useful.


> And as said, even if you don't believe that is a viable approach for a robust build system, the same approach can be
> used to add extra checks to existing build system that they don't miss dependencies.
>

You could still use such a tool on your own code base, just make sure
that you always use search path files instead of directories (which is
what you are proposing anyway).


>> This kind of behaviour already exists in OCaml. Consider this piece of code:
>>
>>      type t = Bar.t (* Bar only contains type definitions *)
>>
>> If you rename bar.mli to baz.mli but don't remove bar.cmi then it will
>> continue to compile until you run "make clean".
>
> Yes, and I see it as a problem.  I would actually prefer a system where one must pass explicitly to the compiler the
> list of files it can use, but this is not possible because of backward compatibility.  Since namespaces change the way
> OCaml interact with the file system anyway and we have this nice notion of explicitly listing available units in
> well-defined files (which can be used by other tools), I think it's a good opportunity to fix the existing problems
> (partially).

My point is that since you are only fixing it partially, it is not a
good reason for excluding a feature. Especially when there is a clear
way to avoid the problem in your own code: always use search path
files.

Note that using an external library that uses "simple namespaces" will
not cause your own builds to have this problem.


> The average user who creates a library to be used by others will need to pick a good namespace
> name and list which files constitute the library.  

This is not the case. I do not currently have to write a list of files
in my libraries. As I said, it depends on which build system you use.

> At this point, writing an explicit .mlpath file does not add any
> burden (the same source of information can be used to define the
> content of the library).

Note that you don't just have to write these files after you have
finished the library, you must maintain them throughout development.


From alain.frisch at lexifi.com  Thu Mar 21 12:16:57 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 21 Mar 2013 13:16:57 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <878v5hm2w2.fsf@kingston.cl.cam.ac.uk>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com> <86li9hzso5.fsf@cam.ac.uk>
 <514AABC3.7040301@lexifi.com> <878v5hm2w2.fsf@kingston.cl.cam.ac.uk>
Message-ID: <514AFA39.8040305@lexifi.com>

On 03/21/2013 12:02 PM, Leo White wrote:
> always use search path files instead of directories (which is
> what you are proposing anyway).

I'm planning to use search path files for namespaced modules only, 
because this will be the only good way to do dependency analysis for 
them (good support for generated files and "simple namespaces" requires 
heavier interaction between ocamldep and the build system).  But I'm 
still planning to use non-namespaced modules for most of our code base, 
and the current combination of -I directories and omake+"ocamldep 
-modules" works really well.  The problem is that your proposal will 
force ocamldep to scan directories for "simple namespaces" as soon as I 
use -I directories.

Even if in your proposal search path files are orthogonal to namespaces, 
they only become critical in presence of namespaces.  I think it's 
important to continue the current mode of operations (with -I 
directories) while allowing to gradually start using libraries using 
namespaces.

It seems kind of weird to me to say that as soon as the project will 
have some generated source files, the build system should behave 
differently and produce a temporary search path file only for dependency 
analysis, while otherwise it would use a different mode of ocamldep. (I 
still don't see how this mode would work in presence of ad hoc "-name" 
arguments.)

> Note that using an external library that uses "simple namespaces" will
> not cause your own builds to have this problem.

Well, I will either have to create search path files myself (while they 
could easily be shipped with the external library) or use -I to these 
directories (in which case ocamlc/ocamldep will start inspecting the 
file system, potentially creating the problems I've described if I need 
to locally patch that library).

>> The average user who creates a library to be used by others will need to pick a good namespace
>> name and list which files constitute the library.
>
> This is not the case. I do not currently have to write a list of files
> in my libraries. As I said, it depends on which build system you use.

Can you share with us how you specify the content of the library in your 
build system?  I can imagine relying on some kind of other conventions 
(filename again or directories?).  But anyway, at some point, you will 
need to pass a list of modules to "ocamlc -a", so you have the 
information readily available and it would be trivial to generate 
automatically a search path file, shipped with the library, for the 
convenience of the library clients who might want to avoid using "simple 
namespaces".  And if you do that, there is no point not using that 
search path file instead of relying on the built-in support for "simple 
namespaces" in the toolchain.

> Note that you don't just have to write these files after you have
> finished the library, you must maintain them throughout development.

If your build system is clever enough to discover the content of a 
library automatically, it should be possible to generate that file as well.


> We should not be looking to design the system that is the easiest for
> the maintainers of omake, we should be looking to design the system that
> is best for the users of OCaml.

Support in omake is only an illustration of possible collateral damages 
of introducing "many ways to do it" in the design.  (And even for omake 
itself, the problem is not only for the maintainers of omake, since I 
suspect more users with large code bases have their local version of the 
build rules for OCaml.)

You don't know about the consequences on all existing code bases of 
adding support for "simple namespaces".  I'm pretty much convinced that 
it will make the life more difficult, not simpler, for users with large 
code bases.  I also believe that the overhead of forcing to use search 
map files for namespaced modules, i.e. mostly for people shipping 
libraries, is negligible and will have nice side effects (fewer problems 
that today).

I won't continue on this topic of "simple namespace" vs "search path 
files"-only for namespaces, because we don't make progress and it 
doesn't seem we are going to reach an agreement.  Let's agree to 
disagree on this point.


Cheers,

Alain

From alain.frisch at lexifi.com  Fri Mar 22 08:53:43 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 22 Mar 2013 09:53:43 +0100
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514AFA39.8040305@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <CACLX4jTSj=qEp-HMdvEdAb2mdozVk=XZxSsT7YEzNHc2SEkMsQ@mail.gmail.com>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com> <86li9hzso5.fsf@cam.ac.uk>
 <514AABC3.7040301@lexifi.com> <878v5hm2w2.fsf@kingston.cl.cam.ac.uk>
 <514AFA39.8040305@lexifi.com>
Message-ID: <514C1C17.1030407@lexifi.com>

On 03/21/2013 01:16 PM, Alain Frisch wrote:
> I won't continue on this topic of "simple namespace" vs "search path
> files"-only for namespaces, because we don't make progress and it
> doesn't seem we are going to reach an agreement.  Let's agree to
> disagree on this point.

A related but different point is about allowing "-" in compilation unit 
names.  If a library ships units with this character in their filenames, 
  client close will be forced to go through namepaced module names, 
which means not only adapting the code but also their build system.  As 
soon as namespaces will be available, some libraries will start using 
them, but some code bases or existing tools might not be ready at that 
time.  Providing a way for namespace-unaware code bases and tools to use 
namespaced libraries can only facilitate the migration phase, even if in 
the long term, using lower-level unit names in client code is not a good 
idea.

Being friendly to newcomers is important for the language adoption, but 
being friendly to long-time users and avoiding breakage of existing 
tools is also important for the perception of our language as a mature 
system for large scale use.  And in that case it's not like being 
friendly to long-time users is difficult: we simply need to keep the 
constraint that compilation unit names are also valid module names, 
which can be used directly in source code without relying on new 
namespace features.


Alain

From ferminreig at fastmail.fm  Fri Mar 22 09:14:15 2013
From: ferminreig at fastmail.fm (Fermin Reig)
Date: Fri, 22 Mar 2013 09:14:15 +0000
Subject: [ocaml-platform] An alternative proposal for namespaces
In-Reply-To: <514C1C17.1030407@lexifi.com>
References: <2006688600.3668799.1361819636548.JavaMail.root@inria.fr>
 <512F73F4.1040005@inria.fr>
 <CACLX4jTBc31N16o4yoRJCybVyRsdeKu4ib4pgA9PRiAaM1irOQ@mail.gmail.com>
 <512FD793.30208@inria.fr>
 <CACLX4jS=m4CRX6zkgRTgRtVH1h8r-nDkJ82CX00PpoAbDxr5Ug@mail.gmail.com>
 <51307B4F.4040006@inria.fr>
 <CACLX4jSG3WaFLm=vNnQ_FY9LydfSyxdR1kk91RYFJp4b_nqbCg@mail.gmail.com>
 <5130AA94.9070008@inria.fr>
 <CACLX4jR=XHwc78UkKqk0rLVSxGQnEfP+70fN4D-KP=LiXHrLNw@mail.gmail.com>
 <5130D186.5040704@inria.fr>
 <Prayer.1.3.5.1303102255480.17188@hermes-1.csi.cam.ac.uk>
 <51498278.5040304@lexifi.com> <87ppyujpt6.fsf@kingston.cl.cam.ac.uk>
 <5149A04E.7050109@lexifi.com> <87ip4mjlfe.fsf@kingston.cl.cam.ac.uk>
 <5149CE18.9050401@lexifi.com> <87ppyuhuj9.fsf@kingston.cl.cam.ac.uk>
 <514A0114.1080403@lexifi.com> <86li9hzso5.fsf@cam.ac.uk>
 <514AABC3.7040301@lexifi.com> <878v5hm2w2.fsf@kingston.cl.cam.ac.uk>
 <514AFA39.8040305@lexifi.com> <514C1C17.1030407@lexifi.com>
Message-ID: <514C20E7.70504@fastmail.fm>

The following paper (and its implementation in the SML/NJ compiler) is 
probably relevant to this discussion. (Section 2.4 is on names and name 
spaces).

Hierarchical Modularity.
Matthias Blume and Andrew W. Appel.
In ACM Transactions on Programming Languages and Systems, Volume 21,
No. 4 (July 1999).
(available athttp://people.cs.uchicago.edu/~blume/pub-cat.html 
<http://people.cs.uchicago.edu/%7Eblume/pub-cat.html>)

andits implementation for SML/NJ

http://www.smlnj.org/doc/CM/index.html 
<http://www.smlnj.org/doc/CM/index.html>

HTH,
Fermin

On 22/03/13 08:53, Alain Frisch wrote:
> On 03/21/2013 01:16 PM, Alain Frisch wrote:
>> I won't continue on this topic of "simple namespace" vs "search path
>> files"-only for namespaces, because we don't make progress and it
>> doesn't seem we are going to reach an agreement.  Let's agree to
>> disagree on this point.
>
> A related but different point is about allowing "-" in compilation 
> unit names.  If a library ships units with this character in their 
> filenames,  client close will be forced to go through namepaced module 
> names, which means not only adapting the code but also their build 
> system.  As soon as namespaces will be available, some libraries will 
> start using them, but some code bases or existing tools might not be 
> ready at that time.  Providing a way for namespace-unaware code bases 
> and tools to use namespaced libraries can only facilitate the 
> migration phase, even if in the long term, using lower-level unit 
> names in client code is not a good idea.
>
> Being friendly to newcomers is important for the language adoption, 
> but being friendly to long-time users and avoiding breakage of 
> existing tools is also important for the perception of our language as 
> a mature system for large scale use.  And in that case it's not like 
> being friendly to long-time users is difficult: we simply need to keep 
> the constraint that compilation unit names are also valid module 
> names, which can be used directly in source code without relying on 
> new namespace features.
>
>
> Alain
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform


From daniel.buenzli at erratique.ch  Sat Mar 23 09:56:39 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Sat, 23 Mar 2013 10:56:39 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with findlib
Message-ID: <79670D009CD547789E064F8D55AE4696@erratique.ch>

Hello,  

I'm kind at lost to do a simple thing I'd like for one of my package. I would like to install custom printers for the toploop so that when one does: 

# #use "topfind";;
# #require "gg";;

The printers are installed. The question are: 

1) Is there support for that in ocamlfind (like a convention that a particular file from the package directory is #use'd, on #require) ? Can't find anything special here [1].

2) How do I specify that in oasis ? 

Or maybe anyone knows a package doing that I could use as a blueprint. 

Thanks,

Daniel

[1] http://projects.camlcity.org/projects/dl/findlib-1.3.3/doc/guide-html/x227.html



From edwin+ml-ocaml at etorok.net  Sat Mar 23 10:13:26 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Sat, 23 Mar 2013 12:13:26 +0200
Subject: [ocaml-platform] Installing custom toplevel printers with
	findlib
In-Reply-To: <79670D009CD547789E064F8D55AE4696@erratique.ch>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
Message-ID: <514D8046.1020200@etorok.net>

On 03/23/2013 11:56 AM, Daniel B?nzli wrote:
> Hello,  
> 
> I'm kind at lost to do a simple thing I'd like for one of my package. I would like to install custom printers for the toploop so that when one does: 
> 
> # #use "topfind";;
> # #require "gg";;
> 
> The printers are installed. The question are: 
> 
> 1) Is there support for that in ocamlfind (like a convention that a particular file from the package directory is #use'd, on #require) ? Can't find anything special here [1].
> 
> 2) How do I specify that in oasis ? 
> 
> Or maybe anyone knows a package doing that I could use as a blueprint. 

See the toploop predicate:

http://docs.camlcity.org/docs/godisrc/ocamlnet-3.6.3.tar.gz/ocamlnet-3.6.3/src/netstring/netstring_top.ml
http://docs.camlcity.org/docs/godisrc/ocamlnet-3.6.3.tar.gz/ocamlnet-3.6.3/src/netstring/META.in


--Edwin

From daniel.buenzli at erratique.ch  Sat Mar 23 12:11:49 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Sat, 23 Mar 2013 13:11:49 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
 findlib
In-Reply-To: <514D8046.1020200@etorok.net>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
Message-ID: <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>

Thanks Edwin you put me on the right tracks. 

The full solution involved taking partial blueprint from the link you mentioned, lacaml [1] and this commit message [2] to materialize this commit [3]. After all these years oasis is still a frustrating beast, lack of up to date docs and error messages under the form of stack traces. 

That said I'm still left wondering if that's not a little bit overkill and if a simple convention in ocamlfind, like on #require, the file $PKGNAME_top.ml will be #use'd by the toplevel wouldn't be simpler. Anyways. 

Best,

Daniel

[1] https://bitbucket.org/mmottl/lacaml/src
[2] https://lists.forge.ocamlcore.org/pipermail/oasis-devel/2012-April/000332.html

[3] https://github.com/dbuenzli/gg/commit/c1c262cb506005bca35d2f5db1e93e3ccc9aff39



From sylvain+ocaml at le-gall.net  Sat Mar 23 13:30:10 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Sat, 23 Mar 2013 14:30:10 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
	findlib
In-Reply-To: <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
 <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
Message-ID: <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>

2013/3/23 Daniel B?nzli <daniel.buenzli at erratique.ch>:
> Thanks Edwin you put me on the right tracks.
>
> The full solution involved taking partial blueprint from the link you mentioned, lacaml [1] and this commit message [2] to materialize this commit [3]. After all these years oasis is still a frustrating beast, lack of up to date docs and error messages under the form of stack traces.
>

Just wondering, what kind of docs would you expect for this ?

I am open to patch if you want to improve the doc or the error
reporting, I just have no idea how to do it better (and never seen a
stack trace before).

Although, building a toplevel printer is not precisely a common task
and at least not something I do. I will be a lot more confident to
accept a patch from someone that will use it rather than to build
something out of the blue...

Cheers
Sylvain

From daniel.buenzli at erratique.ch  Sat Mar 23 14:04:21 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Sat, 23 Mar 2013 15:04:21 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
 findlib
In-Reply-To: <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
 <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
 <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>
Message-ID: <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>

Le samedi, 23 mars 2013 ? 14:30, Sylvain Le Gall a ?crit :
> Just wondering, what kind of docs would you expect for this ?

XMETAExtraLines is not mentioned here [1]. In general in on this documentation page you actually wonder how these fields need to be used in practice, see remark 2) in this email [2].

> I am open to patch if you want to improve the doc or the error
> reporting, I just have no idea how to do it better (and never seen a
> stack trace before).


In fact I now realize errors are reported but at the end of the stack trace and as such I didn't see them. In any case, these stack traces are completely useless to the user you should remove them, it's only noise. A tool should only return a stack trace if it has an internal error. Find an example at the end of this email.  

Best,

Daniel

[1] http://oasis.forge.ocamlcore.org/MANUAL.html#plugin-meta-extra
[2] https://sympa.inria.fr/sympa/arc/caml-list/2012-01/msg00041.html

> cat _oasis
OASISFormat: 0.3
Name: bla
Version: Bli
Synopsis: Bla
Maintainers: Bla
Copyrights: (C) 2008-2009 J.R. Hacker
License: BSD3
Description: Hop blib la
OCamlVersion: >= 3.12.0
Plugins: META (0.3)
BuildTools:ocamlbuild

Library top
Path: src
Modules: Gg
Build: compiler-libs.toplevel
> oasis setup
Raised at file "pervasives.ml", line 22, characters 22-33
Called from file "src/oasis/OASISSchema_intern.ml", line 235, characters 27-56
Called from file "src/oasis/PropList.ml", line 250, characters 24-42
Called from file "src/oasis/OASISAst.ml", line 84, characters 20-266
Called from file "list.ml", line 75, characters 12-15
Called from file "src/oasis/OASISAst.ml", line 161, characters 6-31
Called from file "list.ml", line 86, characters 24-34
Called from file "src/oasis/OASISAst.ml", line 275, characters 4-43
Called from file "src/oasis/OASISParse.ml", line 33, characters 4-49
Called from file "src/cli/Setup.ml", line 70, characters 6-95
Called from file "src/cli/Setup.ml", line 62, characters 4-312
Called from file "src/cli/Main.ml", line 61, characters 6-13
E: Unknown boolean "compiler-libs.toplevel" (possible: true, false)


From daniel.buenzli at erratique.ch  Sat Mar 23 14:38:12 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Sat, 23 Mar 2013 15:38:12 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
 findlib
In-Reply-To: <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
 <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
 <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>
 <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>
Message-ID: <59160312C6984510B0947C8430374BB3@erratique.ch>

Le samedi, 23 mars 2013 ? 15:04, Daniel B?nzli a ?crit :
> Raised at file "pervasives.ml", line 22, characters 22-33
> Called from file "src/oasis/OASISSchema_intern.ml", line 235, characters 27-56
> Called from file "src/oasis/PropList.ml", line 250, characters 24-42
> Called from file "src/oasis/OASISAst.ml", line 84, characters 20-266
> Called from file "list.ml", line 75, characters 12-15
> Called from file "src/oasis/OASISAst.ml", line 161, characters 6-31
> Called from file "list.ml", line 86, characters 24-34
> Called from file "src/oasis/OASISAst.ml", line 275, characters 4-43
> Called from file "src/oasis/OASISParse.ml", line 33, characters 4-49
> Called from file "src/cli/Setup.ml", line 70, characters 6-95
> Called from file "src/cli/Setup.ml", line 62, characters 4-312
> Called from file "src/cli/Main.ml", line 61, characters 6-13
> E: Unknown boolean "compiler-libs.toplevel" (possible: true, false)

And by the way you are still left wondering at which line of the `_oasis` file that happens, which is not always obvious.

Best,

Daniel 

From sylvain+ocaml at le-gall.net  Sat Mar 23 15:16:34 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Sat, 23 Mar 2013 16:16:34 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
	findlib
In-Reply-To: <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
 <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
 <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>
 <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>
Message-ID: <CAOCAUGOhQ8UckkbvD8kjsKUuAZfTxMO7gjLzC8mRQFJSx1DPsQ@mail.gmail.com>

2013/3/23 Daniel B?nzli <daniel.buenzli at erratique.ch>:
> Le samedi, 23 mars 2013 ? 14:30, Sylvain Le Gall a ?crit :
>> Just wondering, what kind of docs would you expect for this ?
>
> XMETAExtraLines is not mentioned here [1]. In general in on this documentation page you actually wonder how these fields need to be used in practice, see remark 2) in this email [2].

The reference doc is always "oasis manual" (i.e. call your oasis exec
with argument manual).

I agree that the website is not up to date and that I should solve this.

FYI, XMETAExtraLines is in the "oasis manual" doc.

>
>> I am open to patch if you want to improve the doc or the error
>> reporting, I just have no idea how to do it better (and never seen a
>> stack trace before).
>
>
> In fact I now realize errors are reported but at the end of the stack trace and as such I didn't see them. In any case, these stack traces are completely useless to the user you should remove them, it's only noise. A tool should only return a stack trace if it has an internal error. Find an example at the end of this email.
>

I thought the trace was useful... Seems like you don't like it.

Do you have set OCAMLRUNPARAMS=b in your environment ? Turning it off
should probably turn of the stack trace as well.

Concerning the line number, this is clearly a bug and I was too lazy
to solve it. Feel free to fill a bug so that I won't forget about this
issue.


> Best,
>
> Daniel
>
> [1] http://oasis.forge.ocamlcore.org/MANUAL.html#plugin-meta-extra
> [2] https://sympa.inria.fr/sympa/arc/caml-list/2012-01/msg00041.html
>
>> cat _oasis
> OASISFormat: 0.3
> Name: bla
> Version: Bli
> Synopsis: Bla
> Maintainers: Bla
> Copyrights: (C) 2008-2009 J.R. Hacker
> License: BSD3
> Description: Hop blib la
> OCamlVersion: >= 3.12.0
> Plugins: META (0.3)
> BuildTools:ocamlbuild
>
> Library top
> Path: src
> Modules: Gg
> Build: compiler-libs.toplevel
>> oasis setup
> Raised at file "pervasives.ml", line 22, characters 22-33
> Called from file "src/oasis/OASISSchema_intern.ml", line 235, characters 27-56
> Called from file "src/oasis/PropList.ml", line 250, characters 24-42
> Called from file "src/oasis/OASISAst.ml", line 84, characters 20-266
> Called from file "list.ml", line 75, characters 12-15
> Called from file "src/oasis/OASISAst.ml", line 161, characters 6-31
> Called from file "list.ml", line 86, characters 24-34
> Called from file "src/oasis/OASISAst.ml", line 275, characters 4-43
> Called from file "src/oasis/OASISParse.ml", line 33, characters 4-49
> Called from file "src/cli/Setup.ml", line 70, characters 6-95
> Called from file "src/cli/Setup.ml", line 62, characters 4-312
> Called from file "src/cli/Main.ml", line 61, characters 6-13
> E: Unknown boolean "compiler-libs.toplevel" (possible: true, false)
>

From daniel.buenzli at erratique.ch  Sat Mar 23 15:54:46 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Sat, 23 Mar 2013 16:54:46 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
 findlib
In-Reply-To: <CAOCAUGOhQ8UckkbvD8kjsKUuAZfTxMO7gjLzC8mRQFJSx1DPsQ@mail.gmail.com>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
 <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
 <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>
 <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>
 <CAOCAUGOhQ8UckkbvD8kjsKUuAZfTxMO7gjLzC8mRQFJSx1DPsQ@mail.gmail.com>
Message-ID: <03C2C932056343DCBC0060963A57F651@erratique.ch>


Le samedi, 23 mars 2013 ? 16:16, Sylvain Le Gall a ?crit :
> The reference doc is always "oasis manual" (i.e. call your oasis exec
> with argument manual).


Ok, maybe that should me made clear in the webpage if you don't update it.  

> I thought the trace was useful... Seems like you don't like it.

For what exactly ? I really don't care how oasis works internally. From a user perspective it's only noise, the stack trace *won't help me to solve my problem*.  
> ls a
ls: a: No such file or directory



> ocaml a
Cannot find file a.



Do we need stack traces here ? Come on.


> Do you have set OCAMLRUNPARAMS=b in your environment ?  
Yes.  
> Turning it off should probably turn of the stack trace as well.

No I won't do that. I need that variable set because I'm an OCaml developer. I'm not going to change that because oasis is doing something wrong [1].
  
Best,

Daniel

[1]  
OT. This reminds me a little bit the debian website that tells you to set your *browser language* to english if you want to browse the site in english when your browser is not because it uses stupid language-based content-negociation on *each request*. Yeah right, I'm going to change my browser user settings to be able to browse the site in english...  



From sylvain+ocaml at le-gall.net  Sat Mar 23 20:12:31 2013
From: sylvain+ocaml at le-gall.net (Sylvain Le Gall)
Date: Sat, 23 Mar 2013 21:12:31 +0100
Subject: [ocaml-platform] Installing custom toplevel printers with
	findlib
In-Reply-To: <03C2C932056343DCBC0060963A57F651@erratique.ch>
References: <79670D009CD547789E064F8D55AE4696@erratique.ch>
 <514D8046.1020200@etorok.net>
 <AD017D030DC545CEBAB54A406469CCA1@erratique.ch>
 <CAOCAUGNt10NhD8brPgSfhe_=TZm9AooZzNLaD8_CieHsWhhPfg@mail.gmail.com>
 <6BDE46CC6E0942A89873B64CCFE7DDA1@erratique.ch>
 <CAOCAUGOhQ8UckkbvD8kjsKUuAZfTxMO7gjLzC8mRQFJSx1DPsQ@mail.gmail.com>
 <03C2C932056343DCBC0060963A57F651@erratique.ch>
Message-ID: <CAOCAUGP2G-DumR+FJGE3mjLWjUbBBTfR9H1m858em0zpsAx=Mg@mail.gmail.com>

2013/3/23 Daniel B?nzli <daniel.buenzli at erratique.ch>:
>
> Le samedi, 23 mars 2013 ? 16:16, Sylvain Le Gall a ?crit :
>> The reference doc is always "oasis manual" (i.e. call your oasis exec
>> with argument manual).
>
>
> Ok, maybe that should me made clear in the webpage if you don't update it.
>
>> I thought the trace was useful... Seems like you don't like it.
>
> For what exactly ? I really don't care how oasis works internally. From a user perspective it's only noise, the stack trace *won't help me to solve my problem*.
>> ls a
> ls: a: No such file or directory
>> ocaml a
> Cannot find file a.
> Do we need stack traces here ? Come on.
>

You made it clear 2 mails ago and it was so obvious to me that I
didn't put words on it. So let me state it clearly: "I will disable
the stack trace printing" or at least hide it enoug behind a "debug"
flag. Although if some exception escape the context, there will still
be stack traces -- but not on purpose.

>
>> Do you have set OCAMLRUNPARAMS=b in your environment ?
> Yes.
>> Turning it off should probably turn of the stack trace as well.
>
> No I won't do that. I need that variable set because I'm an OCaml developer. I'm not going to change that because oasis is doing something wrong [1].
>

That was just a possible quick hack, not a long term solution (of course).

> Best,
>
> Daniel
>
> [1]
> OT. This reminds me a little bit the debian website that tells you to set your *browser language* to english if you want to browse the site in english when your browser is not because it uses stupid language-based content-negociation on *each request*. Yeah right, I'm going to change my browser user settings to be able to browse the site in english...
>

Indeed, this is OT.

>

From lyongu at yahoo.com  Sun Mar 31 03:57:39 2013
From: lyongu at yahoo.com (Yong Lu)
Date: Sat, 30 Mar 2013 19:57:39 -0700 (PDT)
Subject: [ocaml-platform] Passing flags to the OCaml configure script?
Message-ID: <1364698659.70511.YahooMailNeo@web160803.mail.bf1.yahoo.com>

Hi,

I'm writing to ask if there is a way to tell OPAM to pass flags to the OCaml config script? ?

The reason I'm asking is because I was experimenting with dynamically linked share library (http://www.camlcity.org/knowledge/kb_002_shared_library.html), and the instructions require me to compile OCaml with the fPIC flag:

<quote>
How to enable PIC for libasmrun.a:?
When building OCaml, you need to configure it so that PIC is enabled:

./configure -cc "gcc -fPIC" -aspp "gcc -c -fPIC"


</quote>

I searched the OPAM manual but could not find a solution. ?Any help is greatly appreciated.

Thanks,

-Yong

From anil at recoil.org  Sun Mar 31 11:50:58 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Sun, 31 Mar 2013 11:50:58 +0100
Subject: [ocaml-platform] Passing flags to the OCaml configure script?
In-Reply-To: <1364698659.70511.YahooMailNeo@web160803.mail.bf1.yahoo.com>
References: <1364698659.70511.YahooMailNeo@web160803.mail.bf1.yahoo.com>
Message-ID: <6E990403-B066-4A96-AEF0-4876E235CBAC@recoil.org>

Are you on a 32-bit platform by any chance?  If you clone:
http://github.com/OCamlPro/opam-repository

and look in the compilers/ directory, you can copy one of those into a custom compiler.  Several of them define custom configure flags (look at the debug runtime one).

You can use the local cloned repository via

$ opam remote add dev <directory>

and the new compiler should appear.

-a

On 31 Mar 2013, at 03:57, Yong Lu <lyongu at yahoo.com> wrote:

> Hi,
> 
> I'm writing to ask if there is a way to tell OPAM to pass flags to the OCaml config script?  
> 
> The reason I'm asking is because I was experimenting with dynamically linked share library (http://www.camlcity.org/knowledge/kb_002_shared_library.html), and the instructions require me to compile OCaml with the fPIC flag:
> 
> <quote>
> How to enable PIC for libasmrun.a: 
> When building OCaml, you need to configure it so that PIC is enabled:
> 
> ./configure -cc "gcc -fPIC" -aspp "gcc -c -fPIC"
> 
> 
> </quote>
> 
> I searched the OPAM manual but could not find a solution.  Any help is greatly appreciated.
> 
> Thanks,
> 
> -Yong
> _______________________________________________
> Platform mailing list
> Platform at lists.ocaml.org
> http://lists.ocaml.org/listinfo/platform
> 


From lyongu at yahoo.com  Sun Mar 31 21:18:53 2013
From: lyongu at yahoo.com (Yong Lu)
Date: Sun, 31 Mar 2013 16:18:53 -0400
Subject: [ocaml-platform] Passing flags to the OCaml configure script?
In-Reply-To: <6E990403-B066-4A96-AEF0-4876E235CBAC@recoil.org>
References: <1364698659.70511.YahooMailNeo@web160803.mail.bf1.yahoo.com>
 <6E990403-B066-4A96-AEF0-4876E235CBAC@recoil.org>
Message-ID: <278688FC-3CC1-4181-96E4-DDAB9E0E2EAE@yahoo.com>

I'm using a 64bit Linux distro.

Thanks,

Yong 

On Mar 31, 2013, at 6:50 AM, Anil Madhavapeddy <anil at recoil.org> wrote:

> Are you on a 32-bit platform by any chance?  If you clone:
> http://github.com/OCamlPro/opam-repository
> 
> and look in the compilers/ directory, you can copy one of those into a custom compiler.  Several of them define custom configure flags (look at the debug runtime one).
> 
> You can use the local cloned repository via
> 
> $ opam remote add dev <directory>
> 
> and the new compiler should appear.
> 
> -a
> 
> On 31 Mar 2013, at 03:57, Yong Lu <lyongu at yahoo.com> wrote:
> 
>> Hi,
>> 
>> I'm writing to ask if there is a way to tell OPAM to pass flags to the OCaml config script?  
>> 
>> The reason I'm asking is because I was experimenting with dynamically linked share library (http://www.camlcity.org/knowledge/kb_002_shared_library.html), and the instructions require me to compile OCaml with the fPIC flag:
>> 
>> <quote>
>> How to enable PIC for libasmrun.a: 
>> When building OCaml, you need to configure it so that PIC is enabled:
>> 
>> ./configure -cc "gcc -fPIC" -aspp "gcc -c -fPIC"
>> 
>> 
>> </quote>
>> 
>> I searched the OPAM manual but could not find a solution.  Any help is greatly appreciated.
>> 
>> Thanks,
>> 
>> -Yong
>> _______________________________________________
>> Platform mailing list
>> Platform at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/platform
> 

