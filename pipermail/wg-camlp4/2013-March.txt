From yminsky at janestreet.com  Fri Mar  1 04:54:19 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 28 Feb 2013 23:54:19 -0500
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <512FC647.6050900@lexifi.com>
References: <512FC647.6050900@lexifi.com>
Message-ID: <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>

Is there any hope of keeping the "with" syntax for type definitions
that type-conv uses?  There's quite a bit of code that depends on it,
and there seems at least some utility in keeping it.

On Thu, Feb 28, 2013 at 4:04 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> Dear all,
>
> Since there seemed to be a consensus about extending the OCaml grammar with
> attributes and extension nodes in various syntactic categories, I've started
> an experimental branch on the OCaml SVN to try some syntax.
> The branch is called extension_points (
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/ ).
>
> Currently, the following are supported:
>
>  - Extension node as a structure item:
>
>       &(foo expr)
>
>  - Extension node as an expression:
>
>       (&foo expr)
>
>  - Extension node as a type expression:
>
>       (&foo expr)
>
>  - Attribute on a structure item, postfix notation:
>
>       .... :: foo expr
>
>  - Attribute on a type expression, postfix notation:
>
>       .... (/foo expr)
>
> In all cases, foo denotes a lowercase unprefixed identifier (LIDENT) and
> expr is an optional expression (it can be omitted).
>
> (The parser has more commented-out syntax for attributes on expressions with
> prefix and postfix notation, and attributes on type expression with prefix
> notation.)
>
>
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From daniel.buenzli at erratique.ch  Fri Mar  1 08:01:41 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 1 Mar 2013 09:01:41 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <512FC647.6050900@lexifi.com>
References: <512FC647.6050900@lexifi.com>
Message-ID: <7D4C7AF5FE954F738A1DA04E86E45C68@erratique.ch>

Is there example good somewhere so that we can look how it looks like ?  

Daniel



From daniel.buenzli at erratique.ch  Fri Mar  1 08:07:25 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Fri, 1 Mar 2013 09:07:25 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <7D4C7AF5FE954F738A1DA04E86E45C68@erratique.ch>
References: <512FC647.6050900@lexifi.com>
 <7D4C7AF5FE954F738A1DA04E86E45C68@erratique.ch>
Message-ID: <19B456B8AFB04ACCA6E399FE19367A24@erratique.ch>

Le vendredi, 1 mars 2013 ? 09:01, Daniel B?nzli a ?crit :
> Is there example good somewhere so that we can look how it looks like ?

Oula, "example code" !

Daniel



From mshinwell at janestreet.com  Fri Mar  1 08:08:27 2013
From: mshinwell at janestreet.com (Mark Shinwell)
Date: Fri, 1 Mar 2013 08:08:27 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
Message-ID: <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>

On 1 March 2013 04:54, Yaron Minsky <yminsky at janestreet.com> wrote:
> Is there any hope of keeping the "with" syntax for type definitions
> that type-conv uses?  There's quite a bit of code that depends on it,
> and there seems at least some utility in keeping it.

+1.

Two comments on the suggestions from Alain's mail:

1. If possible, I'd rather see one new syntactic form, rather than
three.

2. The syntax seems kind of cryptic to me.  I wonder if we could find
something more accessible without being overly verbose.

Mark

From alain.frisch at lexifi.com  Fri Mar  1 08:29:17 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 09:29:17 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <7D4C7AF5FE954F738A1DA04E86E45C68@erratique.ch>
References: <512FC647.6050900@lexifi.com>
 <7D4C7AF5FE954F738A1DA04E86E45C68@erratique.ch>
Message-ID: <513066DD.5010104@lexifi.com>

On 03/01/2013 09:01 AM, Daniel B?nzli wrote:
> Is there example good somewhere so that we can look how it looks like ?

Not yet.  The syntax is not even fixed yet.  But since the branch exists 
and is intended to experiment with syntax, it is a good time to start 
expressing individual syntactic preferences (like Yaron did).


Alain


From alain.frisch at lexifi.com  Fri Mar  1 08:34:38 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 09:34:38 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
Message-ID: <5130681E.2080500@lexifi.com>

On 03/01/2013 05:54 AM, Yaron Minsky wrote:
> Is there any hope of keeping the "with" syntax for type definitions
> that type-conv uses?  There's quite a bit of code that depends on it,
> and there seems at least some utility in keeping it.

There will be a need for attributes on individual type declarations (not 
only structure items, since a set of mutually recursive declarations in 
a single structure item), and "with" seems quite good.   However, I 
don't believe that it will be possible to find a syntax which will allow 
reusing existing code based on type-conv without any change.  Leo 
suggested that existing Camlp4 extensions could be turned into mapper 
from "old syntax" (the one they used to interpret) to the new one (based 
on attributes/extension nodes, to be interpreted by a -ppx mapper). 
This could help in the migration (at least as a way to document what's 
to be done).

-- Alain

From alain.frisch at lexifi.com  Fri Mar  1 08:52:04 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 09:52:04 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
Message-ID: <51306C34.7090403@lexifi.com>

On 03/01/2013 09:08 AM, Mark Shinwell wrote:
> 1. If possible, I'd rather see one new syntactic form, rather than
> three.

Can you elaborate?

The need for various syntaxes arise from:

  - A distinction between attributes (meta-data which can be ignored by 
the type-checker if they remain after -ppx rewriting) and extension 
nodes (on which the type-checker must fail).  Do you claim they should 
be merged, or that we should somehow find a way to use a similar syntax 
for both?

  - The need for attributes/extension nodes on various syntactic 
categories.  For instance, one wants both attributes on type expressions 
and on type declarations, which easily create conflicts in the grammar. 
  Do you think we should restrict where attributes/extension nodes are 
allowed, or that we should find a uniform syntax for 
attributes/extension nodes on all syntactic categories (with priority 
rules)?

  - The desire to have both prefix and postfix syntaxes for attributes. 
This might be overkill, and if I had to choose, I'd pick a postfix 
syntax (but there are probably use cases where prefix attributes would 
look nicer).



Alain

From alain.frisch at lexifi.com  Fri Mar  1 13:05:30 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 14:05:30 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
Message-ID: <5130A79A.2080505@lexifi.com>

On 03/01/2013 09:08 AM, Mark Shinwell wrote:
> 1. If possible, I'd rather see one new syntactic form, rather than
> three.

I've made the syntax more uniform, dropped prefix attributes, and added 
attributes on type declarations.

The current syntax is:

Attributes:

   On expressions:         expr (:foo expr)
   On type expressions:    type (:foo expr)
   On structure items:     str_item ..(:foo expr)
   On type declarations:   type t = ... with (:foo1 expr1) (:foo2 expr2)

Extension nodes:

   On expressions:         (&foo expr)
   On type expressions:    (&foo expr)
   On structure items:     ..(&foo expr)


A type-conv like example (attributes on type expressions and type 
declarations):


=================================================
  type t = {
     x : int (:default 42);
     y : int (:default 3) (:sexp_drop_default);
     z : int (:default 3) (:sexp_drop_if z_test);
  } with (:sexp)
=================================================


A Bisect-like example (attributes on expressions and structure items):

=================================================
let f x =
   match List.map foo [x; a x; b x] with
   | [y1; y2; y3] -> tata
   | _ -> (assert false) (:bisect visit)


let unused = ()
..(:bisect ignore)
=================================================


A Bolt-like example (extension nodes on expressions):

=================================================
let funct n =
   (&log) "funct(%d)" n LEVEL DEBUG;
   for i = 1 to n do
     print_endline "..."
   done
=================================================

or:

=================================================
let funct n =
   (&log "funct(%d)" n LEVEL DEBUG);
   for i = 1 to n do
     print_endline "..."
   done
=================================================


A map/fold generator (extension nodes on structure item):

=================================================
type variable = string
  and term =
   | Var of variable
   | Lam of variable * term
   | App of term * term


..(&generate_map map term)
=================================================

or, if we also add extension nodes on class expressions:

=================================================
type variable = string
  and term =
   | Var of variable
   | Lam of variable * term
   | App of term * term


class map = (&generate_map term)
=================================================



-- Alain

From gabriel.scherer at gmail.com  Fri Mar  1 13:40:22 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 1 Mar 2013 14:40:22 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5130A79A.2080505@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
Message-ID: <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>

I'm not fond of having "with" as a special case. If you don't support
the type-conv or deriving syntax as is, could we take this as an
opportunity to go back to an uniform syntax? Type declaration could be
handled like any structure item.

Don't we want to have attributes on signature items as well?

Finally, I bet the non-terminal ".." will get little love, but I'm
sure you considered other option (for example just ;;(:foo), but that
doesn't work in the toplevel and we really want ";;" to help *avoid*
precedence issues) and trust that this is one of the less ugly ones.

Is that proposal sufficient to do ocamldoc with structured attributes
rather than comments? It looks like it is. Can an annotation node, by
itself, stand as a structure item (I'm thinking section comments)?

On Fri, Mar 1, 2013 at 2:05 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/01/2013 09:08 AM, Mark Shinwell wrote:
>>
>> 1. If possible, I'd rather see one new syntactic form, rather than
>> three.
>
>
> I've made the syntax more uniform, dropped prefix attributes, and added
> attributes on type declarations.
>
> The current syntax is:
>
> Attributes:
>
>   On expressions:         expr (:foo expr)
>   On type expressions:    type (:foo expr)
>   On structure items:     str_item ..(:foo expr)
>   On type declarations:   type t = ... with (:foo1 expr1) (:foo2 expr2)
>
> Extension nodes:
>
>   On expressions:         (&foo expr)
>   On type expressions:    (&foo expr)
>   On structure items:     ..(&foo expr)
>
>
> A type-conv like example (attributes on type expressions and type
> declarations):
>
>
> =================================================
>  type t = {
>     x : int (:default 42);
>     y : int (:default 3) (:sexp_drop_default);
>     z : int (:default 3) (:sexp_drop_if z_test);
>  } with (:sexp)
> =================================================
>
>
> A Bisect-like example (attributes on expressions and structure items):
>
> =================================================
> let f x =
>   match List.map foo [x; a x; b x] with
>   | [y1; y2; y3] -> tata
>   | _ -> (assert false) (:bisect visit)
>
>
> let unused = ()
> ..(:bisect ignore)
> =================================================
>
>
> A Bolt-like example (extension nodes on expressions):
>
> =================================================
> let funct n =
>   (&log) "funct(%d)" n LEVEL DEBUG;
>   for i = 1 to n do
>     print_endline "..."
>   done
> =================================================
>
> or:
>
> =================================================
> let funct n =
>   (&log "funct(%d)" n LEVEL DEBUG);
>   for i = 1 to n do
>     print_endline "..."
>   done
> =================================================
>
>
> A map/fold generator (extension nodes on structure item):
>
> =================================================
> type variable = string
>  and term =
>   | Var of variable
>   | Lam of variable * term
>   | App of term * term
>
>
> ..(&generate_map map term)
> =================================================
>
> or, if we also add extension nodes on class expressions:
>
> =================================================
> type variable = string
>  and term =
>   | Var of variable
>   | Lam of variable * term
>   | App of term * term
>
>
> class map = (&generate_map term)
> =================================================
>
>
>
> -- Alain
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From markus.mottl at gmail.com  Fri Mar  1 13:47:48 2013
From: markus.mottl at gmail.com (Markus Mottl)
Date: Fri, 1 Mar 2013 08:47:48 -0500
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
Message-ID: <CAP_800rrrqWffWoi+wN-V4yr_-61nsnAVQWQUOfhMMfwHGmzYw@mail.gmail.com>

It would be great to have one uniform syntax for syntax extensions.  I
don't think we absolutely should keep type_conv like extensions if a
new approach can replace them.  I can understand that industrial users
that have thousands of legacy annotations will not be happy having to
change their sources.  But I think updating sources could be safely
automated to a large extent, and any remaining fixes could be applied
with a little elbow grease.

Regards,
Markus

On Fri, Mar 1, 2013 at 8:40 AM, Gabriel Scherer
<gabriel.scherer at gmail.com> wrote:
> I'm not fond of having "with" as a special case. If you don't support
> the type-conv or deriving syntax as is, could we take this as an
> opportunity to go back to an uniform syntax? Type declaration could be
> handled like any structure item.
>
> Don't we want to have attributes on signature items as well?
>
> Finally, I bet the non-terminal ".." will get little love, but I'm
> sure you considered other option (for example just ;;(:foo), but that
> doesn't work in the toplevel and we really want ";;" to help *avoid*
> precedence issues) and trust that this is one of the less ugly ones.
>
> Is that proposal sufficient to do ocamldoc with structured attributes
> rather than comments? It looks like it is. Can an annotation node, by
> itself, stand as a structure item (I'm thinking section comments)?
>
> On Fri, Mar 1, 2013 at 2:05 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> On 03/01/2013 09:08 AM, Mark Shinwell wrote:
>>>
>>> 1. If possible, I'd rather see one new syntactic form, rather than
>>> three.
>>
>>
>> I've made the syntax more uniform, dropped prefix attributes, and added
>> attributes on type declarations.
>>
>> The current syntax is:
>>
>> Attributes:
>>
>>   On expressions:         expr (:foo expr)
>>   On type expressions:    type (:foo expr)
>>   On structure items:     str_item ..(:foo expr)
>>   On type declarations:   type t = ... with (:foo1 expr1) (:foo2 expr2)
>>
>> Extension nodes:
>>
>>   On expressions:         (&foo expr)
>>   On type expressions:    (&foo expr)
>>   On structure items:     ..(&foo expr)
>>
>>
>> A type-conv like example (attributes on type expressions and type
>> declarations):
>>
>>
>> =================================================
>>  type t = {
>>     x : int (:default 42);
>>     y : int (:default 3) (:sexp_drop_default);
>>     z : int (:default 3) (:sexp_drop_if z_test);
>>  } with (:sexp)
>> =================================================
>>
>>
>> A Bisect-like example (attributes on expressions and structure items):
>>
>> =================================================
>> let f x =
>>   match List.map foo [x; a x; b x] with
>>   | [y1; y2; y3] -> tata
>>   | _ -> (assert false) (:bisect visit)
>>
>>
>> let unused = ()
>> ..(:bisect ignore)
>> =================================================
>>
>>
>> A Bolt-like example (extension nodes on expressions):
>>
>> =================================================
>> let funct n =
>>   (&log) "funct(%d)" n LEVEL DEBUG;
>>   for i = 1 to n do
>>     print_endline "..."
>>   done
>> =================================================
>>
>> or:
>>
>> =================================================
>> let funct n =
>>   (&log "funct(%d)" n LEVEL DEBUG);
>>   for i = 1 to n do
>>     print_endline "..."
>>   done
>> =================================================
>>
>>
>> A map/fold generator (extension nodes on structure item):
>>
>> =================================================
>> type variable = string
>>  and term =
>>   | Var of variable
>>   | Lam of variable * term
>>   | App of term * term
>>
>>
>> ..(&generate_map map term)
>> =================================================
>>
>> or, if we also add extension nodes on class expressions:
>>
>> =================================================
>> type variable = string
>>  and term =
>>   | Var of variable
>>   | Lam of variable * term
>>   | App of term * term
>>
>>
>> class map = (&generate_map term)
>> =================================================
>>
>>
>>
>> -- Alain
>>
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4



-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com

From pierre.chambart at crans.org  Fri Mar  1 15:17:54 2013
From: pierre.chambart at crans.org (Pierre Chambart)
Date: Fri, 1 Mar 2013 16:17:54 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
Message-ID: <20130301161754.766b9e9b@crans.org>

Le Fri, 1 Mar 2013 14:40:22 +0100,
Gabriel Scherer <gabriel.scherer at gmail.com> a ?crit :

> I'm not fond of having "with" as a special case. If you don't support
> the type-conv or deriving syntax as is, could we take this as an
> opportunity to go back to an uniform syntax? Type declaration could be
> handled like any structure item.
> 
> Don't we want to have attributes on signature items as well?
> 
> Finally, I bet the non-terminal ".." will get little love, but I'm
> sure you considered other option (for example just ;;(:foo), but that
> doesn't work in the toplevel and we really want ";;" to help *avoid*
> precedence issues) and trust that this is one of the less ugly ones.
> 
> Is that proposal sufficient to do ocamldoc with structured attributes
> rather than comments? It looks like it is. Can an annotation node, by
> itself, stand as a structure item (I'm thinking section comments)?

I think that ocamldoc like things would need the 'any string' kind of
attribute that was discused in previous threads. I imagine that this
will need some clever lexing tricks to find a start delimiter that is
not currently accepted and seems nice. Since I a very bad at choosing
syntax what I will propose will be ugly:

something like

(:#DELIM#ident the real stringDELIM) and
(&#DELIM#ident the real stringDELIM)

maybe it the string does not contains # and ) we could also allow
(:#ident the real string)
(&#ident the real string)

Feel free to find that awfull and have any proposition that will
necessarily be better...

By the way I like the overall proposition. Go on Alain !
-- 
Pierre
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130301/f55c5981/attachment.sig>

From yminsky at janestreet.com  Fri Mar  1 15:31:54 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 1 Mar 2013 10:31:54 -0500
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAP_800rrrqWffWoi+wN-V4yr_-61nsnAVQWQUOfhMMfwHGmzYw@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
 <CAP_800rrrqWffWoi+wN-V4yr_-61nsnAVQWQUOfhMMfwHGmzYw@mail.gmail.com>
Message-ID: <CACLX4jRNv27WgSzqG4j5nxojtt9oS3FOjnfFpsP6M_+i4t=s1Q@mail.gmail.com>

On Fri, Mar 1, 2013 at 8:47 AM, Markus Mottl <markus.mottl at gmail.com> wrote:
> It would be great to have one uniform syntax for syntax extensions.  I
> don't think we absolutely should keep type_conv like extensions if a
> new approach can replace them.  I can understand that industrial users
> that have thousands of legacy annotations will not be happy having to
> change their sources.  But I think updating sources could be safely
> automated to a large extent, and any remaining fixes could be applied
> with a little elbow grease.

I do think that "with (:sexp)" is of no real benefit to us.  There's
some value in keeping the syntax largely as it was (i.e., "with sexp,
bin_io"), but if we're going to change the syntax at all, I'd prefer a
clean break.

And we can surely apply some elbow grease to get over the hump.

y

> Regards,
> Markus
>
> On Fri, Mar 1, 2013 at 8:40 AM, Gabriel Scherer
> <gabriel.scherer at gmail.com> wrote:
>> I'm not fond of having "with" as a special case. If you don't support
>> the type-conv or deriving syntax as is, could we take this as an
>> opportunity to go back to an uniform syntax? Type declaration could be
>> handled like any structure item.
>>
>> Don't we want to have attributes on signature items as well?
>>
>> Finally, I bet the non-terminal ".." will get little love, but I'm
>> sure you considered other option (for example just ;;(:foo), but that
>> doesn't work in the toplevel and we really want ";;" to help *avoid*
>> precedence issues) and trust that this is one of the less ugly ones.
>>
>> Is that proposal sufficient to do ocamldoc with structured attributes
>> rather than comments? It looks like it is. Can an annotation node, by
>> itself, stand as a structure item (I'm thinking section comments)?
>>
>> On Fri, Mar 1, 2013 at 2:05 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>> On 03/01/2013 09:08 AM, Mark Shinwell wrote:
>>>>
>>>> 1. If possible, I'd rather see one new syntactic form, rather than
>>>> three.
>>>
>>>
>>> I've made the syntax more uniform, dropped prefix attributes, and added
>>> attributes on type declarations.
>>>
>>> The current syntax is:
>>>
>>> Attributes:
>>>
>>>   On expressions:         expr (:foo expr)
>>>   On type expressions:    type (:foo expr)
>>>   On structure items:     str_item ..(:foo expr)
>>>   On type declarations:   type t = ... with (:foo1 expr1) (:foo2 expr2)
>>>
>>> Extension nodes:
>>>
>>>   On expressions:         (&foo expr)
>>>   On type expressions:    (&foo expr)
>>>   On structure items:     ..(&foo expr)
>>>
>>>
>>> A type-conv like example (attributes on type expressions and type
>>> declarations):
>>>
>>>
>>> =================================================
>>>  type t = {
>>>     x : int (:default 42);
>>>     y : int (:default 3) (:sexp_drop_default);
>>>     z : int (:default 3) (:sexp_drop_if z_test);
>>>  } with (:sexp)
>>> =================================================
>>>
>>>
>>> A Bisect-like example (attributes on expressions and structure items):
>>>
>>> =================================================
>>> let f x =
>>>   match List.map foo [x; a x; b x] with
>>>   | [y1; y2; y3] -> tata
>>>   | _ -> (assert false) (:bisect visit)
>>>
>>>
>>> let unused = ()
>>> ..(:bisect ignore)
>>> =================================================
>>>
>>>
>>> A Bolt-like example (extension nodes on expressions):
>>>
>>> =================================================
>>> let funct n =
>>>   (&log) "funct(%d)" n LEVEL DEBUG;
>>>   for i = 1 to n do
>>>     print_endline "..."
>>>   done
>>> =================================================
>>>
>>> or:
>>>
>>> =================================================
>>> let funct n =
>>>   (&log "funct(%d)" n LEVEL DEBUG);
>>>   for i = 1 to n do
>>>     print_endline "..."
>>>   done
>>> =================================================
>>>
>>>
>>> A map/fold generator (extension nodes on structure item):
>>>
>>> =================================================
>>> type variable = string
>>>  and term =
>>>   | Var of variable
>>>   | Lam of variable * term
>>>   | App of term * term
>>>
>>>
>>> ..(&generate_map map term)
>>> =================================================
>>>
>>> or, if we also add extension nodes on class expressions:
>>>
>>> =================================================
>>> type variable = string
>>>  and term =
>>>   | Var of variable
>>>   | Lam of variable * term
>>>   | App of term * term
>>>
>>>
>>> class map = (&generate_map term)
>>> =================================================
>>>
>>>
>>>
>>> -- Alain
>>>
>>> _______________________________________________
>>> wg-camlp4 mailing list
>>> wg-camlp4 at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/wg-camlp4
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>
>
>
> --
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Fri Mar  1 16:28:49 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 17:28:49 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <CAPFanBE5MncSgihzf3VevEAPwrGVt=5Mz8ko5kN6_jVVbQi9eQ@mail.gmail.com>
Message-ID: <5130D741.5090704@lexifi.com>

On 03/01/2013 02:40 PM, Gabriel Scherer wrote:
> I'm not fond of having "with" as a special case. If you don't support
> the type-conv or deriving syntax as is, could we take this as an
> opportunity to go back to an uniform syntax? Type declaration could be
> handled like any structure item.

Cf my previous email:

> There will be a need for attributes on individual type declarations (not only structure items, since a set of mutually recursive declarations in a single structure item), and "with" seems quite good.

An alternative solution would be to consider each declared type as its 
own structure item, so that we wouldn't need an extra notation for 
attributes attached to them.  This changes the current definition of the 
Parsetree.  Do you think it would be a good idea?

> Don't we want to have attributes on signature items as well?

Of course we do.  Also on patterns, class expressions, module 
expressions, module types, etc.

> Finally, I bet the non-terminal ".." will get little love, but I'm
> sure you considered other option (for example just ;;(:foo), but that
> doesn't work in the toplevel and we really want ";;" to help *avoid*
> precedence issues) and trust that this is one of the less ugly ones.

Even without considering technical issues with it, ;;(:foo) does not 
seem so good, because ;; looks like a strong end delimiter for the 
reader and it is weird to have something after it related to what's 
before.  (In the same way that it is weird to have a parenthesized 
sentence after a full dot if if related to the previous sentence :-))

> Is that proposal sufficient to do ocamldoc with structured attributes
> rather than comments? It looks like it is. Can an annotation node, by
> itself, stand as a structure item (I'm thinking section comments)?

An extension nodes stands as a structure item:

..(&foo)

but the type-checker is assumed to fail on them.  Attributes are 
normally attached to something.  Here you mention the need for an 
ignorable extension.  I don't think we want to introduce a third notion. 
  A solution would be to say that contrary to "algebraic structures" 
(expressions, type expressions, patterns), attributes within structures 
are not attached to structured items but are just part of the sequence 
of items of the structure.  So they would be more like extension nodes, 
but silently ignored by the type-checker.  We could then have the 
convention that an attribute placed after a structure item might pertain 
to it.  "ocamldoc" could then use some attributes for section delimiters 
and other attributes to document structure items.  Do you think this is 
an interesting direction?


Alain

From lpw25 at cam.ac.uk  Fri Mar  1 17:52:11 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 01 Mar 2013 17:52:11 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5130A79A.2080505@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
Message-ID: <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>

Looking at the code, I don't think that it is taking the correct approach 
to defining the extension syntaxes.

The standard way to define a delimiter like "(:", in keeping with how the 
rest of OCaml is parsed, is to make it a single token from the lexer.

This (dramatically) restricts our choice of delimiters but it also makes it 
much easier to use precedences to parse the extensions in more positions.

After looking through the parser in detail to find safe delimiters, I have 
created a (untested) patch of your implementation that provides the 
following syntaxes:

1. Extensions:

     (: ident expr_opt ) 

   Used as a structure item, signature item, expression or type expression.

2. Attributes:

     [: ident expr_opt ]

   Attached postfix to structure items, signature items, expressions or 
   type expressions.

3. With Attributes

     with ident ( expr), ident, ident (expr) 

   Attached postfix to structure items or signature items.

There are two attribute syntaxes because it is difficult to have a single 
attribute syntax that can be used easily across all these categories. I 
also think that the "with" syntax is particularly nice with types and 
encourages a sensible kind of meta-programming.

The patch is available at:

  http://www.cl.cam.ac.uk/~lpw25/extension_points.diff

Regards,

Leo



From alain.frisch at lexifi.com  Fri Mar  1 18:51:45 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 19:51:45 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
Message-ID: <5130F8C1.9020904@lexifi.com>

On 03/01/2013 06:52 PM, Leo White wrote:
> The standard way to define a delimiter like "(:", in keeping with how
> the rest of OCaml is parsed, is to make it a single token from the lexer.

Agreed!

>
> 1. Extensions:
>
>      (: ident expr_opt )
>    Used as a structure item, signature item, expression or type expression.
>
> 2. Attributes:
>
>      [: ident expr_opt ]
>
>    Attached postfix to structure items, signature items, expressions or
>    type expressions.
>
> 3. With Attributes
>
>      with ident ( expr), ident, ident (expr)
>    Attached postfix to structure items or signature items.

This looks good to me.

We also need attributes on individual types in a type declaration.

Also, I think it make sense for structure/signature items, to consider 
that attributes are "between" items, to support things like ocamldoc 
section headers.

I've started to work on a change to the Parsetree (unfinished, not 
committed yet):

http://alain.frisch.fr/split_type_decls.txt

where each declared type in a type declaration become a full 
structure/signature item with a marker telling if this is the first type 
in the declaration or not (similar to the representation of signatures 
in the Types module).  This puts some extra invariants in the Parsetree 
(a Pstr_type Prec_nextmust follow another Pstr_type ..., maybe with 
attributes in between), but then we don't need to distinguish 
syntactically attributes on a declared type and attributes on the whole 
declarations, which would be hard to explain to users.

The goal is to be able to write (keeping my original syntax for 
attributes in structure items):

===============================================
..(:doc 2 "My section header")

type t = {...} ..(:id expr) ..(:id expr)
and  s = {...} ..(:id expr)

..(:doc 2 "Another section header")
===============================================

Here we have the following sequence of structure items:

  Pstr_attribute "doc"
  Pstr_type (Prec_first, ...)
  Pstr_attributes "id"
  Pstr_attributes "id"
  Pstr_type (Prec_next, ...)
  Pstr_attributes "id"
  Pstr_attributes "doc"



Independently of the syntax, I'd be interested to get feedback on these 
two proposals:

  -  splitting declarations of mutually recursive types into single 
declarations in the Parsetree, and

  -  having attributes as standalone items within signatures and 
structures (so also between types in a single recursive declaration) 
instead of having them attached to other items.


Alain

From gabriel.scherer at gmail.com  Fri Mar  1 20:01:05 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 1 Mar 2013 21:01:05 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5130F8C1.9020904@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <5130F8C1.9020904@lexifi.com>
Message-ID: <CAPFanBE-i0KDTmUAsSyD4eUhRYx7bZT6bxoWO5X9FmNzRFCUzA@mail.gmail.com>

I'm sorry if my remarks set you in this way, but I'm not sure the
recent changes go in the right direction.

1. I have bad feelings about the idea to split "type foo = bar and baz
= foobar" in two structure items. I'm not sure how that affect the
parsing rules (is "type foo = bar;; and baz = foobar" legal now?), and
more importantly it doesn't fit my mental model of structure items as
being self-contained unit of meaning that can, say, be sent separately
to a toplevel (and this is actually a very important use case). If
"foo" and "baz" are mutually recursive type in my example about, it
makes no sense to consider "type foo = bar" in isolation.

This remark is in direct conflict with my previous remark that "with"
could be replaced by the generic annotation on structure_items. This
previous remark was a mistake, as I had not thought of mutually
recursive definitions, and I now believe that you indeed need to
attach attributes to the grammar element named "typedef" in the manual
grammar description (
http://caml.inria.fr/pub/docs/manual-ocaml/manual016.html ).

(Orthogonal anecdote: Damien Doligez has been looking closely at the
BNF described in the manual recently, and committed some fixes to it.
Contrary to what intuition suggests, it is reasonably safe to assume
that it is correctly describes the grammar of the language as we
understand it.)

2. I have mixed feelings about the idea that detaching struct_item
attributes from the corresponding struct_item is the right way to
handle the OCamldoc setting. I'd rather keep a more semantic model
that makes it explicit what an annotation scopes over, and more
convenient to write consumers/extensions to handle attributes (no need
to peek at the next structure items to collect all annotations for the
current one). Maybe ocamldoc sections could simply be modeled as
annotations on "();;", if we don't discover that we really want
ignored-by-default annotations in the general case (I wouldn't be
surprised).


On Fri, Mar 1, 2013 at 7:51 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/01/2013 06:52 PM, Leo White wrote:
>>
>> The standard way to define a delimiter like "(:", in keeping with how
>> the rest of OCaml is parsed, is to make it a single token from the lexer.
>
>
> Agreed!
>
>
>>
>> 1. Extensions:
>>
>>      (: ident expr_opt )
>>    Used as a structure item, signature item, expression or type
>> expression.
>>
>> 2. Attributes:
>>
>>      [: ident expr_opt ]
>>
>>    Attached postfix to structure items, signature items, expressions or
>>    type expressions.
>>
>> 3. With Attributes
>>
>>      with ident ( expr), ident, ident (expr)
>>    Attached postfix to structure items or signature items.
>
>
> This looks good to me.
>
> We also need attributes on individual types in a type declaration.
>
> Also, I think it make sense for structure/signature items, to consider that
> attributes are "between" items, to support things like ocamldoc section
> headers.
>
> I've started to work on a change to the Parsetree (unfinished, not committed
> yet):
>
> http://alain.frisch.fr/split_type_decls.txt
>
> where each declared type in a type declaration become a full
> structure/signature item with a marker telling if this is the first type in
> the declaration or not (similar to the representation of signatures in the
> Types module).  This puts some extra invariants in the Parsetree (a
> Pstr_type Prec_nextmust follow another Pstr_type ..., maybe with attributes
> in between), but then we don't need to distinguish syntactically attributes
> on a declared type and attributes on the whole declarations, which would be
> hard to explain to users.
>
> The goal is to be able to write (keeping my original syntax for attributes
> in structure items):
>
> ===============================================
> ..(:doc 2 "My section header")
>
> type t = {...} ..(:id expr) ..(:id expr)
> and  s = {...} ..(:id expr)
>
> ..(:doc 2 "Another section header")
> ===============================================
>
> Here we have the following sequence of structure items:
>
>  Pstr_attribute "doc"
>  Pstr_type (Prec_first, ...)
>  Pstr_attributes "id"
>  Pstr_attributes "id"
>  Pstr_type (Prec_next, ...)
>  Pstr_attributes "id"
>  Pstr_attributes "doc"
>
>
>
> Independently of the syntax, I'd be interested to get feedback on these two
> proposals:
>
>  -  splitting declarations of mutually recursive types into single
> declarations in the Parsetree, and
>
>  -  having attributes as standalone items within signatures and structures
> (so also between types in a single recursive declaration) instead of having
> them attached to other items.
>
>
> Alain
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Fri Mar  1 22:37:58 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Mar 2013 23:37:58 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAPFanBE-i0KDTmUAsSyD4eUhRYx7bZT6bxoWO5X9FmNzRFCUzA@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <5130F8C1.9020904@lexifi.com>
 <CAPFanBE-i0KDTmUAsSyD4eUhRYx7bZT6bxoWO5X9FmNzRFCUzA@mail.gmail.com>
Message-ID: <51312DC6.7010106@lexifi.com>

On 3/1/2013 9:01 PM, Gabriel Scherer wrote:
> I'm sorry if my remarks set you in this way, but I'm not sure the
> recent changes go in the right direction.

No problem, it is just an experiment.

> This remark is in direct conflict with my previous remark that "with"
> could be replaced by the generic annotation on structure_items. This
> previous remark was a mistake, as I had not thought of mutually
> recursive definitions, and I now believe that you indeed need to
> attach attributes to the grammar element named "typedef" in the manual
> grammar description (
> http://caml.inria.fr/pub/docs/manual-ocaml/manual016.html ).

Do you think we still need generic attributes on structure items, or 
would attributes on each declared typed + each declared values + etc... 
be enough?

> 2. I have mixed feelings about the idea that detaching struct_item
> attributes from the corresponding struct_item is the right way to
> handle the OCamldoc setting. I'd rather keep a more semantic model
> that makes it explicit what an annotation scopes over, and more
> convenient to write consumers/extensions to handle attributes (no need
> to peek at the next structure items to collect all annotations for the
> current one). Maybe ocamldoc sections could simply be modeled as
> annotations on "();;", if we don't discover that we really want
> ignored-by-default annotations in the general case (I wouldn't be
> surprised).

To keep things more structured, it could make sense to have the ocamldoc 
section header be an attribute on the section, as in:

include sig
  ...
end ..(:doc "My section header")

In that case, we'd better have a prefix syntax for attributes on this 
"include" signature item:

(@doc "My section header")
include sig
   ...
end

But while this make sense from a structural point of view, this starts 
to look heavy, doesn't it?   (That said, another advantage of this 
structural approach is that you can use your editor to "fold" the 
ocamldoc section...)


Alain

From alain.frisch at lexifi.com  Mon Mar  4 10:47:48 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 11:47:48 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
Message-ID: <51347BD4.4060008@lexifi.com>

On 03/01/2013 06:52 PM, Leo White wrote:
> Looking at the code, I don't think that it is taking the correct
> approach to defining the extension syntaxes.

I'll backtrack my changes (I agree with Gabriel that it is not a great 
idea to "split" declarations of multiple types into individual 
signature/structure items), and try to incorporate yours.

However:

> 3. With Attributes
>
>      with ident ( expr), ident, ident (expr)
>    Attached postfix to structure items or signature items.

I think those attributes should be attached to declared types, not 
structure/signature items.  It is important to attach different 
attributes to each type in a multi-type declaration.

What I'm less convinced now is that we need attributes on arbitrary 
structure/signature items, rather that on individual components. 
Consider for instance signature items:

and signature_item_desc =
     Psig_value of string loc * value_description
   | Psig_type of (string loc * type_declaration) list
   | Psig_exception of string loc * exception_declaration
   | Psig_module of string loc * module_type
   | Psig_recmodule of (string loc * module_type) list
   | Psig_modtype of string loc * modtype_declaration
   | Psig_open of Longident.t loc
   | Psig_include of module_type
   | Psig_class of class_description list
   | Psig_class_type of class_type_declaration list


I propose to add attributes to value_description, type_declaration, 
exception_declaration, the Psig_module case each item in the 
Psig_recmodule case, the Psig_modtype case, the Psig_open case, the 
Psig_include case, class_description, class_type_declaration.  While we 
are at it, we could introduce a proper record types for 
exception_declaration.  We could also push the names (of declared 
values, names, etc) inside their *_description or *_declaration record.


Opinion on these changes?   I think it's rather important to agree on 
where attributes can be put exactly.



Alain

From lpw25 at cam.ac.uk  Mon Mar  4 10:51:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 04 Mar 2013 10:51:12 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <51347BD4.4060008@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
Message-ID: <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>

>
>Opinion on these changes?   I think it's rather important to agree on 
>where attributes can be put exactly.
>

That all seems reasonable to me.

Leo

From alain.frisch at lexifi.com  Mon Mar  4 13:00:22 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 14:00:22 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
Message-ID: <51349AE6.2090000@lexifi.com>

On 03/04/2013 11:51 AM, Leo White wrote:
>> Opinion on these changes?   I think it's rather important to agree on
>> where attributes can be put exactly.
>>
>
> That all seems reasonable to me.

I've committed a version where attributes are mostly parsed as in your 
patch.

Currently supported:

- Attributes  .... [: lid expr ]
   where .... can be:

     a module expression
     an expression
     a type expression

- Extension (: lid expr )
   in position of a:

    a module expression
    an expression
    a type expression

- Attributes .... with lid1(expr1),..,lidn(exprn)
   where .... can be:

    a single type declaration
    an open or include structure item (more to come)


-- Alain

From lpw25 at cam.ac.uk  Mon Mar  4 13:44:10 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 04 Mar 2013 13:44:10 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <51349AE6.2090000@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
Message-ID: <Prayer.1.3.5.1303041344100.31492@hermes-1.csi.cam.ac.uk>

>I've committed a version where attributes are mostly parsed as in your 
>patch.
>
> [...]
>
>- Extension (: lid expr )
>   in position of a:
>
>    a module expression
>    an expression
>    a type expression


Is there any particular reason that these are not allowed as structure 
items?


From gabriel.scherer at gmail.com  Mon Mar  4 13:52:26 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 4 Mar 2013 14:52:26 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <51349AE6.2090000@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
Message-ID: <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>

Could Alain or Leo summarize what is the design space of safe
annotation grammars, lexing/parsing wise?

Some remarks on the current situation:

1. After thinking about it more, I regret the use of the (: foo)
syntax for two different reasons. For once, all delimiters in the
OCaml syntax so far are symmetric ([, {, (, but also [< and {<), and
I'm not sure there is a reason to break this here, so I'd rather have
(: foo :) (I asked the same question for my sequence-comprehension
camlp4 extension that started using [? foo ], then swichted to [? foo
?] -- with a lexer modification to handle those as two-char tokens) .
Another problematic aspect is that we already have ( exp : ty ) in the
OCaml grammar, and I'm not too happy with something that rather
closely looks like (: ty ). Finally, I'm not sure that it's wise to
eat up both (: and [: for related purposes; there are not a lot of
convenient delimiters (pretty much only (, [ and { ) and we will have
people suggesting new syntaxes for a lot of years to come. Could the
two syntaxes share a single delimiter prefix, for example [: and [:: ?

2. I'm unsure about generalization of the "with" syntax to other
syntactic cases. In expression context, "with" is very much associated
to pattern matching, and in particular there is syntactic contention
around a potential "let try ... = ... with ... in" construct. Using
"with" in local module open introduces avenue for confusion. The
with-syntax has the important advantage of internalizing an existing
practice in type-conv, but I'm not sure it scales so well to other
syntactic constructs. What is the current rationale for when to use
with, and when to use with (besides "when the grammar does not
conflict"?).

3. I think we really need a prefix syntax. If we where to use this
annotation syntax for compiler pragmas (locally enabling/disabling
some warning, for example), users would really want to be able to
write, say,

  begin [: pragma(non_exhaustive_match) :]
    ...
  end


On Mon, Mar 4, 2013 at 2:00 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/04/2013 11:51 AM, Leo White wrote:
>>>
>>> Opinion on these changes?   I think it's rather important to agree on
>>> where attributes can be put exactly.
>>>
>>
>> That all seems reasonable to me.
>
>
> I've committed a version where attributes are mostly parsed as in your
> patch.
>
> Currently supported:
>
> - Attributes  .... [: lid expr ]
>   where .... can be:
>
>     a module expression
>     an expression
>     a type expression
>
> - Extension (: lid expr )
>   in position of a:
>
>    a module expression
>    an expression
>    a type expression
>
> - Attributes .... with lid1(expr1),..,lidn(exprn)
>   where .... can be:
>
>    a single type declaration
>    an open or include structure item (more to come)
>
>
> -- Alain
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Mon Mar  4 14:07:38 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 15:07:38 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303041344100.31492@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <Prayer.1.3.5.1303041344100.31492@hermes-1.csi.cam.ac.uk>
Message-ID: <5134AAAA.5010501@lexifi.com>

On 03/04/2013 02:44 PM, Leo White wrote:
>> I've committed a version where attributes are mostly parsed as in your
>> patch.
>>
>> [...]
>>
>> - Extension (: lid expr )
>>   in position of a:
>>
>>    a module expression
>>    an expression
>>    a type expression
>
>
> Is there any particular reason that these are not allowed as structure
> items?

I've removed the notion of extension as structure item at the same time 
I removed the notion of attribute on structure item.  I believe 
extensions as structure items will not be frequently useful, and they 
required a specific syntax (or created opportunities of conflicts with 
other categories).  It is always possible to write, for instance:

   include (:foo bar)

where (:foo bar) is as a (module expression) extension.

-- Alain

From alain.frisch at lexifi.com  Mon Mar  4 14:32:02 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 15:32:02 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
Message-ID: <5134B062.6010106@lexifi.com>

On 03/04/2013 02:52 PM, Gabriel Scherer wrote:
 > For once, all delimiters in the
 > OCaml syntax so far are symmetric ([, {, (, but also [< and {<),

This is not true, for instance, for ocamldoc comments (I know they are 
not part of the OCaml syntax!), and personally I'm not sure to see the 
benefit of making the syntax heavier just to keep symmetry.

> Could the
> two syntaxes share a single delimiter prefix, for example [: and [:: ?
 > ...
 > I think we really need a prefix syntax.

I don't have a strong opinion on syntax, and I agree with the need for a 
prefix syntax (another example:  ocamldoc section header, as a 
prefix-attribute on an "include").

Leo seems to be a lot more comfortable than me with hacking the concrete 
syntax, so I'll let him comment on the possibilities.

> 2. I'm unsure about generalization of the "with" syntax to other
> syntactic cases. In expression context, "with" is very much associated
> to pattern matching, and in particular there is syntactic contention
> around a potential "let try ... = ... with ... in" construct. Using
> "with" in local module open introduces avenue for confusion.

I was thinking about using the "with" syntax only for 
structure/signature item-like components (only that we want to attach 
them to individual component in case of multi-component declarations), 
and probably exclude the expression-as-a-structure-item case.

But it's true that the following:

open M with foo
include S with foo

can be misleading (this is not a with constraint on module type S).

(Before someone question the need for attributes on such items: yes, I 
think it can be useful.  For instance to guide, an attribute on an 
include statement in an interface could instruct ocamldoc whether it 
should inline the corresponding module type or keep it as a reference. 
For open: an attribute could control whether ocamldoc should use the 
opened module to shorten names in the generated doc.)


What about:

  ... [@id expr]    (* attribute on expression, pattern, type, module 
type, module expr *)

  [^id expr] ...    (* same, prefix syntax *)

  ... [@@id expr]   (* attribute on str/sig item-like components *)

  [#id expr]        (* extension as an expression, etc. *)


Alain

From david.waern at gmail.com  Mon Mar  4 14:44:03 2013
From: david.waern at gmail.com (David Waern)
Date: Mon, 4 Mar 2013 15:44:03 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5134B062.6010106@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com>
Message-ID: <CAN8ZjBFXof4LW_tD=4z+kqmhoaLRQtzoRHAJGQHmb2rqi2dNow@mail.gmail.com>

2013/3/4 Alain Frisch <alain.frisch at lexifi.com>

>
> What about:
>
>  ... [@id expr]    (* attribute on expression, pattern, type, module type,
> module expr *)
>
>  [^id expr] ...    (* same, prefix syntax *)
>

Could we switch these two so that ^ is used for the postfix version? :-)

David
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130304/61083cb6/attachment.html>

From lpw25 at cam.ac.uk  Mon Mar  4 15:55:46 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 04 Mar 2013 15:55:46 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5134AAAA.5010501@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <Prayer.1.3.5.1303041344100.31492@hermes-1.csi.cam.ac.uk>
 <5134AAAA.5010501@lexifi.com>
Message-ID: <Prayer.1.3.5.1303041555460.4948@hermes-1.csi.cam.ac.uk>

>I've removed the notion of extension as structure item at the same time 
>I removed the notion of attribute on structure item.  I believe 
>extensions as structure items will not be frequently useful, and they 
>required a specific syntax (or created opportunities of conflicts with 
>other categories).  It is always possible to write, for instance:
>
>   include (:foo bar)
>
>where (:foo bar) is as a (module expression) extension.

I don't think these are really a problem, since they should simply bind to 
the include statement. For ambiguous cases, inserting a ";;" should be 
sufficient to indicate that a following extension is a structure item.

The more difficult problem is the fact that ordinary expressions are often 
allowed as structure items. I had thought that my previous patch managed to 
sufficiently avoid this problem, but I now think that there will always be 
awkward conflicts between an expression extension and a structure item 
extension (especially in the toplevel).

So, in conclusion, I now agree that we should provide a separate syntax for 
structure item extensions.


From gabriel.scherer at gmail.com  Mon Mar  4 16:03:15 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 4 Mar 2013 17:03:15 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303041555460.4948@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <Prayer.1.3.5.1303041344100.31492@hermes-1.csi.cam.ac.uk>
 <5134AAAA.5010501@lexifi.com>
 <Prayer.1.3.5.1303041555460.4948@hermes-1.csi.cam.ac.uk>
Message-ID: <CAPFanBGehDbzmWnq6NXrjpRVz7FBwEVhQ6bkny_YS_yt6_6J5A@mail.gmail.com>

> I don't think these are really a problem, since they should simply bind to
> the include statement. For ambiguous cases, inserting a ";;" should be
> sufficient to indicate that a following extension is a structure item.

I think Alain's point is not that "include (: foo bar)" would be
conflicting, but precisely that people could decide by convention that
when they want to write (: foo bar) as a structure item, they tag it
with an "include". I'm not sure whether this is a good idea or not,
and if it is I would rather aim for the more canonical "struct (: foo
bar ) end", but I think tagging with terminals to get more structure
could be an interesting choice in other situations as well, eg. we
could possibly ditch prefix annotations and just use "let (: foo bar )
in ...".

On Mon, Mar 4, 2013 at 4:55 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>> I've removed the notion of extension as structure item at the same time I
>> removed the notion of attribute on structure item.  I believe extensions as
>> structure items will not be frequently useful, and they required a specific
>> syntax (or created opportunities of conflicts with other categories).  It is
>> always possible to write, for instance:
>>
>>   include (:foo bar)
>>
>> where (:foo bar) is as a (module expression) extension.
>
>
> I don't think these are really a problem, since they should simply bind to
> the include statement. For ambiguous cases, inserting a ";;" should be
> sufficient to indicate that a following extension is a structure item.
>
> The more difficult problem is the fact that ordinary expressions are often
> allowed as structure items. I had thought that my previous patch managed to
> sufficiently avoid this problem, but I now think that there will always be
> awkward conflicts between an expression extension and a structure item
> extension (especially in the toplevel).
>
> So, in conclusion, I now agree that we should provide a separate syntax for
> structure item extensions.
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Mon Mar  4 16:15:00 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 17:15:00 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAPFanBGehDbzmWnq6NXrjpRVz7FBwEVhQ6bkny_YS_yt6_6J5A@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <Prayer.1.3.5.1303041344100.31492@hermes-1.csi.cam.ac.uk>
 <5134AAAA.5010501@lexifi.com>
 <Prayer.1.3.5.1303041555460.4948@hermes-1.csi.cam.ac.uk>
 <CAPFanBGehDbzmWnq6NXrjpRVz7FBwEVhQ6bkny_YS_yt6_6J5A@mail.gmail.com>
Message-ID: <5134C884.1060701@lexifi.com>

On 03/04/2013 05:03 PM, Gabriel Scherer wrote:
>> I don't think these are really a problem, since they should simply bind to
>> the include statement. For ambiguous cases, inserting a ";;" should be
>> sufficient to indicate that a following extension is a structure item.
>
> I think Alain's point is not that "include (: foo bar)" would be
> conflicting, but precisely that people could decide by convention that
> when they want to write (: foo bar) as a structure item, they tag it
> with an "include".

I don't know if this is what you mean, but I claim that a general 
extension as a structure item is not needed.

The point is that:

include (:foo bar)

already exists; it is not a special case, just an instance of the 
constructions:

include MODULE_EXPR
or:
include MODULE_TYPE

and since we have extensions at the level of module expressions and 
types, the following is a valid structure/signature item:

include (:foo bar)

Given that, I don't see case where people would like to use extension as 
a signature/structure item but would not be happy with that form.


> I'm not sure whether this is a good idea or not,
> and if it is I would rather aim for the more canonical "struct (: foo
> bar ) end", but I think tagging with terminals to get more structure
> could be an interesting choice in other situations as well, eg. we
> could possibly ditch prefix annotations and just use "let (: foo bar )
> in ...".

The difference is that attributes are ignored by the type-checker while 
extensions are rejected.

-- Alain

From alain.frisch at lexifi.com  Mon Mar  4 17:57:05 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 18:57:05 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5134B062.6010106@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com>
Message-ID: <5134E071.4050408@lexifi.com>

Current state of the SVN branch:

Attributes on expressions, module expressions, types, patterns, module 
type expressions:

   postfix syntax: ... [@id expr]
   prefix syntax:  [^id expr] ...

Extensions on the same categories:

   [#lid expr]


Attributes on constructor declarations (needed for constant 
constructors, in particular):

  type t =
    | A [@id expr] [@id expr]
    | B [@id expr] [@id expr] of ...



"Item" attributes:

  postfix syntax:   ... [@@id expr]
  prefix syntax:    [^^id expr] ...

  Currently available on most kind of declarations/statements in 
signatures (except class and class types), and on some kinds of 
declarations in structures (exception declaration, open, include, types)

Example of a signature:

   [^^doc section "My functions"] include sig
      [^^deprecated]
      val foo: int -> int [@@since "3.01"]

      type t = A [@default] | B of (int [@init 10]) * s
	  [@@sexp]
           [@@doc "A type with two constructors"]

      and  [^^deprecated] s = {x : int [@init 1]; y : int [@init 2]}
           [@@doc "A record type"]

      include S
      [@@doc inline]
   end


-- Alain

From alain.frisch at lexifi.com  Mon Mar  4 18:05:40 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 19:05:40 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAN8ZjBFXof4LW_tD=4z+kqmhoaLRQtzoRHAJGQHmb2rqi2dNow@mail.gmail.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com>
 <CAN8ZjBFXof4LW_tD=4z+kqmhoaLRQtzoRHAJGQHmb2rqi2dNow@mail.gmail.com>
Message-ID: <5134E274.5070704@lexifi.com>

On 03/04/2013 03:44 PM, David Waern wrote:
> Could we switch these two so that ^ is used for the postfix version? :-)

For the records, after checking with David, this comes from Haddock (= 
ocamldoc for Haskell, also piggy-backing the generic syntax for comments):

http://www.haskell.org/haddock/doc/html/markup.html#id564988


Alain

From lpw25 at cam.ac.uk  Mon Mar  4 19:09:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 04 Mar 2013 19:09:12 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5134E071.4050408@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
Message-ID: <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>

>Extensions on the same categories:
>
>   [#lid expr]
>

This delimiter isn't technically safe (it could be made safe but its 
probably not worth the effort), might I suggest [%lid expr] as an 
alternative.

>"Item" attributes:
>
>  postfix syntax:   ... [@@id expr]
>  prefix syntax:    [^^id expr] ...
>

How about including "Item" extensions "[%%lid expr]"? I would rather not 
force people to use "include [%id expr]". I can imagine syntax extensions 
that might want to be used as both a strucuture item and a module 
expression.

>Attributes on constructor declarations (needed for constant
>constructors, in particular):
>
>  type t =
>    | A [@id expr] [@id expr]
>    | B [@id expr] [@id expr] of ...

I agree that we need a special syntax for variant constructor attributes. 
How about:

type t =
  | A with id, id(expr)
  | B of ... with id(expr), id

We could also allow this for convenient record label attributes. I think 
this syntax is already used in type-conv, it fits in with the "with" 
attributes for type declarations, and is a lighter syntax than the 
alternative.


From alain.frisch at lexifi.com  Mon Mar  4 20:43:08 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 04 Mar 2013 21:43:08 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
 <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
Message-ID: <5135075C.1080302@lexifi.com>

On 3/4/2013 8:09 PM, Leo White wrote:
>> Extensions on the same categories:
>>
>>   [#lid expr]
>>
>
> This delimiter isn't technically safe (it could be made safe but its
> probably not worth the effort), might I suggest [%lid expr] as an
> alternative.

Ah, I keep forgetting about #type pattern...  I'm fine with [%lid expr].

> How about including "Item" extensions "[%%lid expr]"? I would rather not
> force people to use "include [%id expr]". I can imagine syntax
> extensions that might want to be used as both a strucuture item and a
> module expression.

Well, the extension could always use a different lid to distinguish the 
two cases, but ok, it doesn't add too much complexity to support "item" 
extensions directly.


>>  type t =
>>    | A [@id expr] [@id expr]
>>    | B [@id expr] [@id expr] of ...
>
> I agree that we need a special syntax for variant constructor
> attributes. How about:
>
> type t =
>   | A with id, id(expr)
>   | B of ... with id(expr), id

This is a case where the standard syntax for attributes works well (if 
we put attributes before constructor arguments).  What's the argument in 
favor of a dedicated syntax?  (I like the fact that all attribute 
syntaxes look similar.)

> We could also allow this for convenient record label attributes.

Yes, it make sense.

> I think
> this syntax is already used in type-conv, it fits in with the "with"
> attributes for type declarations, and is a lighter syntax than the
> alternative.

What do you call lighter?  It uses fewer non-alphanumeric symbols, but 
it becomes more compact only with 4 attributes:

A with id(expr), id(expr), id(expr), id(expr)
A [@id expr] [@id expr] [@id expr] [@id expr]


How does type-conv distinguish attributes on the last constructors from 
attributes on the type itself?  (Where do we find the documentation for 
the syntax recognized by type-conv?)


Alain

From david.waern at gmail.com  Tue Mar  5 12:17:07 2013
From: david.waern at gmail.com (David Waern)
Date: Tue, 5 Mar 2013 13:17:07 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5134E274.5070704@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com>
 <CAN8ZjBFXof4LW_tD=4z+kqmhoaLRQtzoRHAJGQHmb2rqi2dNow@mail.gmail.com>
 <5134E274.5070704@lexifi.com>
Message-ID: <CAN8ZjBECg8Ga3=0p7HG3tP+n_PWAeQOXx83UbTNOj_CB+G2vsQ@mail.gmail.com>

2013/3/4 Alain Frisch <alain.frisch at lexifi.com>

> On 03/04/2013 03:44 PM, David Waern wrote:
>
>> Could we switch these two so that ^ is used for the postfix version? :-)
>>
>
> For the records, after checking with David, this comes from Haddock (=
> ocamldoc for Haskell, also piggy-backing the generic syntax for comments):
>
> http://www.haskell.org/**haddock/doc/html/markup.html#**id564988<http://www.haskell.org/haddock/doc/html/markup.html#id564988>
>
>
>
Sorry, should have added a few more sentences. So basically I just wanted
to add that ^ works better for postfix, when the attribute/extension is put
on the next line, since it resembles an up-arrow.

David
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130305/7766ea12/attachment.html>

From lpw25 at cam.ac.uk  Tue Mar  5 13:54:15 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Mar 2013 13:54:15 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <5135075C.1080302@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
 <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
 <5135075C.1080302@lexifi.com>
Message-ID: <Prayer.1.3.5.1303051354150.24635@hermes-1.csi.cam.ac.uk>

>>>  type t =
>>>    | A [@id expr] [@id expr]
>>>    | B [@id expr] [@id expr] of ...
>>
>> I agree that we need a special syntax for variant constructor
>> attributes. How about:
>>
>> type t =
>>   | A with id, id(expr)
>>   | B of ... with id(expr), id
>
>This is a case where the standard syntax for attributes works well (if 
>we put attributes before constructor arguments).  What's the argument in 
>favor of a dedicated syntax?  (I like the fact that all attribute 
>syntaxes look similar.)

My argument was based on the assumption that we were going to provide a 
"with" attribute syntax for type definitions (for convenience and to 
distinguish attributes on a type definition from attributes on a whole set 
of recursive type definitions). I have since noticed that using the same 
syntax for both would conflict.

>What do you call lighter?  It uses fewer non-alphanumeric symbols, but 
>it becomes more compact only with 4 attributes:
>
>A with id(expr), id(expr), id(expr), id(expr)
>
>A [@id expr] [@id expr] [@id expr] [@id expr]

I meant lighter in an aesthetic sense. It is easier for people to read code 
that uses alphanumeric characters. 

I think the "[@id expr]" syntax is more appropriate within expression and 
type expressions, but for "larger" constructs like structure items a 
keyword based solution would be preferable. However, other than by adding a 
keyword, I have not been able to come up with a suitable syntax that 
wouldn't conflict with some existing structure item.

>How does type-conv distinguish attributes on the last constructors from 
>attributes on the type itself?  

It turns out that type-conv only allows "with" for type definitions and 
record labels -- which don't conflict.


From alain.frisch at lexifi.com  Tue Mar  5 15:30:54 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Mar 2013 16:30:54 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303051354150.24635@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
 <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
 <5135075C.1080302@lexifi.com>
 <Prayer.1.3.5.1303051354150.24635@hermes-1.csi.cam.ac.uk>
Message-ID: <51360FAE.7040407@lexifi.com>

On 03/05/2013 02:54 PM, Leo White wrote:
> I meant lighter in an aesthetic sense. It is easier for people to read
> code that uses alphanumeric characters.
> I think the "[@id expr]" syntax is more appropriate within expression
> and type expressions, but for "larger" constructs like structure items a
> keyword based solution would be preferable.

One could argue that attributes "within expressions" should be the light 
ones (with only alphanumeric characters) because they are "in the way", 
while attributes on items on the contrary, can be allowed to be more 
visible because they apply on well-delimited and big pieces of syntax.

Also note that ocamldoc uses "non alphanumeric characters" for its 
"attributes" on small (constructors) and big items.

> However, other than by
> adding a keyword, I have not been able to come up with a suitable syntax
> that wouldn't conflict with some existing structure item.

Talking from experience, there will be a strong resistance to add a new 
keyword (and it is likely that a proposal for a new keyword would use a 
quite common name).  So let's assume this is not an option.


Alain

From alain.frisch at lexifi.com  Wed Mar  6 10:05:43 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 11:05:43 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
 <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
Message-ID: <513714F7.2090203@lexifi.com>

On 03/04/2013 08:09 PM, Leo White wrote:
> How about including "Item" extensions "[%%lid expr]"?

I now believe it would also be useful to have attributes as 
extension/signature item (in addition to attributes *on* items).  This 
will be lighter than putting attributes on "include" statements (e.g. 
for ocamldoc section headers), and it could also be useful to specify 
meta-data for the whole unit (as an attribute at the beginning of the 
file).   This problem is that this requires a third syntax for attributes.

Do people agree on the need for such attributes, and that a new syntax 
is required?  Any proposal?  I believe the following would be safe, for 
instance:

  [*  ...]
  [@@@ ...]
  [%? ...]


An alternative could be to have a "nop" signature/structure item 
(semantically equivalent to "include sig end"/"include struct end"), on 
which we can use the standard syntax for item attributes.  But we still 
need some new syntax for it...


Alain

From lpw25 at cam.ac.uk  Wed Mar  6 12:57:20 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 06 Mar 2013 12:57:20 +0000
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <513714F7.2090203@lexifi.com>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
 <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
 <513714F7.2090203@lexifi.com>
Message-ID: <Prayer.1.3.5.1303061257200.564@hermes-1.csi.cam.ac.uk>

>Do people agree on the need for such attributes, and that a new syntax 
>is required?  

I can understand the desire to attach attributes to the whole compilation 
unit, but that could be done without a new syntax by allowing postfix 
attributes at the start of a file.

I'm not sure that I understand the need for general attributes not attached 
to anything in the middle of the module. If their position is important 
then there must be some item that they are essentially attached to, if 
their position is not important then they can just be placed at the top of 
the module.


From alain.frisch at lexifi.com  Wed Mar  6 13:18:12 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 14:18:12 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <Prayer.1.3.5.1303061257200.564@hermes-1.csi.cam.ac.uk>
References: <512FC647.6050900@lexifi.com>
 <CACLX4jTkfWe-Ax+SUL=vvq-P_vhO2nVKMAbj61p=kqKXW44D6g@mail.gmail.com>
 <CAM3Ki76qvbESLoGiPahUrO00-vDf2Tz-sZ_33ev_w78oO6dEag@mail.gmail.com>
 <5130A79A.2080505@lexifi.com>
 <Prayer.1.3.5.1303011752110.11703@hermes-1.csi.cam.ac.uk>
 <51347BD4.4060008@lexifi.com>
 <Prayer.1.3.5.1303041051120.31488@hermes-1.csi.cam.ac.uk>
 <51349AE6.2090000@lexifi.com>
 <CAPFanBEqWfZj9KpPnypG2Lj7j=hdzwifz7o-V-ANdD9H67CB5w@mail.gmail.com>
 <5134B062.6010106@lexifi.com> <5134E071.4050408@lexifi.com>
 <Prayer.1.3.5.1303041909120.11091@hermes-1.csi.cam.ac.uk>
 <513714F7.2090203@lexifi.com>
 <Prayer.1.3.5.1303061257200.564@hermes-1.csi.cam.ac.uk>
Message-ID: <51374214.6030501@lexifi.com>

On 03/06/2013 01:57 PM, Leo White wrote:
> I'm not sure that I understand the need for general attributes not
> attached to anything in the middle of the module. If their position is
> important then there must be some item that they are essentially
> attached to, if their position is not important then they can just be
> placed at the top of the module.

I was mentioning ocamldoc section headers.  Without "floating" 
attributes, one can write:

[^^doc section "....."] include sig
    ...
end

On the one hand, this is nice, because it materializes the scope of the 
section (and you can benefit from your editor's folding feature).  But 
on the other hand, it is quite verbose and forces some extra 
indentation.  More fundamentally, this might not interact nicely with 
other features/tools, which might require a different nesting structure. 
  For instance, imagine a global dead code detector, for which one might 
want to exclude whole "sections" of exported declarations.  One could 
use the same technique as for ocamldoc sections:

[^^dead_code_detector ignore] include sig
    ...
end

But then we need to close/reopen those sections so that they remain 
nested within ocamldoc ones.  With floating attributes, one can write:


[*doc section "Section 1"]

[*dead_code_detector ignore true]

....

[*doc section "Section 2"]

....

[*dead_code_detector ignore false]

....


Does it make sense?


Alain

From alain.frisch at lexifi.com  Wed Mar  6 15:02:12 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 16:02:12 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
Message-ID: <51375A74.5090304@lexifi.com>

I've started a document to describe the current state of the branch:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?view=markup

A copy of the current version is attached.

Recent additions:


  - Attributes on labels in record declarations.
  - Attributes as standalone signature/structure items.
  - An alternative syntax for attributes on some kinds of expressions
    starting with a keyword, e.g.  "let[@id] p = e in e" is parsed
    as "(let p = e in e)[@id]" and as "[^id](let p = e in e)".
    Do people think this is useful?

    (I'm considering recognizing also "let[%id] p = e in e"
    as "(%id (let p = e in e))" and "let[%id e0] p = e in e"
    e.g. as "(%id (%id e0) (let p = e in e))".  Opinion?)


Don't hesitate to comment on the choice of syntaxes and representation 
in the Parsetree, etc!


Alain
-------------- next part --------------
This file describes the changes on the extension_points branch.


=== Attributes

Attributes are "decorations" of the syntax tree which are ignored by
the type-checker.  An attribute is made of an identifier (an "LIDENT", written
id below) and an optional expression (written expr below).

Four syntaxes exist for attributes, according to the kind of component
the attribute applies to, and whether the attribute is written before
or after the component.

On expressions, type expressions, module expressions, module type expressions,
patterns (TODO: class expressions, class type expressions):
 
  Prefix syntax:   [^id expr] ...
  Postfix syntax:  ... [@id expr]

The postfix syntax [@id expr] is also available to add attributes on
constructors and labels in type declarations:

  type t =
    | A [@id1]
    | B [@id2] of int [@id3]

Here, id1 (resp. id2) is attached to the constructor A (resp. B)
and id3 is attached to the int type expression.  Example on records:

 type t =
   {
      x [@id1]: int;
      mutable y [@id2] [@id3]: string [@id4];
   }  


On items:

  Prefix syntax: [^^id expr] ...
  Postfix syntax: ... [@@id expr]

  Items designate signature and structure items, and also individual
  components of multiple declaration (type declarations, recursive modules,
  class declarations, class type declarations). (TODO: class fields?)

  For multiple declarations:

    - prefix attributes written before the first keyword of the item
      are attached to the first declared component

    - postfix attributes written after the item are attached to the
      last declared component

    - more prefix attributes can be inserted after the opening keyword
      (for the first component) and after the "and" keyword (for other
      components)

    - more postfix attributes can be inserted before the "and" keyword

  For instance, consider:

    [^^id1] type [^^id2] t1 = ... [@@id3] and [^^id4] t2 = ... [@@id5]

  Here, the attributes on t1 are id1, id2 and id3; the attributes on
  t2 are id4 and id5.

  Note: item attributes are currently not supported on Pstr_eval
  and Pstr_value structure items.

A fifth syntax exists for attributes which stand as signature or
structure item on their own (i.e. they are not attached to any other
component):

   [*id expr]

([^^] and [@@] attributes cannot be attached to such a standalone attribute.)


=== Alternative syntax for attributes on specific kinds of nodes

Some constructions starting with a keyword KW supports an alternative
syntax for attributes:

  KW[@id expr]...[@id expr] ....
  ---->
  (KW ....)[@id expr]...[@id expr]

For instance:

let[@foo] x = 2 in x + 1

is equivalent to:

(let x = 2 in x + 1)[@foo]

and also to:

[^foo](let x = 2 in x + 1)

Supported constructions:

local let binding
function ...
fun (type t) ->  ...
match ... with ...
try ... with ...
begin ... end


=== Representation of attributes in the Parsetree

For attributes on expressions and similar categories, attributes are
just another possible constructor (one single attribute per node):

and expression_desc =
  ....
  | Pexp_attribute of (expression * attribute)

Note: we currently don't distinguish between prefix and postfix attributes.

Similarly, attributes as standalone signature/structure items are represented
by a new constructor:
  | Psig_attribute of attribute
  | Pstr_attribute of attribute

For "declarations"-like items (type declarations, module declarations,
..., but also constructors and record labels), all attributes are stored
in an extra field in their record (again, without making the distinction
between prefix and postfix attributes):

and type_declaration = {
   ...
   ptype_attributes: attribute list;
   ...

For other kinds of items (currently: open/include stataments,
exception rebind), the attributes are stored directly in the
constructor of the item:

  | Pstr_open of Longident.t loc * attribute list



=== Extension nodes

Extension nodes replace valid components in the syntax tree.  They are
normally interpreted and expanded by AST mapper.  The type-checker
fails when it encounters such an extension node.  An extension node is
made of an identifier (an "LIDENT", written id below) and an optional
expression (written expr below).

Two syntaxes exist for extension node:

As expressions, type expressions, module expressions, module type expressions,
patterns (TODO: class expressions, class type expressions):

  [%id expr]

As structure or signature item (TODO: class fields?):
 
  [%%id expr]

As other structure or signature items, attributes can be attached to a
[%%id expr] extension node.


=== Other changes to the parser and Parsetree

--- Relaxing the syntax for recursive modules.

Before:
   module X1 : MT1 = M1 and ... and Xn : MTn = Mn

Now:
   module X1 = M1 and ... and Xn = Mn
   (with the usual sugar that Xi = (Mi : MTi) can be written as Xi : MTi = Mi
   which gives the old syntax)

   The type-checker fails when a module expression is not of
   the form (M : MT)
   

Rationale:

1. More uniform representation in the Parsetree.

2. The type-checker can be made more clever in the future to support
   other forms of module expressions (e.g. functions with an explicit
   constraint on its result; or a structure with only type-level
   components).
    
      
--- Turning some tuple or n-ary constructors into records

Before:

  | Pstr_module of string loc * module_expr

After:

  | Pstr_module of module_binding
...
  and module_binding =
    {
     pmb_name: string loc;
     pmb_expr: module_expr;
     pmb_attributes: attribute list;
    }



Rationale:

More self-documented, more robust to future additions (such as
attributes), simplifies some code.


--- Keeping names inside value_description and type_declaration

Before:

  | Psig_type of (string loc * type_declaration) list


After:

  | Psig_type of type_declaration list

....
and type_declaration =
  { ptype_name: string loc;
    ...
  }

Rationale:

More self-documented, simplifies some code.


=== More TODOs

- Adapt pprintast.
- Adapt Camlp4 (both its parser(s) and its internal representation of OCaml ASTs).
- Propagate attributes to the Typedtree (so that they can be retrieved in .cmt/.cmti).
- Consider adding hooks to the type-checker so that custom extension expanders can be registered (a la OCaml Templates).
- Quotations (i.e. string literals with custom delimiters and without any interpretation of special characters in them), and a syntax which combines extension nodes and quotations.
- More cleanups to the Parsetree + documentation.

From xavier.clerc at inria.fr  Wed Mar  6 15:17:46 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 6 Mar 2013 16:17:46 +0100 (CET)
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <51375A74.5090304@lexifi.com>
Message-ID: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>

----- Mail original -----
> I've started a document to describe the current state of the branch:
> 
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?view=markup
> 
> A copy of the current version is attached.
> 
> Recent additions:
> 
> 
>   - Attributes on labels in record declarations.
>   - Attributes as standalone signature/structure items.
>   - An alternative syntax for attributes on some kinds of expressions
>     starting with a keyword, e.g.  "let[@id] p = e in e" is parsed
>     as "(let p = e in e)[@id]" and as "[^id](let p = e in e)".
>     Do people think this is useful?
> 
>     (I'm considering recognizing also "let[%id] p = e in e"
>     as "(%id (let p = e in e))" and "let[%id e0] p = e in e"
>     e.g. as "(%id (%id e0) (let p = e in e))".  Opinion?)
> 
> 
> Don't hesitate to comment on the choice of syntaxes and
> representation
> in the Parsetree, etc!

I will not discuss the syntax per se, but I wonder whether
having both prefix and suffix attributes is not error-prone.
Could you elaborate on the need of having both?

Another, unrelated question: as an extension developer, it
seems that I will have to deal with full-fledged expressions
as attributes values. Do you plan some mechanism to allow
easy access to an identifier used in such an expression.
I mean, it can even refer to another module. This also implies
that you could create dependencies between modules solely
through attributes; is that correct?


Sorry if those questions have already been answered, I did
not follow the previous thread about extension points.


Xavier Clerc

From alain.frisch at lexifi.com  Wed Mar  6 15:51:17 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 16:51:17 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
Message-ID: <513765F5.5020900@lexifi.com>

On 03/06/2013 04:17 PM, Xavier Clerc wrote:
> I will not discuss the syntax per se, but I wonder whether
> having both prefix and suffix attributes is not error-prone.
> Could you elaborate on the need of having both?

I proposed to use a prefix attribute (on an include statement) to create 
ocamldoc sections:

[^^doc section "Section Title"] include
    ...
end

but I now tend to prefer "floating" attributes in signatures.

Gabriel gave another example to justify the need for a prefix syntax:

  begin [: pragma(non_exhaustive_match) :]
     ...
  end

but this might be subsumed by the special form:

    begin[@id expr] ... end

which is equivalent to:

   (...)[@id expr]


Do people see use cases where the prefix syntax is much better?

> Another, unrelated question: as an extension developer, it
> seems that I will have to deal with full-fledged expressions
> as attributes values. Do you plan some mechanism to allow
> easy access to an identifier used in such an expression.
> I mean, it can even refer to another module. This also implies
> that you could create dependencies between modules solely
> through attributes; is that correct?

Expressions used inside attributes/extension nodes are just syntactical 
expressions.  They are never type-checked and their identifiers are not 
resolved; ocamldep does not look inside those expressions.

We could use any "universal" type instead of expressions (strings, 
s-expressions, xml, json).  Some arguments to use OCaml expressions:

  - This is a rich language, in which we can encode various DSL 
understood by extensions, so that the extensions don't need to do any 
parsing.

  - We already have a parser!

  - The syntax will look familiar to OCaml developers and adapting 
editors to nicely support (colors, indentation, etc) them will be easy.

  - It won't be uncommon to embed fragments of OCaml code, to be 
inserted into the real code fed to the compiler, within those 
expressions. Example:

   type t = {
      x: int;
      y [@default (x + 1)]: int;
      z [@optional]: int option;
   } [@@builder {with_labels; invariant=(x <= y)}]

  rewritten to:

   type t = {
      x: int;
      y: int;
   }

   let build_t ~x ?(y = x + 1) ?z () =
      assert(x <= y);
      {x; y; z}



As an extension developer, you don't need to suffer from the complexity 
of OCaml expression.  Instead,  you are free to define the subset of 
OCaml expressions which make sense inside "your" attributes/extension 
nodes, and fail when the user doesn't comply with this constraint.

From xavier.clerc at inria.fr  Wed Mar  6 16:03:00 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 6 Mar 2013 17:03:00 +0100 (CET)
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <513765F5.5020900@lexifi.com>
Message-ID: <2090494651.3090344.1362585780838.JavaMail.root@inria.fr>



----- Mail original -----
> On 03/06/2013 04:17 PM, Xavier Clerc wrote:
> > I will not discuss the syntax per se, but I wonder whether
> > having both prefix and suffix attributes is not error-prone.
> > Could you elaborate on the need of having both?
> 
> I proposed to use a prefix attribute (on an include statement) to
> create
> ocamldoc sections:
> 
> [^^doc section "Section Title"] include
>     ...
> end
> 
> but I now tend to prefer "floating" attributes in signatures.
> 
> Gabriel gave another example to justify the need for a prefix syntax:
> 
>   begin [: pragma(non_exhaustive_match) :]
>      ...
>   end
> 
> but this might be subsumed by the special form:
> 
>     begin[@id expr] ... end
> 
> which is equivalent to:
> 
>    (...)[@id expr]
> 
> 
> Do people see use cases where the prefix syntax is much better?
> 
> > Another, unrelated question: as an extension developer, it
> > seems that I will have to deal with full-fledged expressions
> > as attributes values. Do you plan some mechanism to allow
> > easy access to an identifier used in such an expression.
> > I mean, it can even refer to another module. This also implies
> > that you could create dependencies between modules solely
> > through attributes; is that correct?
> 
> Expressions used inside attributes/extension nodes are just
> syntactical
> expressions.  They are never type-checked and their identifiers are
> not
> resolved; ocamldep does not look inside those expressions.
> 
> We could use any "universal" type instead of expressions (strings,
> s-expressions, xml, json).  Some arguments to use OCaml expressions:
> 
>   - This is a rich language, in which we can encode various DSL
> understood by extensions, so that the extensions don't need to do any
> parsing.
> 
>   - We already have a parser!
> 
>   - The syntax will look familiar to OCaml developers and adapting
> editors to nicely support (colors, indentation, etc) them will be
> easy.
> 
>   - It won't be uncommon to embed fragments of OCaml code, to be
> inserted into the real code fed to the compiler, within those
> expressions. Example:
> 
>    type t = {
>       x: int;
>       y [@default (x + 1)]: int;
>       z [@optional]: int option;
>    } [@@builder {with_labels; invariant=(x <= y)}]
> 
>   rewritten to:
> 
>    type t = {
>       x: int;
>       y: int;
>    }
> 
>    let build_t ~x ?(y = x + 1) ?z () =
>       assert(x <= y);
>       {x; y; z}
> 
> 
> 
> As an extension developer, you don't need to suffer from the
> complexity
> of OCaml expression.  Instead,  you are free to define the subset of
> OCaml expressions which make sense inside "your" attributes/extension
> nodes, and fail when the user doesn't comply with this constraint.

Thanks for the clarification. However, I am now afraid about user side...
Expression will be treated in a non-uniform way by attributes.
Moreover, replacing a literal constant with a symbolic one will cause
extension to stop working. Honestly, I cannot say if it is a big deal.
But, I think it can be a surprise.


Xavier Clerc


From alain.frisch at lexifi.com  Wed Mar  6 16:28:01 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 17:28:01 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <2090494651.3090344.1362585780838.JavaMail.root@inria.fr>
References: <2090494651.3090344.1362585780838.JavaMail.root@inria.fr>
Message-ID: <51376E91.8090202@lexifi.com>

On 03/06/2013 05:03 PM, Xavier Clerc wrote:
> Thanks for the clarification. However, I am now afraid about user side...
> Expression will be treated in a non-uniform way by attributes.
> Moreover, replacing a literal constant with a symbolic one will cause
> extension to stop working. Honestly, I cannot say if it is a big deal.
> But, I think it can be a surprise.

Would the situation be very different if we used a different syntax for 
attributes?

I expect extensions to document exactly which attributes are recognized 
and fail if the user does something wrong.

Example:

  type t =
   {
     foo: float [@xml digits 3];
     bar [@xml omit_if (fun s -> s = "")]: string;
   } [@@xml]


where the "xml" extension would specify something like:

"Within the type declaration, some special attributes are recognized on 
to customize the rendering of OCaml values as XML:

  - on type expressions:
    float [@xml digits N]  (where N is a integer literal)
                The float value is displayed with N digits
    date [@xml format "YYYY-MM-DD"]
                ...

  - on record fields:
    field[@xml omit_if <fun>]: ...
                Omit the XML element corresponding to the field if the
                provided function evaluates to false when passed the
                field value.
  ...
"

If we used, say, JSON as the attribute argument, the example would look 
like:

  type t =
   {
     foo: float [@xml {digits:3}];
     bar [@xml {omit_if:"(fun s -> s = \"\")"}]: string;
   } [@@xml]



Would that be really less confusing?

-- Alain

From xavier.clerc at inria.fr  Wed Mar  6 16:31:31 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 6 Mar 2013 17:31:31 +0100 (CET)
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <51376E91.8090202@lexifi.com>
Message-ID: <1844158249.3101104.1362587491534.JavaMail.root@inria.fr>

----- Mail original -----
> On 03/06/2013 05:03 PM, Xavier Clerc wrote:
> > Thanks for the clarification. However, I am now afraid about user
> > side...
> > Expression will be treated in a non-uniform way by attributes.
> > Moreover, replacing a literal constant with a symbolic one will
> > cause
> > extension to stop working. Honestly, I cannot say if it is a big
> > deal.
> > But, I think it can be a surprise.
> 
> Would the situation be very different if we used a different syntax
> for
> attributes?

No, probably not.


(...)


> Would that be really less confusing?

No, you are clearly right.
I just feel dizzy when there is less type safety...
but that's a problem with me, not with your proposal!


Xavier Clerc

From alain.frisch at lexifi.com  Wed Mar  6 16:31:48 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 17:31:48 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <513765F5.5020900@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com>
Message-ID: <51376F74.8020502@lexifi.com>

On 03/06/2013 04:51 PM, Alain Frisch wrote:
> We could use any "universal" type instead of expressions (strings,
> s-expressions, xml, json).  Some arguments to use OCaml expressions:

I forgot one important argument: using expressions as arguments of 
attributes make it possible, if desired, to have rewriters applied on 
those arguments as well.  For instance, if the first -ppx rewriters to 
be applied are a "macro expander" and a "conditional compilation" 
system, they could operate naturally on the content of attributes 
understood by later rewriters.  This could be useful, for instance, to 
decide to include or not some fragments in the generated documentation 
(generated by a variant of ocamldoc based on attributes) based on 
whether some symbols are defined or not (to create a "public" 
documentation vs. a "private" one, for the same module).

-- Alain

From alain.frisch at lexifi.com  Wed Mar  6 16:41:32 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 06 Mar 2013 17:41:32 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <1844158249.3101104.1362587491534.JavaMail.root@inria.fr>
References: <1844158249.3101104.1362587491534.JavaMail.root@inria.fr>
Message-ID: <513771BC.3050706@lexifi.com>

On 03/06/2013 05:31 PM, Xavier Clerc wrote:
> I just feel dizzy when there is less type safety...

But is it really the case that there is less safety?  If you use a 
"wrong" expression as an argument of some attribute, the -ppx rewriter 
will (hopefully) let you know at compile time, exactly as a good old 
type error.  I see there is something "weird" in re-using the same 
syntax as expressions for something treated very differently by the 
compiler, but I believe the technical advantages outweigh this feeling 
of weirdness.

The only thing which is not checked is the fact that the attribute 
itself is recognized (i.e. if you mistype the attribute name, the 
attribute will just be ignored by the type-checker).  We could introduce 
yet another syntax for non-ignorable attributes.  Or we could create an 
"attribute checker" (a -ppx rewriter applied after all the other ones, 
and which checks that no attribute remain in the AST).  But since it is 
not an abnormal situation to have attributes remaining in the final AST 
(for later use by tools based on .cmt/.cmti files, for instance, such as 
a new ocamldoc), the tool would need to be configured with a list of 
such attributes to accept.


Alain

From amc79 at cam.ac.uk  Wed Mar  6 17:17:18 2013
From: amc79 at cam.ac.uk (Amir Chaudhry)
Date: Wed, 6 Mar 2013 17:17:18 +0000
Subject: [wg-camlp4] Reminder of OCaml Labs-related mailing lists
Message-ID: <7B2B1F92-FA0B-4D82-A0CC-7C9064031608@cam.ac.uk>

Dear all,

I thought it would be useful to point out the range of mailing lists that OCaml Labs is involved in.  Most of these have public archives and if you're interested in any of the topics, please feel free to sign-up.  I'm sending this message to each list, so apologies if you receive it multiple times.

cl-ocamllabs at lists.cam.ac.uk
Mostly used for announcements and updates. Discussions take place elsewhere.
Join: https://lists.cam.ac.uk/mailman/listinfo/cl-ocamllabs

cl-mirage at lists.cam.ac.uk
Day to day development talk on Mirage [1] and related projects.
Archive: https://lists.cam.ac.uk/pipermail/cl-mirage/
Join: https://lists.cam.ac.uk/mailman/listinfo/cl-mirage

platform at lists.ocaml.org
Discussions on aspects of the OCaml Platform and things that pertain to it.
Archive: http://lists.ocaml.org/pipermail/platform/
Join: http://lists.ocaml.org/listinfo/platform

infrastructure at lists.ocaml.org
Discussions on continuous integration infrastructure, ocaml.org and other things supporting OCaml.
Archive: http://lists.ocaml.org/pipermail/infrastructure
Join: http://lists.ocaml.org/listinfo/infrastructure

wg-camlp4 at lists.ocaml.org
Community working group on the future of syntax extensions to OCaml.
Archive: http://lists.ocaml.org/pipermail/wg-camlp4/
Join: http://lists.ocaml.org/listinfo/wg-camlp4

[1] mirage - http://openmirage.org and http://www.cl.cam.ac.uk/projects/ocamllabs/projects/mirage.html

Best wishes,
Amir

From xavier.clerc at inria.fr  Wed Mar  6 19:24:25 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 6 Mar 2013 20:24:25 +0100 (CET)
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <513771BC.3050706@lexifi.com>
Message-ID: <1693542754.3283877.1362597865344.JavaMail.root@inria.fr>

----- Mail original -----
> On 03/06/2013 05:31 PM, Xavier Clerc wrote:
> > I just feel dizzy when there is less type safety...
> 
> But is it really the case that there is less safety?  If you use a
> "wrong" expression as an argument of some attribute, the -ppx
> rewriter
> will (hopefully) let you know at compile time, exactly as a good old
> type error.

Quite not, as this is rewriter-dependent. A developer may very well
decide to accept both integers and floats for a given value for example.


(...)


> The only thing which is not checked is the fact that the attribute
> itself is recognized (i.e. if you mistype the attribute name, the
> attribute will just be ignored by the type-checker).

Yes, this is a potential pitfall.
And I would state things differently: the only thing that is checked
is that attribute values are syntactically well-formed.


>  We could introduce yet another syntax for non-ignorable attributes.
>  Or we could create an "attribute checker" (a -ppx rewriter applied
> after all the other ones, and which checks that no attribute remain
> in the AST).  But since it
> is
> not an abnormal situation to have attributes remaining in the final
> AST
> (for later use by tools based on .cmt/.cmti files, for instance, such
> as
> a new ocamldoc), the tool would need to be configured with a list of
> such attributes to accept.

Rather than a new syntax (they are already multiple), I would argue
for another solution:
  - maybe a tag to indicate that a given attribute has been preprocessed;
  - or, as the rewriter to register the attributes they handle and issue
    a warning if there is an attribute that cannot be treated by the
    rewriters.
Just wild ideas, though.


Xavier Clerc

From alain.frisch at lexifi.com  Thu Mar  7 09:07:41 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Mar 2013 10:07:41 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <513765F5.5020900@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com>
Message-ID: <513858DD.6040705@lexifi.com>

On 03/06/2013 04:51 PM, Alain Frisch wrote:
> Do people see use cases where the prefix syntax is much better?

I found only one case: attaching meta-data to a function in an .ml file 
is better done before the function code than after, for readability 
purposes.  (In interfaces, it's fine to put the comments/meta-data after 
the function declaration, since the prototype is short enough.)


[^^backend ensure_inlining]
let foobar x l =
   ...

But I'm not sure it is worth creating more syntax only for that case.

What do you think?

Unless someone objects to it, I'll remove the prefix syntax.



An alternative solution to the case above (which we can implement later) 
could be to keep the standard syntax for postfix [@...] attributes and 
allow to put the attribute on the function name and/or on the let keyword:

    let foobar [@backend ensure_inlining] x l =
       ...

    or:

    let[@backend ensure_inlining] foobar x l =
       ...

which could be represented as:

    let foobar = ((fun x l -> ...) [@backend ensure_inlining])
    (the attribute is on the function expression)

    or:

    let (foobar [@backend ensure_inlining]) = fun x l -> ...
    (the attribute is on the pattern)




Alain

From alain.frisch at lexifi.com  Thu Mar  7 14:31:51 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Mar 2013 15:31:51 +0100
Subject: [wg-camlp4] Request for feedback (was: A new branch to experiment
 with extension points)
In-Reply-To: <513858DD.6040705@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
Message-ID: <5138A4D7.5040804@lexifi.com>

On 03/07/2013 10:07 AM, Alain Frisch wrote:
> Unless someone objects to it, I'll remove the prefix syntax.

Done!

I've also removed the special syntax [*id expr] for floating 
signature/structure item attributes.  Instead, they use the standard 
syntax for "item" attributes ([@@id expr]), recognized at the beginning 
of the whole signature/structure or after a ";;" token.   (I've also 
changed the grammar a little bit so that a signature/structure can start 
with a ";;" token and it is allowed to have two successive ";;" tokens. 
  This makes it possible to prefix any floating attribute [@@id expr] 
with ";;" and this will work in any context.)

With these simplifications, we've reduced the number of different 
syntaxes for attributes from 5 to 2.

Sorry for all those repeated changes, and thanks to those who can follow 
and comment :-)  I think I'm now pretty happy with the current 
implementation,  and I'd really like to get feedback on the current 
syntactic choices, in particular on the following points, where at least 
someone objected to the current choice:

- Gabriel mentioned that he would prefer more symmetric delimiters (e.g. 
[@ ... @] and not [@ ... ]).  I'd personally prefer something lighter, 
and I've argued that ocamldoc comments are already non symmetric.

- Leo did not seem convinced by the need for floating 
signature/structure items.  I've given the example of ocamldoc section 
headers.

- Leo expressed some preference for a more alphanumeric syntax for item 
attributes (... with ...).  I prefer to have a more similar syntax for 
all kinds of attributes.

(Did I forget any other discussed point about the syntax?)

There is also the question of how attributes are represented in the 
Parsetree, on which there was little discussion.  For instance, it could 
make sense to store attributes on expressions as an extra field of the 
expression record (next to pexp_desc, pexp_loc) instead of introducing a 
new constructor to expression_desc.  On the one hand, it would make it 
slighlty more complex to pattern match on a specific attribute (it could 
be anywhere in the list), but on the other hand it would make it simpler 
to detect a non-trivial Parsetree fragment for its structure modulo 
attributes.



Alain

From gabriel.scherer at gmail.com  Thu Mar  7 14:43:18 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 7 Mar 2013 15:43:18 +0100
Subject: [wg-camlp4] Request for feedback (was: A new branch to
 experiment with extension points)
In-Reply-To: <5138A4D7.5040804@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
Message-ID: <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>

I think it would be useful to see concrete example use cases, to get a
better feel of the concrete syntax choices.

Could you go over some of the examples in
https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases
, and transcode the ones that are reachable through such annotations
in your current syntax?

(Feel free to create a new wiki page; otherwise I'll probably add it
myself as I did for
https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases-using-light-annotations
)

On Thu, Mar 7, 2013 at 3:31 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/07/2013 10:07 AM, Alain Frisch wrote:
>>
>> Unless someone objects to it, I'll remove the prefix syntax.
>
>
> Done!
>
> I've also removed the special syntax [*id expr] for floating
> signature/structure item attributes.  Instead, they use the standard syntax
> for "item" attributes ([@@id expr]), recognized at the beginning of the
> whole signature/structure or after a ";;" token.   (I've also changed the
> grammar a little bit so that a signature/structure can start with a ";;"
> token and it is allowed to have two successive ";;" tokens.  This makes it
> possible to prefix any floating attribute [@@id expr] with ";;" and this
> will work in any context.)
>
> With these simplifications, we've reduced the number of different syntaxes
> for attributes from 5 to 2.
>
> Sorry for all those repeated changes, and thanks to those who can follow and
> comment :-)  I think I'm now pretty happy with the current implementation,
> and I'd really like to get feedback on the current syntactic choices, in
> particular on the following points, where at least someone objected to the
> current choice:
>
> - Gabriel mentioned that he would prefer more symmetric delimiters (e.g. [@
> ... @] and not [@ ... ]).  I'd personally prefer something lighter, and I've
> argued that ocamldoc comments are already non symmetric.
>
> - Leo did not seem convinced by the need for floating signature/structure
> items.  I've given the example of ocamldoc section headers.
>
> - Leo expressed some preference for a more alphanumeric syntax for item
> attributes (... with ...).  I prefer to have a more similar syntax for all
> kinds of attributes.
>
> (Did I forget any other discussed point about the syntax?)
>
> There is also the question of how attributes are represented in the
> Parsetree, on which there was little discussion.  For instance, it could
> make sense to store attributes on expressions as an extra field of the
> expression record (next to pexp_desc, pexp_loc) instead of introducing a new
> constructor to expression_desc.  On the one hand, it would make it slighlty
> more complex to pattern match on a specific attribute (it could be anywhere
> in the list), but on the other hand it would make it simpler to detect a
> non-trivial Parsetree fragment for its structure modulo attributes.
>
>
>
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Thu Mar  7 15:32:24 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Mar 2013 16:32:24 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
Message-ID: <5138B308.5080301@lexifi.com>

On 03/07/2013 03:43 PM, Gabriel Scherer wrote:
> I think it would be useful to see concrete example use cases, to get a
> better feel of the concrete syntax choices.
>
> Could you go over some of the examples in
> https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases
> , and transcode the ones that are reachable through such annotations
> in your current syntax?

Good suggestion.  I've committed a list of examples at the end of:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?view=markup


As a small change, the "id" of attributes and extension nodes can now be 
uppercase identifiers (and later, keywords will also be accepted). 
Should we accept qualified identifiers as well?

Alain

From gabriel.scherer at gmail.com  Thu Mar  7 16:23:29 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 7 Mar 2013 17:23:29 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <5138B308.5080301@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
Message-ID: <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>

I understood the syntactic constructs, but it really help to see them
used in realistic cases.
I actually find those examples quite impressive:
- the [@lwt] ones are good because you managed to give a clean
semantics to the relevant syntactic exceptions.
- I didn't except the quotation-using ones to work that well either

I'm wondering how much I should trust them :p Have you actually tried
to parse the most daring ones with your parser? If you have a
testsuite, it may be interesting to add them to it.

While I admire the cleverness of using the fact that attributes are
OCaml syntax to get the "quotation" use cases for free, it also gives
me mixed feelings:
- I'm not sure how robust it is to future design changes
- For multi-line quotations, I would appreciate a slightly more
explicit syntax (possibly the symmetric delimiter to help users see
where the quotation end).

No precise idea on this front, but that's still something to think about.

On Thu, Mar 7, 2013 at 4:32 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/07/2013 03:43 PM, Gabriel Scherer wrote:
>>
>> I think it would be useful to see concrete example use cases, to get a
>> better feel of the concrete syntax choices.
>>
>> Could you go over some of the examples in
>> https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases
>> , and transcode the ones that are reachable through such annotations
>> in your current syntax?
>
>
> Good suggestion.  I've committed a list of examples at the end of:
>
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?view=markup
>
>
> As a small change, the "id" of attributes and extension nodes can now be
> uppercase identifiers (and later, keywords will also be accepted). Should we
> accept qualified identifiers as well?
>
> Alain

From alain.frisch at lexifi.com  Thu Mar  7 16:55:14 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Mar 2013 17:55:14 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
Message-ID: <5138C672.3030504@lexifi.com>

On 03/07/2013 05:23 PM, Gabriel Scherer wrote:
> I'm wondering how much I should trust them :p Have you actually tried
> to parse the most daring ones with your parser? If you have a
> testsuite, it may be interesting to add them to it.

Yes, I've tried most of them.  Most of them work. A few number are 
rejected, but only because more work is needed on the parser (e.g. 
for[@id] is not yet supported, even though it would have taken less time 
to add support than to write this sentence; and class expressions do not 
yet support extension nodes).

> While I admire the cleverness of using the fact that attributes are
> OCaml syntax to get the "quotation" use cases for free, it also gives
> me mixed feelings:
> - I'm not sure how robust it is to future design changes

It is true that there could be some discontinuity: at some point, you 
can shoehorn your "DSL" in the syntax of OCaml expressions, but when you 
extend it, you might not find a nice way to continue doing so and you 
might be forced to switch to a very different embedding.  I don't 
believe that this will be a serious problem in practice, in particular 
because one can always use an extension node with a string literal 
content  in order to use custom concrete syntax locally in most 
syntactic categories (or directly a string if the category accept it, 
i.e. expressions and patterns).  As an example, let's have a look at the 
bitstring example:

let bits = Bitstring.bitstring_of_file "/bin/ls" in
[%bit match bits with
| [ 0x7f, 8; "ELF", 24, string;  (* ELF magic number *)
     e_ident, Mul(12,8), bitstring;    (* ELF identifier *)
     e_type, 16, littleendian;    (* object file type *)
     e_machine, 16, littleendian  (* architecture *)
   ] ->
   printf "This is an ELF binary, type %d, arch %d\n"
     e_type e_machine
]

One can imagine that in an early version, the size field could only be 
specified as an int literal.  When the author decides to let his users 
write "12*8", he can decide between:

  - Creating some "DSL" to describe those formulas, with a syntax 
compatible with patterns, as I did in the example above (Mul(12, 8))

   e_ident, Mul(12,8), bitstring;    (* ELF identifier *)

  - Using a string to represent the formula (but then one must create a 
new parser... or call the OCaml parser!):

   e_ident, "12 * 8", bitstring;

  - Using an extension node to allow injecting an expression without 
requiring a parser:

   e_ident, [%sz 12 * 8], bitstring;

   (Here we don't care about the "id" of the extension node.  It is 
worth creating a syntax for name-less extension nodes?)



> - For multi-line quotations, I would appreciate a slightly more
> explicit syntax (possibly the symmetric delimiter to help users see
> where the quotation end).

Do you mean:

[%bit ... %bit]
or:
[%bit ... bit%]
or:
[%bit ... %]

or something else?

Note than one can also write:

begin[@bit]
....
end

The only difference is that if we compile without the "bitstring 
expander", we will probably get a type-error which might be a little 
harder to understand.  I was thinking about supporting:

begin[%bit]
....
end

as an equivalent to:

[%bit ....]

but this would be ambiguous (function appliction with [%bit] in function 
position).


Alain

From gabriel.scherer at gmail.com  Thu Mar  7 17:07:18 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 7 Mar 2013 18:07:18 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <5138C672.3030504@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
Message-ID: <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>

> It is true that there could be some discontinuity: at some point, you can
> shoehorn your "DSL" in the syntax of OCaml expressions, but when you extend
> it, you might not find a nice way to continue doing so and you might be
> forced to switch to a very different embedding.

I was thinking of changes to the extension mechanism itself. There
have been sparse but regular calls to a more structured representation
of annotations (eg. using a few literal categories to do some form of
structure-checking uniformly on all annotations), and if we found out
in the future we really want that, that could be disruptive to
existing quotation usages. In the discussion you suggested a dedicated
{{...}} syntax for quotations, something like that seems less likely
to want to evolve and forbid previous precious use cases.

(Don't jump implementing {{...}} yet! There are equally compelling
reasons to limit the number of new concepts and appreciate the
expressivity of the core you have, so it's more thinking out loud
about possible arguments and counter-arguments.)

> Do you mean:
>
> [%bit ... %bit]
> or:
> [%bit ... bit%]
> or:
> [%bit ... %]
>
> or something else?

I was thinking of [%bit ... %]. On the other hand, it's not clear we
would want to have two syntaxes, one for "short annotations" and one
for "long annotations", while one suffices semantically. Also, for
extensions that are really quotations, that is of the form

  [%name
     ...long expr...
  ]

we could use the following pattern by convention

[%name(
   ... long expr ...
)]

or even

[%name begin
   ... long expr ...
end]


In a perfect world, I would dream of a long-syntax with symmetric
delimiters [% foo bar %], and a short-syntax *without delimiters*
reserved to the specific cases where the extension is attached to a
keyword: for%lwt, let%monad, etc., so we can have both convenient
short-scale marks and readable, structured, symmetric larger-scale
delimiters. However, non-delimited syntaxes such as for%lwt open a new
parsing can of worms, so it's reasonable to choose [% foo bar ] as an
awkward compromise that is not too painful at small scale, even if
maybe not optimal at large scale.


On Thu, Mar 7, 2013 at 5:55 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/07/2013 05:23 PM, Gabriel Scherer wrote:
>>
>> I'm wondering how much I should trust them :p Have you actually tried
>> to parse the most daring ones with your parser? If you have a
>> testsuite, it may be interesting to add them to it.
>
>
> Yes, I've tried most of them.  Most of them work. A few number are rejected,
> but only because more work is needed on the parser (e.g. for[@id] is not yet
> supported, even though it would have taken less time to add support than to
> write this sentence; and class expressions do not yet support extension
> nodes).
>
>
>> While I admire the cleverness of using the fact that attributes are
>> OCaml syntax to get the "quotation" use cases for free, it also gives
>> me mixed feelings:
>> - I'm not sure how robust it is to future design changes
>
>
> It is true that there could be some discontinuity: at some point, you can
> shoehorn your "DSL" in the syntax of OCaml expressions, but when you extend
> it, you might not find a nice way to continue doing so and you might be
> forced to switch to a very different embedding.  I don't believe that this
> will be a serious problem in practice, in particular because one can always
> use an extension node with a string literal content  in order to use custom
> concrete syntax locally in most syntactic categories (or directly a string
> if the category accept it, i.e. expressions and patterns).  As an example,
> let's have a look at the bitstring example:
>
> let bits = Bitstring.bitstring_of_file "/bin/ls" in
> [%bit match bits with
> | [ 0x7f, 8; "ELF", 24, string;  (* ELF magic number *)
>     e_ident, Mul(12,8), bitstring;    (* ELF identifier *)
>     e_type, 16, littleendian;    (* object file type *)
>     e_machine, 16, littleendian  (* architecture *)
>   ] ->
>   printf "This is an ELF binary, type %d, arch %d\n"
>     e_type e_machine
> ]
>
> One can imagine that in an early version, the size field could only be
> specified as an int literal.  When the author decides to let his users write
> "12*8", he can decide between:
>
>  - Creating some "DSL" to describe those formulas, with a syntax compatible
> with patterns, as I did in the example above (Mul(12, 8))
>
>   e_ident, Mul(12,8), bitstring;    (* ELF identifier *)
>
>  - Using a string to represent the formula (but then one must create a new
> parser... or call the OCaml parser!):
>
>   e_ident, "12 * 8", bitstring;
>
>  - Using an extension node to allow injecting an expression without
> requiring a parser:
>
>   e_ident, [%sz 12 * 8], bitstring;
>
>   (Here we don't care about the "id" of the extension node.  It is worth
> creating a syntax for name-less extension nodes?)
>
>
>
>
>> - For multi-line quotations, I would appreciate a slightly more
>> explicit syntax (possibly the symmetric delimiter to help users see
>> where the quotation end).
>
>
> Do you mean:
>
> [%bit ... %bit]
> or:
> [%bit ... bit%]
> or:
> [%bit ... %]
>
> or something else?
>
> Note than one can also write:
>
> begin[@bit]
> ....
> end
>
> The only difference is that if we compile without the "bitstring expander",
> we will probably get a type-error which might be a little harder to
> understand.  I was thinking about supporting:
>
> begin[%bit]
> ....
> end
>
> as an equivalent to:
>
> [%bit ....]
>
> but this would be ambiguous (function appliction with [%bit] in function
> position).
>
>
> Alain

From alain.frisch at lexifi.com  Fri Mar  8 08:19:32 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 08 Mar 2013 09:19:32 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
In-Reply-To: <CAN8ZjBHCu20dbMkU1-ta-FNyTtNg_6pzef=tVV3M5zuDjouZUg@mail.gmail.com>
References: <51375A74.5090304@lexifi.com>
 <CAN8ZjBHCu20dbMkU1-ta-FNyTtNg_6pzef=tVV3M5zuDjouZUg@mail.gmail.com>
Message-ID: <51399F14.4080500@lexifi.com>

On 03/08/2013 12:01 AM, David Waern wrote:
> Would it be a crazy idea to replace expr by seq_expr in attributes and
> extensions? That would allow a more light-weight monadic notation:
>
> [%do a; b; c <-- d; f c; ...]

This is an excellent idea!  It is now committed.

Thanks for suggestion,

Alain

> which could be useful where begin[%monad] ... end would be too verbose,
> typically when embedding small fragments of monadic code inside
> non-monadic code.
>
> I think it's nice to make overloading the semi-colon light-weight (this
> way, without needing parentheses) for other use-cases as well (e.g
> literals for custom list types).
>
> Or does this cause any problems that I've overlooked?


From alain.frisch at lexifi.com  Fri Mar  8 09:19:15 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 08 Mar 2013 10:19:15 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
Message-ID: <5139AD13.8050304@lexifi.com>

I've generalized the "attribute on the opening keyword" form to all 
kinds of expressions starting with a keyword, a sequence of keywords 
(let open, let module), and even delimiters.  In the same way that we 
can write:

   let[@id arg] p = e1 in e2

for:

   (let p = e1 in e2)[@id arg]

we can also write:

   ((@id arg) expr)

which is equivalent to:

   (expr (@id arg))

(We see the first form as an attribute of the opening delimiter of the 
construction "(expr)".)

I think it is nice to be able to use the same syntax and essentially get 
prefix attributes as well.  Do you guy agree?  Or do you believe that 
this creates too much confusion?


On 03/07/2013 06:07 PM, Gabriel Scherer wrote:
> However, non-delimited syntaxes such as for%lwt open a new
> parsing can of worms

Actually, I believe this works quite well, and I'm playing with the idea 
that this could be the (only) syntax for extension nodes.

We could actually extend the idea above of putting attributes on opening 
keywords/delimiters to support also an optional extension identifier. 
For instance:

   let%foo p = e1 in e2

would be equivalent to:

   [%foo let p = e1 in e2]

Doing that for the "lwt" example would not only give a more compact 
syntax, but also make use of extensions instead of attributes, which can 
be preferred in that case (so that the compiler fails cleanly if we 
don't compile with "-ppx lwt" instead of giving weird error messages).


The "bitstring" example could then be written:

match%bit bits with ...

instead of

[%bit match bits with ...]



And if we do the same for the parenthesized expressions, we could write:

  (%foo expr)

which would be equivalent to:

  [%foo expr]

At this point, if we do that, it makes little sense to keep the original 
form for extensions ([%id expr]), and we could use (%id expr) instead, 
for all categories (not only expressions).

What do you think?


Alain

From lpw25 at cam.ac.uk  Wed Mar 13 17:30:56 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 13 Mar 2013 17:30:56 +0000
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <5139AD13.8050304@lexifi.com> (Alain Frisch's message of "Fri, 08
 Mar 2013 10:19:15 +0100")
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com>
Message-ID: <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>

Alain Frisch <alain.frisch at lexifi.com> writes:

> I've generalized the "attribute on the opening keyword" form to all kinds of expressions starting with a keyword, a
> sequence of keywords (let open, let module), and even delimiters.  In the same way that we can write:
>
>   let[@id arg] p = e1 in e2
>
> for:
>
>   (let p = e1 in e2)[@id arg]

That seems reasonable.
>
> we can also write:
>
>   ((@id arg) expr)
>
> which is equivalent to:
>
>   (expr (@id arg))

As long as you meant

    ([@id arg] expr)

then this is also a good idea.

> On 03/07/2013 06:07 PM, Gabriel Scherer wrote:
>> However, non-delimited syntaxes such as for%lwt open a new
>> parsing can of worms
>
> Actually, I believe this works quite well, and I'm playing with the idea that this could be the (only) syntax for
> extension nodes.

I have to agree with Gabriel here, these things are a pain to get
right. If you don't handle it in the lexer then you allow things like:

   let% lwt x =  (* defining a lwt function? *) 

or

  let % lwt x = (* defining the % operator? *)

which is definitly undesirable. It also allows comments and newlines to
be inserted in awkward places.

This means that you must lex "let%lwt" as a single token which can be a
bit awkward. It is probably ok for a few specific cases, but expanding
it to all keywords is asking for trouble.

> And if we do the same for the parenthesized expressions, we could write:
>
>  (%foo expr)
>
> which would be equivalent to:
>
>  [%foo expr]
>

I don't think this is a good idea because you are parsing '%' as a
strange prefix operator, so that all of the following are allowed:

(% foo expr) ( %foo expr ) ( % foo expr )

((* hello world*)%
  foo expr
)

this is probably a bad idea, and disagrees with how every other two
character delimiter in OCaml is parsed.

And lexing '(%' as single token conflicts with other places in the
grammar.


From alain.frisch at lexifi.com  Wed Mar 13 17:49:17 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Mar 2013 18:49:17 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5140BC1D.3060703@lexifi.com>

On 03/13/2013 06:30 PM, Leo White wrote:
>> we can also write:
>>
>>    ((@id arg) expr)
>>
>> which is equivalent to:
>>
>>    (expr (@id arg))
>
> As long as you meant
>
>      ([@id arg] expr)
>
> then this is also a good idea.

No, I really meant (expr (@id arg)).

It is really the same as:

begin[@id arg] ... end

being equivalent to:

... [@id arg]

i.e. putting the attribute on the opening keyword (here the opening 
parenthesis being considered as the opening keyword).

> I have to agree with Gabriel here, these things are a pain to get
> right. If you don't handle it in the lexer then you allow things like:
>
>     let% lwt x =  (* defining a lwt function? *)
>
> or
>
>    let % lwt x = (* defining the % operator? *)
>
> which is definitly undesirable. It also allows comments and newlines to
> be inserted in awkward places.

I can see that there is a possibility to write awkward code, but I don't 
think people would actually do it.  We can try to find a better syntax, 
but I would find it sad to pick something more heavy only because the 
light syntax could theoretically allow people to write confusing code.

I don't see "let % lwt" as a worst kind of code than:

   let (* oh, you really believe I'm going to define a local value here ?
   Wait a minute ...*)

   open List

   (* and now you think this is a global open statement *)

   in
   ...


> This means that you must lex "let%lwt" as a single token which can be a
> bit awkward. It is probably ok for a few specific cases, but expanding
> it to all keywords is asking for trouble.

If we go this way (and as said I'm not convinced this is required) this 
would only be necessary for the keywords used as the first token of 
expressions (e.g. not "in", "with", "to" for instance).  And we could 
limit ourselves to the most useful ones only.


> I don't think this is a good idea because you are parsing '%' as a
> strange prefix operator, so that all of the following are allowed:
>
> (% foo expr) ( %foo expr ) ( % foo expr )
>
> ((* hello world*)%
>    foo expr
> )

Again, we can try to fix that in the lexer/parser, or just publicize the 
"good style".  I don't think that the grammar is supposed to prevent 
people from writing un-readable code, just to allow and encourage them 
to write good one.


Alain

From lpw25 at cam.ac.uk  Wed Mar 13 21:32:22 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Wed, 13 Mar 2013 21:32:22 +0000
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <5140BC1D.3060703@lexifi.com> (Alain Frisch's message of "Wed, 13
 Mar 2013 18:49:17 +0100")
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
 <5140BC1D.3060703@lexifi.com>
Message-ID: <86fvzzgf4p.fsf@cam.ac.uk>

>>> we can also write:
>>>
>>>    ((@id arg) expr)
>>>
>>> which is equivalent to:
>>>
>>>    (expr (@id arg))
>>
>> As long as you meant
>>
>>      ([@id arg] expr)
>>
>> then this is also a good idea.
>
> No, I really meant (expr (@id arg)).
>

Sorry, what i meant was that it should be ([@id arg] expr) instead of
((@arg) expr). In other words, it should be square brackets like the
other attributes.

>
> I can see that there is a possibility to write awkward code, but I don't think people would actually do it.  We can try
> to find a better syntax, but I would find it sad to pick something more heavy only because the light syntax could
> theoretically allow people to write confusing code.
>
> I don't see "let % lwt" as a worst kind of code than: ...

I do think that 

  let % lwt x = ...

is potentially confusing. Maybe it would be better as

  let . lwt x = ...

since people nearly always write dots without spaces, and a dot
obviously can't be an operator. Another posibility would be

  let .% lwt x = ...

It does seems like we're going from having a single extension syntax to
having many extension syntaxes. I can see the benefit of "let % lwt"
since that will probably be a common extension point (the same goes for
"match % bit") but is there much to be gained from the other possible
keyword extensions. The [%foo expr] syntax provides a clear indication
of which parts are an extension, that is less clear for some other
constructs.

>> I don't think this is a good idea because you are parsing '%' as a
>> strange prefix operator, so that all of the following are allowed:
>>
>> (% foo expr) ( %foo expr ) ( % foo expr )
>>
>> ((* hello world*)%
>>    foo expr
>> )
>
> Again, we can try to fix that in the lexer/parser, or just publicize the "good style".  I don't think that the grammar
> is supposed to prevent people from writing un-readable code, just to allow and encourage them to write good one.

While "let % lwt" may be alright, I do think that

( % id expr )

is a bad idea. It looks too much like a prefix operator. Also, having a
two character delimiter that isn't a single token is different from
every other two character delimiter in the langauge. It also means that
you can't use precedence to resolve conflicts in the parser. Is there
any real benefit in using (%id expr) instead of [%id expr]?

From alain.frisch at lexifi.com  Thu Mar 14 08:34:47 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 14 Mar 2013 09:34:47 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <86fvzzgf4p.fsf@cam.ac.uk>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
 <5140BC1D.3060703@lexifi.com> <86fvzzgf4p.fsf@cam.ac.uk>
Message-ID: <51418BA7.2030305@lexifi.com>

On 03/13/2013 10:32 PM, Leo White wrote:
> Sorry, what i meant was that it should be ([@id arg] expr) instead of
> ((@arg) expr). In other words, it should be square brackets like the
> other attributes.

Oh yes, sorry, of course.

> I do think that
>
>    let % lwt x = ...
>
> is potentially confusing. Maybe it would be better as
>
>    let . lwt x = ...
>
> since people nearly always write dots without spaces, and a dot
> obviously can't be an operator.

If people see examples written "let%lwt", they will probably do the 
same, don't you think?   "%" does not seem very common in OCaml code; I 
don't think people already have "bad habits" about it.  And if people 
insist to write "let % lwt", it will be because they believe it somehow 
better.

I'm not very fond of "let.lwt".  The dot symbol has already so many 
different uses in OCaml...  At least "%" is quite rare and will thus be 
clearly noticed as an extension.

> Another posibility would be
>
>    let .% lwt x = ...

Do you believe it is worth making the syntax more heavy only to 
discourage (and not even prevent) people from potentially writing code 
with a style we don't like?

> It does seems like we're going from having a single extension syntax to
> having many extension syntaxes. I can see the benefit of "let % lwt"
> since that will probably be a common extension point (the same goes for
> "match % bit") but is there much to be gained from the other possible
> keyword extensions.

function%ext and try%ext are also probably useful.

And I can imagine examples where {%ext x1=e1; ...; xn=en} would be 
useful as well (see the "pre-polyrecord" example).

At this point, why not be uniform, and do the same for all kinds of 
expressions starting with a well-defined keyword or symbol, including 
the parenthesized expressions "begin%ext expr end" and "(%ext expr)". 
For other syntactic categories than expressions, this last form would be 
recognized (as the only syntax for extensions), instead of "[%ext 
expr]".  There is a single syntax.

> While "let % lwt" may be alright, I do think that
>
> ( % id expr )
>
> is a bad idea. It looks too much like a prefix operator. Also, having a
> two character delimiter that isn't a single token is different from
> every other two character delimiter in the langauge. It also means that
> you can't use precedence to resolve conflicts in the parser. Is there
> any real benefit in using (%id expr) instead of [%id expr]?

The benefit I can see is the uniformity with other forms of expressions:

    KW%id ...

where KW is the opening keyword/symbol (here "(") and ... the rest of 
the construction starting with KW.


Alain

From lpw25 at cam.ac.uk  Thu Mar 14 11:00:02 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 14 Mar 2013 11:00:02 +0000
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <51418BA7.2030305@lexifi.com> (Alain Frisch's message of "Thu, 14
 Mar 2013 09:34:47 +0100")
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
 <5140BC1D.3060703@lexifi.com> <86fvzzgf4p.fsf@cam.ac.uk>
 <51418BA7.2030305@lexifi.com>
Message-ID: <878v5qtff1.fsf@kingston.cl.cam.ac.uk>

> If people see examples written "let%lwt", they will probably do the same, don't you think?   "%" does not seem very
> common in OCaml code; I don't think people already have "bad habits" about it.  And if people insist to write "let %
> lwt", it will be because they believe it somehow better.
>
> I'm not very fond of "let.lwt".  The dot symbol has already so many different uses in OCaml...  At least "%" is quite
> rare and will thus be clearly noticed as an extension.
>
>> Another posibility would be
>>
>>    let .% lwt x = ...
>
> Do you believe it is worth making the syntax more heavy only to discourage (and not even prevent) people from
> potentially writing code with a style we don't like?
>

To be honest I am (cautiously) ok with "let%lwt x = ...". 

>> It does seems like we're going from having a single extension syntax to
>> having many extension syntaxes. I can see the benefit of "let % lwt"
>> since that will probably be a common extension point (the same goes for
>> "match % bit") but is there much to be gained from the other possible
>> keyword extensions.
>
> function%ext and try%ext are also probably useful.

I'm much less sure about these other syntaxes. I think that

    [%bit match foo with
        bit-pattern -> ...
      | other-bit-pattern -> ...
    ]

makes it much more obvious that we are abusing the OCaml syntax within
an extension, which is important. It is also not much heavier than:

    match%bit foot with
      bit-pattern -> ...
    | other-bit-pattern -> ...

The same goes for function%ext and try%ext.

Note that for "let" the trade-off is potentially much worse:

[%lwt let x = .... in
  [%lwt let y = ... in
    [%lwt let z = ... in
       ...
    ]
  ]
]

vs.

let%lwt x = ... in
let%lwt y = ... in
let%lwt z = ... in
  ...

So while I think it is worth it for let, I'm much less sure about the
other constructs. I also think that it will be difficult to persuade the
OCaml developers to allow "KWD % id" all over the place.

> And I can imagine examples where {%ext x1=e1; ...; xn=en} would be useful as well (see the "pre-polyrecord" example).

[%ext x1=e1; ...; xn=en] would already be valid. Also, this might get in
the way of my proposed short quotation extension form: {%id { .... }}.

Which reminds me, at the very least, we must implement a {x{ ... }x}
quoting construct for quotation extensions.

>> While "let % lwt" may be alright, I do think that
>>
>> ( % id expr )
>>
>> is a bad idea. It looks too much like a prefix operator. Also, having a
>> two character delimiter that isn't a single token is different from
>> every other two character delimiter in the langauge. It also means that
>> you can't use precedence to resolve conflicts in the parser. Is there
>> any real benefit in using (%id expr) instead of [%id expr]?
>
> The benefit I can see is the uniformity with other forms of expressions:
>
>    KW%id ...
>
> where KW is the opening keyword/symbol (here "(") and ... the rest of the construction starting with KW.

I don't think there is any uniformity here, people do not think of
keywords and delimiters as equivalent, and do not expect them to behave
the same. They do expect all delimiters to behave the same, which is why
"( % id expr )" really should not be allowed.

From alain.frisch at lexifi.com  Thu Mar 14 11:34:04 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 14 Mar 2013 12:34:04 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <878v5qtff1.fsf@kingston.cl.cam.ac.uk>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
 <5140BC1D.3060703@lexifi.com> <86fvzzgf4p.fsf@cam.ac.uk>
 <51418BA7.2030305@lexifi.com> <878v5qtff1.fsf@kingston.cl.cam.ac.uk>
Message-ID: <5141B5AC.7090702@lexifi.com>

On 03/14/2013 12:00 PM, Leo White wrote:
> To be honest I am (cautiously) ok with "let%lwt x = ...".

If we only support the special form for "let", I agree it would make 
sense to make "let%ext" a single token.

I don't have a strong opinion about it, but if we special-case the 
treatment of the "let" binding, maybe it is worth introducing a custom 
kind of extension point for this construction, like supporting an 
arbitrary sequence of symbol characters:

   [%%lwt let suffix = "**"]
   [%%lazy let suffix = "..."]

   ...
      let** x1 = e1 in
      let** x2 = e2 in
      ...
   ...
      let... rec x = button "X" ~click:(fun () -> y # set_text "X")
      and  y = button "Y" ~click:(fun () -> x # set_text "Y")
      in
      hbox [x; y]


> Note that for "let" the trade-off is potentially much worse:

It makes sense.

What do other people on the list think?

  - Should we support a compact syntax for extension nodes on all 
constructions starting with a keyword or delimiter (and if so, should 
this become the only syntax for extension nodes)?

  - If not, should be do it for the (local) let-binding only?  Or, if we 
special-case this construction, should we do something different for it 
altogether (arbitrary symbol characters)?



Alain

From gabriel.scherer at gmail.com  Thu Mar 14 16:57:27 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 14 Mar 2013 17:57:27 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <5141B5AC.7090702@lexifi.com>
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
 <5140BC1D.3060703@lexifi.com> <86fvzzgf4p.fsf@cam.ac.uk>
 <51418BA7.2030305@lexifi.com>
 <878v5qtff1.fsf@kingston.cl.cam.ac.uk> <5141B5AC.7090702@lexifi.com>
Message-ID: <CAPFanBHtio4eAf7g18bxzh+je-bNe=XQVykj4eVL96heV9rDJA@mail.gmail.com>

> What do other people on the list think?
>
>  - Should we support a compact syntax for extension nodes on all
> constructions starting with a keyword or delimiter (and if so, should this
> become the only syntax for extension nodes)?
>
>  - If not, should be do it for the (local) let-binding only?  Or, if we
> special-case this construction, should we do something different for it
> altogether (arbitrary symbol characters)?

If we have a let%foo syntax, I think it's better to have it for all
constructions starting with a keyword than for an arbitrary subset of
them. I have no strong opinion on whether delimiters should be
included as well. That said, I appreciate the idea of having a single,
uniform way to put an annotation in any grammar class, that can be
introduced anywhere the keyword structure is not satisfying.

That said, I'm still a bit uncomfortable with translating (let%foo p =
e1 in e2) into [%foo let p = e1 in e2]. This amounts to injecting
arbitrary "Annot" node in the AST structure, and I'm worried about the
implementation consequences: the -bin-annot implementation showed than
adding new nodes in between is a bad idea when the compiler does
depth-higher-than-one pattern-matching to spot optimization
opportunities. I'm wondering whether all such extensibility data could
have a more second-class place in the AST structure, as the location
fields have today (they're attached to each "real AST node", not a
node of their own), orthogonally to the distinction (to which I'm not
really attached in any case) between "stuff that it is legal to have
left after preprocessing and must be ignored" and "stuff that should
provoke a failure if left unattended".

On Thu, Mar 14, 2013 at 12:34 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/14/2013 12:00 PM, Leo White wrote:
>>
>> To be honest I am (cautiously) ok with "let%lwt x = ...".
>
>
> If we only support the special form for "let", I agree it would make sense
> to make "let%ext" a single token.
>
> I don't have a strong opinion about it, but if we special-case the treatment
> of the "let" binding, maybe it is worth introducing a custom kind of
> extension point for this construction, like supporting an arbitrary sequence
> of symbol characters:
>
>   [%%lwt let suffix = "**"]
>   [%%lazy let suffix = "..."]
>
>   ...
>      let** x1 = e1 in
>      let** x2 = e2 in
>      ...
>   ...
>      let... rec x = button "X" ~click:(fun () -> y # set_text "X")
>      and  y = button "Y" ~click:(fun () -> x # set_text "Y")
>      in
>      hbox [x; y]
>
>
>
>> Note that for "let" the trade-off is potentially much worse:
>
>
> It makes sense.
>
> What do other people on the list think?
>
>  - Should we support a compact syntax for extension nodes on all
> constructions starting with a keyword or delimiter (and if so, should this
> become the only syntax for extension nodes)?
>
>  - If not, should be do it for the (local) let-binding only?  Or, if we
> special-case this construction, should we do something different for it
> altogether (arbitrary symbol characters)?
>
>
>
> Alain

From lpw25 at cam.ac.uk  Thu Mar 14 17:18:56 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 14 Mar 2013 17:18:56 +0000
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBHtio4eAf7g18bxzh+je-bNe=XQVykj4eVL96heV9rDJA@mail.gmail.com>
 (Gabriel Scherer's message of "Thu, 14 Mar 2013 17:57:27 +0100")
References: <1827966950.3050167.1362583066514.JavaMail.root@inria.fr>
 <513765F5.5020900@lexifi.com> <513858DD.6040705@lexifi.com>
 <5138A4D7.5040804@lexifi.com>
 <CAPFanBH1eZ-Uukhs2w2X1zPb=CjUpan85MOYnorBXFeFfM-01Q@mail.gmail.com>
 <5138B308.5080301@lexifi.com>
 <CAPFanBFvP6AjZzYOuBQB3JnE0JM7omud_LseF65LOcryzbGW=A@mail.gmail.com>
 <5138C672.3030504@lexifi.com>
 <CAPFanBFTvmCugwvom_fdhs-2W7BHuYpamWQpFH3AHG8WMoTyQA@mail.gmail.com>
 <5139AD13.8050304@lexifi.com> <87hakf6wbz.fsf@kingston.cl.cam.ac.uk>
 <5140BC1D.3060703@lexifi.com> <86fvzzgf4p.fsf@cam.ac.uk>
 <51418BA7.2030305@lexifi.com> <878v5qtff1.fsf@kingston.cl.cam.ac.uk>
 <5141B5AC.7090702@lexifi.com>
 <CAPFanBHtio4eAf7g18bxzh+je-bNe=XQVykj4eVL96heV9rDJA@mail.gmail.com>
Message-ID: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>

> [...] I appreciate the idea of having a single,
> uniform way to put an annotation in any grammar class, that can be
> introduced anywhere the keyword structure is not satisfying.

I agree.

> That said, I'm still a bit uncomfortable with translating (let%foo p =
> e1 in e2) into [%foo let p = e1 in e2]. This amounts to injecting
> arbitrary "Annot" node in the AST structure, and I'm worried about the
> implementation consequences: the -bin-annot implementation showed than
> adding new nodes in between is a bad idea when the compiler does
> depth-higher-than-one pattern-matching to spot optimization
> opportunities. 

Since the extension nodes have to be compiled away by an AST transformer
before type-checking, there is no danger of them preventing an
optimisation. Attributes on the other hand could cause problems.

> I'm wondering whether all such extensibility data could
> have a more second-class place in the AST structure, as the location
> fields have today

I think that this is definitely the right way to go for attributes. For
extensions, I think it makes more sense to give them their own AST
node. The idea is that an extension used as an expression *is* an
expression, so it should be represented in the AST as such.

From alain.frisch at lexifi.com  Fri Mar 15 11:24:25 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 15 Mar 2013 12:24:25 +0100 (CET)
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
Message-ID: <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>

> I think that this is definitely the right way to go for attributes.

Attributes are now implemented as an extra field of the expression (and other) record in the Parsetree.

> For
> extensions, I think it makes more sense to give them their own AST
> node. The idea is that an extension used as an expression *is* an
> expression, so it should be represented in the AST as such.

Agreed.

Extension designers will need to choose between using an attribute:

  let[@foo] x = e1 in e2

or an extension node:

  let%foo x = e1 in e2


The first form is clearly to be preferred for adding meta-data which can be safely ignored by the type-checker, and the second one for constructions which just piggy-back existing syntax with a very different semantics (a la sedlex, bitstring, etc).   There is a gray area in between, though.

-- Alain

From gabriel.scherer at gmail.com  Fri Mar 15 13:04:14 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 15 Mar 2013 14:04:14 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
Message-ID: <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>

But why do we have a heavier syntax for innocuous stuff, and an easy
syntax for wild-semantics-change stuff? Would let at foo work as well?

On Fri, Mar 15, 2013 at 12:24 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> I think that this is definitely the right way to go for attributes.
>
> Attributes are now implemented as an extra field of the expression (and other) record in the Parsetree.
>
>> For
>> extensions, I think it makes more sense to give them their own AST
>> node. The idea is that an extension used as an expression *is* an
>> expression, so it should be represented in the AST as such.
>
> Agreed.
>
> Extension designers will need to choose between using an attribute:
>
>   let[@foo] x = e1 in e2
>
> or an extension node:
>
>   let%foo x = e1 in e2
>
>
> The first form is clearly to be preferred for adding meta-data which can be safely ignored by the type-checker, and the second one for constructions which just piggy-back existing syntax with a very different semantics (a la sedlex, bitstring, etc).   There is a gray area in between, though.
>
> -- Alain

From alain.frisch at lexifi.com  Fri Mar 15 13:51:26 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 15 Mar 2013 14:51:26 +0100 (CET)
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
Message-ID: <84430774.3486159.1363355486267.JavaMail.root@lexifi.com>

Gabriel:
> But why do we have a heavier syntax for innocuous stuff, and an easy
> syntax for wild-semantics-change stuff? Would let at foo work as well?

Attributes takes an optional argument, i.e. you can write:

  let[@foo bla] x = ....

so we need some delimeters.  (Maybe we could have a lighter syntax for attributes without arguments.)

In the form "let%foo x = ...", the argument of the extension is "let x = ...".


-- Alain

From lpw25 at cam.ac.uk  Fri Mar 15 13:53:06 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Fri, 15 Mar 2013 13:53:06 +0000
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 (Gabriel Scherer's message of "Fri, 15 Mar 2013 14:04:14 +0100")
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
Message-ID: <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>

Gabriel Scherer <gabriel.scherer at gmail.com> writes:

> But why do we have a heavier syntax for innocuous stuff, and an easy
> syntax for wild-semantics-change stuff? Would let at foo work as well?
>

I think that is because "let at foo x = ..." doesn't annotate foo with much
information. The expected uses are more like:

    let [@foo (*some information pretending to be an expression*)] x = ...

where obviously the hevier syntax is required.

From gabriel.scherer at gmail.com  Fri Mar 15 15:16:07 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 15 Mar 2013 16:16:07 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>

I suspect we could get some value, for example, of

  let at nowarn [x;y;z] = List.map normalize [x;y;z]

(More generally I've been thinking about compiler pragmas, and those
often don't need arguments.)

I think the answer is yes, but I don't quite remember: if let[@foo
bar] .. = ... in .. is accepted, do we also allow let[%foo bar] ... in
... as a shortcut for [%foo bar (let .. in ...)]?

On Fri, Mar 15, 2013 at 2:53 PM, Leo White <lpw25 at cam.ac.uk> wrote:
> Gabriel Scherer <gabriel.scherer at gmail.com> writes:
>
>> But why do we have a heavier syntax for innocuous stuff, and an easy
>> syntax for wild-semantics-change stuff? Would let at foo work as well?
>>
>
> I think that is because "let at foo x = ..." doesn't annotate foo with much
> information. The expected uses are more like:
>
>     let [@foo (*some information pretending to be an expression*)] x = ...
>
> where obviously the hevier syntax is required.

From alain.frisch at lexifi.com  Thu Mar 21 09:15:45 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 21 Mar 2013 10:15:45 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
Message-ID: <514ACFC1.5090705@lexifi.com>

On 03/15/2013 04:16 PM, Gabriel Scherer wrote:
> I suspect we could get some value, for example, of
>
>    let at nowarn [x;y;z] = List.map normalize [x;y;z]
>
> (More generally I've been thinking about compiler pragmas, and those
> often don't need arguments.)
>
> I think the answer is yes, but I don't quite remember: if let[@foo
> bar] .. = ... in .. is accepted, do we also allow let[%foo bar] ... in
> ... as a shortcut for [%foo bar (let .. in ...)]?

No, currently let[%foo bar] ... in ... is not allowed.

I think we should move forward and make a decision concerning the 
alternative syntax for attributes and extension nodes on opening 
delimiters and keywords.  As a reminder, the current version in the SVN 
supports the following sugar for an EXPRESSION which starts with a 
keyword or delimiter KW (EXPRESSION == KW REST):

Attributes:

   KW[@id expr]...[@id expr] REST
   ---->
   EXPRESSION[@id expr]...[@id expr]

Extension node:

   KW%id REST
   ---->
   [%id EXPRESSION]

Attributes on extension node:

   KW%id[@id expr]...[@id expr] REST
   ---->
   [%id EXPRESSION][@id expr]...[@id expr]


where KW can stand for:

  (
  (module
  [
  [|
  assert
  begin
  for
  fun
  function
  if
  lazy
  let
  let module
  let open
  match
  new
  object
  try
  while
  {
  {<



I propose to choose between one of the following:

  1. Continue with the current situation.

  2. Completely get rid of this alternative "prefix" syntax for 
attributes and extension points.  This only affect parser.mly and can 
easily be discussed again and added later.  This would reduce the 
changes to the concrete grammar (and would thus simplify supporting 
attributes and extension points in Camlp4)

  3. Keep the syntax, but only for real keywords, not opening delimiters 
( [ [| { and {<.

  4. Do something special for "let" (it has been argued that for other 
constructions, the normal syntax of extension point does not add too 
much overhead); to be detailed.


Note, even if we go with 2, we can still write:

  let (x, y) [@lwt] = ... in
  ...

i.e. use (a postfix) attribute on the (first) pattern of the binding.


I'm now slightly in favor of 2, neutral between 1 and 3, and slightly 
against 4.

Please share your opinion (and feel free to propose something else)!



Alain

From lpw25 at cam.ac.uk  Thu Mar 21 10:15:03 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 21 Mar 2013 10:15:03 +0000
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <514ACFC1.5090705@lexifi.com> (Alain Frisch's message of "Thu, 21
 Mar 2013 10:15:45 +0100")
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com>
Message-ID: <87ppytm53s.fsf@kingston.cl.cam.ac.uk>

> I propose to choose between one of the following:
>
>  1. Continue with the current situation.
>
>  2. Completely get rid of this alternative "prefix" syntax for attributes and extension points.  This only affect
> parser.mly and can easily be discussed again and added later.  This would reduce the changes to the concrete grammar
> (and would thus simplify supporting attributes and extension points in Camlp4)
>
>  3. Keep the syntax, but only for real keywords, not opening delimiters ( [ [| { and {<.
>
>  4. Do something special for "let" (it has been argued that for other constructions, the normal syntax of extension
> point does not add too much overhead); to be detailed.
>

I'm basically fine with 2, 3 or 4. I would also be fine with:

  1.5. Completely get rid of the "prefix" syntax for extensions but
       keep it for attributes.

It might be best to go with 2 for now since, as you suggested, it will be
much easier to add syntactic sugar later than to remove it.

From gabriel.scherer at gmail.com  Thu Mar 21 13:22:17 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 21 Mar 2013 14:22:17 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
Message-ID: <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>

The translation of
   KW%id[@id expr]..[@id expr] REST
into
  [%id KW REST] [@id expr]..[@id expr]
is surprising to me. I would instead have expected it to translate into
  [%id (KW REST)[@id expr]..[@id expr] ]
(the extensions would have precedence over attributes, so that
localized extension handlers only rewriting what is inside the [%id
EXPR] can see the attributes and react to them)

Among the options you highlight, my own current preference goes for (3).

I think the question is: how much do we need for the "easy cases" of
current camlp4 users to switch to this style, and not the style of
"overloading valid code semantics" that is currently used by, say,
ppx_monad, and I think is the wrong way to go on the long term?

If having a convenient syntax as discussed here is not necessary to do
the switch, maybe that's enough. But if it is necessary, I think it
should be agreed upon right away, to be sure that the "good solutions"
will not, when studied in the future, require changes to what you will
implement short-term.

On Thu, Mar 21, 2013 at 11:15 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> I propose to choose between one of the following:
>>
>>  1. Continue with the current situation.
>>
>>  2. Completely get rid of this alternative "prefix" syntax for attributes and extension points.  This only affect
>> parser.mly and can easily be discussed again and added later.  This would reduce the changes to the concrete grammar
>> (and would thus simplify supporting attributes and extension points in Camlp4)
>>
>>  3. Keep the syntax, but only for real keywords, not opening delimiters ( [ [| { and {<.
>>
>>  4. Do something special for "let" (it has been argued that for other constructions, the normal syntax of extension
>> point does not add too much overhead); to be detailed.
>>
>
> I'm basically fine with 2, 3 or 4. I would also be fine with:
>
>   1.5. Completely get rid of the "prefix" syntax for extensions but
>        keep it for attributes.
>
> It might be best to go with 2 for now since, as you suggested, it will be
> much easier to add syntactic sugar later than to remove it.

From alain.frisch at lexifi.com  Fri Mar 22 11:36:42 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 22 Mar 2013 12:36:42 +0100
Subject: [wg-camlp4] Request for feedback
In-Reply-To: <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
Message-ID: <514C424A.6070905@lexifi.com>

On 03/21/2013 02:22 PM, Gabriel Scherer wrote:
> The translation of
>     KW%id[@id expr]..[@id expr] REST
> into
>    [%id KW REST] [@id expr]..[@id expr]
> is surprising to me. I would instead have expected it to translate into
>    [%id (KW REST)[@id expr]..[@id expr] ]
> (the extensions would have precedence over attributes, so that
> localized extension handlers only rewriting what is inside the [%id
> EXPR] can see the attributes and react to them)

I don't think it will make a big difference in practice if the 
attributes are stored in the pexp_attributes of the record whose 
pexp_desc is Pexp_extension(_, e) instead of e.pexp_attributes.

But I've changed the code to match the behavior you describe.

> Among the options you highlight, my own current preference goes for (3).

Since Leo and me are also ok with that, and nobody else commented, let's 
go with (3) for now.  I've removed support for the alternative syntax 
for expression constructions not starting with a keyword or a combinator 
of keywords (let module, let open).  I've considered "(module ...)" as 
not starting with a keyword.

-- Alain

From alain.frisch at lexifi.com  Mon Mar 25 11:42:57 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 25 Mar 2013 12:42:57 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <514C424A.6070905@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com>
Message-ID: <51503841.7040708@lexifi.com>

Dear all,

Now that we have reached a stable state concerning the syntax of 
attributes and extension nodes, I'd like to get feedback on the proposed 
changes to the definition of the Parsetree:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/parsing/parsetree.mli?r1=13329&r2=HEAD


The following changes have been applied:

  - Adding new constructors for extension nodes and for attributes as 
stand-alone signature/structure items.

  - Storing attributes as new fields in record types (such as 
expression, pattern, core_type, etc).

  - Introducing some more records to replace tuples/n-ary constructors: 
label_declaration, constructor_declaration, exception_declaration, 
module_declaration, module_type_declaration, module_binding, 
module_type_binding.

  - Adding a name field to value_description and type_declaration.

Another tiny change is that recursive modules are no longer restricted 
syntactically to come with explicit module types (this is enforced in 
the type-checker).  This means that "module rec A = (struct ... end : 
sig ... end)" is now accepted as well as "module rec A : sig ... end = 
struct ... end".


More cleanup to the Parsetree representation can be considered. Examples:

  - Cleaner representation of "when" guard (before doing anything here, 
I'd like to know if the removal of the "fun pat when cond -> ..." form 
will be accepted, see http://caml.inria.fr/mantis/view.php?id=5939).

  - Doing less desugaring the parser (interval patterns, M.(e) === let 
open M in e, ....).

  - Make the type-checker more robust w.r.t. where Ptyp_poly node have 
to be inserted (currently the parser introduces some empty Ptyp_poly 
nodes and the type-checker expects to find them).

  - Replacing Booleans with more explicit sum types and getting rid of 
more tuples/n-ary constructors.


It's probably good to validate the general approach first with the core 
team before we apply any such further cleanups.  Before submitting the 
current version for review to the core team, I'd like to get feedback 
from the participants of this working group.


Alain

From lpw25 at cam.ac.uk  Mon Mar 25 14:05:42 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Mon, 25 Mar 2013 14:05:42 +0000
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <51503841.7040708@lexifi.com> (Alain Frisch's message of "Mon, 25
 Mar 2013 12:42:57 +0100")
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
Message-ID: <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk>

> Now that we have reached a stable state concerning the syntax of attributes and extension nodes, I'd like to get
> feedback on the proposed changes to the definition of the Parsetree:
>
> [...]
>
> It's probably good to validate the general approach first with the core team before we apply any such further cleanups.
> Before submitting the current version for review to the core team, I'd like to get feedback from the participants of
> this working group.

All of those changes seem reasonable. 

Another small clean-up I'd like would be to change "ptype_params" from
"string loc option list" to "core_type list" and the first part of
"pci_params" from "string loc list" to "core_type list".

I think this would be more consistent with what people will expect. It
also improves Typedtree by attaching the Type of the parameters to their
place in the syntax tree. (and it makes things a little simpler for my
"open types" branch.)

Before you submit the changes to the core team, we really need to add
the:

    {x{ ... }x}

syntax for use with quotations. It should be simple enough to add to the
lexer, and then accept as a "constant" in the parser. In the parsetree
it should either be represented by its own node (Const_quote) or just
translated into a Const_string.



    

From jathdr at gmail.com  Mon Mar 25 14:13:09 2013
From: jathdr at gmail.com (jathdr)
Date: Mon, 25 Mar 2013 15:13:09 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <51503841.7040708@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
Message-ID: <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>



Alain Frisch <alain.frisch at lexifi.com>:

> Now that we have reached a stable state concerning the syntax of attributes and extension nodes, I'd like to get feedback on the proposed changes to the definition of the Parsetree:
> 

Could we get a summary of the current syntax proposal? I've been following along, but I'm a bit lost as to what has been discussed, accepted, rejected, etc. 

> - Doing less desugaring the parser (interval patterns, M.(e) === let open M in e, ....).
> 

This is probably a bit off topic, but while we're talking about interval patterns: I discovered the other day that interval patterns only work for chars, while I always assumed they also worked for ints. Is there a reason why they don't?

From alain.frisch at lexifi.com  Mon Mar 25 18:49:49 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 25 Mar 2013 19:49:49 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
Message-ID: <51509C4D.9010509@lexifi.com>

On 03/25/2013 03:13 PM, jathdr wrote:
> Could we get a summary of the current syntax proposal? I've been
> following along, but I'm a bit lost as to what has been discussed,
> accepted, rejected, etc.

This file describes the current syntax proposal:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup


> This is probably a bit off topic, but while we're talking about
> interval patterns: I discovered the other day that interval patterns
> only work for chars, while I always assumed they also worked for
> ints. Is there a reason why they don't?

Currently, range patterns for characters are expanded in the parser. 
Doing so for integers as well could lead to huge or-patterns to be 
processed by the rest of the compiler.  Supporting range patterns 
directly in the compiler would add a little bit of extra complexity for 
type-checking (exhaustiveness check) and code generation.  I don't see 
any theoretical problem, though.


-- Alain

From hongboz at seas.upenn.edu  Mon Mar 25 21:50:20 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 25 Mar 2013 17:50:20 -0400
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <51509C4D.9010509@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com>
 <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
 <51509C4D.9010509@lexifi.com>
Message-ID: <CANcqPu5hO1d6+ifdTZNxYpJ5m4gWu2XeM+D6BO7nbv6AW2izOQ@mail.gmail.com>

Hi Alain,
  I am a bit busy this week, but I would like to follow the discussion and
give some feedback next week, Thanks
On Mon, Mar 25, 2013 at 2:49 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 03/25/2013 03:13 PM, jathdr wrote:
>
>> Could we get a summary of the current syntax proposal? I've been
>> following along, but I'm a bit lost as to what has been discussed,
>> accepted, rejected, etc.
>>
>
> This file describes the current syntax proposal:
>
> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
> extension_points/experimental/**frisch/extension_points.txt?**
> revision=HEAD&view=markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup>
>
>
>
>  This is probably a bit off topic, but while we're talking about
>> interval patterns: I discovered the other day that interval patterns
>> only work for chars, while I always assumed they also worked for
>> ints. Is there a reason why they don't?
>>
>
> Currently, range patterns for characters are expanded in the parser. Doing
> so for integers as well could lead to huge or-patterns to be processed by
> the rest of the compiler.  Supporting range patterns directly in the
> compiler would add a little bit of extra complexity for type-checking
> (exhaustiveness check) and code generation.  I don't see any theoretical
> problem, though.
>
>
> -- Alain
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130325/bf0eb737/attachment.html>

From alain.frisch at lexifi.com  Tue Mar 26 11:34:32 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Mar 2013 12:34:32 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk>
Message-ID: <515187C8.2030109@lexifi.com>

On 03/25/2013 03:05 PM, Leo White wrote:
> Another small clean-up I'd like would be to change "ptype_params" from
> "string loc option list" to "core_type list" and the first part of
> "pci_params" from "string loc list" to "core_type list".

Would you change the parser to accept arbitrary types (instead of _ and 
type variables), and enforce the previous constraint in the 
type-checker?  It would also make sense to merge the ptype_variance 
information into ptype_params (probably introducing a record type to 
represent each type parameter).

> Before you submit the changes to the core team, we really need to add
> the:
>
>      {x{ ... }x}
>
> syntax for use with quotations. It should be simple enough to add to the
> lexer, and then accept as a "constant" in the parser. In the parsetree
> it should either be represented by its own node (Const_quote) or just
> translated into a Const_string.

I've committed this change, using {x| ... |x} instead of {x{ ... }x} 
(this just looks more readable to me; feel free to object).  In this 
syntax, x is an arbitrary (possibly empty) sequence of lowercase 
letters, no whitespaces allowed between { and |.  Inside the quoted 
string, no character is interpreted in a special way.  In the Parsetree, 
this is represented by changing Const_string to:

   | Const_string of string * string option

where the delimiter is stored in the "string option" (None for the 
regular syntax of OCaml strings).


Another change I've committed recently is an update to the Typedtree 
representation, to bring it closer to the current state of the 
Parsetree, including attributes.  This makes it possible for external 
tools to process attributes in .cmt/.cmti files.  I've committed an 
example of a "mini-ocamldoc" based on this technique:

 
http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/minidoc.ml?revision=HEAD&view=markup
 
http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/testdoc.mli?revision=HEAD&view=markup 



Leo: you mentioned that you're working on a revised ocamldoc.  Do you 
have plans to have it rely on attributes?


Alain


From thomas at ocamlpro.com  Tue Mar 26 11:57:15 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 26 Mar 2013 12:57:15 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <515187C8.2030109@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
Message-ID: <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>

Hi,

just few minor remarks/questions:

* is the distinction between top-level items and other items really necessary (eg, @ vs. @@) ? This seems to be the only "complex" thing to explain, as the other parts of the design nicely sounds rather simple. Also I'm not sure to understand why you need/want to annotate individual structure items in a recursive type declaration.

> Another change I've committed recently is an update to the Typedtree representation, to bring it closer to the current state of the Parsetree, including attributes.  This makes it possible for external tools to process attributes in .cmt/.cmti files.  I've committed an example of a "mini-ocamldoc" based on this technique:

* the doc annotations are the ones where you usually prefer to have some kind of suffix notation (eg. you usually read what the function / module does before reading its signature). Is the plan to automatically transform suffix ocamldoc snippets into prefix annotations or to drop the suffix doc snippets completely ?

Thomas





> 
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/minidoc.ml?revision=HEAD&view=markup
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/testdoc.mli?revision=HEAD&view=markup 
> 
> 
> Leo: you mentioned that you're working on a revised ocamldoc.  Do you have plans to have it rely on attributes?
> 
> 
> Alain
> 
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From thomas at ocamlpro.com  Tue Mar 26 12:01:27 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 26 Mar 2013 13:01:27 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
Message-ID: <4E9D70B6-C14E-4E0A-88F9-3F562AA19308@ocamlpro.com>

> * the doc annotations are the ones where you usually prefer to have some kind of suffix notation

I meant *prefix*


From alain.frisch at lexifi.com  Tue Mar 26 12:33:38 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Mar 2013 13:33:38 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
Message-ID: <515195A2.5020501@lexifi.com>

On 03/26/2013 12:57 PM, Thomas Gazagnaire wrote:
> * is the distinction between top-level items and other items really
> necessary (eg, @ vs. @@) ? This seems to be the only "complex" thing
> to explain, as the other parts of the design nicely sounds rather
> simple.

Consider:

type t = Foo of int [@xxx]

val x: int [@xxx]

module X : S [@xxx]

These are attributes on (module) type expressions.  If we want to 
support such attributes in addition to attributes on the corresponding 
"items" (type, value, module declarations), we need a different syntax.

 > Also I'm not sure to understand why you need/want to annotate
> individual structure items in a recursive type declaration.

type t = X | Y
   [@@sexp]
   [@@doc "This is the type [t], supporting s-exp."]

and s = A | B
   [@@xml]
   [@@doc "This is the type [s], supporting xml."]

> * the doc annotations are the ones where you usually prefer to have
> some kind of prefix notation (eg. you usually read what the function
> / module does before reading its signature). Is the plan to
> automatically transform prefix ocamldoc snippets into suffix
> annotations or to drop the prefix doc snippets completely ?

I don't have any plan to rewrite ocamldoc myself; I only mentioned that 
attributes could be used to drastically simplify the design of ocamldoc, 
avoiding the need to re-parse to source file to find comments.

Concerning the syntax, I tend to write ocamldoc comments *after* 
signature items.  Since the comments often refers to parts of the 
definition (function parameters, constructors, etc), it makes sense to 
do so.  This seems to be the convention adopted in the stdlib, for instance.

When using ocamldoc to generate doc based on implementations, not 
interfaces, it would indeed be more natural to put the description 
before the function definition.  But I don't think that ocamldoc is 
really used like that.  Or is it an important use case for you?


Alain

From thomas at ocamlpro.com  Tue Mar 26 12:49:06 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 26 Mar 2013 13:49:06 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <515195A2.5020501@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
 <515195A2.5020501@lexifi.com>
Message-ID: <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>

>> * is the distinction between top-level items and other items really
>> necessary (eg, @ vs. @@) ? This seems to be the only "complex" thing
>> to explain, as the other parts of the design nicely sounds rather
>> simple.
> 
> Consider:
> 
> type t = Foo of int [@xxx]
> 
> val x: int [@xxx]
> 
> module X : S [@xxx]
> 
> These are attributes on (module) type expressions.  If we want to support such attributes in addition to attributes on the corresponding "items" (type, value, module declarations), we need a different syntax.

ok.

> > Also I'm not sure to understand why you need/want to annotate
>> individual structure items in a recursive type declaration.
> 
> type t = X | Y
>  [@@sexp]
>  [@@doc "This is the type [t], supporting s-exp."]
> 
> and s = A | B
>  [@@xml]
>  [@@doc "This is the type [s], supporting xml."]

For the @@sexp and @@xml parts, you won't see that in real-codebases. Usually, all the types in a given module/file have their associated generators. But ok for the documentation.

> Concerning the syntax, I tend to write ocamldoc comments *after* signature items.  Since the comments often refers to parts of the definition (function parameters, constructors, etc), it makes sense to do so.  This seems to be the convention adopted in the stdlib, for instance.

A lot of existing code doesn't follow this convention (JS' core for instance). Personally, I found clearer to read what the function/type/module does in a comment, before reading its signature. 

> When using ocamldoc to generate doc based on implementations, not interfaces, it would indeed be more natural to put the description before the function definition.  But I don't think that ocamldoc is really used like that.  Or is it an important use case for you?

I never use ocamldoc on .ml files, so no, it's not important for me.

Thomas



From alain.frisch at lexifi.com  Tue Mar 26 12:59:15 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Mar 2013 13:59:15 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
 <515195A2.5020501@lexifi.com>
 <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
Message-ID: <51519BA3.2@lexifi.com>

On 03/26/2013 01:49 PM, Thomas Gazagnaire wrote:
> Personally, I found clearer to read what the function/type/module does in a comment, before reading its signature.

Of course, nothing prevent the tool to show the text before the item in 
the generated doc.  This is really a discussion about where to put the 
text in the source file (we expect users to read the ocamldoc-generated 
documentation, not the source .mli files).

Note that you can write:

;;[@@doc "blabla"]
val f: int -> unit

Here, the attribute is a standalone (floating) signature-item attribute. 
  The tool could interpret such attributes as being attached to the 
following item.  But I don't find it very nice to break the natural 
"scoping" of attributes like that.  (To some extent, the minidoc example 
already does that, since it allows "section headers" to be put on other 
items' attributes.)

ocamldoc uses the same syntax for prefix and postfix notation, and 
relies on heuristics based on concrete placement (including whitespace, 
I believe) in order to attach comments to items.  This is very fragile, 
and it doesn't support some interesting usage scenarios (like 
documentation fragments generated/inserted by -ppx filters).  If we had 
to support a prefix notation for attributes, we would need to introduce 
a different syntax.  We discussed it, but I don't think it is worthwhile 
doing so only for this use case.


-- Alain



From daniel.buenzli at erratique.ch  Tue Mar 26 13:26:40 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 26 Mar 2013 14:26:40 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
 <515195A2.5020501@lexifi.com>
 <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
Message-ID: <881B15BF470F4FC3AC20ED82AC08DD6F@erratique.ch>

Le mardi, 26 mars 2013 ? 13:49, Thomas Gazagnaire a ?crit :

> (eg. you usually read what the function / module does before reading its signature).
[...]  

> A lot of existing code doesn't follow this convention (JS' core for instance). Personally, I found clearer to read what the function/type/module does in a comment, before reading its signature.

I also write them after. I think that for *libraries* the "usually you read what the function does before reading its signature" is quite debatable.  

For a library maybe once or twice you will read an interface from top to bottom, but that's not the average use case. Most of the time you want to first *find* a function and then consult its signature (often a brain refresh on that is sufficient) and *maybe* read the documentation.  

From that perspective making the comment after makes it easier to skip from one definition to the other: just look for what follows a blank space.  If comments are before, you have to look for blank space and then move up again, which incurs direction changes that slows down your scanning. (For those that object that CTRL-s does the scanning, I respond that your brain sometimes doesn't remember the exact name you are looking for).  

Besides having comments after also matches the order in which it appears in the generated html, which makes it easier for my brain to switch from one representation to the other.  

These may seem like details, but I think they are relevant from a human factor point of view.  

Best,

Daniel 

From mike.mcclurg at gmail.com  Tue Mar 26 15:15:52 2013
From: mike.mcclurg at gmail.com (Mike McClurg)
Date: Tue, 26 Mar 2013 15:15:52 +0000
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <51509C4D.9010509@lexifi.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com>
 <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
 <51509C4D.9010509@lexifi.com>
Message-ID: <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>

Hi Alain,

Thanks for writing up that proposal. Is the code in your extension_points
branch ready for testing at all yet?

On a separate note, might it be a good idea to add an opam-repo-dev
repository to github.com/ocaml, which would provide opam switches for all
the experimental OCaml branches, such as extension_points? Or is there such
an experimental opam repo out there already?

Mike


On Mon, Mar 25, 2013 at 6:49 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 03/25/2013 03:13 PM, jathdr wrote:
>
>> Could we get a summary of the current syntax proposal? I've been
>> following along, but I'm a bit lost as to what has been discussed,
>> accepted, rejected, etc.
>>
>
> This file describes the current syntax proposal:
>
> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
> extension_points/experimental/**frisch/extension_points.txt?**
> revision=HEAD&view=markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup>
>
>
>
>  This is probably a bit off topic, but while we're talking about
>> interval patterns: I discovered the other day that interval patterns
>> only work for chars, while I always assumed they also worked for
>> ints. Is there a reason why they don't?
>>
>
> Currently, range patterns for characters are expanded in the parser. Doing
> so for integers as well could lead to huge or-patterns to be processed by
> the rest of the compiler.  Supporting range patterns directly in the
> compiler would add a little bit of extra complexity for type-checking
> (exhaustiveness check) and code generation.  I don't see any theoretical
> problem, though.
>
>
> -- Alain
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130326/08db427c/attachment.html>

From anil at recoil.org  Tue Mar 26 15:22:54 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 26 Mar 2013 15:22:54 +0000
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
 <51509C4D.9010509@lexifi.com>
 <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>
Message-ID: <DAF0958C-4577-4694-9348-3BC7A37C8FD4@recoil.org>

There is no such OPAM remote at the moment, but I think it would be good to add one and move out some of the more experimental branches (e.g. allocation-profiling) from the main OPAM repo.

Thomas, any objections to me doing this rearrangement in OCamlPro/opam-repository?

-anil

On 26 Mar 2013, at 15:15, Mike McClurg <mike.mcclurg at gmail.com> wrote:

> Hi Alain,
> 
> Thanks for writing up that proposal. Is the code in your extension_points branch ready for testing at all yet?
> 
> On a separate note, might it be a good idea to add an opam-repo-dev repository to github.com/ocaml, which would provide opam switches for all the experimental OCaml branches, such as extension_points? Or is there such an experimental opam repo out there already?
> 
> Mike
> 
> 
> On Mon, Mar 25, 2013 at 6:49 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 03/25/2013 03:13 PM, jathdr wrote:
> Could we get a summary of the current syntax proposal? I've been
> following along, but I'm a bit lost as to what has been discussed,
> accepted, rejected, etc.
> 
> This file describes the current syntax proposal:
> 
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup
> 
> 
> 
> This is probably a bit off topic, but while we're talking about
> interval patterns: I discovered the other day that interval patterns
> only work for chars, while I always assumed they also worked for
> ints. Is there a reason why they don't?
> 
> Currently, range patterns for characters are expanded in the parser. Doing so for integers as well could lead to huge or-patterns to be processed by the rest of the compiler.  Supporting range patterns directly in the compiler would add a little bit of extra complexity for type-checking (exhaustiveness check) and code generation.  I don't see any theoretical problem, though.
> 
> 
> -- Alain
> 
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From thomas at ocamlpro.com  Tue Mar 26 15:25:44 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 26 Mar 2013 16:25:44 +0100
Subject: [wg-camlp4] [opam-devel]  Changes to the parsetree
In-Reply-To: <DAF0958C-4577-4694-9348-3BC7A37C8FD4@recoil.org>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
 <51509C4D.9010509@lexifi.com>
 <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>
 <DAF0958C-4577-4694-9348-3BC7A37C8FD4@recoil.org>
Message-ID: <F67CCC6A-1F88-4092-9108-1B792FDE6757@ocamlpro.com>

> Thomas, any objections to me doing this rearrangement in OCamlPro/opam-repository?

No pb. I am just a bit concerned with the list of compilers growing unbounded, but for now I think it's completely fine.

Thomas

> 
> -anil
> 
> On 26 Mar 2013, at 15:15, Mike McClurg <mike.mcclurg at gmail.com> wrote:
> 
>> Hi Alain,
>> 
>> Thanks for writing up that proposal. Is the code in your extension_points branch ready for testing at all yet?
>> 
>> On a separate note, might it be a good idea to add an opam-repo-dev repository to github.com/ocaml, which would provide opam switches for all the experimental OCaml branches, such as extension_points? Or is there such an experimental opam repo out there already?
>> 
>> Mike
>> 
>> 
>> On Mon, Mar 25, 2013 at 6:49 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> On 03/25/2013 03:13 PM, jathdr wrote:
>> Could we get a summary of the current syntax proposal? I've been
>> following along, but I'm a bit lost as to what has been discussed,
>> accepted, rejected, etc.
>> 
>> This file describes the current syntax proposal:
>> 
>> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup
>> 
>> 
>> 
>> This is probably a bit off topic, but while we're talking about
>> interval patterns: I discovered the other day that interval patterns
>> only work for chars, while I always assumed they also worked for
>> ints. Is there a reason why they don't?
>> 
>> Currently, range patterns for characters are expanded in the parser. Doing so for integers as well could lead to huge or-patterns to be processed by the rest of the compiler.  Supporting range patterns directly in the compiler would add a little bit of extra complexity for type-checking (exhaustiveness check) and code generation.  I don't see any theoretical problem, though.
>> 
>> 
>> -- Alain
>> 
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>> 
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> _______________________________________________
> opam-devel mailing list
> opam-devel at lists.ocaml.org
> http://lists.ocaml.org/listinfo/opam-devel


From anil at recoil.org  Tue Mar 26 15:27:19 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 26 Mar 2013 15:27:19 +0000
Subject: [wg-camlp4] [opam-devel]  Changes to the parsetree
In-Reply-To: <F67CCC6A-1F88-4092-9108-1B792FDE6757@ocamlpro.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
 <51509C4D.9010509@lexifi.com>
 <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>
 <DAF0958C-4577-4694-9348-3BC7A37C8FD4@recoil.org>
 <F67CCC6A-1F88-4092-9108-1B792FDE6757@ocamlpro.com>
Message-ID: <F7606EEE-F157-4128-8D1D-009028FD055C@recoil.org>

On 26 Mar 2013, at 15:25, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:

>> Thomas, any objections to me doing this rearrangement in OCamlPro/opam-repository?
> 
> No pb. I am just a bit concerned with the list of compilers growing unbounded, but for now I think it's completely fine.
> 

Right, so this would reduce the number of compilers in OCamlPro/opam-repository and move them to this experimental one.

I wonder if it's time to have an OPAM remotes discovery service :-)

-anil



> Thomas
> 
>> 
>> -anil
>> 
>> On 26 Mar 2013, at 15:15, Mike McClurg <mike.mcclurg at gmail.com> wrote:
>> 
>>> Hi Alain,
>>> 
>>> Thanks for writing up that proposal. Is the code in your extension_points branch ready for testing at all yet?
>>> 
>>> On a separate note, might it be a good idea to add an opam-repo-dev repository to github.com/ocaml, which would provide opam switches for all the experimental OCaml branches, such as extension_points? Or is there such an experimental opam repo out there already?
>>> 
>>> Mike
>>> 
>>> 
>>> On Mon, Mar 25, 2013 at 6:49 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>> On 03/25/2013 03:13 PM, jathdr wrote:
>>> Could we get a summary of the current syntax proposal? I've been
>>> following along, but I'm a bit lost as to what has been discussed,
>>> accepted, rejected, etc.
>>> 
>>> This file describes the current syntax proposal:
>>> 
>>> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup
>>> 
>>> 
>>> 
>>> This is probably a bit off topic, but while we're talking about
>>> interval patterns: I discovered the other day that interval patterns
>>> only work for chars, while I always assumed they also worked for
>>> ints. Is there a reason why they don't?
>>> 
>>> Currently, range patterns for characters are expanded in the parser. Doing so for integers as well could lead to huge or-patterns to be processed by the rest of the compiler.  Supporting range patterns directly in the compiler would add a little bit of extra complexity for type-checking (exhaustiveness check) and code generation.  I don't see any theoretical problem, though.
>>> 
>>> 
>>> -- Alain
>>> 
>>> _______________________________________________
>>> wg-camlp4 mailing list
>>> wg-camlp4 at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/wg-camlp4
>>> 
>>> _______________________________________________
>>> wg-camlp4 mailing list
>>> wg-camlp4 at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/wg-camlp4
>> 
>> _______________________________________________
>> opam-devel mailing list
>> opam-devel at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/opam-devel
> 


From alain.frisch at lexifi.com  Tue Mar 26 16:07:42 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Mar 2013 17:07:42 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
 <515195A2.5020501@lexifi.com>
 <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
Message-ID: <5151C7CE.7040500@lexifi.com>

On 03/26/2013 01:49 PM, Thomas Gazagnaire wrote:
> For the @@sexp and @@xml parts, you won't see that in real-codebases. Usually, all the types in a given module/file have their associated generators.

This is rather minor (especially considering that other use cases are 
sufficient to justify "item" attributes on individual types), but isn't 
it possible to provide a custom function for a specific type instead of 
asking the extension to generate the function?


-- Alain

From alain.frisch at lexifi.com  Tue Mar 26 16:11:28 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 26 Mar 2013 17:11:28 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <83EA4AF5-E403-4CB1-971B-04C82078C183@gmail.com>
 <51509C4D.9010509@lexifi.com>
 <CALru5wV2n-+oo1Vy5J=RWKD966hGAFiQ4APKnVcLcNW0L+mxAQ@mail.gmail.com>
Message-ID: <5151C8B0.9000901@lexifi.com>

On 03/26/2013 04:15 PM, Mike McClurg wrote:
> Hi Alain,
>
> Thanks for writing up that proposal. Is the code in your
> extension_points branch ready for testing at all yet?

Some more work will be done later, so if you write code now against the 
branch (-ppx rewriters or tools based on .cmt/.cmti files), it might 
break in the future.  But otherwise, yes, the branch is ready for 
testing and feedback will be appreciated.

The branch can be obtained with:

svn co http://caml.inria.fr/svn/ocaml/branches/extension_points


-- Alain

From lpw25 at cam.ac.uk  Tue Mar 26 19:56:49 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 26 Mar 2013 19:56:49 +0000
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <515187C8.2030109@lexifi.com> (Alain Frisch's message of "Tue, 26
 Mar 2013 12:34:32 +0100")
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
Message-ID: <87620e6ike.fsf@study.localdomain>

> On 03/25/2013 03:05 PM, Leo White wrote:
>> Another small clean-up I'd like would be to change "ptype_params" from
>> "string loc option list" to "core_type list" and the first part of
>> "pci_params" from "string loc list" to "core_type list".
>
> Would you change the parser to accept arbitrary types (instead of _ and type variables), and enforce the previous
> constraint in the type-checker?  

It might be better to get a syntax error there as it's probably
a common beginner mistake. On the other hand, if the error from the type
checker is nice and clear then it shouldn't be a problem. Either way, we
might as well support extensions and attributes there.

> I've committed this change, using {x| ... |x} instead of {x{ ... }x} (this just looks more readable to me; feel free to
> object).

I slightly prefer {{ ... }} but either seems fine.

> In this syntax, x is an arbitrary (possibly empty) sequence of lowercase letters, no whitespaces allowed
> between { and |.

It might be better for x to be a sequence of operator symbols (and maybe
numbers), since most lexical tokens in OCaml are all symbols or all
characters, but this is probably a matter of taste.

> Another change I've committed recently is an update to the Typedtree representation, to bring it closer to the current
> state of the Parsetree, including attributes.  This makes it possible for external tools to process attributes in
> .cmt/.cmti files.  I've committed an example of a "mini-ocamldoc" based on this technique:
>
>
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/minidoc.ml?revision=HEAD&view=markup
>
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/testdoc.mli?revision=HEAD&view=markup 
>
>
>
> Leo: you mentioned that you're working on a revised ocamldoc.  Do you have plans to have it rely on attributes?

My plans, which are about half implemented, are for the compiler (or
ocamldoc) to be able to produce a ".cmd" file describing the
documentation for a module. Then tools can combine this file with a
".cmt" file to produce the actual documentation.

The ".cmd" file is kept separate from the ".cmt" to make it easier to do
things like providing multiple translations for documentation, creating
documentation not related to a source file, or using a single
documentation article for multiple source files.

While I think that comments are a good place for documentation, and will
primarily support the current ocamldoc format, it would be very simple
to write a "-ppx" that created a ".cmd" file from attributes. It would
also be very easy to write a tool that extracted a ".cmd" file from the
attributes in a ".cmt" file.

From lpw25 at cam.ac.uk  Tue Mar 26 19:58:31 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Tue, 26 Mar 2013 19:58:31 +0000
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <5151C7CE.7040500@lexifi.com> (Alain Frisch's message of "Tue, 26
 Mar 2013 17:07:42 +0100")
References: <87r4jh3nnj.fsf@kingston.cl.cam.ac.uk>
 <1625554563.3446096.1363346665809.JavaMail.root@lexifi.com>
 <CAPFanBG+2necpa3XvjQLhLiYM0rc1m9tpj=6yJ60i2GDaS3h-g@mail.gmail.com>
 <87sj3wojlp.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBFgNn1knLyafsAh6bxy5V_O--cyuvfUJ-ba-MBRfrKLmg@mail.gmail.com>
 <514ACFC1.5090705@lexifi.com> <87ppytm53s.fsf@kingston.cl.cam.ac.uk>
 <CAPFanBHi473eqdtW8hpoH1xk+buMjiRQ_xLgH3SiJOE1gu67ag@mail.gmail.com>
 <514C424A.6070905@lexifi.com> <51503841.7040708@lexifi.com>
 <87mwtrh8w9.fsf@kingston.cl.cam.ac.uk> <515187C8.2030109@lexifi.com>
 <201C3856-0344-47E0-A506-879068D2865C@ocamlpro.com>
 <515195A2.5020501@lexifi.com>
 <9A9E5F6A-A828-457F-9030-4AAA88B2B8C7@ocamlpro.com>
 <5151C7CE.7040500@lexifi.com>
Message-ID: <871ub26ihk.fsf@study.localdomain>

> This is rather minor (especially considering that other use cases are sufficient to justify "item" attributes on
> individual types), but isn't it possible to provide a custom function for a specific type instead of asking the
> extension to generate the function?

You can, but it is difficult to do it for mutually recursive types since the
functions will probably also have to be mutually recursive.

From info at gerd-stolpmann.de  Thu Mar 28 16:13:36 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Thu, 28 Mar 2013 17:13:36 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <51509C4D.9010509@lexifi.com> (from alain.frisch@lexifi.com on
 Mon Mar 25 19:49:49 2013)
Message-ID: <1364487216.14693.6@samsung>

Am 25.03.2013 19:49:49 schrieb(en) Alain Frisch:
> On 03/25/2013 03:13 PM, jathdr wrote:
>> Could we get a summary of the current syntax proposal? I've been
>> following along, but I'm a bit lost as to what has been discussed,
>> accepted, rejected, etc.
> 
> This file describes the current syntax proposal:
> 
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/extension_points.txt?revision=HEAD&view=markup

Two little comments:

  - So far, a begin/end pair can always be replaced by normal  
parentheses.
    The "keyword" rules do not allow it so far - when we have
    begin [@foo] ... end, why not also allow ([@foo] ...) ?

    (Currently, it's even possible to use begin/end and parentheses
    in a mixed way, like ( ... end - maybe also get rid of this
    asymmetry, as we are at syntax?)

  - Am I right that we get a new form of commenting out code blocks?

    (* {ignore| commented out text can almost contain anything |ignore}  
*)

    That would be helpful to comment out blocks that violate the lexing
    rules.



> 
>> This is probably a bit off topic, but while we're talking about
>> interval patterns: I discovered the other day that interval patterns
>> only work for chars, while I always assumed they also worked for
>> ints. Is there a reason why they don't?
> 
> Currently, range patterns for characters are expanded in the parser.  
> Doing so for integers as well could lead to huge or-patterns to be  
> processed by the rest of the compiler.  Supporting range patterns  
> directly in the compiler would add a little bit of extra complexity  
> for type-checking (exhaustiveness check) and code generation.  I  
> don't see any theoretical problem, though.
> 
> 
> -- Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From alain.frisch at lexifi.com  Thu Mar 28 21:54:09 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 28 Mar 2013 22:54:09 +0100
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <1364487216.14693.6@samsung>
References: <1364487216.14693.6@samsung>
Message-ID: <5154BC01.1060401@lexifi.com>

On 3/28/2013 5:13 PM, Gerd Stolpmann wrote:
>   - So far, a begin/end pair can always be replaced by normal parentheses.
>     The "keyword" rules do not allow it so far - when we have
>     begin [@foo] ... end, why not also allow ([@foo] ...) ?

This (and also (%foo ...)) used to be recognized, but there has been 
some resistance to it.  I don't have a strong opinion on this topic and 
it will always be possible to add more syntax if the current one turns 
out to be inconvenient in some cases.

>     (Currently, it's even possible to use begin/end and parentheses
>     in a mixed way, like ( ... end - maybe also get rid of this
>     asymmetry, as we are at syntax?)

I don't think that this mixed syntax is actually accepted.


>   - Am I right that we get a new form of commenting out code blocks?
>
>     (* {ignore| commented out text can almost contain anything |ignore} *)
>
>     That would be helpful to comment out blocks that violate the lexing
>     rules.

It is not currently supported in the branch (quoted strings are not 
recognized within comments), but this is a bug.  You're right that it 
will allow to embed non-lexable data (even binary, if you wish) in comments.

-- Alain

From lpw25 at cam.ac.uk  Thu Mar 28 23:09:19 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: Thu, 28 Mar 2013 23:09:19 +0000
Subject: [wg-camlp4] Changes to the parsetree
In-Reply-To: <5154BC01.1060401@lexifi.com> (Alain Frisch's message of "Thu, 28
 Mar 2013 22:54:09 +0100")
References: <1364487216.14693.6@samsung> <5154BC01.1060401@lexifi.com>
Message-ID: <87ehezjf4w.fsf@study.localdomain>

>>   - So far, a begin/end pair can always be replaced by normal parentheses.
>>     The "keyword" rules do not allow it so far - when we have
>>     begin [@foo] ... end, why not also allow ([@foo] ...) ?
>
> This (and also (%foo ...)) used to be recognized, but there has been some resistance to it.  I don't have a strong
> opinion on this topic and it will always be possible to add more syntax if the current one turns out to be inconvenient
> in some cases.

Note that my objection was to "(% foo ...)", I have no problem with
"([@foo ...] ...)".

From alain.frisch at lexifi.com  Fri Mar 29 13:04:09 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 29 Mar 2013 14:04:09 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5107F74E.8010603@frisch.fr>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr>
Message-ID: <51559149.2020900@lexifi.com>

On 01/29/2013 05:22 PM, Alain Frisch wrote:
> On 01/29/2013 04:37 PM, Xavier Clerc wrote:
>> However, during development,
>> it was a time-saver to be able to easily express and experiment new
>> ideas by manipulating "bits of the actual language". Camlp4 was kind
>> enough to translate them for me into AST code which I had to check.
>
> What about having a tool (either stand-alone or part of the compilers)
> which dumps the Parsetree representation of some code fragment in as
> textual OCaml values (probably without locations)?
>
> So you can type your "model" as source code and obtain quickly the
> Parsetree representation, copy/paste it into a nice pattern and replace
> some parts with variables.

I've hacked a quick implementation of such a tool, reusing the generic 
value printer from the toplevel:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/tools/dump_ast.ml?revision=HEAD&view=markup

It parses either command-line arguments (currently, as types, 
expressions or patterns) or external .ml/.mli files, and shows the 
internal Parsetree representation.  By default, location and empty 
attribute fields are removed (they can be restored with command-line 
flags: -locs and -emptyattrs).

Examples:

$ ./ocamlast -w 50 -e "1 + x [@attr] * 2"
{pexp_desc =
   Pexp_apply
    ({pexp_desc = Pexp_ident {txt = Lident "*"}},
    [("",
      {pexp_desc =
        Pexp_apply
         ({pexp_desc =
            Pexp_ident {txt = Lident "+"}},
         [("",
           {pexp_desc =
             Pexp_constant (Const_int 1)});
          ("",
           {pexp_desc =
             Pexp_ident {txt = Lident "x"}})]);
       pexp_attributes =
        [("attr",
          {pexp_desc =
            Pexp_construct ({txt = Lident "()"},
             None, false)})]});
     ("",
      {pexp_desc = Pexp_constant (Const_int 2)})])}


$ ./ocamlast -w 50 -emptyattrs -t "int list * string"
{ptyp_desc =
   Ptyp_tuple
    [{ptyp_desc =
       Ptyp_constr ({txt = Lident "list"},
        [{ptyp_desc =
           Ptyp_constr ({txt = Lident "int"}, []);
          ptyp_attributes = []}]);
      ptyp_attributes = []};
     {ptyp_desc =
       Ptyp_constr ({txt = Lident "string"}, []);
      ptyp_attributes = []}];
  ptyp_attributes = []}


This should should simplify the learning curve of the Parsetree, and 
even allow quick copy/paste to write patterns/expressions on Parsetree. 
  That said, creating Parsetree fragments manually is quite tedious, and 
I've created a module to make this easier:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/parsing/ast_helper.mli?revision=HEAD&view=markup

Currently, this module exposes "builder functions" which are very close 
to Parsetree constructors/records (making locations and attributes 
optional), but one can easily improve its interface (either by changing 
the existing functions, e.g. to use optional and labelled arguments, or 
by exposing other function to cover common cases).


Alain

From gabriel.scherer at gmail.com  Fri Mar 29 13:46:47 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 29 Mar 2013 14:46:47 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <51559149.2020900@lexifi.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
Message-ID: <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>

Would it be possible to use the extension mechanism itself for lightweight
quasiquotations?

I did a small experiment with -ppx recently (
http://gallium.inria.fr/blog/a-library-to-record-ocaml-backtraces/smartcatch_ppx.ml,
as a contribution to Jacques-Henri Jourdan's work on
http://gallium.inria.fr/blog/a-library-to-record-ocaml-backtraces/ ), and
frankly the absence of quasiquotations felt like a pain in the ass. Compare
the camlp4 part of the relevant code:

  let add_debug_expr _loc patvar e =
    <:expr<
        let _ = ExceptionHandling.register $lid:patvar$ in
        $e$
    >>

with the Ast_rewriter equivalent (the recommended solution alongside -ppx
right now):

let add_register patvar body =
  let open Ast_mapper in
  let register_fun = Location.mknoloc (Longident.parse
"ExceptionHandling.register") in
  (* let _ = <register_fun> <patvar> in <body> *)
  E.(let_ Nonrecursive
       [P.any (), apply (ident register_fun)  ["", ident patvar]]
       body)

There is a gap of readability, maintainability but also writability between
the two approaches. I suspect that the Ast_mapper.E domain-specific
language could be improved to reduce it, but I'm not sure quasiquotations
are not the best long-term solution. But maybe we can have quasiquotations
with the current extension mechanism?

let add_register patvar body =
  [%quote
    let _ = ExceptionHandling.register [%anti patvar] in [%anti body]
  ]


I'm rather interested in getting ideas of how this actually would work and
fleshing it out.

(Note that the problem here is to have a convenient way to write little
pieces of OCaml AST when you program AST-to-AST filters of any kind. This
is a restricted use case as compared to Camlp4 quasiquotations conventions,
that offer facilities for antiquotations inside foreign quotations
implementing a completely different syntax. I used the latter in Macaque,
and they are exposed to end-users, so user-friendliness of the
antiquotation syntax was important. Here it's only for extension *writers*,
so it's ok if it's *a bit* heavy.)

On Fri, Mar 29, 2013 at 2:04 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 01/29/2013 05:22 PM, Alain Frisch wrote:
>
>> On 01/29/2013 04:37 PM, Xavier Clerc wrote:
>>
>>> However, during development,
>>> it was a time-saver to be able to easily express and experiment new
>>> ideas by manipulating "bits of the actual language". Camlp4 was kind
>>> enough to translate them for me into AST code which I had to check.
>>>
>>
>> What about having a tool (either stand-alone or part of the compilers)
>> which dumps the Parsetree representation of some code fragment in as
>> textual OCaml values (probably without locations)?
>>
>> So you can type your "model" as source code and obtain quickly the
>> Parsetree representation, copy/paste it into a nice pattern and replace
>> some parts with variables.
>>
>
> I've hacked a quick implementation of such a tool, reusing the generic
> value printer from the toplevel:
>
> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
> extension_points/tools/dump_**ast.ml?revision=HEAD&view=**markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/tools/dump_ast.ml?revision=HEAD&view=markup>
>
> It parses either command-line arguments (currently, as types, expressions
> or patterns) or external .ml/.mli files, and shows the internal Parsetree
> representation.  By default, location and empty attribute fields are
> removed (they can be restored with command-line flags: -locs and
> -emptyattrs).
>
> Examples:
>
> $ ./ocamlast -w 50 -e "1 + x [@attr] * 2"
> {pexp_desc =
>   Pexp_apply
>    ({pexp_desc = Pexp_ident {txt = Lident "*"}},
>    [("",
>      {pexp_desc =
>        Pexp_apply
>         ({pexp_desc =
>            Pexp_ident {txt = Lident "+"}},
>         [("",
>           {pexp_desc =
>             Pexp_constant (Const_int 1)});
>          ("",
>           {pexp_desc =
>             Pexp_ident {txt = Lident "x"}})]);
>       pexp_attributes =
>        [("attr",
>          {pexp_desc =
>            Pexp_construct ({txt = Lident "()"},
>             None, false)})]});
>     ("",
>      {pexp_desc = Pexp_constant (Const_int 2)})])}
>
>
> $ ./ocamlast -w 50 -emptyattrs -t "int list * string"
> {ptyp_desc =
>   Ptyp_tuple
>    [{ptyp_desc =
>       Ptyp_constr ({txt = Lident "list"},
>        [{ptyp_desc =
>           Ptyp_constr ({txt = Lident "int"}, []);
>          ptyp_attributes = []}]);
>      ptyp_attributes = []};
>     {ptyp_desc =
>       Ptyp_constr ({txt = Lident "string"}, []);
>      ptyp_attributes = []}];
>  ptyp_attributes = []}
>
>
> This should should simplify the learning curve of the Parsetree, and even
> allow quick copy/paste to write patterns/expressions on Parsetree.  That
> said, creating Parsetree fragments manually is quite tedious, and I've
> created a module to make this easier:
>
> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
> extension_points/parsing/ast_**helper.mli?revision=HEAD&view=**markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/parsing/ast_helper.mli?revision=HEAD&view=markup>
>
> Currently, this module exposes "builder functions" which are very close to
> Parsetree constructors/records (making locations and attributes optional),
> but one can easily improve its interface (either by changing the existing
> functions, e.g. to use optional and labelled arguments, or by exposing
> other function to cover common cases).
>
>
>
> Alain
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/467e1def/attachment.html>

From hongboz at seas.upenn.edu  Fri Mar 29 14:05:00 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Fri, 29 Mar 2013 10:05:00 -0400
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
Message-ID: <CANcqPu47Dtw90bn_3G24-GcDcrz83eGSqZ5Ac53U+kjb6CGJVA@mail.gmail.com>

Dear all,
    I just submitted a paper about the metaprogramming in OCaml, it's
available here:http://www.seas.upenn.edu/~hongboz/main.pdf. Hope you could
find something interesting.
    Thanks!


On Fri, Mar 29, 2013 at 9:46 AM, Gabriel Scherer
<gabriel.scherer at gmail.com>wrote:

> Would it be possible to use the extension mechanism itself for lightweight
> quasiquotations?
>
> I did a small experiment with -ppx recently (
> http://gallium.inria.fr/blog/a-library-to-record-ocaml-backtraces/smartcatch_ppx.ml,
> as a contribution to Jacques-Henri Jourdan's work on
> http://gallium.inria.fr/blog/a-library-to-record-ocaml-backtraces/ ), and
> frankly the absence of quasiquotations felt like a pain in the ass. Compare
> the camlp4 part of the relevant code:
>
>   let add_debug_expr _loc patvar e =
>     <:expr<
>         let _ = ExceptionHandling.register $lid:patvar$ in
>         $e$
>     >>
>
> with the Ast_rewriter equivalent (the recommended solution alongside -ppx
> right now):
>
> let add_register patvar body =
>   let open Ast_mapper in
>   let register_fun = Location.mknoloc (Longident.parse "ExceptionHandling.register") in
>   (* let _ = <register_fun> <patvar> in <body> *)
>   E.(let_ Nonrecursive
>        [P.any (), apply (ident register_fun)  ["", ident patvar]]
>        body)
>
> There is a gap of readability, maintainability but also writability
> between the two approaches. I suspect that the Ast_mapper.E domain-specific
> language could be improved to reduce it, but I'm not sure quasiquotations
> are not the best long-term solution. But maybe we can have quasiquotations
> with the current extension mechanism?
>
> let add_register patvar body =
>   [%quote
>     let _ = ExceptionHandling.register [%anti patvar] in [%anti body]
>   ]
>
>
> I'm rather interested in getting ideas of how this actually would work and
> fleshing it out.
>
> (Note that the problem here is to have a convenient way to write little
> pieces of OCaml AST when you program AST-to-AST filters of any kind. This
> is a restricted use case as compared to Camlp4 quasiquotations conventions,
> that offer facilities for antiquotations inside foreign quotations
> implementing a completely different syntax. I used the latter in Macaque,
> and they are exposed to end-users, so user-friendliness of the
> antiquotation syntax was important. Here it's only for extension *writers*,
> so it's ok if it's *a bit* heavy.)
>
> On Fri, Mar 29, 2013 at 2:04 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:
>
>> On 01/29/2013 05:22 PM, Alain Frisch wrote:
>>
>>> On 01/29/2013 04:37 PM, Xavier Clerc wrote:
>>>
>>>> However, during development,
>>>> it was a time-saver to be able to easily express and experiment new
>>>> ideas by manipulating "bits of the actual language". Camlp4 was kind
>>>> enough to translate them for me into AST code which I had to check.
>>>>
>>>
>>> What about having a tool (either stand-alone or part of the compilers)
>>> which dumps the Parsetree representation of some code fragment in as
>>> textual OCaml values (probably without locations)?
>>>
>>> So you can type your "model" as source code and obtain quickly the
>>> Parsetree representation, copy/paste it into a nice pattern and replace
>>> some parts with variables.
>>>
>>
>> I've hacked a quick implementation of such a tool, reusing the generic
>> value printer from the toplevel:
>>
>> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
>> extension_points/tools/dump_**ast.ml?revision=HEAD&view=**markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/tools/dump_ast.ml?revision=HEAD&view=markup>
>>
>> It parses either command-line arguments (currently, as types, expressions
>> or patterns) or external .ml/.mli files, and shows the internal Parsetree
>> representation.  By default, location and empty attribute fields are
>> removed (they can be restored with command-line flags: -locs and
>> -emptyattrs).
>>
>> Examples:
>>
>> $ ./ocamlast -w 50 -e "1 + x [@attr] * 2"
>> {pexp_desc =
>>   Pexp_apply
>>    ({pexp_desc = Pexp_ident {txt = Lident "*"}},
>>    [("",
>>      {pexp_desc =
>>        Pexp_apply
>>         ({pexp_desc =
>>            Pexp_ident {txt = Lident "+"}},
>>         [("",
>>           {pexp_desc =
>>             Pexp_constant (Const_int 1)});
>>          ("",
>>           {pexp_desc =
>>             Pexp_ident {txt = Lident "x"}})]);
>>       pexp_attributes =
>>        [("attr",
>>          {pexp_desc =
>>            Pexp_construct ({txt = Lident "()"},
>>             None, false)})]});
>>     ("",
>>      {pexp_desc = Pexp_constant (Const_int 2)})])}
>>
>>
>> $ ./ocamlast -w 50 -emptyattrs -t "int list * string"
>> {ptyp_desc =
>>   Ptyp_tuple
>>    [{ptyp_desc =
>>       Ptyp_constr ({txt = Lident "list"},
>>        [{ptyp_desc =
>>           Ptyp_constr ({txt = Lident "int"}, []);
>>          ptyp_attributes = []}]);
>>      ptyp_attributes = []};
>>     {ptyp_desc =
>>       Ptyp_constr ({txt = Lident "string"}, []);
>>      ptyp_attributes = []}];
>>  ptyp_attributes = []}
>>
>>
>> This should should simplify the learning curve of the Parsetree, and even
>> allow quick copy/paste to write patterns/expressions on Parsetree.  That
>> said, creating Parsetree fragments manually is quite tedious, and I've
>> created a module to make this easier:
>>
>> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
>> extension_points/parsing/ast_**helper.mli?revision=HEAD&view=**markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/parsing/ast_helper.mli?revision=HEAD&view=markup>
>>
>> Currently, this module exposes "builder functions" which are very close
>> to Parsetree constructors/records (making locations and attributes
>> optional), but one can easily improve its interface (either by changing the
>> existing functions, e.g. to use optional and labelled arguments, or by
>> exposing other function to cover common cases).
>>
>>
>>
>> Alain
>> ______________________________**_________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>>
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/4606c9c0/attachment-0001.html>

From alain.frisch at lexifi.com  Fri Mar 29 14:35:03 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 29 Mar 2013 15:35:03 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
Message-ID: <5155A697.7050302@lexifi.com>

On 03/29/2013 02:46 PM, Gabriel Scherer wrote:
> Would it be possible to use the extension mechanism itself for
> lightweight quasiquotations?
>
> I did a small experiment with -ppx recently (
> http://gallium.inria.fr/blog/a-library-to-record-ocaml-backtraces/smartcatch_ppx.ml,
> as a contribution to Jacques-Henri Jourdan's work on
> http://gallium.inria.fr/blog/a-library-to-record-ocaml-backtraces/ ),
> and frankly the absence of quasiquotations felt like a pain in the ass.
> Compare the camlp4 part of the relevant code:
>
>    let add_debug_expr _loc patvar e =
>      <:expr<
>          let _ = ExceptionHandling.register $lid:patvar$ in
>          $e$
>      >>
>
> with the Ast_rewriter equivalent (the recommended solution alongside
> -ppx right now):
>
> let add_register patvar body =
>    let open Ast_mapper in
>    let register_fun = Location.mknoloc (Longident.parse "ExceptionHandling.register") in
>    (* let _ = <register_fun> <patvar> in <body> *)
>    E.(let_ Nonrecursive
>         [P.any (), apply (ident register_fun)  ["", ident patvar]]
>         body)


I'd write it as:


let add_register e body =
   let_in [pany, app (evar "ExceptionHandling.register") [e]] body


which does not look so bad.  This relies on the following definitions, 
which could go e.g. in a Ast_helper.Convenience module:

let evar s = E.ident (mknoloc (Longident.parse s))
let let_in l body = E.let_ Nonrecursive l b
    (* maybe with an optional argument for the recursive case *)
let pany = P.any ()
let app f args = apply f (List.map (fun a -> "", a) args)



The rest of the code is interesting as well:

Camlp4:

   value rec map_handler =
     let patvar = "__exn" in
     fun
     [ <:match_case at _loc< $m1$ | $m2$ >> ->
         <:match_case< $map_handler m1$ | $map_handler m2$ >>
     | <:match_case at _loc< $p$ when $w$ -> $e$ >> ->
         <:match_case at _loc<
           ($p$ as $lid:patvar$) when $w$ -> $add_debug_expr _loc patvar 
e$ >>
     | m -> m ];

   value filter = object
     inherit Ast.map as super;
     method expr = fun
     [ <:expr at _loc< try $e$ with [ $h$ ] >> ->
       <:expr< try $e$ with [ $map_handler h$ ] >>
     | x -> super#expr x ];
   end;


PPX:

   method expr e =
     let e = super#expr e in
     { e with pexp_desc =
         match e.pexp_desc with
           | Pexp_try (body, handler) ->
             let instrument_case (pat, body) =
               let patvar_str =  "__exn" in
               let patvar = Location.mknoloc (Longident.parse patvar_str) in
               let pat = { pat with ppat_desc =
                 Ppat_alias (pat, Location.mknoloc patvar_str) } in
               (pat, add_register patvar body) in
             Pexp_try (body, List.map instrument_case handler)
           | other -> other
     }


This might be a matter of taste, but I prefer the PPX version, which I 
can read only by knowing about the Parsetree (which is required anyway 
to write any such code), a normal OCaml library.  The quotation and 
anti-quotations in the Camlp4 version look very noisy, and it relies on 
a syntax I'm not familiar with (revised syntax) and syntactic extensions 
(quotations/antiquotations), with their own conventions 
("<:match_case<", $lid:$).  Since I'm not writing extensions every day, 
I really prefer having to learn how to use simple OCaml data types and 
libraries (Parsetree, Ast_helper) rather than to learn new syntax and 
new concepts.  Also, I'd write the code above as:

(* --> in Ast_helper.Convenience *)
let palias p x = P.alias p (mknoloc x)
let evar s = E.ident (mknoloc (Longident.parse s))
...


   method expr e =
     let e = super#expr e in
     match e.pexp_desc with
     | Pexp_try (body, handler) ->
         let instrument_case (pat, body) =
           (palias pat "__exn", add_register (evar "__exn") body)
         in
         {e with pexp_desc = Pexp_try (body, List.map instrument_case 
handler)}
     | e -> e

> But maybe we
> can have quasiquotations with the current extension mechanism?
>
> let add_register patvar body =
>    [%quote
>      let _ = ExceptionHandling.register [%anti patvar] in [%anti body]
>    ]

Implementing this "quote" expander is not very difficult, just a little 
bit tedious (and this can be automated by parsing the definition of the 
Parsetree).  Note that nothing forces to use [%anti x] for 
antiquotations.  We could very well decide on a more lightweight 
convention, like prefixing identifiers, or using a dedicated operator:


     [%quote
       let _ = ExceptionHandling.register __patvar in __body
     ]

     [%quote
       let _ = ExceptionHandling.register !!patvar in !!body
     ]


But this approach would work nicely only for writing expressions or 
patterns on OCaml expressions, not on other syntactic categories 
(because the content of an extension node is an expression).  The 
problem is that AST-manipulating code tend to require to work a lot with 
many different categories (like "match cases") even to build expressions.

Quasi-quotations would be useful if the expanders had to generate big 
fragments of mostly static code, with only a few "dynamic" placeholders. 
  In my experience, this is rarely the case: you assemble the resulting 
OCaml code by combining many small fragments generated programmatically. 
  For these cases, a nice library of "AST constructors" seems better to me.



-- Alain

From gabriel.scherer at gmail.com  Fri Mar 29 15:12:42 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 29 Mar 2013 16:12:42 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5155A697.7050302@lexifi.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
 <5155A697.7050302@lexifi.com>
Message-ID: <CAPFanBFhAkfqJ9DiyRuM6D0HBetFy2KtUyQAj1VmEJM3tj4rAw@mail.gmail.com>

On Fri, Mar 29, 2013 at 3:35 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> I'd write it as:
>
> let add_register e body =
>   let_in [pany, app (evar "ExceptionHandling.register") [e]] body
>
> which does not look so bad.  This relies on the following definitions,
> which could go e.g. in a Ast_helper.Convenience module:
>
> let evar s = E.ident (mknoloc (Longident.parse s))
> let let_in l body = E.let_ Nonrecursive l b
>    (* maybe with an optional argument for the recursive case *)
> let pany = P.any ()
> let app f args = apply f (List.map (fun a -> "", a) args)
>

That is better indeed. I can only encourage you to add these kind of
conveniences in the E submodule (or maybe somewhere else) as usage suggests
that they are useful. I originally planned to report on that through proper
(?) channels, but that got lost in the noise of things to do, sorry.

I'm still not sure that quasi-quotations are not a better approach, because
the problem here is that the user has to learn a new interface to describe
code fragments instead of using the syntax he's already familiar with. You
have convincingly argued that the OCaml syntax cannot always be used to
describe AST fragments (even in Camlp4, if you use the classic syntax in
quotations some ambiguities force you to revert to plain AST constructors
from time to time), and I hear the argument about fitting lots of small
pieces together instead of inserting large chunks of code. I still have the
intuition that those arguments are more relevant to the expert extension
writer, and that for a large set of use cases that concern *simple*
extensions and beginner extension writers, quasiquotations are still
noticeably easier to use. That this feeling appears to be reflected by
Xavier Clerc, which is one of the other early-triers of -ppx, gives me a
hint that it may have some objective qualities.


>
> The rest of the code is interesting as well:
>
> Camlp4:
>
>   value rec map_handler =
>     let patvar = "__exn" in
>     fun
>     [ <:match_case at _loc< $m1$ | $m2$ >> ->
>         <:match_case< $map_handler m1$ | $map_handler m2$ >>
>     | <:match_case at _loc< $p$ when $w$ -> $e$ >> ->
>         <:match_case at _loc<
>           ($p$ as $lid:patvar$) when $w$ -> $add_debug_expr _loc patvar e$
> >>
>     | m -> m ];
>
>   value filter = object
>     inherit Ast.map as super;
>     method expr = fun
>     [ <:expr at _loc< try $e$ with [ $h$ ] >> ->
>       <:expr< try $e$ with [ $map_handler h$ ] >>
>     | x -> super#expr x ];
>   end;
>
>
> PPX:
>
>   method expr e =
>     let e = super#expr e in
>     { e with pexp_desc =
>         match e.pexp_desc with
>           | Pexp_try (body, handler) ->
>             let instrument_case (pat, body) =
>               let patvar_str =  "__exn" in
>               let patvar = Location.mknoloc (Longident.parse patvar_str) in
>               let pat = { pat with ppat_desc =
>                 Ppat_alias (pat, Location.mknoloc patvar_str) } in
>               (pat, add_register patvar body) in
>             Pexp_try (body, List.map instrument_case handler)
>           | other -> other
>     }
>
>
> This might be a matter of taste, but I prefer the PPX version, which I can
> read only by knowing about the Parsetree (which is required anyway to write
> any such code), a normal OCaml library.  The quotation and anti-quotations
> in the Camlp4 version look very noisy, and it relies on a syntax I'm not
> familiar with (revised syntax) and syntactic extensions
> (quotations/antiquotations), with their own conventions ("<:match_case<",
> $lid:$).  Since I'm not writing extensions every day, I really prefer
> having to learn how to use simple OCaml data types and libraries
> (Parsetree, Ast_helper) rather than to learn new syntax and new concepts.
>  Also, I'd write the code above as:
>
> (* --> in Ast_helper.Convenience *)
> let palias p x = P.alias p (mknoloc x)
> let evar s = E.ident (mknoloc (Longident.parse s))
> ...
>
>   method expr e =
>     let e = super#expr e in
>     match e.pexp_desc with
>     | Pexp_try (body, handler) ->
>         let instrument_case (pat, body) =
>           (palias pat "__exn", add_register (evar "__exn") body)
>         in
>         {e with pexp_desc = Pexp_try (body, List.map instrument_case
> handler)}
>     | e -> e



I used this example specifically to discuss the quasiquotation feature, not
as a general comparison of -ppx and Camlp4's extension writing facilities.
I do agree that, in this example, the AST traversal framework of -ppx is in
fact better than Camlp4's. This is related to the fact that the AST
structure is simpler and more closely reflect the way I logically think
about pieces of OCaml code: match only takes a (pattern * expr) list
instead of being a recursive expression of nested branches. That's a plus
for ppx's design (and I like your approach of improving the upstream AST
description to make it even better, at least while we don't have extension
writers with code that breaks when we change it).

That said, I think you're also a bit quick to jump to conclusions here. The
question of whether the extension uses classical or revised syntax is
largely orthogonal to the design of the extension itself (except
occasionally with quotation ambiguities concerns), and I could have used
the classic syntax to write the Camlp4 extension just as well. What
happened in practice is that I looked at the set of old Camlp4 extensions I
had lying around, copy-pasted the code of the one that looked most closely
like what I was looking for (traversing the "match" structure), and spent
the rest of the time wondering which output code to produce (the
"add_register" function I quoted, plus the pattern-alias stuff).

So the bottleneck in practice was in the code production part. It was just
as true for the -ppx version (the traversal part was easy to write), but my
experience producing code in the -ppx version was much less gratifying. Of
course, it was my first use of your Ast_mapper.E interface, so there was
some learning cost to take into account. But then I had type errors, I had
to look at the documentation again, and it was a bit painful. Finally, I
only handle Camlp4 extensions about once a year, so I have time to forget
most details about how they work, in particular I *always* look at the
documentation for the concrete AST constructor names in the (rare) cases
where I need them. I found that there was no such re-learning curve with
quasiquotations, they just work out of the box -- once you've been
rebrained, once and forall, to see those <:stuff< >> as structured code
rather than ASCII noise.

I think the small tool you just introduced (translating OCaml code into
AST-building ocaml code) may have made this "code production" part easier,
but I'm not fond of the idea of pasting auto-generated code in my own code.
In any case, it would be better if it produced code using the nice
high-level interface, rather than the hard-to-read AST definitions, but
that may be much more painful to implement so I'm not really asking for
that.



>  But maybe we
>> can have quasiquotations with the current extension mechanism?
>>
>> let add_register patvar body =
>>    [%quote
>>      let _ = ExceptionHandling.register [%anti patvar] in [%anti body]
>>    ]
>>
>
> Implementing this "quote" expander is not very difficult, just a little
> bit tedious (and this can be automated by parsing the definition of the
> Parsetree).


Isn't that essentially the same thing as the tool you implemented for
Xavier above? (Can you reuse code between both?)
If I understand correctly, this is also the "Meta" operation of Camlp4,
turning the AST for the expression <foo> into the AST for the OCaml
expression representing the AST for <foo>. When you say "automated by
parsing the definition of the Parsetree", do you have a realistic design in
mind for such boilerplate code generators, or do you plan in practice to
implement them by hand?

Note that nothing forces to use [%anti x] for antiquotations.  We could
> very well decide on a more lightweight convention, like prefixing
> identifiers, or using a dedicated operator:


>     [%quote
>       let _ = ExceptionHandling.register __patvar in __body
>     ]
>
>     [%quote
>       let _ = ExceptionHandling.register !!patvar in !!body
>     ]
>

Same old battle-horse: I dislike the idea that [%quote ] would change the
meaning of syntactically valid OCaml code such as __patvar or !!patvar. I
think I would with [%anti ] for now, or maybe just [%a ] if need be -- in
any case this is not part of the eventually-crowded extension namespace as
they really are only markers to be rewritten by the implementation of
%quote.


> But this approach would work nicely only for writing expressions or
> patterns on OCaml expressions, not on other syntactic categories (because
> the content of an extension node is an expression).  The problem is that
> AST-manipulating code tend to require to work a lot with many different
> categories (like "match cases") even to build expressions.
>

That's a good point.


> Quasi-quotations would be useful if the expanders had to generate big
> fragments of mostly static code, with only a few "dynamic" placeholders.
>  In my experience, this is rarely the case: you assemble the resulting
> OCaml code by combining many small fragments generated programmatically.
>  For these cases, a nice library of "AST constructors" seems better to me.
>

Maybe we need both, but if we eventually get nice constructor names for the
AST definitions (I know that doesn't depend on you) I think if we only had
time/energy/maintenance for two among (1) AST definitions (2) AST
combinator library and (3) quasiquotation mechanism, I would suggest we
keep (1) and (3) rather than (1) and (2).


>
>
>
> -- Alain
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/2be180d9/attachment-0001.html>

From hongboz at seas.upenn.edu  Fri Mar 29 15:33:06 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Fri, 29 Mar 2013 11:33:06 -0400
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <CAPFanBFhAkfqJ9DiyRuM6D0HBetFy2KtUyQAj1VmEJM3tj4rAw@mail.gmail.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
 <5155A697.7050302@lexifi.com>
 <CAPFanBFhAkfqJ9DiyRuM6D0HBetFy2KtUyQAj1VmEJM3tj4rAw@mail.gmail.com>
Message-ID: <CANcqPu4iJ9FRXUxu3r=999GyrnyN90hOenVwrdyqrhCSijY94A@mail.gmail.com>

Writing metaprogramming either in quasiquotation or combinator is fine for
me, the problem is the
latter approach does not work well with IDE and it's hard to read (we read
code more than write)
About implementation, my experience is that quotation is very tedious but
not difficult, antiquotation is not easy to get correct. about map_handler,
it can be improved in Fan
let rec map_handler =
  let patvar = "__exn" in with match_case (* set the default language*)
   fun
   [ {| $m1 $ $m2 |} ->
     {| $(map_hander m1) | $(map_handler m2)  |}
   | {| $p when $w -> $e |} ->
     {| ($p as $lid:patvar) when $w -> $(add_debug_expr _loc patvar e)  |}
   | m -> m ];;

On Fri, Mar 29, 2013 at 11:12 AM, Gabriel Scherer <gabriel.scherer at gmail.com
> wrote:

>
>
> On Fri, Mar 29, 2013 at 3:35 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:
>
>> I'd write it as:
>>
>> let add_register e body =
>>   let_in [pany, app (evar "ExceptionHandling.register") [e]] body
>>
>> which does not look so bad.  This relies on the following definitions,
>> which could go e.g. in a Ast_helper.Convenience module:
>>
>> let evar s = E.ident (mknoloc (Longident.parse s))
>> let let_in l body = E.let_ Nonrecursive l b
>>    (* maybe with an optional argument for the recursive case *)
>> let pany = P.any ()
>> let app f args = apply f (List.map (fun a -> "", a) args)
>>
>
> That is better indeed. I can only encourage you to add these kind of
> conveniences in the E submodule (or maybe somewhere else) as usage suggests
> that they are useful. I originally planned to report on that through proper
> (?) channels, but that got lost in the noise of things to do, sorry.
>
> I'm still not sure that quasi-quotations are not a better approach,
> because the problem here is that the user has to learn a new interface to
> describe code fragments instead of using the syntax he's already familiar
> with. You have convincingly argued that the OCaml syntax cannot always be
> used to describe AST fragments (even in Camlp4, if you use the classic
> syntax in quotations some ambiguities force you to revert to plain AST
> constructors from time to time), and I hear the argument about fitting lots
> of small pieces together instead of inserting large chunks of code. I still
> have the intuition that those arguments are more relevant to the expert
> extension writer, and that for a large set of use cases that concern
> *simple* extensions and beginner extension writers, quasiquotations are
> still noticeably easier to use. That this feeling appears to be reflected
> by Xavier Clerc, which is one of the other early-triers of -ppx, gives me a
> hint that it may have some objective qualities.
>
>
>>
>> The rest of the code is interesting as well:
>>
>> Camlp4:
>>
>>   value rec map_handler =
>>     let patvar = "__exn" in
>>     fun
>>     [ <:match_case at _loc< $m1$ | $m2$ >> ->
>>         <:match_case< $map_handler m1$ | $map_handler m2$ >>
>>     | <:match_case at _loc< $p$ when $w$ -> $e$ >> ->
>>         <:match_case at _loc<
>>           ($p$ as $lid:patvar$) when $w$ -> $add_debug_expr _loc patvar
>> e$ >>
>>     | m -> m ];
>>
>>   value filter = object
>>     inherit Ast.map as super;
>>     method expr = fun
>>     [ <:expr at _loc< try $e$ with [ $h$ ] >> ->
>>       <:expr< try $e$ with [ $map_handler h$ ] >>
>>     | x -> super#expr x ];
>>   end;
>>
>>
>> PPX:
>>
>>   method expr e =
>>     let e = super#expr e in
>>     { e with pexp_desc =
>>         match e.pexp_desc with
>>           | Pexp_try (body, handler) ->
>>             let instrument_case (pat, body) =
>>               let patvar_str =  "__exn" in
>>               let patvar = Location.mknoloc (Longident.parse patvar_str)
>> in
>>               let pat = { pat with ppat_desc =
>>                 Ppat_alias (pat, Location.mknoloc patvar_str) } in
>>               (pat, add_register patvar body) in
>>             Pexp_try (body, List.map instrument_case handler)
>>           | other -> other
>>     }
>>
>>
>> This might be a matter of taste, but I prefer the PPX version, which I
>> can read only by knowing about the Parsetree (which is required anyway to
>> write any such code), a normal OCaml library.  The quotation and
>> anti-quotations in the Camlp4 version look very noisy, and it relies on a
>> syntax I'm not familiar with (revised syntax) and syntactic extensions
>> (quotations/antiquotations), with their own conventions ("<:match_case<",
>> $lid:$).  Since I'm not writing extensions every day, I really prefer
>> having to learn how to use simple OCaml data types and libraries
>> (Parsetree, Ast_helper) rather than to learn new syntax and new concepts.
>>  Also, I'd write the code above as:
>>
>> (* --> in Ast_helper.Convenience *)
>> let palias p x = P.alias p (mknoloc x)
>> let evar s = E.ident (mknoloc (Longident.parse s))
>> ...
>>
>>   method expr e =
>>     let e = super#expr e in
>>     match e.pexp_desc with
>>     | Pexp_try (body, handler) ->
>>         let instrument_case (pat, body) =
>>           (palias pat "__exn", add_register (evar "__exn") body)
>>         in
>>         {e with pexp_desc = Pexp_try (body, List.map instrument_case
>> handler)}
>>     | e -> e
>
>
>
> I used this example specifically to discuss the quasiquotation feature,
> not as a general comparison of -ppx and Camlp4's extension writing
> facilities. I do agree that, in this example, the AST traversal framework
> of -ppx is in fact better than Camlp4's. This is related to the fact that
> the AST structure is simpler and more closely reflect the way I logically
> think about pieces of OCaml code: match only takes a (pattern * expr) list
> instead of being a recursive expression of nested branches. That's a plus
> for ppx's design (and I like your approach of improving the upstream AST
> description to make it even better, at least while we don't have extension
> writers with code that breaks when we change it).
>
> That said, I think you're also a bit quick to jump to conclusions here.
> The question of whether the extension uses classical or revised syntax is
> largely orthogonal to the design of the extension itself (except
> occasionally with quotation ambiguities concerns), and I could have used
> the classic syntax to write the Camlp4 extension just as well. What
> happened in practice is that I looked at the set of old Camlp4 extensions I
> had lying around, copy-pasted the code of the one that looked most closely
> like what I was looking for (traversing the "match" structure), and spent
> the rest of the time wondering which output code to produce (the
> "add_register" function I quoted, plus the pattern-alias stuff).
>
> So the bottleneck in practice was in the code production part. It was just
> as true for the -ppx version (the traversal part was easy to write), but my
> experience producing code in the -ppx version was much less gratifying. Of
> course, it was my first use of your Ast_mapper.E interface, so there was
> some learning cost to take into account. But then I had type errors, I had
> to look at the documentation again, and it was a bit painful. Finally, I
> only handle Camlp4 extensions about once a year, so I have time to forget
> most details about how they work, in particular I *always* look at the
> documentation for the concrete AST constructor names in the (rare) cases
> where I need them. I found that there was no such re-learning curve with
> quasiquotations, they just work out of the box -- once you've been
> rebrained, once and forall, to see those <:stuff< >> as structured code
> rather than ASCII noise.
>
> I think the small tool you just introduced (translating OCaml code into
> AST-building ocaml code) may have made this "code production" part easier,
> but I'm not fond of the idea of pasting auto-generated code in my own code.
> In any case, it would be better if it produced code using the nice
> high-level interface, rather than the hard-to-read AST definitions, but
> that may be much more painful to implement so I'm not really asking for
> that.
>
>
>
>>  But maybe we
>>> can have quasiquotations with the current extension mechanism?
>>>
>>> let add_register patvar body =
>>>    [%quote
>>>      let _ = ExceptionHandling.register [%anti patvar] in [%anti body]
>>>    ]
>>>
>>
>> Implementing this "quote" expander is not very difficult, just a little
>> bit tedious (and this can be automated by parsing the definition of the
>> Parsetree).
>
>
> Isn't that essentially the same thing as the tool you implemented for
> Xavier above? (Can you reuse code between both?)
> If I understand correctly, this is also the "Meta" operation of Camlp4,
> turning the AST for the expression <foo> into the AST for the OCaml
> expression representing the AST for <foo>. When you say "automated by
> parsing the definition of the Parsetree", do you have a realistic design in
> mind for such boilerplate code generators, or do you plan in practice to
> implement them by hand?
>
> Note that nothing forces to use [%anti x] for antiquotations.  We could
>> very well decide on a more lightweight convention, like prefixing
>> identifiers, or using a dedicated operator:
>
>
>>     [%quote
>>       let _ = ExceptionHandling.register __patvar in __body
>>     ]
>>
>>     [%quote
>>       let _ = ExceptionHandling.register !!patvar in !!body
>>     ]
>>
>
> Same old battle-horse: I dislike the idea that [%quote ] would change the
> meaning of syntactically valid OCaml code such as __patvar or !!patvar. I
> think I would with [%anti ] for now, or maybe just [%a ] if need be -- in
> any case this is not part of the eventually-crowded extension namespace as
> they really are only markers to be rewritten by the implementation of
> %quote.
>
>
>> But this approach would work nicely only for writing expressions or
>> patterns on OCaml expressions, not on other syntactic categories (because
>> the content of an extension node is an expression).  The problem is that
>> AST-manipulating code tend to require to work a lot with many different
>> categories (like "match cases") even to build expressions.
>>
>
> That's a good point.
>
>
>> Quasi-quotations would be useful if the expanders had to generate big
>> fragments of mostly static code, with only a few "dynamic" placeholders.
>>  In my experience, this is rarely the case: you assemble the resulting
>> OCaml code by combining many small fragments generated programmatically.
>>  For these cases, a nice library of "AST constructors" seems better to me.
>>
>
> Maybe we need both, but if we eventually get nice constructor names for
> the AST definitions (I know that doesn't depend on you) I think if we only
> had time/energy/maintenance for two among (1) AST definitions (2) AST
> combinator library and (3) quasiquotation mechanism, I would suggest we
> keep (1) and (3) rather than (1) and (2).
>
>
>>
>>
>>
>> -- Alain
>>
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/35302e52/attachment.html>

From alain.frisch at lexifi.com  Fri Mar 29 19:18:01 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 29 Mar 2013 20:18:01 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <CAPFanBFhAkfqJ9DiyRuM6D0HBetFy2KtUyQAj1VmEJM3tj4rAw@mail.gmail.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
 <5155A697.7050302@lexifi.com>
 <CAPFanBFhAkfqJ9DiyRuM6D0HBetFy2KtUyQAj1VmEJM3tj4rAw@mail.gmail.com>
Message-ID: <5155E8E9.1050905@lexifi.com>

On 3/29/2013 4:12 PM, Gabriel Scherer wrote:
> That is better indeed. I can only encourage you to add these kind of
> conveniences in the E submodule (or maybe somewhere else) as usage
> suggests that they are useful.

I believe that a good design for a Convenience submodule will follow the 
adaptation of existing syntax extension into -ppx style.  A first list 
of convenience functions can be found in:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/print_gen.ml?revision=HEAD&view=markup

(a quick attempt to generate "variantizer" functions from type 
definitions, here taken from .cmi files)

> I'm still not sure that quasi-quotations are not a better approach,
> because the problem here is that the user has to learn a new interface
> to describe code fragments instead of using the syntax he's already
> familiar with.

I think it is very similar with quotations and antiquotations.  There 
are fewer names to know, but this can become more confusing.

For instance, in:

   <:expr<  $xxx:e$ >>

you need different antiquotations names to indicate at least that x is 
(i) an expression, or (ii) a string to be interpreted as a lower-case 
identifier, or (iii) a longident, or (iv) a string to be interpreted as 
a constructor name, or (v) a string to be interpreted as a string 
literal.  Each anti-quotation can be used only in specific contexts. 
Basically, one recreates a dedicated sub-language, with its own syntax 
and types, whereas OCaml is not *that* bad at manipulating ASTs.


> I still have the intuition that those arguments are more
> relevant to the expert extension writer, and that for a large set of use
> cases that concern *simple* extensions and beginner extension writers,
> quasiquotations are still noticeably easier to use.

I wouldn't trust a syntactic tool written by someone who is not quite 
familiar with the definition of the Parsetree.  That said, I've nothing 
against trying to make writing extensions as simple as possible. I'm 
personally more interested in providing tools and techniques to support 
writing robust "non trivial" extensions, but it's a nice observation 
that the current proposal with extension nodes supports quotation, and I 
encourage people interested in supporting "concrete syntax" ppx 
rewriters to push this idea further.


> The question of whether the extension uses classical or revised syntax
> is largely orthogonal to the design of the extension itself (except
> occasionally with quotation ambiguities concerns), and I could have used
> the classic syntax to write the Camlp4 extension just as well.

Including within quotations?  At some time, this was not supported; 
later it was supported but discouraged, because the standard syntax was 
not "regular" enough to support non-ambiguous quotations (I don't know 
the details).  But maybe that the status of quotations in regular syntax 
has changed.

> I found that
> there was no such re-learning curve with quasiquotations, they just work
> out of the box -- once you've been rebrained, once and forall, to see
> those <:stuff< >> as structured code rather than ASCII noise.

Can you tell without looking at the documentation or existing code how 
to write a function which maps a string s to an AST fragment 
representing a constructor of name s applied to a single argument, the 
string literal represented by s.  I.e. mapping "Foo" to the AST fragment 
corresponding to the expression

   Foo "Foo"

?

>     Implementing this "quote" expander is not very difficult, just a
>     little bit tedious (and this can be automated by parsing the
>     definition of the Parsetree).
>
>
> Isn't that essentially the same thing as the tool you implemented for
> Xavier above? (Can you reuse code between both?)

This tool relies on the toplevel value printer.  I'm not sure it will be 
easy to suport anti-quotations with this approach.

 > If I understand correctly, this is also the "Meta" operation of
 > Camlp4,
 > turning the AST for the expression <foo> into the AST for the OCaml
 > expression representing the AST for <foo>. When you say "automated by
 > parsing the definition of the Parsetree", do you have a realistic
 > design
 > in mind for such boilerplate code generators, or do you plan in
 > practice
 > to implement them by hand?

Something similar to 
branches/extension_points/experimental/frisch/print_gen.ml could be used 
to generate automatically an AST lifter.  The difficult part is to 
design anti-quotations, though, and since I'm not convinced by this 
approach, I'd rather put energy myself in other projects.

> Same old battle-horse: I dislike the idea that [%quote ] would change
> the meaning of syntactically valid OCaml code such as __patvar or
> !!patvar.

Point taken.  But since we are already under an "extension", I think 
this is less bad.

>     Quasi-quotations would be useful if the expanders had to generate
>     big fragments of mostly static code, with only a few "dynamic"
>     placeholders.  In my experience, this is rarely the case: you
>     assemble the resulting OCaml code by combining many small fragments
>     generated programmatically.  For these cases, a nice library of "AST
>     constructors" seems better to me.
>
>
> Maybe we need both, but if we eventually get nice constructor names for
> the AST definitions (I know that doesn't depend on you) I think if we
> only had time/energy/maintenance for two among (1) AST definitions (2)
> AST combinator library and (3) quasiquotation mechanism, I would suggest
> we keep (1) and (3) rather than (1) and (2).

My preference, as you understood, would be (1) and (2) rather than (1) 
and (3).

An interesting project would be to review existing syntax extension and 
see how much "almost static fragments" (where quasi-quotations shine) 
they have compared to code assembling tiny fragments (where combinators 
are betters).  I suspect that most interesting tools based on Camlp4 
don't have a lot of static fragments, but I might be wrong.


-- Alain


From gabriel.scherer at gmail.com  Fri Mar 29 19:42:08 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 29 Mar 2013 20:42:08 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5155E8E9.1050905@lexifi.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
 <5155A697.7050302@lexifi.com>
 <CAPFanBFhAkfqJ9DiyRuM6D0HBetFy2KtUyQAj1VmEJM3tj4rAw@mail.gmail.com>
 <5155E8E9.1050905@lexifi.com>
Message-ID: <CAPFanBF7aOGBN4WQkKTEYeQAkWOFo9CpdNa=MB_DLnpCMcmh9w@mail.gmail.com>

Agreed: let's get a bit more experience with which syntax extensions can be
expressed with extension and attribute nodes before drawing more
conclusions on quasiquotations.


On Fri, Mar 29, 2013 at 8:18 PM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 3/29/2013 4:12 PM, Gabriel Scherer wrote:
>
>> That is better indeed. I can only encourage you to add these kind of
>> conveniences in the E submodule (or maybe somewhere else) as usage
>> suggests that they are useful.
>>
>
> I believe that a good design for a Convenience submodule will follow the
> adaptation of existing syntax extension into -ppx style.  A first list of
> convenience functions can be found in:
>
> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**
> extension_points/experimental/**frisch/print_gen.ml?revision=**
> HEAD&view=markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/print_gen.ml?revision=HEAD&view=markup>
>
> (a quick attempt to generate "variantizer" functions from type
> definitions, here taken from .cmi files)
>
>
>  I'm still not sure that quasi-quotations are not a better approach,
>> because the problem here is that the user has to learn a new interface
>> to describe code fragments instead of using the syntax he's already
>> familiar with.
>>
>
> I think it is very similar with quotations and antiquotations.  There are
> fewer names to know, but this can become more confusing.
>
> For instance, in:
>
>   <:expr<  $xxx:e$ >>
>
> you need different antiquotations names to indicate at least that x is (i)
> an expression, or (ii) a string to be interpreted as a lower-case
> identifier, or (iii) a longident, or (iv) a string to be interpreted as a
> constructor name, or (v) a string to be interpreted as a string literal.
>  Each anti-quotation can be used only in specific contexts. Basically, one
> recreates a dedicated sub-language, with its own syntax and types, whereas
> OCaml is not *that* bad at manipulating ASTs.
>
>
>
>  I still have the intuition that those arguments are more
>> relevant to the expert extension writer, and that for a large set of use
>> cases that concern *simple* extensions and beginner extension writers,
>> quasiquotations are still noticeably easier to use.
>>
>
> I wouldn't trust a syntactic tool written by someone who is not quite
> familiar with the definition of the Parsetree.  That said, I've nothing
> against trying to make writing extensions as simple as possible. I'm
> personally more interested in providing tools and techniques to support
> writing robust "non trivial" extensions, but it's a nice observation that
> the current proposal with extension nodes supports quotation, and I
> encourage people interested in supporting "concrete syntax" ppx rewriters
> to push this idea further.
>
>
>
>  The question of whether the extension uses classical or revised syntax
>> is largely orthogonal to the design of the extension itself (except
>> occasionally with quotation ambiguities concerns), and I could have used
>> the classic syntax to write the Camlp4 extension just as well.
>>
>
> Including within quotations?  At some time, this was not supported; later
> it was supported but discouraged, because the standard syntax was not
> "regular" enough to support non-ambiguous quotations (I don't know the
> details).  But maybe that the status of quotations in regular syntax has
> changed.
>
>
>  I found that
>> there was no such re-learning curve with quasiquotations, they just work
>> out of the box -- once you've been rebrained, once and forall, to see
>> those <:stuff< >> as structured code rather than ASCII noise.
>>
>
> Can you tell without looking at the documentation or existing code how to
> write a function which maps a string s to an AST fragment representing a
> constructor of name s applied to a single argument, the string literal
> represented by s.  I.e. mapping "Foo" to the AST fragment corresponding to
> the expression
>
>   Foo "Foo"
>
>
> ?
>
>      Implementing this "quote" expander is not very difficult, just a
>>     little bit tedious (and this can be automated by parsing the
>>     definition of the Parsetree).
>>
>>
>> Isn't that essentially the same thing as the tool you implemented for
>> Xavier above? (Can you reuse code between both?)
>>
>
> This tool relies on the toplevel value printer.  I'm not sure it will be
> easy to suport anti-quotations with this approach.
>
>
> > If I understand correctly, this is also the "Meta" operation of
> > Camlp4,
> > turning the AST for the expression <foo> into the AST for the OCaml
> > expression representing the AST for <foo>. When you say "automated by
> > parsing the definition of the Parsetree", do you have a realistic
> > design
> > in mind for such boilerplate code generators, or do you plan in
> > practice
> > to implement them by hand?
>
> Something similar to branches/extension_points/**experimental/frisch/
> print_gen.**ml <http://print_gen.ml> could be used to generate
> automatically an AST lifter.  The difficult part is to design
> anti-quotations, though, and since I'm not convinced by this approach, I'd
> rather put energy myself in other projects.
>
>
>  Same old battle-horse: I dislike the idea that [%quote ] would change
>> the meaning of syntactically valid OCaml code such as __patvar or
>> !!patvar.
>>
>
> Point taken.  But since we are already under an "extension", I think this
> is less bad.
>
>
>      Quasi-quotations would be useful if the expanders had to generate
>>     big fragments of mostly static code, with only a few "dynamic"
>>     placeholders.  In my experience, this is rarely the case: you
>>     assemble the resulting OCaml code by combining many small fragments
>>     generated programmatically.  For these cases, a nice library of "AST
>>     constructors" seems better to me.
>>
>>
>> Maybe we need both, but if we eventually get nice constructor names for
>> the AST definitions (I know that doesn't depend on you) I think if we
>> only had time/energy/maintenance for two among (1) AST definitions (2)
>> AST combinator library and (3) quasiquotation mechanism, I would suggest
>> we keep (1) and (3) rather than (1) and (2).
>>
>
> My preference, as you understood, would be (1) and (2) rather than (1) and
> (3).
>
> An interesting project would be to review existing syntax extension and
> see how much "almost static fragments" (where quasi-quotations shine) they
> have compared to code assembling tiny fragments (where combinators are
> betters).  I suspect that most interesting tools based on Camlp4 don't have
> a lot of static fragments, but I might be wrong.
>
>
> -- Alain
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/547fc9f9/attachment.html>

From hongboz at seas.upenn.edu  Sat Mar 30 05:00:37 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Sat, 30 Mar 2013 01:00:37 -0400
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5155A697.7050302@lexifi.com>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
 <5107F74E.8010603@frisch.fr> <51559149.2020900@lexifi.com>
 <CAPFanBEDhSAqq97uV6_vf675Q6Oz_18OptR9dU4JadeC5REe6A@mail.gmail.com>
 <5155A697.7050302@lexifi.com>
Message-ID: <CANcqPu6wv+26UvPX-c7FKkcykotyfW=VixdXrZpodNMJKwZ5Jw@mail.gmail.com>

> This might be a matter of taste, but I prefer the PPX version, which I can
> read only by knowing about the Parsetree (which is required anyway to write
> any such code), a normal OCaml library.  The quotation and anti-quotations
> in the Camlp4 version look very noisy, and it relies on a syntax I'm not
> familiar with (revised syntax) and syntactic extensions
> (quotations/antiquotations), with their own conventions ("<:match_case<",
> $lid:$).

This is an interesting point. Actually I have an idea to make it more named
antiquotation more tractable, that's instead of allowing antiquote
everything, only a lower identifier is allowed to be antiquoted. so
{:exp| .... $x ....|} (*allowed *)
{:exp| ...  $(arbitrary expression ) ||} (* Disallowed*)
let a = (arbitrary expression) in
{:exp| ...    $a .... |}                             (* written this way*)

Based on such simplified antiquotation, named antiquotation is no longer
context-sensitive, which means for all syntax categories:
$lid:x    -> `Lid (_loc,x)
$uid:x   -> `Uid (_loc,x)
....

Such rules should not be hard to remember and quite intuitive. In terms of
implementation, I think this is already available in Fan, Camlp4's
antiquotation uses both Ant constructor and string mangling, it make some
time to implement, but should not be too difficult.





>
>
> -- Alain
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130330/fb6116cf/attachment.html>

