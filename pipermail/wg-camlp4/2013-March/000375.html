<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:wg-camlp4%40lists.ocaml.org?Subject=Re%3A%20%5Bwg-camlp4%5D%20Matching%20on%20concrete%20syntax%20%28was%3A%20Re%3A%20Camlp4%20uses%29&In-Reply-To=%3CCAPFanBF7aOGBN4WQkKTEYeQAkWOFo9CpdNa%3DMB_DLnpCMcmh9w%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000374.html">
   <LINK REL="Next"  HREF="000376.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)</H1>
    <B>Gabriel Scherer</B> 
    <A HREF="mailto:wg-camlp4%40lists.ocaml.org?Subject=Re%3A%20%5Bwg-camlp4%5D%20Matching%20on%20concrete%20syntax%20%28was%3A%20Re%3A%20Camlp4%20uses%29&In-Reply-To=%3CCAPFanBF7aOGBN4WQkKTEYeQAkWOFo9CpdNa%3DMB_DLnpCMcmh9w%40mail.gmail.com%3E"
       TITLE="[wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)">gabriel.scherer at gmail.com
       </A><BR>
    <I>Fri Mar 29 19:42:08 GMT 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="000374.html">[wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
</A></li>
        <LI>Next message: <A HREF="000376.html">[wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#375">[ date ]</a>
              <a href="thread.html#375">[ thread ]</a>
              <a href="subject.html#375">[ subject ]</a>
              <a href="author.html#375">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Agreed: let's get a bit more experience with which syntax extensions can be
expressed with extension and attribute nodes before drawing more
conclusions on quasiquotations.


On Fri, Mar 29, 2013 at 8:18 PM, Alain Frisch &lt;<A HREF="http://lists.ocaml.org/listinfo/wg-camlp4">alain.frisch at lexifi.com</A>&gt;wrote:

&gt;<i> On 3/29/2013 4:12 PM, Gabriel Scherer wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> That is better indeed. I can only encourage you to add these kind of
</I>&gt;&gt;<i> conveniences in the E submodule (or maybe somewhere else) as usage
</I>&gt;&gt;<i> suggests that they are useful.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I believe that a good design for a Convenience submodule will follow the
</I>&gt;<i> adaptation of existing syntax extension into -ppx style.  A first list of
</I>&gt;<i> convenience functions can be found in:
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**">http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/branches/**</A>
</I>&gt;<i> extension_points/experimental/**frisch/print_gen.ml?revision=**
</I>&gt;<i> HEAD&amp;view=markup&lt;<A HREF="http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/print_gen.ml?revision=HEAD&amp;view=markup">http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/experimental/frisch/print_gen.ml?revision=HEAD&amp;view=markup</A>&gt;
</I>&gt;<i>
</I>&gt;<i> (a quick attempt to generate &quot;variantizer&quot; functions from type
</I>&gt;<i> definitions, here taken from .cmi files)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  I'm still not sure that quasi-quotations are not a better approach,
</I>&gt;&gt;<i> because the problem here is that the user has to learn a new interface
</I>&gt;&gt;<i> to describe code fragments instead of using the syntax he's already
</I>&gt;&gt;<i> familiar with.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I think it is very similar with quotations and antiquotations.  There are
</I>&gt;<i> fewer names to know, but this can become more confusing.
</I>&gt;<i>
</I>&gt;<i> For instance, in:
</I>&gt;<i>
</I>&gt;<i>   &lt;:expr&lt;  $xxx:e$ &gt;&gt;
</I>&gt;<i>
</I>&gt;<i> you need different antiquotations names to indicate at least that x is (i)
</I>&gt;<i> an expression, or (ii) a string to be interpreted as a lower-case
</I>&gt;<i> identifier, or (iii) a longident, or (iv) a string to be interpreted as a
</I>&gt;<i> constructor name, or (v) a string to be interpreted as a string literal.
</I>&gt;<i>  Each anti-quotation can be used only in specific contexts. Basically, one
</I>&gt;<i> recreates a dedicated sub-language, with its own syntax and types, whereas
</I>&gt;<i> OCaml is not *that* bad at manipulating ASTs.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  I still have the intuition that those arguments are more
</I>&gt;&gt;<i> relevant to the expert extension writer, and that for a large set of use
</I>&gt;&gt;<i> cases that concern *simple* extensions and beginner extension writers,
</I>&gt;&gt;<i> quasiquotations are still noticeably easier to use.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I wouldn't trust a syntactic tool written by someone who is not quite
</I>&gt;<i> familiar with the definition of the Parsetree.  That said, I've nothing
</I>&gt;<i> against trying to make writing extensions as simple as possible. I'm
</I>&gt;<i> personally more interested in providing tools and techniques to support
</I>&gt;<i> writing robust &quot;non trivial&quot; extensions, but it's a nice observation that
</I>&gt;<i> the current proposal with extension nodes supports quotation, and I
</I>&gt;<i> encourage people interested in supporting &quot;concrete syntax&quot; ppx rewriters
</I>&gt;<i> to push this idea further.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  The question of whether the extension uses classical or revised syntax
</I>&gt;&gt;<i> is largely orthogonal to the design of the extension itself (except
</I>&gt;&gt;<i> occasionally with quotation ambiguities concerns), and I could have used
</I>&gt;&gt;<i> the classic syntax to write the Camlp4 extension just as well.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Including within quotations?  At some time, this was not supported; later
</I>&gt;<i> it was supported but discouraged, because the standard syntax was not
</I>&gt;<i> &quot;regular&quot; enough to support non-ambiguous quotations (I don't know the
</I>&gt;<i> details).  But maybe that the status of quotations in regular syntax has
</I>&gt;<i> changed.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  I found that
</I>&gt;&gt;<i> there was no such re-learning curve with quasiquotations, they just work
</I>&gt;&gt;<i> out of the box -- once you've been rebrained, once and forall, to see
</I>&gt;&gt;<i> those &lt;:stuff&lt; &gt;&gt; as structured code rather than ASCII noise.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Can you tell without looking at the documentation or existing code how to
</I>&gt;<i> write a function which maps a string s to an AST fragment representing a
</I>&gt;<i> constructor of name s applied to a single argument, the string literal
</I>&gt;<i> represented by s.  I.e. mapping &quot;Foo&quot; to the AST fragment corresponding to
</I>&gt;<i> the expression
</I>&gt;<i>
</I>&gt;<i>   Foo &quot;Foo&quot;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ?
</I>&gt;<i>
</I>&gt;<i>      Implementing this &quot;quote&quot; expander is not very difficult, just a
</I>&gt;&gt;<i>     little bit tedious (and this can be automated by parsing the
</I>&gt;&gt;<i>     definition of the Parsetree).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Isn't that essentially the same thing as the tool you implemented for
</I>&gt;&gt;<i> Xavier above? (Can you reuse code between both?)
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> This tool relies on the toplevel value printer.  I'm not sure it will be
</I>&gt;<i> easy to suport anti-quotations with this approach.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; If I understand correctly, this is also the &quot;Meta&quot; operation of
</I>&gt;<i> &gt; Camlp4,
</I>&gt;<i> &gt; turning the AST for the expression &lt;foo&gt; into the AST for the OCaml
</I>&gt;<i> &gt; expression representing the AST for &lt;foo&gt;. When you say &quot;automated by
</I>&gt;<i> &gt; parsing the definition of the Parsetree&quot;, do you have a realistic
</I>&gt;<i> &gt; design
</I>&gt;<i> &gt; in mind for such boilerplate code generators, or do you plan in
</I>&gt;<i> &gt; practice
</I>&gt;<i> &gt; to implement them by hand?
</I>&gt;<i>
</I>&gt;<i> Something similar to branches/extension_points/**experimental/frisch/
</I>&gt;<i> print_gen.**ml &lt;<A HREF="http://print_gen.ml">http://print_gen.ml</A>&gt; could be used to generate
</I>&gt;<i> automatically an AST lifter.  The difficult part is to design
</I>&gt;<i> anti-quotations, though, and since I'm not convinced by this approach, I'd
</I>&gt;<i> rather put energy myself in other projects.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  Same old battle-horse: I dislike the idea that [%quote ] would change
</I>&gt;&gt;<i> the meaning of syntactically valid OCaml code such as __patvar or
</I>&gt;&gt;<i> !!patvar.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Point taken.  But since we are already under an &quot;extension&quot;, I think this
</I>&gt;<i> is less bad.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>      Quasi-quotations would be useful if the expanders had to generate
</I>&gt;&gt;<i>     big fragments of mostly static code, with only a few &quot;dynamic&quot;
</I>&gt;&gt;<i>     placeholders.  In my experience, this is rarely the case: you
</I>&gt;&gt;<i>     assemble the resulting OCaml code by combining many small fragments
</I>&gt;&gt;<i>     generated programmatically.  For these cases, a nice library of &quot;AST
</I>&gt;&gt;<i>     constructors&quot; seems better to me.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Maybe we need both, but if we eventually get nice constructor names for
</I>&gt;&gt;<i> the AST definitions (I know that doesn't depend on you) I think if we
</I>&gt;&gt;<i> only had time/energy/maintenance for two among (1) AST definitions (2)
</I>&gt;&gt;<i> AST combinator library and (3) quasiquotation mechanism, I would suggest
</I>&gt;&gt;<i> we keep (1) and (3) rather than (1) and (2).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> My preference, as you understood, would be (1) and (2) rather than (1) and
</I>&gt;<i> (3).
</I>&gt;<i>
</I>&gt;<i> An interesting project would be to review existing syntax extension and
</I>&gt;<i> see how much &quot;almost static fragments&quot; (where quasi-quotations shine) they
</I>&gt;<i> have compared to code assembling tiny fragments (where combinators are
</I>&gt;<i> betters).  I suspect that most interesting tools based on Camlp4 don't have
</I>&gt;<i> a lot of static fragments, but I might be wrong.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -- Alain
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/547fc9f9/attachment.html">http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130329/547fc9f9/attachment.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000374.html">[wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
</A></li>
	<LI>Next message: <A HREF="000376.html">[wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#375">[ date ]</a>
              <a href="thread.html#375">[ thread ]</a>
              <a href="subject.html#375">[ subject ]</a>
              <a href="author.html#375">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ocaml.org/listinfo/wg-camlp4">More information about the wg-camlp4
mailing list</a><br>
</body></html>
