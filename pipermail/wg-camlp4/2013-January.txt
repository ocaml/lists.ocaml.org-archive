From alain at frisch.fr  Thu Jan 24 14:31:01 2013
From: alain at frisch.fr (Alain Frisch)
Date: Thu, 24 Jan 2013 15:31:01 +0100
Subject: [wg-camlp4] Working Group: the future of syntax extensions in OCaml,
	after camlp4
Message-ID: <510145A5.6030807@frisch.fr>

Dear caml-list,

There is a growing opinion that camlp4 is overly complex considering the 
benefits it brings to OCaml developers.  I would personally go as far as 
to say that the future of OCaml and the OCaml community would be 
brighter if camlp4 could be removed from our "basic ecosystem".  In 
particular, most of the current uses of camlp4 to create syntax 
extensions could probably be replaced by the new "-ppx" technology (see 
below) and small extensions to the compilers.

A lot needs to happens for this camlp4-free OCaml ecosystem to become a 
reality and we have to come up with a solid transition plan.  A new 
community-driven working group, chaired by Leo White and me, is being 
set up today to elaborate this plan.  If this topic is of interest to 
you, please join our mailing list:

   http://lists.ocaml.org/listinfo/wg-camlp4


Some of the most important tasks for our new working group will be:

  - Gather information from the community about the use of camlp4.
    (Please consider sharing information about your use of camlp4
    and camlp4-based extensions, even if you don't plan to participate
    to the working group discussions!)

  - Finalize support for -ppx and make technical proposals for
    extensions of the OCaml compilers in order to enable a transition of
    camlp4-based extensions to -ppx (in particular, we need to come up
    with a concrete syntax for generic extension points in the grammar).

  - Write some "canonical" examples of extensions based on -ppx and
    provide information and support to developers of extensions for
    switching from camlp4 to -ppx.

  - Discuss integration of -ppx with existing tools (findlib, build
    systems, etc).

  - Find a solution in the community for the future of camlp4
    (in particular, discuss how / how long / by who it will be
    maintained).

  - Discuss longer-terms plans beyond -ppx, including extra language
    support, to facilitate light syntactic meta-programming for OCaml
    (Leo has some clever ideas!).



The discussion on the mailing list will start in a few days, to give 
some time for interested people to join.  In the meanwhile, Leo has 
written a blog post to get the discussion started:

  http://www.lpw25.net/2013/01/23/camlp4-alternative-part-1.html

You can also read about -ppx:

  http://www.lexifi.com/blog/syntax-extensions-without-camlp4
  http://www.lexifi.com/blog/syntax-extensions-without-camlp4-lets-do-it

Some projects have already started to replace camlp4 by -ppx:

   bisect (supports both camlp4 and ppx since version 1.3)
   sedlex (unicode-friendly lexer generator, successor of ulex)
   omonad (syntax for monadic code, similar to pa_monad)


Many thanks to Anil Madhavapeddy and to OCamlLabs for setting up the 
working group and its mailing list!


Alain

From daniel.buenzli at erratique.ch  Thu Jan 24 15:57:37 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Thu, 24 Jan 2013 16:57:37 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <510145A5.6030807@frisch.fr>
References: <510145A5.6030807@frisch.fr>
Message-ID: <90C5BC201F264C4C902B4E7897660042@erratique.ch>

Le jeudi, 24 janvier 2013 ? 15:31, Alain Frisch a ?crit :
> - Gather information from the community about the use of camlp4.
> (Please consider sharing information about your use of camlp4
> and camlp4-based extensions, even if you don't plan to participate
> to the working group discussions!)

I tried to disable camlp4 to compile OCaml 4.00.1 on a raspberry pi --- takes half the (long) compilation time, and allows you to compile OCaml without having to increase the swap size of the default raspbian image to prevent the system from crashing during camlp4 compilation...

However one thing I learned is that currently, it's pretty a no go as camlp4 is needed by ocamlfind which means that if you use something like opam to install software you can't install any of the 'required by' packages mentioned on this page [1].  

So it seems that to get rid of camlp4, ocamlfind needs to get rid of camlp4, I'd be interested in what Gerd has to say about that (I have no idea if camlp4 is used by the tool itself or if it's just needed to provide support for camlp4).  

Best,

Daniel

[1] http://opam.ocamlpro.com/pkg/ocamlfind.1.3.3.html

From info at gerd-stolpmann.de  Thu Jan 24 16:24:19 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Thu, 24 Jan 2013 17:24:19 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <90C5BC201F264C4C902B4E7897660042@erratique.ch> (from
 daniel.buenzli@erratique.ch on Thu Jan 24 16:57:37 2013)
References: <510145A5.6030807@frisch.fr>
 <90C5BC201F264C4C902B4E7897660042@erratique.ch>
Message-ID: <1359044659.30715.4@samsung>

Am 24.01.2013 16:57:37 schrieb(en) Daniel B?nzli:
> Le jeudi, 24 janvier 2013 ? 15:31, Alain Frisch a ?crit :
> > - Gather information from the community about the use of camlp4.
> > (Please consider sharing information about your use of camlp4
> > and camlp4-based extensions, even if you don't plan to participate
> > to the working group discussions!)
> 
> I tried to disable camlp4 to compile OCaml 4.00.1 on a raspberry pi  
> --- takes half the (long) compilation time, and allows you to compile  
> OCaml without having to increase the swap size of the default  
> raspbian image to prevent the system from crashing during camlp4  
> compilation...
> 
> However one thing I learned is that currently, it's pretty a no go as  
> camlp4 is needed by ocamlfind which means that if you use something  
> like opam to install software you can't install any of the 'required  
> by' packages mentioned on this page [1].
> 
> So it seems that to get rid of camlp4, ocamlfind needs to get rid of  
> camlp4, I'd be interested in what Gerd has to say about that (I have  
> no idea if camlp4 is used by the tool itself or if it's just needed  
> to provide support for camlp4).

It's used in the tool, but only for stream parsing. I could also  
distribute the already-preprocessed file (and maybe I'll do so in the  
next release).

Stream parsing is certainly one of the topics to discuss.

Just fyi, findlib was originally developed at a time when camlp4 was  
separately distributed, and stream parsing was supported by core OCaml  
w/o camlp4.

Gerd


> 
> Best,
> 
> Daniel
> 
> [1] http://opam.ocamlpro.com/pkg/ocamlfind.1.3.3.html
> 
> --
> Caml-list mailing list.  Subscription management and archives:
> https://sympa.inria.fr/sympa/arc/caml-list
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From john.r.harrison at intel.com  Thu Jan 24 23:03:47 2013
From: john.r.harrison at intel.com (Harrison, John R)
Date: Thu, 24 Jan 2013 23:03:47 +0000
Subject: [wg-camlp4] My uses of syntax extension
Message-ID: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>

I'm currently using camlp5 for syntax extensions. I never switched to
the new camlp4. It was introduced with minimal discussion and hardly
any useful documentation, while even things that were trivial in
camlp5 seemed complicated, so I never made the effort.

I think one of my applications (item 2 below) is very unusual, so
perhaps it will be a useful, or at least amusing, outlier in any list
people accumulate of current uses of syntax extension.

1. In the code for my book (http://www.cl.cam.ac.uk/~jrh13/atp/) I use
   items entered in <<quotations>>, which I simply want to treat as a
   string to get passed to my parser. This is essentially trivial in
   camlp5, though I think it is less so in camlp4.

   let quotexpander s =
     .... "default_parser \""^(String.escaped s)^"\"";;

   Quotation.add "" (Quotation.ExStr (fun x -> quotexpander));;

2. For the HOL Light prover (http://code.google.com/p/hol-light/),
   backward compatibility with other HOLs (where ML is used not only
   as the implementation language but also as the toplevel) dictates
   that I do various things to make OCaml look like old-style ML:

       * Add some alphanumeric infixes like "o" and "THEN"

       * Use "it" as the default binding for the previous expression
         (actually, I would prefer the toplevel to do this anyway).

       * Use quotations, but within the characters `....` not <<...>>

       * Completely change the OCaml lexical conventions so that
         all-uppercase words like INST and REWRITE_TAC are treated as
         ordinary identifiers.

   The subversion of the lexical conventions is the most tiresome
   aspect. (It also needs to be switchable in order to allow easy
   interfacing with more conventional OCaml code.) In camlp5, I do
   this by copying and editing the existing lexer, which makes it
   very brittle and necessitates frequent changes as camlp5's
   internals evolve. I would very much like a better solution.

John.


From anil at recoil.org  Fri Jan 25 16:34:42 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 25 Jan 2013 16:34:42 +0000
Subject: [wg-camlp4] Feedback to Leo's post from Jake
Message-ID: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>

I summarised some of the Twitter conversation at this URL, which has the thread:
http://twitter.theinfo.org/294459288762601472

Jake's last point is perhaps most important: "surveying what exists then supporting only common cases is philosophically backward for an extension mechanism".

While camlp4 is a powerful extension mechanism, it's perhaps been too successful.  Some of the common extensions have been used for years now without being integrated back into the core compiler suite, to the point that it's almost impossible to write a real application without using camlp4. 

I view the current effort as a selection process for the successful extensions from camlp4, and building lightweight alternatives that reduce the reliance on the larger mechanism.  This makes the process of integrating other tools such as build, IDE integration and documentation much easier.  For example, we're currently working on a new ocamldoc that generates unified cross-references, and would like to separately render type_conv-generated functions to avoid cluttering the output. This is easy with annotations+ppx (assuming that type_conv's `with` is added to the default grammar).

There's no reason why camlp4 cannot continue to co-exist with some of these alternative mechanisms, but our addiction to it really ought to be reduced.

Another point he raises is that Leo's blog post "misses important camlp4 use cases. e.g. nested quot/antiquot, exts to pattern matching".  Some extensions (such as bitstring) are very naturally packaged as camlp4 syntax extensions, and not entirely solved by the ppx scheme.  It would be good to understand if this is outside of the scope of ppx, or on the list to solve.

(And thanks for the comments Jake; as I noted on Twitter, it was his fantastic blog series [1] and ICFP tutorial [2] that really unlocked the mysteries of camlp4 for me).

[1] http://ambassadortothecomputers.blogspot.co.uk/search/label/camlp4
[2] http://nicolaspouillard.fr/talks/cufp-metaprogramming-tutorial-slides.pdf

-anil

From hongboz at seas.upenn.edu  Fri Jan 25 16:48:52 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Fri, 25 Jan 2013 11:48:52 -0500
Subject: [wg-camlp4] Feedback to Leo's post from Jake
In-Reply-To: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
References: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
Message-ID: <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>

Hi Anil,
   I am just wondering why not expose a simple API on top of  Camlp4
instead of rolling a new mechanism? The advanced users can still have
advanced features.


On Fri, Jan 25, 2013 at 11:34 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I summarised some of the Twitter conversation at this URL, which has the thread:
> http://twitter.theinfo.org/294459288762601472
>
> Jake's last point is perhaps most important: "surveying what exists then supporting only common cases is philosophically backward for an extension mechanism".
>
> While camlp4 is a powerful extension mechanism, it's perhaps been too successful.  Some of the common extensions have been used for years now without being integrated back into the core compiler suite, to the point that it's almost impossible to write a real application without using camlp4.
>
> I view the current effort as a selection process for the successful extensions from camlp4, and building lightweight alternatives that reduce the reliance on the larger mechanism.  This makes the process of integrating other tools such as build, IDE integration and documentation much easier.  For example, we're currently working on a new ocamldoc that generates unified cross-references, and would like to separately render type_conv-generated functions to avoid cluttering the output. This is easy with annotations+ppx (assuming that type_conv's `with` is added to the default grammar).
>
> There's no reason why camlp4 cannot continue to co-exist with some of these alternative mechanisms, but our addiction to it really ought to be reduced.
>
> Another point he raises is that Leo's blog post "misses important camlp4 use cases. e.g. nested quot/antiquot, exts to pattern matching".  Some extensions (such as bitstring) are very naturally packaged as camlp4 syntax extensions, and not entirely solved by the ppx scheme.  It would be good to understand if this is outside of the scope of ppx, or on the list to solve.
>
> (And thanks for the comments Jake; as I noted on Twitter, it was his fantastic blog series [1] and ICFP tutorial [2] that really unlocked the mysteries of camlp4 for me).
>
> [1] http://ambassadortothecomputers.blogspot.co.uk/search/label/camlp4
> [2] http://nicolaspouillard.fr/talks/cufp-metaprogramming-tutorial-slides.pdf
>
> -anil
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4



-- 
-- Regards, Hongbo

From anil at recoil.org  Fri Jan 25 16:54:28 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 25 Jan 2013 16:54:28 +0000
Subject: [wg-camlp4] Feedback to Leo's post from Jake
In-Reply-To: <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
References: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
 <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
Message-ID: <C15E148C-75B6-4155-B41D-DBE0F1BF791D@recoil.org>

Camlp4 slows down my projects, makes them more complex to build, and more prone to hard-to-track failures (due to buggy extensions generating invalid AST fragments occasionally).  It also makes it hard to build reliable IDE integration when you have to deal with an extensible grammar.

I love using it as an extension mechanism, and I hate using it day-to-day for every single bit of code that I write.

Alain and Leo are proposing separating extensible grammars from AST transformations, which seems sensible to me.  Can you be more specific about what you envisage a simple API would look like?

-anil

On 25 Jan 2013, at 16:48, Hongbo Zhang <hongboz at seas.upenn.edu> wrote:

> Hi Anil,
>   I am just wondering why not expose a simple API on top of  Camlp4
> instead of rolling a new mechanism? The advanced users can still have
> advanced features.
> 
> 
> On Fri, Jan 25, 2013 at 11:34 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> I summarised some of the Twitter conversation at this URL, which has the thread:
>> http://twitter.theinfo.org/294459288762601472
>> 
>> Jake's last point is perhaps most important: "surveying what exists then supporting only common cases is philosophically backward for an extension mechanism".
>> 
>> While camlp4 is a powerful extension mechanism, it's perhaps been too successful.  Some of the common extensions have been used for years now without being integrated back into the core compiler suite, to the point that it's almost impossible to write a real application without using camlp4.
>> 
>> I view the current effort as a selection process for the successful extensions from camlp4, and building lightweight alternatives that reduce the reliance on the larger mechanism.  This makes the process of integrating other tools such as build, IDE integration and documentation much easier.  For example, we're currently working on a new ocamldoc that generates unified cross-references, and would like to separately render type_conv-generated functions to avoid cluttering the output. This is easy with annotations+ppx (assuming that type_conv's `with` is added to the default grammar).
>> 
>> There's no reason why camlp4 cannot continue to co-exist with some of these alternative mechanisms, but our addiction to it really ought to be reduced.
>> 
>> Another point he raises is that Leo's blog post "misses important camlp4 use cases. e.g. nested quot/antiquot, exts to pattern matching".  Some extensions (such as bitstring) are very naturally packaged as camlp4 syntax extensions, and not entirely solved by the ppx scheme.  It would be good to understand if this is outside of the scope of ppx, or on the list to solve.
>> 
>> (And thanks for the comments Jake; as I noted on Twitter, it was his fantastic blog series [1] and ICFP tutorial [2] that really unlocked the mysteries of camlp4 for me).
>> 
>> [1] http://ambassadortothecomputers.blogspot.co.uk/search/label/camlp4
>> [2] http://nicolaspouillard.fr/talks/cufp-metaprogramming-tutorial-slides.pdf
>> 
>> -anil
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 
> 
> -- 
> -- Regards, Hongbo
> 


From hongboz at seas.upenn.edu  Fri Jan 25 17:05:38 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Fri, 25 Jan 2013 12:05:38 -0500
Subject: [wg-camlp4] Feedback to Leo's post from Jake
In-Reply-To: <C15E148C-75B6-4155-B41D-DBE0F1BF791D@recoil.org>
References: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
 <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
 <C15E148C-75B6-4155-B41D-DBE0F1BF791D@recoil.org>
Message-ID: <CANcqPu7YoCXNu-zyq+Lm=iCWnBtKC3Aj9X=9BLj0s1+jWbX0Bg@mail.gmail.com>

On Fri, Jan 25, 2013 at 11:54 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> Camlp4 slows down my projects, makes them more complex to build, and more prone to hard-to-track failures (due to buggy extensions generating invalid AST fragments occasionally).  It also makes it hard to build reliable IDE integration when you have to deal with an extensible grammar.
That's true, but I have already solved  this problem, Fan(my branch of
p4) can be built under 20s instead of 10 minutes in the trunk. I also
solved the building complexity problem(details to explain later)
>
> I love using it as an extension mechanism, and I hate using it day-to-day for every single bit of code that I write.
>
> Alain and Leo are proposing separating extensible grammars from AST transformations, which seems sensible to me.  Can you be more specific about what you envisage a simple API would look like?
I also solved this problem, the generic deriving mechanism is built in
Fan(something similar to your work
http://gazagnaire.org/pub/GM10.pdf).

The parsetree is really a not nice ast to do the transformations for
two technical reasons:
    1. It does some syntax desguaring..
           suppose you want to pattern match bigarray syntax, it's
really painful
    2. It mixes records and algebraic data type, I rewrite the camlp4,
I know it would makes
the *Ast lifting* really really hard, so the nested quotation and
antiquotation mechanism  is really hard to implement, let alone the
syntax extension..

For the user, you really don't need to mutate the syntax , we could
provide some plugins for the end user.  I would write a blog to
explain more about this this weekend.

Thanks!



>
> -anil
>
> On 25 Jan 2013, at 16:48, Hongbo Zhang <hongboz at seas.upenn.edu> wrote:
>
>> Hi Anil,
>>   I am just wondering why not expose a simple API on top of  Camlp4
>> instead of rolling a new mechanism? The advanced users can still have
>> advanced features.
>>
>>
>> On Fri, Jan 25, 2013 at 11:34 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> I summarised some of the Twitter conversation at this URL, which has the thread:
>>> http://twitter.theinfo.org/294459288762601472
>>>
>>> Jake's last point is perhaps most important: "surveying what exists then supporting only common cases is philosophically backward for an extension mechanism".
>>>
>>> While camlp4 is a powerful extension mechanism, it's perhaps been too successful.  Some of the common extensions have been used for years now without being integrated back into the core compiler suite, to the point that it's almost impossible to write a real application without using camlp4.
>>>
>>> I view the current effort as a selection process for the successful extensions from camlp4, and building lightweight alternatives that reduce the reliance on the larger mechanism.  This makes the process of integrating other tools such as build, IDE integration and documentation much easier.  For example, we're currently working on a new ocamldoc that generates unified cross-references, and would like to separately render type_conv-generated functions to avoid cluttering the output. This is easy with annotations+ppx (assuming that type_conv's `with` is added to the default grammar).
>>>
>>> There's no reason why camlp4 cannot continue to co-exist with some of these alternative mechanisms, but our addiction to it really ought to be reduced.
>>>
>>> Another point he raises is that Leo's blog post "misses important camlp4 use cases. e.g. nested quot/antiquot, exts to pattern matching".  Some extensions (such as bitstring) are very naturally packaged as camlp4 syntax extensions, and not entirely solved by the ppx scheme.  It would be good to understand if this is outside of the scope of ppx, or on the list to solve.
>>>
>>> (And thanks for the comments Jake; as I noted on Twitter, it was his fantastic blog series [1] and ICFP tutorial [2] that really unlocked the mysteries of camlp4 for me).
>>>
>>> [1] http://ambassadortothecomputers.blogspot.co.uk/search/label/camlp4
>>> [2] http://nicolaspouillard.fr/talks/cufp-metaprogramming-tutorial-slides.pdf
>>>
>>> -anil
>>> _______________________________________________
>>> wg-camlp4 mailing list
>>> wg-camlp4 at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/wg-camlp4
>>
>>
>>
>> --
>> -- Regards, Hongbo
>>
>



-- 
-- Regards, Hongbo

From alain at frisch.fr  Fri Jan 25 17:26:30 2013
From: alain at frisch.fr (Alain Frisch)
Date: Fri, 25 Jan 2013 18:26:30 +0100
Subject: [wg-camlp4] Feedback to Leo's post from Jake
In-Reply-To: <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
References: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
 <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
Message-ID: <5102C046.5030207@frisch.fr>

On 01/25/2013 05:48 PM, Hongbo Zhang wrote:> Hi Anil,
 >     I am just wondering why not expose a simple API on top of  Camlp4
 > instead of rolling a new mechanism? The advanced users can still have
 > advanced features.

Even if you manage to simplify Camlp4, it will always be a complex 
beast, creating some maintenance overhead for the core team when the 
language evolve or if you need to work with a fork of the language (such 
as MetaOCaml, OCamlDuce, or LexiFi's local version).  As a very concrete 
example, Jacques Garrigue recently proposed a patch (for generative 
functors) which requires a (light) extension to the OCaml syntax.  Of 
course, he did not upgrade Camlp4 (its version of the OCaml AST, its N 
parsers, and the mapping to the regular OCaml AST) yet.  So you cannot 
try this patch on your whole project if it depends on any camlp4-based 
tool.  This is very sad, isn't it?  Projects which rely on -ppx (like 
Bisect, sedlex, omonad) work perfectly ok with Jacques'  patch and 
nobody had to suffer to make this happen.

Why should we build something simple on top of something complicated 
when it is rather easy to build the simple solution directly?  This 
seems much more robust and future proof to me.  Those who enjoy the 
extra complexity (or actually need it) can indeed continue to work on 
and use camlp4/camlp5/fan.  This is not incompatible with -ppx at all. 
But the day ocamlfind, lwt, js_of_ocaml, type_conv and other 
"infrastructure" tools will work without camlp4, I will feel much more 
comfortable relying on them.

Also, I have reasons to believe that -ppx based tools will interact 
nicely with each other, better than camlp4 ones (I think about the
unfortunate incompatibility between deriving and type_conv). I claim 
that camlp4's model of independent extensions being allowed to tweak the 
concrete syntax as they want by mutating grammar rules is a design 
mistake with unfortunate consequences.  I have other technical concerns 
with camlp4 and I will try to summarize them in a blog post, so as to 
keep this mailing list more focused to pushing alternatives to camlp4 
(rather than justifying why this is a good idea to do so).

On 01/25/2013 05:34 PM, Anil Madhavapeddy wrote:
 >  Some extensions (such as bitstring) are very naturally packaged as
 > camlp4 syntax extensions, and not entirely solved by the ppx scheme. 
  > It would be good to understand if this is outside of the scope of
 > ppx, or on the list to solve.


This does not look very different from Sedlex ( 
http://www.lexifi.com/sedlex ), which encodes regular expressions as 
normal patterns.   And adding quotations in pattern position would make 
it possible to use any concrete syntax.


Alain


From anil at recoil.org  Fri Jan 25 18:07:50 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 25 Jan 2013 18:07:50 +0000
Subject: [wg-camlp4] Feedback to Leo's post from Jake
In-Reply-To: <5102C046.5030207@frisch.fr>
References: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
 <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
 <5102C046.5030207@frisch.fr>
Message-ID: <95CBF314-2F17-4A55-9F3E-DD5E4995F283@recoil.org>

On 25 Jan 2013, at 17:26, Alain Frisch <alain at frisch.fr> wrote:

> This does not look very different from Sedlex ( http://www.lexifi.com/sedlex ), which encodes regular expressions as normal patterns. And adding quotations in pattern position would make it possible to use any concrete syntax.

That makes sense to me; I'll look at sedlex in more detail next week. Another 
extension which we've developed and depend on very heavily is a quick way to
map C structures to OCaml:

  https://github.com/mirage/ocaml-cstruct

cstruct pcap_header {
  uint32_t magic_number;   (* magic number *)
  uint16_t version_major;  (* major version number *)
  uint16_t version_minor;  (* minor version number *)
  uint32_t thiszone;       (* GMT to local correction *)
  uint32_t sigfigs;        (* accuracy of timestamps *)
  uint32_t snaplen;        (* max length of captured packets, in octets *)
  uint32_t network         (* data link type *)
} as little_endian


Will generate accessor functions for each field for a Bigarray.  This sounds 
like it'll just be a quotation in the ppx world, so slightly more syntactically
heavy (but I think that's an acceptable cost).

-anil

From yminsky at janestreet.com  Fri Jan 25 18:15:58 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 25 Jan 2013 13:15:58 -0500
Subject: [wg-camlp4] Feedback to Leo's post from Jake
In-Reply-To: <5102C046.5030207@frisch.fr>
References: <9A42DC5C-5752-41E6-A7E2-4AC9BC75AA2C@recoil.org>
 <CANcqPu4P7N1pdtsD=mSQbMxgcM4EwT8THdpREpf3f5zhTRGing@mail.gmail.com>
 <5102C046.5030207@frisch.fr>
Message-ID: <CACLX4jRTb6+-VLmWW76+KV-GSZq=o0sMnJKQ3PHD1qnKRwL6nA@mail.gmail.com>

I very much agree with Alain on this.  Having a simple core seems
essential, from a number of viewpoints.  Implementation complexity
alone seems to demand it.

Moreover, I would argue that we should move past the question of
whether to build a simpler thing, and focus more on what that simple
thing should look like.  Once we have a clearer idea about that, we
can circle back and make sure we think like the end result is good
enough to justify the change.

y

On Fri, Jan 25, 2013 at 12:26 PM, Alain Frisch <alain at frisch.fr> wrote:
> On 01/25/2013 05:48 PM, Hongbo Zhang wrote:> Hi Anil,
>
>>     I am just wondering why not expose a simple API on top of  Camlp4
>> instead of rolling a new mechanism? The advanced users can still have
>> advanced features.
>
> Even if you manage to simplify Camlp4, it will always be a complex beast,
> creating some maintenance overhead for the core team when the language
> evolve or if you need to work with a fork of the language (such as
> MetaOCaml, OCamlDuce, or LexiFi's local version).  As a very concrete
> example, Jacques Garrigue recently proposed a patch (for generative
> functors) which requires a (light) extension to the OCaml syntax.  Of
> course, he did not upgrade Camlp4 (its version of the OCaml AST, its N
> parsers, and the mapping to the regular OCaml AST) yet.  So you cannot try
> this patch on your whole project if it depends on any camlp4-based tool.
> This is very sad, isn't it?  Projects which rely on -ppx (like Bisect,
> sedlex, omonad) work perfectly ok with Jacques'  patch and nobody had to
> suffer to make this happen.
>
> Why should we build something simple on top of something complicated when it
> is rather easy to build the simple solution directly?  This seems much more
> robust and future proof to me.  Those who enjoy the extra complexity (or
> actually need it) can indeed continue to work on and use camlp4/camlp5/fan.
> This is not incompatible with -ppx at all. But the day ocamlfind, lwt,
> js_of_ocaml, type_conv and other "infrastructure" tools will work without
> camlp4, I will feel much more comfortable relying on them.
>
> Also, I have reasons to believe that -ppx based tools will interact nicely
> with each other, better than camlp4 ones (I think about the
> unfortunate incompatibility between deriving and type_conv). I claim that
> camlp4's model of independent extensions being allowed to tweak the concrete
> syntax as they want by mutating grammar rules is a design mistake with
> unfortunate consequences.  I have other technical concerns with camlp4 and I
> will try to summarize them in a blog post, so as to keep this mailing list
> more focused to pushing alternatives to camlp4 (rather than justifying why
> this is a good idea to do so).
>
>
> On 01/25/2013 05:34 PM, Anil Madhavapeddy wrote:
>>  Some extensions (such as bitstring) are very naturally packaged as
>> camlp4 syntax extensions, and not entirely solved by the ppx scheme.  > It
>> would be good to understand if this is outside of the scope of
>> ppx, or on the list to solve.
>
>
> This does not look very different from Sedlex ( http://www.lexifi.com/sedlex
> ), which encodes regular expressions as normal patterns.   And adding
> quotations in pattern position would make it possible to use any concrete
> syntax.
>
>
> Alain
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From edwin+ml-ocaml at etorok.net  Fri Jan 25 19:38:16 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Fri, 25 Jan 2013 21:38:16 +0200
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
Message-ID: <5102DF28.90802@etorok.net>

Hi,

Here are my uses of camlp4:

* camlp4o     - for better syntax errors (see http://caml.inria.fr/mantis/view.php?id=5068). This is a time-saver during development
* js_of_ocaml - (blogpost says its not really needed if a different operator would be used)
* bisect      - haven't figured how to use ppx from oasis/ocamlfind, The camlp4 one is as simple as:
	$(SETUP) -build -tag pkg_bisect -tag pkg_str -tag syntax_camlp4o -tag syntax_bisect_pp $(BUILDFLAGS)

camlp4 syntax extensions needed to build libraries that I use:
lwt, tyxml (needs camlp4of), camlp4.macro

Syntax extensions I considered using but never got around to:
pa-monad (didn't really need it), bitstring

Also when initially learning OCaml I have used the revised syntax (camlp4r) quite heavily.
Nowadays I write everything in the original syntax.
While I wouldn't miss the revised syntax, I do think that its much easier to first learn the revised syntax so it'd be nice
if the camlp4 replacement provided that as well.

Best regards,	
--Edwin






From lukstafi at gmail.com  Fri Jan 25 20:52:06 2013
From: lukstafi at gmail.com (Lukasz Stafiniak)
Date: Fri, 25 Jan 2013 21:52:06 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5102DF28.90802@etorok.net>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net>
Message-ID: <CAJMfKEW1Ls0mVOnx2SHJOyaPFLiULgEDsQiF0OUn+QxTuzCO=Q@mail.gmail.com>

My uses of camlp4:
- "let try n = expr in expr with handlers"
- LOGging
- recently, matrix access/assignment like in bigarrays but for
built-in arrays (long ago I also played with matlab-like notation)
- js_of_ocaml
- list comprehensions and pa_monad, but for educational purposes so far.

From alain at frisch.fr  Mon Jan 28 10:57:28 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 11:57:28 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
Message-ID: <51065998.9090009@frisch.fr>

Hi John,

Thanks for sharing this information!

On 01/25/2013 12:03 AM, Harrison, John R wrote:
> 1. In the code for my book (http://www.cl.cam.ac.uk/~jrh13/atp/) I use
>     items entered in <<quotations>>, which I simply want to treat as a
>     string to get passed to my parser. This is essentially trivial in
>     camlp5, though I think it is less so in camlp4.
>
>     let quotexpander s =
>       .... "default_parser \""^(String.escaped s)^"\"";;
>
>     Quotation.add "" (Quotation.ExStr (fun x -> quotexpander));;

It is planned to extend OCaml grammar directly with generic quotations 
(in place of expressions, patterns, etc).  The type-checker would fail 
on them, but -ppx filters will have a chance to rewrite them to 
something the compiler understands.  It is not completely clear yet 
which syntax (delimiters, lexing rules) will be chosen, though. 
Delimiters will probably be different from Camlp4, to make it possible 
to combine Camlp4 and -ppx.

*If* you don't care too much about having to escape some characters in 
the content of the quotations, a poor-man version is to rely on standard 
strings.  For instance, a -ppx filter can detect the construction:

   !"....."

(i.e. the bang character followed by a string literal) and rewrites it 
to whatever it wants.  But given your example (where the quotation 
expands to a simple function call on the string literal), I assume that 
you use quotations precisely for them lexical properties.  Is that right?

> 2. For the HOL Light prover (http://code.google.com/p/hol-light/),
>     backward compatibility with other HOLs (where ML is used not only
>     as the implementation language but also as the toplevel) dictates
>     that I do various things to make OCaml look like old-style ML:
>
>         * Add some alphanumeric infixes like "o" and "THEN"
>
>         * Use "it" as the default binding for the previous expression
>           (actually, I would prefer the toplevel to do this anyway).
>
>         * Use quotations, but within the characters `....` not <<...>>
>
>         * Completely change the OCaml lexical conventions so that
>           all-uppercase words like INST and REWRITE_TAC are treated as
>           ordinary identifiers.
>
>     The subversion of the lexical conventions is the most tiresome
>     aspect. (It also needs to be switchable in order to allow easy
>     interfacing with more conventional OCaml code.) In camlp5, I do
>     this by copying and editing the existing lexer, which makes it
>     very brittle and necessitates frequent changes as camlp5's
>     internals evolve. I would very much like a better solution.


This is really about proposing a concrete syntax (even lexical 
conventions) different from regular OCaml, a little bit in the same vein 
as camlp4's revised syntax.  I believe this is better left outside the 
scope of -ppx, which is about providing syntactic facilities (code 
generation, macros, etc) rather than changing the concrete syntax.

To support fully custom syntax, the "-pp" flag will always be available. 
  You can implement a custom parser with 
camlp4/camlp5/ocamlyacc/menhir/etc and then use -ppx rewriters on the 
result, if needed (so that your users will be able to use all the nice 
-ppx rewriter even if your concrete syntax is quite different from 
OCaml).  In a sense, -ppx improve the situation here, because I suspect 
that changing OCaml's grammar means destroying/shadowing some rules in 
Camlp'4 OCaml grammar, and those rules might be relied upon by "syntax 
extensions".  With -ppx, we would have a stricter separation between the 
concrete syntax, and additional syntactic tools (-ppx).

Btw, did you consider forking OCaml's lexer/parser instead of relying on 
camlp5 plus hacks for the lexical part?


Alain

From alain at frisch.fr  Mon Jan 28 12:04:28 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 13:04:28 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5102DF28.90802@etorok.net>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net>
Message-ID: <5106694C.3020703@frisch.fr>

On 01/25/2013 08:38 PM, T?r?k Edwin wrote:
> * camlp4o     - for better syntax errors (see http://caml.inria.fr/mantis/view.php?id=5068). This is a time-saver during development

Interesting.  It would certainly be useful to improve OCaml syntax error 
messages.  There has been some improvements recently, with the addition 
of some explicit error rules, but more work (or maybe a different 
approach as the one you suggest in the note of this ticket) would be needed.

Of course, nothing will prevent you from continuing using camlp4 instead 
of the official OCaml parser, as a "local convenience" (code you might 
distribute will not depend on camlp4, at least if you don't start 
relying on differences between camlp4's ocaml parser and the official one).

> * js_of_ocaml - (blogpost says its not really needed if a different operator would be used)

Indeed, it was our first use of -ppx here at LexiFi.  Some version of it 
can be found there:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/trunk/experimental/frisch/js_syntax.ml?revision=12932&view=markup

Basically, instead of introducing new syntax (o ## m) to access, say, a 
Javascript property, we ask the user to write:

   JVS.(o.m)

In the scope of a local-open on the pseudo JVS module name, we interpret 
a few syntactic constructs as meaning something else.  We did the 
minimum work required to allow us playing with js_of_ocaml as part of an 
internship exploratory project.  Hopefully, the js_of_ocaml folks will 
pick up on that and provide all the required syntactic support, 
including for the creation of JS objects and so on.  (We could for 
instance use the following syntax: JVS.(object ... end).)

Note that we have reused the compact syntax for local opens in order to 
define a special "scope" where some constructions are interpreted 
differently.  Maybe we should keep two different kinds of node in the 
Parsetree to distinguish "let open M in e" from "M.(e)".  Or maybe we 
should introduce explicitly another kind of "named scope" to the OCaml 
grammar, to be interpreted by -ppx rewriters  (and this could be 
available not only for expressions, but also for other entities like 
patterns, types, etc).  Or maybe we can find a nice syntax for 
"attributes" which could be used for this kind of purposes.  Or is the 
solution based on piggy-backing the syntax for local opens just fine? 
Comments are welcome!


> * bisect      - haven't figured how to use ppx from oasis/ocamlfind, The camlp4 one is as simple as:
> 	$(SETUP) -build -tag pkg_bisect -tag pkg_str -tag syntax_camlp4o -tag syntax_bisect_pp $(BUILDFLAGS)

We use the -ppx version of Bisect here.  This is probably not supported 
by ocamlfind right now.  We simply add the following command-line options:

  * for compiling:
     -ppx ..../bisect_ppx$(EXE)	

  * for linking:
     -I <path_to_bisect>  bisect.cma (or .cmxa)


> camlp4 syntax extensions needed to build libraries that I use:
> lwt, tyxml (needs camlp4of), camlp4.macro

tyxml: my understanding is that support for quotations (with 
anti-quotations in them?) would be enough.

camlp4.macro:  does this refer to pa_macro?  It seems that this is more 
about conditional compilation than proper macro expansion.  I suspect 
that conditional compilation is used rarely enough in OCaml project, so 
that a slightly more verbose syntax would not a big deal.  Do you confirm?

See 
http://www.lexifi.com/blog/syntax-extensions-without-camlp4-lets-do-it 
for a -ppx based version of conditional compilation.  The syntax is:

   include IFDEF(SYMBOL)(struct
      ... (* structure items in case SYMBOL is defined *)
   end)(struct
      ... (* structure items in case SYMBOL is not defined *)
   end)



For lwt: this project (and similar ones) might justify some special 
extensions to the concrete grammar.  There are basically two approaches 
are:  either support "let-fix" operators directly in the OCaml or just 
extend the syntax and let -ppx rewriters to the job.  There are several 
variations around the first solution, but we could for instance allow 
defining let-fix operators like:

   let (let***) x f = ...

and then use them as:

  let*** x = e1 in e2

which would be just sugar for:

   (let***) e1 (fun x -> e2)

(here I've assumed that let-fix operators are made of the characters 
"l", "e", "t" followed by an non-empty sequence of "operator" characters.)

The second approach is simply to extend the parser to accept

   let*** x = e1 in e2

and represent this explicitly in the Parsetree (a -ppx rewriter will 
then have to be used to rewrite that to something the type-checker accepts).

Both approaches can be combined: a default behavior for let-fix 
operators, but with an explicit representation in the Parsetree, 
allowing -ppx rewriters to provide a different interpretation. 
Typically, lwt has a notion of parallel binding, which would probably 
require some custom support (-ppx).


> Syntax extensions I considered using but never got around to:
> pa-monad (didn't really need it), bitstring

pa-monad: Wojciech Meyer announced omonad, a -ppx version of pa_monad.

bitstring: see my comment in another post.  Conceptually, this is quite 
similar to Sedlex.  The question is whether we can come up with a 
reasonable syntax (either with standard patterns, or maybe with pattern 
quotations?).

> Also when initially learning OCaml I have used the revised syntax (camlp4r) quite heavily.
> Nowadays I write everything in the original syntax.
> While I wouldn't miss the revised syntax, I do think that its much easier to first learn the revised syntax so it'd be nice
> if the camlp4 replacement provided that as well.

See the other post.  -ppx is really aimed at "syntax extensions"
which are more about code generation (type-conv, sedlex, ...) or code 
manipulation (conditional compilation, ...) than actual changes to the 
concrete syntax.  When the concrete syntax is the main objective, I can 
see two different cases:

   - Small local syntactic additions, like the one implemented by 
pa_lwt: we should think about generic extension points in the official 
parser to support them (together with -ppx rewriters).  Or even direct 
support in the compiler when it makes sense (e.g. direct support for 
local opens is much better than pa_openin).

   - More pervasive changes to the whole language grammar (like the 
revised syntax):  this is really what -pp is good at, and I personally 
don't have plans to propose an alternative for these cases.  It's good 
that you can experiment with parsers written with any technology.  That 
said, while I can admit that alternative syntaxes are interesting for 
experiments or educational purposes, I believe that released source code 
(libraries, applications) should stick to the official syntax, to avoid 
fragmentation of the community and issues with editors/IDE.



Alain

From alain at frisch.fr  Mon Jan 28 12:15:06 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 13:15:06 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <1359044659.30715.4@samsung>
References: <510145A5.6030807@frisch.fr>
 <90C5BC201F264C4C902B4E7897660042@erratique.ch> <1359044659.30715.4@samsung>
Message-ID: <51066BCA.1020201@frisch.fr>

On 01/24/2013 05:24 PM, Gerd Stolpmann wrote:
> It's used in the tool, but only for stream parsing. I could also
> distribute the already-preprocessed file (and maybe I'll do so in the
> next release).
>
> Stream parsing is certainly one of the topics to discuss.

I've no idea how widely stream parsing is used.  Has anyone some 
intuition about this?

Stream parsers probably fall in the same category as bitstring or sedlex 
(custom notions of pattern matching).  It seems that stream parsers 
(which I'm not familiar with) require to be able to write expressions 
within "left-hand sides", which might require special support.  Or maybe 
the whole left-hand sides should just be quotations.

Anyway, for a basic infrastructure tool such as ocamlfind, I'd probably 
advocate for a "manual" solution which works out of the box with a basic 
OCaml installation (ocamlyacc or manual top-down parser).  Gerd: does 
that sound reasonable to you?


Alain


From edwin+ml-ocaml at etorok.net  Mon Jan 28 13:06:44 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Mon, 28 Jan 2013 15:06:44 +0200
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106694C.3020703@frisch.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
Message-ID: <510677E4.2000500@etorok.net>

On 01/28/2013 02:04 PM, Alain Frisch wrote:
> On 01/25/2013 08:38 PM, T?r?k Edwin wrote:
>> * camlp4o     - for better syntax errors (see http://caml.inria.fr/mantis/view.php?id=5068). This is a time-saver during development
> 
> Interesting.  It would certainly be useful to improve OCaml syntax error messages.  There has been some improvements recently, with the addition of some explicit error rules, but more work (or maybe a
> different approach as the one you suggest in the note of this ticket) would be needed.
> 
> Of course, nothing will prevent you from continuing using camlp4 instead of the official OCaml parser, as a "local convenience" (code you might distribute will not depend on camlp4, at least if you
> don't start relying on differences between camlp4's ocaml parser and the official one).
> 
>> * js_of_ocaml - (blogpost says its not really needed if a different operator would be used)
> 
> Indeed, it was our first use of -ppx here at LexiFi.  Some version of it can be found there:
> 
> http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/trunk/experimental/frisch/js_syntax.ml?revision=12932&view=markup
> 
> Basically, instead of introducing new syntax (o ## m) to access, say, a Javascript property, we ask the user to write:
> 
>   JVS.(o.m)
> 
> In the scope of a local-open on the pseudo JVS module name, we interpret a few syntactic constructs as meaning something else.  We did the minimum work required to allow us playing with js_of_ocaml as
> part of an internship exploratory project.  Hopefully, the js_of_ocaml folks will pick up on that and provide all the required syntactic support, including for the creation of JS objects and so on. 
> (We could for instance use the following syntax: JVS.(object ... end).)
> 
> Note that we have reused the compact syntax for local opens in order to define a special "scope" where some constructions are interpreted differently.  Maybe we should keep two different kinds of node
> in the Parsetree to distinguish "let open M in e" from "M.(e)".  Or maybe we should introduce explicitly another kind of "named scope" to the OCaml grammar, to be interpreted by -ppx rewriters  (and
> this could be available not only for expressions, but also for other entities like patterns, types, etc).  Or maybe we can find a nice syntax for "attributes" which could be used for this kind of
> purposes.  Or is the solution based on piggy-backing the syntax for local opens just fine? Comments are welcome!
> 
> 
>> * bisect      - haven't figured how to use ppx from oasis/ocamlfind, The camlp4 one is as simple as:
>>     $(SETUP) -build -tag pkg_bisect -tag pkg_str -tag syntax_camlp4o -tag syntax_bisect_pp $(BUILDFLAGS)
> 
> We use the -ppx version of Bisect here.  This is probably not supported by ocamlfind right now.  We simply add the following command-line options:
> 
>  * for compiling:
>     -ppx ..../bisect_ppx$(EXE)   
> 
>  * for linking:
>     -I <path_to_bisect>  bisect.cma (or .cmxa)
> 
> 
>> camlp4 syntax extensions needed to build libraries that I use:
>> lwt, tyxml (needs camlp4of), camlp4.macro
> 
> tyxml: my understanding is that support for quotations (with anti-quotations in them?) would be enough.
> 
> camlp4.macro:  does this refer to pa_macro?  It seems that this is more about conditional compilation than proper macro expansion.  I suspect that conditional compilation is used rarely enough in
> OCaml project, so that a slightly more verbose syntax would not a big deal.  Do you confirm?
> 
> See http://www.lexifi.com/blog/syntax-extensions-without-camlp4-lets-do-it for a -ppx based version of conditional compilation.  The syntax is:
> 
>   include IFDEF(SYMBOL)(struct
>      ... (* structure items in case SYMBOL is defined *)
>   end)(struct
>      ... (* structure items in case SYMBOL is not defined *)
>   end)
> 

This is for ocamlnet and ounit, I don't use it in my code.

Backward compatibility would be appreciated, especially for something as simple as IFDEF.
Otherwise if a library switches to use the new ppx-based tool, it will no longer build with OCaml 3.12.1 + the camlp4 based syntax.
In fact the uses of IFDEF are quite simple, and maybe a tool that uses the lexer from compiler-libs and performs a lex-time ifdef replacement would work.

Alternatively whenever a new ppx-based tool is released that requires a new syntax, its camlp4-based complement should be updated to support the new syntax as well.
But that is probably a lot of work for little benefit.

> 
> 
> For lwt: this project (and similar ones) might justify some special extensions to the concrete grammar.  There are basically two approaches are:  either support "let-fix" operators directly in the
> OCaml or just extend the syntax and let -ppx rewriters to the job.  There are several variations around the first solution, but we could for instance allow defining let-fix operators like:
> 
>   let (let***) x f = ...
> 
> and then use them as:
> 
>  let*** x = e1 in e2
> 
> which would be just sugar for:
> 
>   (let***) e1 (fun x -> e2)
> 
> (here I've assumed that let-fix operators are made of the characters "l", "e", "t" followed by an non-empty sequence of "operator" characters.)
> 
> The second approach is simply to extend the parser to accept
> 
>   let*** x = e1 in e2
> 
> and represent this explicitly in the Parsetree (a -ppx rewriter will then have to be used to rewrite that to something the type-checker accepts).
> 
> Both approaches can be combined: a default behavior for let-fix operators, but with an explicit representation in the Parsetree, allowing -ppx rewriters to provide a different interpretation.
> Typically, lwt has a notion of parallel binding, which would probably require some custom support (-ppx).

Thinking about backward compatibility again perhaps there should be more transformation phases:
 -ppl Parser.token -> Parser.token, this can transform 'lwt' into 'let***' (or whatever ppx expects) for backwards compat
 -ppx Parsetree -> Parsetree as currently

Also it'd be nice to have:
 -ppt Typedtree -> Typedtree for type-level transformations

> 
> 
>> Syntax extensions I considered using but never got around to:
>> pa-monad (didn't really need it), bitstring
> 
> pa-monad: Wojciech Meyer announced omonad, a -ppx version of pa_monad.
> 
> bitstring: see my comment in another post.  Conceptually, this is quite similar to Sedlex.  The question is whether we can come up with a reasonable syntax (either with standard patterns, or maybe
> with pattern quotations?).
> 
>> Also when initially learning OCaml I have used the revised syntax (camlp4r) quite heavily.
>> Nowadays I write everything in the original syntax.
>> While I wouldn't miss the revised syntax, I do think that its much easier to first learn the revised syntax so it'd be nice
>> if the camlp4 replacement provided that as well.
> 
> See the other post.  -ppx is really aimed at "syntax extensions"
> which are more about code generation (type-conv, sedlex, ...) or code manipulation (conditional compilation, ...) than actual changes to the concrete syntax.  When the concrete syntax is the main
> objective, I can see two different cases:
> 
>   - Small local syntactic additions, like the one implemented by pa_lwt: we should think about generic extension points in the official parser to support them (together with -ppx rewriters).  Or even
> direct support in the compiler when it makes sense (e.g. direct support for local opens is much better than pa_openin).
> 
>   - More pervasive changes to the whole language grammar (like the revised syntax):  this is really what -pp is good at, and I personally don't have plans to propose an alternative for these cases. 
> It's good that you can experiment with parsers written with any technology.  That said, while I can admit that alternative syntaxes are interesting for experiments or educational purposes, I believe
> that released source code (libraries, applications) should stick to the official syntax, to avoid fragmentation of the community and issues with editors/IDE.
> 

Will have to think about this more.

--Edwin

From yminsky at janestreet.com  Mon Jan 28 14:05:54 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 28 Jan 2013 09:05:54 -0500
Subject: [wg-camlp4] Planning for the different syntax extensions
Message-ID: <CACLX4jT7wpUhO5EO69o_9yLyQaeuhCKn29HM6mGqRPH_tM3zmw@mail.gmail.com>

I'm wondering if it would be worth putting up a page on a wiki
somewhere where we can organize our understanding of how different
syntax extensions could be handled in a -ppx world?  It might be nice
to have this include code-examples of ways in which syntax would have
to change to make these work.

Beyond that, what problems do we need to solve on this WG?  My mental
to-do list is something like:

- Reach a consensus that a -ppx based solution is a good way to
  replace camlp4 as a required part of the OCaml toolchain.

- Enumerate the major current syntax extensions, and for each one,
  determine how this could be handled in a -ppx world

- Figure out what additional syntax (annotations and the like) would
  need to be supported to make -ppx be able to handle the vast
  majority of uses.

- Settle on a proposed concrete syntax for the above.

Is that roughly what we should be aiming to do?

y

From anil at recoil.org  Mon Jan 28 14:08:21 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 28 Jan 2013 14:08:21 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAJMfKEW1Ls0mVOnx2SHJOyaPFLiULgEDsQiF0OUn+QxTuzCO=Q@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net>
 <CAJMfKEW1Ls0mVOnx2SHJOyaPFLiULgEDsQiF0OUn+QxTuzCO=Q@mail.gmail.com>
Message-ID: <8602D292-ED4F-48C1-9FC2-F5757763C738@recoil.org>

On 25 Jan 2013, at 20:52, Lukasz Stafiniak <lukstafi at gmail.com> wrote:

> My uses of camlp4:
> - "let try n = expr in expr with handlers"
> - LOGging
> - recently, matrix access/assignment like in bigarrays but for
> built-in arrays (long ago I also played with matlab-like notation)
> - js_of_ocaml
> - list comprehensions and pa_monad, but for educational purposes so far.

Could you expand on the logging and matrix ones (are they online anywhere?)

I'm interested in a universal logging extension that makes it easier to introduce lazy logging statements through code, but the existing ones are all a bit tied to their frameworks (e.g. Lwt_log).

Is the matrix access one just a variant of x.{4}.{5}, or does it do something cunning to reshape 2D arrays as well?

cheers,
Anil


From romain.bardou at inria.fr  Mon Jan 28 14:32:53 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Mon, 28 Jan 2013 15:32:53 +0100
Subject: [wg-camlp4] My experience with syntax extension
Message-ID: <51068C15.30402@inria.fr>

Hello,

Here is my experience with syntax extension, if it can help you. I know 
the goal of -ppx is not syntax extension but more AST rewriting, but well.

- When I was younger I wished for some easy way to add constructs such 
as foreach or stuff like that. Now I'm more for stability, reliability, 
uniformity, simplicity, anything which ensures my project will compile 
easily everywhere (even by, let's say, an impatient non-programmer on 
Windows). And I'm more used to functional programming idioms which make 
those syntax extensions irrelevant.

- I tried CamlP5 (when it was still CamlP4), had some fun, then CamlP4 
arrived with no documentation and lost me.

- I don't use any preprocessor at all nowadays. I think changing the 
syntax does not ease the compilation process nor the maintenance process 
(hard to read a non-standard syntax 6 months later ? and lack of support 
from emacs). I've always found other ways.

- The ones I have felt the most need for are local open ? which is now 
part of the language ? and Lwt-like syntax, especially for let-like 
constructions ? which seems to be considered by this working group as a 
potential candidate for official support in some way.

- I'm the author of Melt, which is a preprocessor. But I consider Melt 
to be a domain-specific language which happens to be friendly to OCaml 
users, not an OCaml extension. I did not use CamlP4, because I lacked 
the expertise ? as a result, error messages are terribly located.

- I think the Melt preprocessor could be rewritten as an AST rewriter 
using -ppx. This would probably be for the best, except for the special 
approach of quotations from Melt? Which is actually rather important though.

- I understand the OCaml AST quite well, and to me -ppx sounds simple 
and accessible.

- I use custom operators such as "let (++) =" when it's reasonable.

- I don't like the external, "meta" annotations (-pp in Makefile, 
mainly), which are required to compile a program which uses a 
preprocessor. Custom operators are great in that regard: they are a way 
to provide features which look like syntax extensions but which are 
actually part of the language.

- I would really like a way to specify, in a .ml file itself, that the 
file must be preprocessed using some given tool. This would remove the 
need to change the build process, and would make it clear to the reader 
of the file that it *must* be read with the extension in mind. This may 
not be easy for generic extenders such as CamlP4 but for a tool such as 
-ppx whose purpose is actually to use the official syntax, I think it 
should be discussed. If an extension is optional, for instance if it 
only adds debugging information, then it makes sense to use -ppx as an 
optional compilation flag.

- (somehow related, but not really) I found the recent changes to how 
tuareg indents my code very annoying, especially when my code has a lot 
of parentheses. Syntax extensions which allow me to have less 
parentheses have bonus points from me.

Overall, I'm very much in favor of -ppx + generic annotations entry 
points in official OCaml + official integration of largely recognized 
extensions. I would consider using your proposal, but probably never CamlP4.

Cheers,

-- 
Romain Bardou

From alain at frisch.fr  Mon Jan 28 14:33:48 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 15:33:48 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <510677E4.2000500@etorok.net>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net>
Message-ID: <51068C4C.8090801@frisch.fr>

On 01/28/2013 02:06 PM, T?r?k Edwin wrote:
> Backward compatibility would be appreciated, especially for something as simple as IFDEF.
 >...
> Thinking about backward compatibility again perhaps there should be more transformation phases:

Backward compatibility is an important topic, since the goal of this 
working group is to propose a migration plan.

My personal view is that we should not complexify our "target" (-ppx) 
only to support backward compatibility.  Clearly, -ppx will require some 
user-visible changes, since it is no longer an option to change the 
concrete syntax.  To take a concrete example, what should a project like 
js_of_ocaml do, once they have a fully functional -ppx version?
An option could be to keep maintaining their camlp4 extension in 
parallel, but extend it to support for the syntax chosen for the -ppx 
version.  The only benefit of it is that users stuck with older versions 
of ocaml can still move smoothly to the new syntax, so as to be ready to 
get rid of camlp4 at some point.  Other users don't need that: they can 
rewrite their project progressively (e.g. module per module) using both 
the camlp4 syntax extension and the -ppx rewriter, and then stop using 
camlp4 when everything has been rewritten.  Is it worth the effort to 
adapt the camlp4 extension to match the new syntax?  It's probably up to 
each project maintainer to decide (considering that supporting several 
versions of camlp4 is also quite challenging).  Who is really stuck with 
old versions of ocaml (and still wanting and able to use new versions of 
packages)?

> Also it'd be nice to have:
>   -ppt Typedtree -> Typedtree for type-level transformations

I don't believe this is a viable option.  Producing Typedtree without 
breaking invariants of the type system (and the type soundness) is 
extremely challenging.  I'd be more comfortable with supporting a 
"Typedtree -> Parsetree" pass, where you'd only need to be able to use 
information from the typedtree so as to produce fragments of code which 
are then type-checked again.  You don't need to fully understand 
everything in the Typedtree to do that, and the type-checker acts as a 
safety net.

OCamlPro worked on a project called "OCaml Templates" doing exactly 
that, but I don't know the status of this project.  (Someone from 
OCamlPro to comment?)


Alain



From alain at frisch.fr  Mon Jan 28 14:45:30 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 15:45:30 +0100
Subject: [wg-camlp4] Planning for the different syntax extensions
In-Reply-To: <CACLX4jT7wpUhO5EO69o_9yLyQaeuhCKn29HM6mGqRPH_tM3zmw@mail.gmail.com>
References: <CACLX4jT7wpUhO5EO69o_9yLyQaeuhCKn29HM6mGqRPH_tM3zmw@mail.gmail.com>
Message-ID: <51068F0A.3000103@frisch.fr>

On 01/28/2013 03:05 PM, Yaron Minsky wrote:
> I'm wondering if it would be worth putting up a page on a wiki
> somewhere where we can organize our understanding of how different
> syntax extensions could be handled in a -ppx world?  It might be nice
> to have this include code-examples of ways in which syntax would have
> to change to make these work.

I like this suggestion, but I propose to wait a little bit.  We can 
discuss on this mailing list about possible -ppx replacement for 
different camlp4 extensions, and then collect the information later, 
when some consensus is reached.

> Beyond that, what problems do we need to solve on this WG?  My mental
> to-do list is something like:
>
> - Reach a consensus that a -ppx based solution is a good way to
>    replace camlp4 as a required part of the OCaml toolchain.
>
> - Enumerate the major current syntax extensions, and for each one,
>    determine how this could be handled in a -ppx world
>
> - Figure out what additional syntax (annotations and the like) would
>    need to be supported to make -ppx be able to handle the vast
>    majority of uses.
>
> - Settle on a proposed concrete syntax for the above.
>
> Is that roughly what we should be aiming to do?

Yes.  See also the list of tasks in the email where I announced the 
creation of this working group ( 
http://lists.ocaml.org/pipermail/wg-camlp4/2013-January/000000.html ). 
The first important task, for me, is to get an idea of the most 
important uses of camlp4 and refine the intended scope of -ppx.

Alain

From hongboz at seas.upenn.edu  Mon Jan 28 14:47:18 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 09:47:18 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <51068C4C.8090801@frisch.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
Message-ID: <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>

Hi Alain,
   Is there any chance to see your current work to decide how hard it
would be to adapt p4 to your new syntax?
  Btw: do you have a clear idea how to implement ast lifting in ppx(
the meta filter in p4) which is an essential part in
quasi-quotation?(the stream parsers have non-trivial optimizations
which depends on it )
On Mon, Jan 28, 2013 at 9:33 AM, Alain Frisch <alain at frisch.fr> wrote:
> On 01/28/2013 02:06 PM, T?r?k Edwin wrote:
>>
>> Backward compatibility would be appreciated, especially for something as
>> simple as IFDEF.
>
>>...
>
>> Thinking about backward compatibility again perhaps there should be more
>> transformation phases:
>
>
> Backward compatibility is an important topic, since the goal of this working
> group is to propose a migration plan.
>
> My personal view is that we should not complexify our "target" (-ppx) only
> to support backward compatibility.  Clearly, -ppx will require some
> user-visible changes, since it is no longer an option to change the concrete
> syntax.  To take a concrete example, what should a project like js_of_ocaml
> do, once they have a fully functional -ppx version?
> An option could be to keep maintaining their camlp4 extension in parallel,
> but extend it to support for the syntax chosen for the -ppx version.  The
> only benefit of it is that users stuck with older versions of ocaml can
> still move smoothly to the new syntax, so as to be ready to get rid of
> camlp4 at some point.  Other users don't need that: they can rewrite their
> project progressively (e.g. module per module) using both the camlp4 syntax
> extension and the -ppx rewriter, and then stop using camlp4 when everything
> has been rewritten.  Is it worth the effort to adapt the camlp4 extension to
> match the new syntax?  It's probably up to each project maintainer to decide
> (considering that supporting several versions of camlp4 is also quite
> challenging).  Who is really stuck with old versions of ocaml (and still
> wanting and able to use new versions of packages)?
>
>
>> Also it'd be nice to have:
>>   -ppt Typedtree -> Typedtree for type-level transformations
>
>
> I don't believe this is a viable option.  Producing Typedtree without
> breaking invariants of the type system (and the type soundness) is extremely
> challenging.  I'd be more comfortable with supporting a "Typedtree ->
> Parsetree" pass, where you'd only need to be able to use information from
> the typedtree so as to produce fragments of code which are then type-checked
> again.  You don't need to fully understand everything in the Typedtree to do
> that, and the type-checker acts as a safety net.
>
> OCamlPro worked on a project called "OCaml Templates" doing exactly that,
> but I don't know the status of this project.  (Someone from OCamlPro to
> comment?)
>
>
> Alain
>
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4



-- 
-- Regards, Hongbo

From alain at frisch.fr  Mon Jan 28 15:03:28 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 16:03:28 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
Message-ID: <51069340.7050308@frisch.fr>

On 01/28/2013 03:47 PM, Hongbo Zhang wrote:
> Hi Alain,
>     Is there any chance to see your current work to decide how hard it
> would be to adapt p4 to your new syntax?

Which current work are you referring to?  The stuff about conditional 
compilation implemented on top of -ppx is there:

https://www.lexifi.com/blog/syntax-extensions-without-camlp4-lets-do-it

(I've just adapted the code to the current version of Ast_mapper.)

>    Btw: do you have a clear idea how to implement ast lifting in ppx(
> the meta filter in p4) which is an essential part in
> quasi-quotation?(the stream parsers have non-trivial optimizations
> which depends on it )

Unfortunately, I'm not sure to know what quasi-quotations are (compared 
to just "quotations" in camlp4 parlance).

Can you elaborate on which kinds of non-trivial optimizations in stream 
parser depend on ast lifting?  Compilers have implemented optimizations 
based on AST rewriting for decades without going meta, and I suspect 
that can probably be done for stream parser optimizations as well, but I 
might be proven wrong.


Alain

From darioteixeira at yahoo.com  Mon Jan 28 15:10:59 2013
From: darioteixeira at yahoo.com (Dario Teixeira)
Date: Mon, 28 Jan 2013 07:10:59 -0800 (PST)
Subject: [wg-camlp4] PG'OCaml and syntax proliferation
Message-ID: <1359385859.58820.YahooMailNeo@web120406.mail.ne1.yahoo.com>

Hi,


Another syntax extension to consider is PG'OCaml's.? Though it seems like
it can easily be adapted to the ppx system, it does raise an issue which I
think ought to be discussed.

Here's how code making use of embedded SQL in PG'OCaml currently looks like:
(the dbh parameter is the database handle)

? let fetch_users dbh =
??????? PGSQL(dbh) "select id, name from users"

This is syntactally incorrect, of course.? Therefore, any adaptation to the
ppx system will necessarily be backwards-incompatible with existing code
(not a big problem for me personally, but others may disagree).? As for
the new syntax, several possibilities exist.? A straightforward one would
be to lowercase the "PGSQL" token; embedded SQL statements would thus take
the form of fake function calls:

? let fetch_users dbh =
??????? pgsql(dbh) "select id, name from users"

Another possiblity would be for the SQL statements to be arguments to a fake
variant type constructor:

? let fetch_users dbh =
??????? PGSQL (dbh, "select id, name from users")

I could go on.? Anyway, regardless of choice, one issue comes to mind.
Presently, code using the PG'OCaml syntax extension is conspicuous by its
syntactic incorrectness.? Therefore, someone unfamiliar with PG'OCaml who
happened to be looking at code using the syntax extension would immediately
suspect something camlp4ish was going on.? With ppx, this signaling would
go away.? This could make code harder to read if several syntax extensions
are simultaneously used, particularly if syntax extensions become more
popular because ppx makes it so much easier to write them.

One solution is for the community to adopt conventions that make syntax
extensions stand out to the naked eye (syntax highlighters in Vim or Emacs
could also take advantage of these conventions).? For example: the fake variant
constructor could be instead a fake PV constructor ending in "'" (prime).
It should not be hard for editors to highlight this code in a special way:

? let fetch_users dbh =
??????? `PGSQL' (dbh, "select id, name from users")

What do you think?

Best regards,
Dario Teixeira


From hongboz at seas.upenn.edu  Mon Jan 28 15:14:20 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 10:14:20 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <51069340.7050308@frisch.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <51069340.7050308@frisch.fr>
Message-ID: <CANcqPu6Oin5CuHLX51fW1yfpBv_NkfX3iV7A4RT9v_B8=+3RBw@mail.gmail.com>

On Mon, Jan 28, 2013 at 10:03 AM, Alain Frisch <alain at frisch.fr> wrote:

> Unfortunately, I'm not sure to know what quasi-quotations are (compared to
> just "quotations" in camlp4 parlance).
>
> Can you elaborate on which kinds of non-trivial optimizations in stream
> parser depend on ast lifting?
http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/trunk/camlp4/Camlp4Parsers/Camlp4OCamlRevisedParserParser.ml?view=markup

 Compilers have implemented optimizations
> based on AST rewriting for decades without going meta, and I suspect that
> can probably be done for stream parser optimizations as well, but I might be
> proven wrong.
That's true, but some domain specific optimizations are not implemented in
the compiler(and should not be).


let's keep it simple, suppose in the normal parsing phase
let a = 3  --> will be translated to an normal Parsetree A
<:str_item< let a = 3>> ---> will be translated to a Parsetree B
encoding the Parsetree A, is this the quotation you mean? if so, would
you mind elaborating a bit how to implement it?
>

>
> Alain



-- 
-- Regards, Hongbo

From xavier.clerc at inria.fr  Mon Jan 28 15:17:21 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Mon, 28 Jan 2013 16:17:21 +0100 (CET)
Subject: [wg-camlp4] Camlp4 uses
In-Reply-To: <1740380178.366565.1359385127796.JavaMail.root@inria.fr>
Message-ID: <70951260.390480.1359386241331.JavaMail.root@inria.fr>

Dear list,

As requested, here are my current uses of camlp4:
  1- in Bisect (code coverage tool), camlp4 is used
     to "inject" code;
  2- in Bolt (logging tool), camlp4 is used to provide
     a new "LOG ... LEVEL ..." expression (such expressions
     can be stripped at compile-time);
  3- in Mascot (style tool), camlp4 is used to get either
     a stream of lexical tokens or an AST, both being used
     to detect code smells;
  4- in Barista (library for handling of Java class files),
     camlp4 is used to provide @"..." and @'...' constructs
     akin to "..." and '...' ones except based upon UTF8;
  5- in Barista, camlp4 is also used to succinctly declare
     exceptions (*).


As previously stated by Alain, case 1 has already been
"ported" to ppx, with minimal effort. Case 4 seems easy
to support through ppx, and case 2 could as well modulo
a slight change in syntax (in the very same spirit as
what has been said about js_of_ocaml).

Case 3 may appear as a perfect fit for ppx, but indeed
it is quite pleasant to write some code smell in OCaml
syntax (through quotations), rather than by matching
against a bare AST. The latter becomes very verbose,
and very hard to read/maintain to say the least.

Case 5 may be adapted to ppx, at the cost of a syntax
change, which is not a big problem as the objective is
only to avoid writing boilerplate code.

At the end of the day, the only thing I am missing in
the current version of ppx is a quotation mechanism.
It is convenient to rely on such a mechanism in order
to easily either generate code, or match against code
patterns.


My two cents,

Xavier Clerc


(*) a small example should be self-explanatory:
  BARISTA_ERROR =
  | O -> "o"
  | A of (x : int) -> Printf.sprintf "%d" x
  | B of (y : float) * (z : string) * (t : char)-> Printf.sprintf "%f %S %C" y z t
being rewritten to:
  type error =
    | O
    | A of int
    | B of float * string * char
  exception Exception of error
  let fail e = raise (Exception e)
  let string_of_error e =
    match e with
    | O -> "o"
    | A x -> Printf.sprintf "%d" x
    | B ((y, z, t)) -> Printf.sprintf "%f %S %C" y z t
  let () =
    Printexc.register_printer
      (function | Exception e -> Some (string_of_error e) | _ -> None)



From edwin+ml-ocaml at etorok.net  Mon Jan 28 15:22:28 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Mon, 28 Jan 2013 17:22:28 +0200
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <51068C4C.8090801@frisch.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
Message-ID: <510697B4.3020804@etorok.net>

On 01/28/2013 04:33 PM, Alain Frisch wrote:
> On 01/28/2013 02:06 PM, T?r?k Edwin wrote:
>> Backward compatibility would be appreciated, especially for something as simple as IFDEF.
>>...
>> Thinking about backward compatibility again perhaps there should be more transformation phases:
> 
> Backward compatibility is an important topic, since the goal of this working group is to propose a migration plan.
> 
> My personal view is that we should not complexify our "target" (-ppx) only to support backward compatibility.  Clearly, -ppx will require some user-visible changes, since it is no longer an option to
> change the concrete syntax.  To take a concrete example, what should a project like js_of_ocaml do, once they have a fully functional -ppx version?
> An option could be to keep maintaining their camlp4 extension in parallel, but extend it to support for the syntax chosen for the -ppx version.  The only benefit of it is that users stuck with older
> versions of ocaml can still move smoothly to the new syntax, so as to be ready to get rid of camlp4 at some point.  Other users don't need that: they can rewrite their project progressively (e.g.
> module per module) using both the camlp4 syntax extension and the -ppx rewriter, and then stop using camlp4 when everything has been rewritten.  Is it worth the effort to adapt the camlp4 extension to
> match the new syntax?  It's probably up to each project maintainer to decide (considering that supporting several versions of camlp4 is also quite challenging).

Maybe the simplest solution to maintaining backwards compatibility is to ship pre-processed source code (using -ppx version) in release tarballs of libraries,
but that isn't without problems either:
+ you don't need to have 4.00.1 to build newer versions of libraries
+ you can switch to the -ppx syntax in your library
+ building the library doesn't require building/running the syntax extension
- you need a simple way to do this, i.e. oasis/OCamlMakefile/etc. should be updated to support this transparently
- ppx's output has to be converted to source code again, and that must be backwards compatible with older OCaml versions
- ppx transformations have to be architecture independent
- without an automated way to test the above it could easily break

>  Who is really stuck with old versions
> of ocaml (and still wanting and able to use new versions of packages)?

My use-case would be: I write an application that I want to be buildable at least with OCaml 3.12.1 and 4.00.1 (3.11.2 support would be nice, but not required).
The end-user doesn't have to be aware of what OCaml is, I just want them to run my application on their OS without having to build a compiler to do that.

Of course I can stick to the last version of a library that supports both (if they introduce an incompatibility) but then I'd have to backport
bugfixes to a private branch on my own. If it comes to that I'd rather figure a way to distribute preprocessed OCaml source code for the libraries that I use.

> 
>> Also it'd be nice to have:
>>   -ppt Typedtree -> Typedtree for type-level transformations
> 
> I don't believe this is a viable option.  Producing Typedtree without breaking invariants of the type system (and the type soundness) is extremely challenging.  I'd be more comfortable with supporting
> a "Typedtree -> Parsetree" pass, where you'd only need to be able to use information from the typedtree so as to produce fragments of code which are then type-checked again.  You don't need to fully
> understand everything in the Typedtree to do that, and the type-checker acts as a safety net.
> OCamlPro worked on a project called "OCaml Templates" doing exactly that, but I don't know the status of this project.  (Someone from OCamlPro to comment?)

That'd work too, although the -ppx based tool could do all that on its own. There wouldn't be any compiler changes required (i.e. no -ppt), just a library
like astmapper to simplify this task.

In fact my -ppl proposal is not really needed either, it could be just a library and the tool: a -pp based tool.

The tool would be invoked by -pp:
load all plugins
read source
use OCaml's lexer from compiler-libs to create tokens
apply any token mappers from the plugins
create the parsedtree using compiler-libs again
apply any astmappers from the plugins
run any ppx astmappers given on cmdline
create the typedtree using compiler-libs
apply and typedtree -> parsetree mappers from the plugins
output the ast

This would then be an almost drop-in replacement for camlp4, except that syntax extensions (plugins here) will depend on compiler-libs instead of camlp4,
and of course you would have similar limitations as -ppx, except you can modify the tokenstream as well.
I haven't checked how ocamlfind invokes camlp4 exactly, but it might be possible to reuse its camlp4 support for this.

Best regards,
--Edwin

From david.waern at gmail.com  Mon Jan 28 15:32:50 2013
From: david.waern at gmail.com (David Waern)
Date: Mon, 28 Jan 2013 16:32:50 +0100
Subject: [wg-camlp4] My uses of syntax extension
Message-ID: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>

Lukasz Stafiniak wrote:

> My uses of camlp4:
> - "let try n = expr in expr with handlers"

Could you explain what this means? Is the handler installed around the
first expression here only?

Thanks,
David

From alain.frisch at lexifi.com  Mon Jan 28 15:25:43 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 28 Jan 2013 16:25:43 +0100
Subject: [wg-camlp4] Improvements to the OCaml Parsetree
Message-ID: <51069877.5070307@lexifi.com>

Dear all,

Another useful topic for discussion related to -ppx are improvements to 
the OCaml Parsetree itself.  Of course, since the Parsetree is "going 
public" with -ppx, it make sense to improve it before too much code 
depend on it.

Let me list of few points I have in mind:

  - Get rid of some tuples / n-ary constructors in favor of proper 
record types (self-documented, more future proof).  Similarly, prefer 
explicit constructors to "bool" flags (although if we use more records, 
this is less of a problem).

  - Get rid of weird encodings in favor of more explicit representation. 
For instance, Pexp_when: guard expressions should be explicitly put next 
to patterns (or maybe allowed within the pattern algebra with some 
type-error if they are not at the toplevel).  Also, I'm not sure about 
the special "Pexp_assertfalse" node.  Do you have another examples?

  - Be more liberal about where Ptyp_poly must/might appear (the 
type-checker currently expect some dummy Ptyp_poly wrapper in some 
places, and the parser know that).

  - Avoid doing too much desugaring in the parser.  For instance, we 
should probably distinguish between "let open M in e" and "M.(e)" in the 
Parsetree.  Where to stop exactly, I'm not sure.  For instance, I don't 
have a clear opinion on whether record field punning should be handled 
purely in the parser or reflected in the Parsetree.  What do people here 
think?

  - This needs to be discussed, but what about remove those Ptyp_, 
Pexp_, ...., prefixes everywhere?  And similarly for record fields 
(ptype_, ...). Now that we have type-based disambiguation of 
constructors/labels, we don't really need those prefixes and they 
increase the verbosity of AST rewriters.  Some experimentation is 
needed, though.


Don't hesitate to comment on those points and add more!


Alain

From lpw25 at cam.ac.uk  Mon Jan 28 15:43:18 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 15:43:18 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>


>  Btw: do you have a clear idea how to implement ast lifting in ppx(
>the meta filter in p4) which is an essential part in
>quasi-quotation?(the stream parsers have non-trivial optimizations
>which depends on it )

I don't think that it is necessery for how I think we should implement 
anti-quotations.

If you consider some quotation with an anti-quotation like:

let body x = 
<:html < <body attr=$x$> Hello, World <\body> >>

When the quotation's parser sees the first "$" it knows it has found an 
anti-quotation. What it then needs to do is ask an OCaml parser to try to 
parse an expression with all the text up until the next unnested "$". With 
a bit of care we can provide this ability with the main compiler's parser 
(which can be linked to through comper-libs).

The quotation parser will then have an parsetree node of type expression. 
Since it is building a parsetree expression to replace the quotation, the 
parsetree node of the antiquotation can be included within this expression 
directly.


From romain.bardou at inria.fr  Mon Jan 28 15:43:49 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Mon, 28 Jan 2013 16:43:49 +0100
Subject: [wg-camlp4] Improvements to the OCaml Parsetree
In-Reply-To: <51069877.5070307@lexifi.com>
References: <51069877.5070307@lexifi.com>
Message-ID: <51069CB5.6000706@inria.fr>

Le 28/01/2013 16:25, Alain Frisch a ?crit :
> Dear all,
>
> Another useful topic for discussion related to -ppx are improvements to
> the OCaml Parsetree itself. Of course, since the Parsetree is "going
> public" with -ppx, it make sense to improve it before too much code
> depend on it.
>
> Let me list of few points I have in mind:
>
> - Get rid of some tuples / n-ary constructors in favor of proper record
> types (self-documented, more future proof). Similarly, prefer explicit
> constructors to "bool" flags (although if we use more records, this is
> less of a problem).

Good.

> - Get rid of weird encodings in favor of more explicit representation.
> For instance, Pexp_when: guard expressions should be explicitly put next
> to patterns (or maybe allowed within the pattern algebra with some
> type-error if they are not at the toplevel). Also, I'm not sure about
> the special "Pexp_assertfalse" node. Do you have another examples?

About assert false as a special node: I think it should stay like this.

It may add a case to treat, but the treatment will usually be trivial. 
If it is not, then it will probably be an instance of the assert case, 
in which case you can just call the assert case with <<false>> as an 
argument. Else it means that you have a very different treatment for 
false and in this case, you?re glad that they are separate.

Moreover, this case really is a special case as it is typed differently. 
I think it is better if the parse tree reflects this, so that the 
programmer is conscious of this when transforming assertions.

> - Be more liberal about where Ptyp_poly must/might appear (the
> type-checker currently expect some dummy Ptyp_poly wrapper in some
> places, and the parser know that).
>
> - Avoid doing too much desugaring in the parser. For instance, we should
> probably distinguish between "let open M in e" and "M.(e)" in the
> Parsetree. Where to stop exactly, I'm not sure. For instance, I don't
> have a clear opinion on whether record field punning should be handled
> purely in the parser or reflected in the Parsetree. What do people here
> think?

That?s a tricky one!!

> - This needs to be discussed, but what about remove those Ptyp_, Pexp_,
> ...., prefixes everywhere? And similarly for record fields (ptype_,
> ...). Now that we have type-based disambiguation of constructors/labels,
> we don't really need those prefixes and they increase the verbosity of
> AST rewriters. Some experimentation is needed, though.

I think it would probably be better if it is actually possible, yes.

-- 
Romain Bardou


From Fabrice.Le_fessant at inria.fr  Mon Jan 28 15:44:51 2013
From: Fabrice.Le_fessant at inria.fr (Fabrice Le Fessant)
Date: Mon, 28 Jan 2013 16:44:51 +0100
Subject: [wg-camlp4] My uses of syntax extension
Message-ID: <CAHvkLrNC4XmDbUBdoEfJGER+K_Bza_2evgBWyzqxBUBQoY=K2w@mail.gmail.com>

> From: Alain Frisch <alain at frisch.fr>
>> Also it'd be nice to have:
>>  -ppt Typedtree -> Typedtree for type-level transformations
>
> I don't believe this is a viable option.  Producing Typedtree without breaking invariants of the type system (and the type soundness) is extremely challenging.  I'd be more comfortable with supporting a "Typedtree -> Parsetree" pass, where you'd only need to be able to use information from the typedtree so as to produce fragments of code which are then type-checked again.  You don't need to fully understand everything in the Typedtree to do that, and the type-checker acts as a safety net.
>
> OCamlPro worked on a project called "OCaml Templates" doing exactly that, but I don't know the status of this project.  (Someone from OCamlPro to comment?)

What I did was to add a new quotation <:PARSER_NAME<STRING>> to the
syntax for expressions (and <#PARSER_NAME<STRING>> for toplevel
statements). Then, a new node would be produced in the parsetree,
containing both the PARSER_NAME and the STRING.

During typing, when the typer would find this node, it would try to
find a parser called PARSER_NAME in a database of parsers (loaded by
dynamic linking), use it to parse STRING and generate a parsetree from
it (sometimes, it would return a parsetree containing other quoted
nodes), that would be given to the typer immediatly.

One interesting thing is that the typer calls the parser with an Env.t
argument, i.e. the typing environment at the quotation, that can be
used to find the types of identifiers.

For example:

<@string_of<t>>

would be parsed by a parser "string_of", that would locate "t" among
types in the current environment, and generate a function to print it
in a string. The difference with "type_conv" is that the definition of
the type is exact, i.e. not a syntactic approximation.

Also, <:type_of<x>> can be used to return a type representation of the
type of variable "x" in the current env.

--Fabrice

From hongboz at seas.upenn.edu  Mon Jan 28 15:50:07 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 10:50:07 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>

On Mon, Jan 28, 2013 at 10:43 AM, Leo White <lpw25 at cam.ac.uk> wrote:

> I don't think that it is necessery for how I think we should implement
> anti-quotations.
>
> If you consider some quotation with an anti-quotation like:
>
> let body x = <:html < <body attr=$x$> Hello, World <\body> >>
>
The html example is trivial to implement in ppx, I agree.

Here is not the parser problem, it's the staging  problem when you
generalize it to the quotation "str_item" or "expr". Using the
built-in parser does not help here.



-- 
-- Regards, Hongbo

From alain at frisch.fr  Mon Jan 28 15:54:28 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 16:54:28 +0100
Subject: [wg-camlp4] PG'OCaml and syntax proliferation
In-Reply-To: <1359385859.58820.YahooMailNeo@web120406.mail.ne1.yahoo.com>
References: <1359385859.58820.YahooMailNeo@web120406.mail.ne1.yahoo.com>
Message-ID: <51069F34.6000007@frisch.fr>

On 01/28/2013 04:10 PM, Dario Teixeira wrote:
>    let fetch_users dbh =
>          PGSQL(dbh) "select id, name from users"
>
> This is syntactally incorrect, of course.

I've written Caml code for 17 years, and it was not clear to me that 
this is syntactically incorrect, I had to try...

As an alternative but close enough syntax, I suggest:

(PGSQL dbh) "select id, name from users"

or:

(PGSQL) dbg "select id, name from users"

Since a constructor never evaluates to a function, it remains clear 
enough that these two forms are special.

> I could go on.  Anyway, regardless of choice, one issue comes to mind.
> Presently, code using the PG'OCaml syntax extension is conspicuous by its
> syntactic incorrectness.    Therefore, someone unfamiliar with
 > PG'OCaml who happened to be looking at code using the syntax
 > extension would immediately suspect something camlp4ish was going on.

Good point.

What do you think of the proposals above?  They are "trivially" wrong 
OCaml code, although not on a strictly syntactic criterion (but a simple 
local typing criterion is close enough).

>    let fetch_users dbh =
>          `PGSQL' (dbh, "select id, name from users")

This is also an option.  I agree that it's a good idea to reach some 
consensus about such guidelines (and I know it will be difficult, as for 
any syntactic choice!).



Alain

From hongboz at seas.upenn.edu  Mon Jan 28 15:54:58 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 10:54:58 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
Message-ID: <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>

This paper may help you understand how quasi-quotation is implemented
http://ipaper.googlecode.com/git-history/969fbd798753dc0b10ea9efe5af7773ff10f728a/Miscs/why-its-nice-to-be-quoted.pdf
The problem is unlike Haskell, we don't have a nice generic
programming ability in ocaml(The Scrap your bolierpolate approach in
Haskell)

On Mon, Jan 28, 2013 at 10:50 AM, Hongbo Zhang <hongboz at seas.upenn.edu> wrote:
> On Mon, Jan 28, 2013 at 10:43 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>
>> I don't think that it is necessery for how I think we should implement
>> anti-quotations.
>>
>> If you consider some quotation with an anti-quotation like:
>>
>> let body x = <:html < <body attr=$x$> Hello, World <\body> >>
>>
> The html example is trivial to implement in ppx, I agree.
>
> Here is not the parser problem, it's the staging  problem when you
> generalize it to the quotation "str_item" or "expr". Using the
> built-in parser does not help here.
>
>
>
> --
> -- Regards, Hongbo



-- 
-- Regards, Hongbo

From Fabrice.Le_fessant at inria.fr  Mon Jan 28 15:58:57 2013
From: Fabrice.Le_fessant at inria.fr (Fabrice Le Fessant)
Date: Mon, 28 Jan 2013 16:58:57 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
Message-ID: <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>

On Mon, Jan 28, 2013 at 4:43 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>
>>  Btw: do you have a clear idea how to implement ast lifting in ppx(
>> the meta filter in p4) which is an essential part in
>> quasi-quotation?(the stream parsers have non-trivial optimizations
>> which depends on it )
>
>
> I don't think that it is necessery for how I think we should implement
> anti-quotations.
>
> If you consider some quotation with an anti-quotation like:
>
> let body x = <:html < <body attr=$x$> Hello, World <\body> >>

In my ocaml-templates approach, the "html" parser would just receive a
string "<body attr=$x$> Hello, World <\body>", and call its parser,
that would have to understand anti-quotations, by returning a node
Pquotation("ocaml", "x") telling the typer that it should call the
ocaml parser on the string "x"...

--Fabrice

From lukstafi at gmail.com  Mon Jan 28 16:22:15 2013
From: lukstafi at gmail.com (Lukasz Stafiniak)
Date: Mon, 28 Jan 2013 17:22:15 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <8602D292-ED4F-48C1-9FC2-F5757763C738@recoil.org>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net>
 <CAJMfKEW1Ls0mVOnx2SHJOyaPFLiULgEDsQiF0OUn+QxTuzCO=Q@mail.gmail.com>
 <8602D292-ED4F-48C1-9FC2-F5757763C738@recoil.org>
Message-ID: <CAJMfKEW8CaPsmTnALo85LMkH5oNQH09HNaS7dJaU_ruiywzprA@mail.gmail.com>

I forgot to mention that we also use optional compilation "IFDEF" / "ELSE".

On Mon, Jan 28, 2013 at 3:08 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On 25 Jan 2013, at 20:52, Lukasz Stafiniak <lukstafi at gmail.com> wrote:
>
>> My uses of camlp4:
>> - "let try n = expr in expr with handlers"
>> - LOGging
>> - recently, matrix access/assignment like in bigarrays but for
>> built-in arrays (long ago I also played with matlab-like notation)
>> - js_of_ocaml
>> - list comprehensions and pa_monad, but for educational purposes so far.
>
> Could you expand on the logging and matrix ones (are they online anywhere?)
>
> I'm interested in a universal logging extension that makes it easier to introduce lazy logging statements through code, but the existing ones are all a bit tied to their frameworks (e.g. Lwt_log).

http://sourceforge.net/p/toss/code-0/1821/tree/trunk/Toss/caml_extensions/pa_log.ml

> Is the matrix access one just a variant of x.{4}.{5}, or does it do something cunning to reshape 2D arrays as well?

The syntax is x.(4,5) and it currently translates into x.(4).(5); it
might be reasonable to use flat arrays but the main purpose is
readability.

http://sourceforge.net/p/toss/code-0/1821/tree/trunk/Toss/caml_extensions/pa_matrix.ml

From lpw25 at cam.ac.uk  Mon Jan 28 16:26:45 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 16:26:45 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>


>In my ocaml-templates approach, the "html" parser would just receive a
>string "<body attr=$x$> Hello, World <\body>", and call its parser,
>that would have to understand anti-quotations, by returning a node
>Pquotation("ocaml", "x") telling the typer that it should call the
>ocaml parser on the string "x"...

The problem with this method is that it does not support nested 
anti-quotations, or any other occurrence of the closing delimiter (the 
second "$") within the expression. You don't know whether "x" is the 
expression that needs to be parsed without asking the OCaml parser.


From lukstafi at gmail.com  Mon Jan 28 16:29:12 2013
From: lukstafi at gmail.com (Lukasz Stafiniak)
Date: Mon, 28 Jan 2013 17:29:12 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>
References: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>
Message-ID: <CAJMfKEUTHbibNMbUEDFfR=BAUDP06c8GD2dDsQNos2RVHO8_KQ@mail.gmail.com>

On Mon, Jan 28, 2013 at 4:32 PM, David Waern <david.waern at gmail.com> wrote:
> Lukasz Stafiniak wrote:
>
>> My uses of camlp4:
>> - "let try n = expr in expr with handlers"
>
> Could you explain what this means? Is the handler installed around the
> first expression here only?

Yes.

http://sourceforge.net/p/toss/code-0/1821/tree/trunk/Toss/caml_extensions/pa_let_try.ml
http://research.microsoft.com/en-us/um/people/akenn/sml/ExceptionalSyntax.pdf

From lpw25 at cam.ac.uk  Mon Jan 28 16:31:37 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 16:31:37 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>

> This paper may help you understand how quasi-quotation is implemented 
> http://ipaper.googlecode.com/git-history/969fbd798753dc0b10ea9efe5af7773ff10f728a/Miscs/why-its-nice-to-be-quoted.pdf

You only need the meta filter if you implement quotations using "option 1" 
(see Section 3.1 of the paper). "Option 2", which is what I described in my 
last post, works perfectly well without it.


From alain at frisch.fr  Mon Jan 28 16:42:18 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 17:42:18 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re:  Camlp4 uses)
In-Reply-To: <70951260.390480.1359386241331.JavaMail.root@inria.fr>
References: <70951260.390480.1359386241331.JavaMail.root@inria.fr>
Message-ID: <5106AA6A.8090006@frisch.fr>

On 01/28/2013 04:17 PM, Xavier Clerc wrote:
>    3- in Mascot (style tool), camlp4 is used to get either
>       a stream of lexical tokens or an AST, both being used
>       to detect code smells;
...
> Case 3 may appear as a perfect fit for ppx, but indeed
> it is quite pleasant to write some code smell in OCaml
> syntax (through quotations), rather than by matching
> against a bare AST. The latter becomes very verbose,
> and very hard to read/maintain to say the least.

I've the intuition that matching AST with patterns in a concrete syntax 
is a source of never lasting problems.  But it seems you disagree, so 
I'm very much interested in your experience!

Let me explain my point.

First, the parsing (concrete syntax -> AST) has some built-in 
ambiguities and resolution mechanism that the programmer does not even 
need to be aware of.  For instance, I cannot tell how a pattern like "p1 
| p2 | p3" or an expression "e1 || e2 || e3" is parsed without looking 
at the parser (or most probably, playing with -dparsetree).  Is the 
pattern parsed like "(p1 | p2) | p3" or "p1 | (p2 | p3)"?  The problem 
is that you might need to know such information if you write AST 
transformation/matching with concrete syntax.

Second, you need some special extra "concrete" syntax to be able to 
specify whether you care or not about some features.  For instance, you 
need to be able to write a pattern which matches a recursive let 
binding, or non-recursive let binding, or any kind of let binding 
(recursive or not).  In the latter case, you probably want to be able to 
extract the recursive flag for later use.  You need to introduce some 
syntax for that.  Similarly, we need some expert knowledge and specific 
syntax to know exactly what your "free variables" stand for: you need to 
be able to say that you want to match an arbitrary constructor or a 
constructor with no module prefix.  This is the source for a lot of 
complexity related to anti-quotations in camlp4, in my opinion.

Third, working on concrete syntax gives a false feeling that you don't 
need to master the abstract syntax, but this is wrong.  You need to know 
if "M.(e)" and "let open M in e" map to the same AST or not, if record 
punning is implemented in the parser or if is represented in the AST 
(exercise: define a "code smell rule" to detect missed punning 
opportunity, i.e. an instance of a record field "l = l"), etc.

Fourth, working with concrete syntax requires to master a new 
sub-language (with quotations, anti-quotations), which is far from 
trivial, and which looks like the real OCaml syntax but is not really 
the same.  There is a learning curve here, which should not be neglected.


At the end of the day, I find it both simpler and more robust to work on 
abstract syntax, even if this is marginally more verbose.  Some actions 
can reduce the syntactic overhead of working with abstract syntax: 
cleaning up the Parsetree (and removing prefixes) and improvements to 
our beloved host language itself (such as 
http://caml.inria.fr/mantis/view.php?id=5667 or even more ambitious 
extensions).  I'd rather see time invested in such improvements than on 
providing support for working with (almost-)concrete syntax.  But YMMV, 
and I'm very much interested to hear about the opinion and experience of 
other people on this topic.  (And of course, once quotations are 
supported, nothing prevent some -ppx rewriter to provide support for 
concrete-syntax matching, to be used for compiling other -ppx rewriters...)



Alain

From Fabrice.Le_fessant at inria.fr  Mon Jan 28 16:44:49 2013
From: Fabrice.Le_fessant at inria.fr (Fabrice Le Fessant)
Date: Mon, 28 Jan 2013 17:44:49 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
 <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>
Message-ID: <5106AB01.8050603@inria.fr>

On 01/28/2013 05:26 PM, Leo White wrote:
>
>> In my ocaml-templates approach, the "html" parser would just receive a
>> string "<body attr=$x$> Hello, World <\body>", and call its parser,
>> that would have to understand anti-quotations, by returning a node
>> Pquotation("ocaml", "x") telling the typer that it should call the
>> ocaml parser on the string "x"...
>
> The problem with this method is that it does not support nested
> anti-quotations, or any other occurrence of the closing delimiter (the
> second "$") within the expression. You don't know whether "x" is the
> expression that needs to be parsed without asking the OCaml parser.

Of course. For that, anyway, you need a "standard" of quotations and 
anti-quotations, i.e. all parsers must obey the rule that 
anti-quotations are between $...$ and quotations between <:XXX< ... >>.
Then, you don't need to know the syntax within the (anti-)quotations, 
you can delegate parsing at the time the parsetree is needed.

--Fabrice
-------------- next part --------------
A non-text attachment was scrubbed...
Name: fabrice_le_fessant.vcf
Type: text/x-vcard
Size: 380 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/b1748c41/attachment.vcf>

From anil at recoil.org  Mon Jan 28 16:45:19 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 28 Jan 2013 16:45:19 +0000
Subject: [wg-camlp4] Planning for the different syntax extensions
In-Reply-To: <CACLX4jT7wpUhO5EO69o_9yLyQaeuhCKn29HM6mGqRPH_tM3zmw@mail.gmail.com>
References: <CACLX4jT7wpUhO5EO69o_9yLyQaeuhCKn29HM6mGqRPH_tM3zmw@mail.gmail.com>
Message-ID: <38DF26ED-18E2-4258-BCDD-37F8FB803AF9@recoil.org>

On 28 Jan 2013, at 14:05, Yaron Minsky <yminsky at janestreet.com> wrote:

> I'm wondering if it would be worth putting up a page on a wiki
> somewhere where we can organize our understanding of how different
> syntax extensions could be handled in a -ppx world?  It might be nice
> to have this include code-examples of ways in which syntax would have
> to change to make these work.

I've been Doing Some Science (tm) via a bulk build of OPAM where we
replace all the camlp4 binaries with wrapper scripts that redirect
their command lines to a log directory.  This lets us grab a full
list of pa_*.cma files that are built, and then manually classify
them.  That should help populate the wiki when it's time to set it up.

The (incomplete) list of .cma files used in the build so far is below.
Some of these are clearly just support libraries (bigarray), and others
are from the compiler libs, but there's a good number that I haven't
seen before.  I'll update this list tomorrow when the bulk build is 
complete.

--
bigarray.cma
bin_prot.cma
bitstring.cma
bitstring_persistent.cma
comparelib.cma
cstruct-syntax.cma
fieldslib.cma
lwt-syntax.cma
lwt-syntax-log.cma
lwt-syntax-options.cma
netaccel.cma
netstring.cma
netstring-pcre.cma
netsys.cma
netsys_oothr.cma
nums.cma
odn.cma
optcomp.cma
oUnit.cma
pa_bin_prot.cma
pa_compare.cma
pa_deriving.cma
pa_dyntype.cma
pa_fields_conv.cma
../pa_meta_conv.cma
pa_odn.cma
pa_orakuda.cma
pa_ounit.cma
../../pa/pa_meta_conv.cma
pa_pipebang.cma
parsing/grammar.cma
pa_sexp_conv.cma
pa_type_conv.cma
pa_ulex.cma
pa_variants_conv.cma
pcre.cma
pxp_pp.cma
sexplib.cma
src/pa_do.cma
src/pa_do_nums.cma
src/pa_infix.cma
str.cma
syntax/pa_cow.cma
../syntax/pa_deriving.cma
unix.cma
variantslib.cma
xstrp4.cma


From alain at frisch.fr  Mon Jan 28 16:51:34 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 17:51:34 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106AB01.8050603@inria.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
 <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>
 <5106AB01.8050603@inria.fr>
Message-ID: <5106AC96.60906@frisch.fr>

On 01/28/2013 05:44 PM, Fabrice Le Fessant wrote:
> On 01/28/2013 05:26 PM, Leo White wrote:
>>
>>> In my ocaml-templates approach, the "html" parser would just receive a
>>> string "<body attr=$x$> Hello, World <\body>", and call its parser,
>>> that would have to understand anti-quotations, by returning a node
>>> Pquotation("ocaml", "x") telling the typer that it should call the
>>> ocaml parser on the string "x"...
>>
>> The problem with this method is that it does not support nested
>> anti-quotations, or any other occurrence of the closing delimiter (the
>> second "$") within the expression. You don't know whether "x" is the
>> expression that needs to be parsed without asking the OCaml parser.
>
> Of course. For that, anyway, you need a "standard" of quotations and
> anti-quotations, i.e. all parsers must obey the rule that
> anti-quotations are between $...$ and quotations between <:XXX< ... >>.
> Then, you don't need to know the syntax within the (anti-)quotations,
> you can delegate parsing at the time the parsetree is needed.

We need to be careful about lexical conventions: do we lex strings and 
comments as the standard lexer within quotations, for instance?  Do we 
provide a mechanism to escape the closing delimiters?

-- Alain

From lpw25 at cam.ac.uk  Mon Jan 28 17:00:56 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 17:00:56 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106AC96.60906@frisch.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
 <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>
 <5106AB01.8050603@inria.fr> <5106AC96.60906@frisch.fr>
Message-ID: <Prayer.1.3.5.1301281700560.32043@hermes-1.csi.cam.ac.uk>

On Jan 28 2013, Alain Frisch wrote:

>On 01/28/2013 05:44 PM, Fabrice Le Fessant wrote:
>> On 01/28/2013 05:26 PM, Leo White wrote:
>>>
>>>> In my ocaml-templates approach, the "html" parser would just receive a
>>>> string "<body attr=$x$> Hello, World <\body>", and call its parser,
>>>> that would have to understand anti-quotations, by returning a node
>>>> Pquotation("ocaml", "x") telling the typer that it should call the
>>>> ocaml parser on the string "x"...
>>>
>>> The problem with this method is that it does not support nested
>>> anti-quotations, or any other occurrence of the closing delimiter (the
>>> second "$") within the expression. You don't know whether "x" is the
>>> expression that needs to be parsed without asking the OCaml parser.
>>
>> Of course. For that, anyway, you need a "standard" of quotations and
>> anti-quotations, i.e. all parsers must obey the rule that
>> anti-quotations are between $...$ and quotations between <:XXX< ... >>.
>> Then, you don't need to know the syntax within the (anti-)quotations,
>> you can delegate parsing at the time the parsetree is needed.
>
>We need to be careful about lexical conventions: do we lex strings and 
>comments as the standard lexer within quotations, for instance?  Do we 
>provide a mechanism to escape the closing delimiters?

I don't think that we should lex anything other than the closing delimeter, 
that is, after all, the idea of a quotation.

Rather than providing an escape mechanism, it would be easier to provide 
multiple options for the delimers. For instance we could allow <:foo ?< 
(where ? is any character) to be matched by >?>, this makes it easy to 
avoid clashes.

We could also allow <:foo ?{  ... }?>, <:foo ?( ... )?> etc.

From Fabrice.Le_fessant at inria.fr  Mon Jan 28 17:01:14 2013
From: Fabrice.Le_fessant at inria.fr (Fabrice Le Fessant)
Date: Mon, 28 Jan 2013 18:01:14 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106AC96.60906@frisch.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
 <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>
 <5106AB01.8050603@inria.fr> <5106AC96.60906@frisch.fr>
Message-ID: <5106AEDA.4050305@inria.fr>

On 01/28/2013 05:51 PM, Alain Frisch wrote:
> On 01/28/2013 05:44 PM, Fabrice Le Fessant wrote:
>> Of course. For that, anyway, you need a "standard" of quotations and
>> anti-quotations, i.e. all parsers must obey the rule that
>> anti-quotations are between $...$ and quotations between <:XXX< ... >>.
>> Then, you don't need to know the syntax within the (anti-)quotations,
>> you can delegate parsing at the time the parsetree is needed.
>
> We need to be careful about lexical conventions: do we lex strings and
> comments as the standard lexer within quotations, for instance?  Do we
> provide a mechanism to escape the closing delimiters?

You would probably want to have "$$" => "$" to escape it, and
something similar for "<:" and ">>".

I think you have two sets of alternative levels, i.e. "even" and "odd" 
levels, $...$ can only appear in "even" levels, and <:...<...>> in "odd" 
levels, so you only need to escape delimiters in the levels where they 
can appear, no ?

--Fabrice
-------------- next part --------------
A non-text attachment was scrubbed...
Name: fabrice_le_fessant.vcf
Type: text/x-vcard
Size: 380 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/af16089f/attachment-0001.vcf>

From lpw25 at cam.ac.uk  Mon Jan 28 17:07:02 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 17:07:02 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106AEDA.4050305@inria.fr>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CAHvkLrPuDdadx7o43cKuW35Z1rZ_20MD+phrAXCx2Jwga=TPHA@mail.gmail.com>
 <Prayer.1.3.5.1301281626450.32043@hermes-1.csi.cam.ac.uk>
 <5106AB01.8050603@inria.fr> <5106AC96.60906@frisch.fr>
 <5106AEDA.4050305@inria.fr>
Message-ID: <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>

>You would probably want to have "$$" => "$" to escape it, and
>something similar for "<:" and ">>".
>
>I think you have two sets of alternative levels, i.e. "even" and "odd" 
>levels, $...$ can only appear in "even" levels, and <:...<...>> in "odd" 
>levels, so you only need to escape delimiters in the levels where they 
>can appear, no ?

I think it would be better to leave parsing anti-quotations to the 
quotations themselves, rather than forcing everyone to use $...$. For many 
situations $...$ is much more heavyweight syntax than necessary.


From david.waern at gmail.com  Mon Jan 28 17:13:34 2013
From: david.waern at gmail.com (David Waern)
Date: Mon, 28 Jan 2013 18:13:34 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAJMfKEUTHbibNMbUEDFfR=BAUDP06c8GD2dDsQNos2RVHO8_KQ@mail.gmail.com>
References: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>
 <CAJMfKEUTHbibNMbUEDFfR=BAUDP06c8GD2dDsQNos2RVHO8_KQ@mail.gmail.com>
Message-ID: <CAN8ZjBEV57pAUD4Urfr19+NQK2yiuo2gVvV7Ef2bp4t2E7iDfA@mail.gmail.com>

2013/1/28 Lukasz Stafiniak <lukstafi at gmail.com>:
> On Mon, Jan 28, 2013 at 4:32 PM, David Waern <david.waern at gmail.com> wrote:
>> Lukasz Stafiniak wrote:
>>
>>> My uses of camlp4:
>>> - "let try n = expr in expr with handlers"
>>
>> Could you explain what this means? Is the handler installed around the
>> first expression here only?
>
> Yes.
>
> http://sourceforge.net/p/toss/code-0/1821/tree/trunk/Toss/caml_extensions/pa_let_try.ml
> http://research.microsoft.com/en-us/um/people/akenn/sml/ExceptionalSyntax.pdf

OK. I've also wanted similar syntax, but I've noticed that if Alain's
"static exceptions" [1] proposal is accepted then encoding such things
using existing OCaml syntax becomes a bit lighter:

try raise (`Cont expr) with
| `Cont n -> expr
| handlers

[1]: http://www.lexifi.com/blog/static-exceptions

David

From virgile.prevosto at m4x.org  Mon Jan 28 17:18:52 2013
From: virgile.prevosto at m4x.org (Virgile Prevosto)
Date: Mon, 28 Jan 2013 18:18:52 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <51066BCA.1020201@frisch.fr>
References: <510145A5.6030807@frisch.fr>
 <90C5BC201F264C4C902B4E7897660042@erratique.ch>
 <1359044659.30715.4@samsung> <51066BCA.1020201@frisch.fr>
Message-ID: <CA+yPOVhXtvV5dESJK8=fH2AM6cU2mp0Y2CMDHpKRBDBxybh0Jw@mail.gmail.com>

Hello,

2013/1/28 Alain Frisch <alain at frisch.fr>:

>> Stream parsing is certainly one of the topics to discuss.
>
>
> I've no idea how widely stream parsing is used.  Has anyone some intuition
> about this?
>

Well, it's about the only camlp4 "extension" that I'm using. It's
quite convenient for parsing things that are too complex for regexps
but do not require a full-blown menhir/ocamlyacc grammar. And like
Gerd, I'd find it a bit sad if a feature that once belonged to core
OCaml syntax was to disappear.

Best regards,
-- 
E tutto per oggi, a la prossima volta
Virgile

From hongboz at seas.upenn.edu  Mon Jan 28 17:22:48 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 12:22:48 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
 <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>

I suggest that you might think twice before you think it's a viable option
---------------------------
2. *Copy and paste, creating two new versions of the parser. *One
version will directly return Haskell abstract syntax for a Haskell
pattern, and the other will return Haskell abstract syntax for an
expression.
*This is potentially a maintenance nightmare.*
Furthermore, we lose a lot of the bene?ts of the type checker:
a value of type TH.ExpQ is Haskell abstract syntax for an
expression, but knowing this tells us nothing about the type of
the Haskell expression represented by the abstract syntax. This
expression could be an Integer, a String or have any other
type?we know only that it is syntactically correct, not that it is
type correct.

On Mon, Jan 28, 2013 at 11:31 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>> This paper may help you understand how quasi-quotation is implemented
>>
http://ipaper.googlecode.com/git-history/969fbd798753dc0b10ea9efe5af7773ff10f728a/Miscs/why-its-nice-to-be-quoted.pdf
>
>
> You only need the meta filter if you implement quotations using "option 1"
> (see Section 3.1 of the paper). "Option 2", which is what I described in
my
> last post, works perfectly well without it.
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/d64221d3/attachment.html>

From alain at frisch.fr  Mon Jan 28 17:55:02 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 18:55:02 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAN8ZjBEV57pAUD4Urfr19+NQK2yiuo2gVvV7Ef2bp4t2E7iDfA@mail.gmail.com>
References: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>
 <CAJMfKEUTHbibNMbUEDFfR=BAUDP06c8GD2dDsQNos2RVHO8_KQ@mail.gmail.com>
 <CAN8ZjBEV57pAUD4Urfr19+NQK2yiuo2gVvV7Ef2bp4t2E7iDfA@mail.gmail.com>
Message-ID: <5106BB76.6030804@frisch.fr>

On 01/28/2013 06:13 PM, David Waern wrote:
> OK. I've also wanted similar syntax, but I've noticed that if Alain's
> "static exceptions" [1] proposal is accepted then encoding such things
> using existing OCaml syntax becomes a bit lighter:
>
> try raise (`Cont expr) with
> | `Cont n -> expr
> | handlers

As a side note, this encoding with static exceptions is also much more 
efficient (no allocation required to escape from the exception handler).

Still, this is a good example.  One might indeed want to use a dedicated 
syntax for this common idiom.  My preference would be for extending the 
official language to support it directly.  If one thinks it is generally 
useful, why not put it in the language itself?  It is not difficult to 
extend OCaml to support it directly.

If the proposal is rejected but we have let-fix operators, one can 
decide to have a -ppx rewriter detecting and rewriting the following form:

let? x = try e1 with p -> e2 in
e3


-- Alain

From lukstafi at gmail.com  Mon Jan 28 18:12:38 2013
From: lukstafi at gmail.com (Lukasz Stafiniak)
Date: Mon, 28 Jan 2013 19:12:38 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106BB76.6030804@frisch.fr>
References: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>
 <CAJMfKEUTHbibNMbUEDFfR=BAUDP06c8GD2dDsQNos2RVHO8_KQ@mail.gmail.com>
 <CAN8ZjBEV57pAUD4Urfr19+NQK2yiuo2gVvV7Ef2bp4t2E7iDfA@mail.gmail.com>
 <5106BB76.6030804@frisch.fr>
Message-ID: <CAJMfKEXv5sPxcEiZKVfptTAqiVKpMwnU6FY4Ge56CBxWHo2sVg@mail.gmail.com>

On Mon, Jan 28, 2013 at 6:55 PM, Alain Frisch <alain at frisch.fr> wrote:
>
> As a side note, this encoding with static exceptions is also much more
> efficient (no allocation required to escape from the exception handler).
>
> Still, this is a good example.  One might indeed want to use a dedicated
> syntax for this common idiom.  My preference would be for extending the
> official language to support it directly.  If one thinks it is generally
> useful, why not put it in the language itself?  It is not difficult to
> extend OCaml to support it directly.
>
> If the proposal is rejected but we have let-fix operators, one can decide to
> have a -ppx rewriter detecting and rewriting the following form:
>
> let? x = try e1 with p -> e2 in
> e3

In discussion on ocaml-batteries list, a syntax like the above was in
a tie with the syntax I prefer (and which is used in tutorials about
camlp4/camlp5)...

From alain at frisch.fr  Mon Jan 28 18:23:21 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 19:23:21 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <CA+yPOVhXtvV5dESJK8=fH2AM6cU2mp0Y2CMDHpKRBDBxybh0Jw@mail.gmail.com>
References: <510145A5.6030807@frisch.fr>
 <90C5BC201F264C4C902B4E7897660042@erratique.ch> <1359044659.30715.4@samsung>
 <51066BCA.1020201@frisch.fr>
 <CA+yPOVhXtvV5dESJK8=fH2AM6cU2mp0Y2CMDHpKRBDBxybh0Jw@mail.gmail.com>
Message-ID: <5106C219.3090401@frisch.fr>

On 01/28/2013 06:18 PM, Virgile Prevosto wrote:
> Well, it's about the only camlp4 "extension" that I'm using. It's
> quite convenient for parsing things that are too complex for regexps
> but do not require a full-blown menhir/ocamlyacc grammar. And like
> Gerd, I'd find it a bit sad if a feature that once belonged to core
> OCaml syntax was to disappear.

A general point here: the goal here is not to kill camlp4 and associated 
extensions, but rather to free the basic OCaml ecosystem from its 
dependency to camlp4 in a reasonable time frame.  For instance, I find 
it quite important that ocamlfind could be compiled/maintained without 
camlp4 (if only to make it usable with MetaOCaml, LexiFi's variant of 
OCaml, or the next cool experimental patch to OCaml, etc), and if it's 
easier to rewrite its parser with ocamlyacc or as a manual recursive 
descent one than to develop a replacement for camlp4's stream parsing 
extension, I believe it is a good idea to go this way.  Of course, Gerd 
has to decide!  Even if someone finally decides to write the stream 
parsing stuff based on -ppx, it make sense to me that ocamlfind has a 
minimal number of external dependencies, so it would not be a waste of 
time anyway.

Is anyone else using stream parsers?

Alain

From lpw25 at cam.ac.uk  Mon Jan 28 18:25:40 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 18:25:40 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
 <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301281825400.19837@hermes-1.csi.cam.ac.uk>


>I suggest that you might think twice before you think it's a viable option
>---------------------------
>2. *Copy and paste, creating two new versions of the parser. *One
>version will directly return Haskell abstract syntax for a Haskell
>pattern, and the other will return Haskell abstract syntax for an
>expression.
>*This is potentially a maintenance nightmare.*

This part is referring to needing two parsing functions: one for the when 
the quotation is used as a pattern and one for when it is used as an 
expression. I don't think that needing two parsing functions is really a 
"maintenance nightmare". Also, with GADTs they don't need to be two 
separate functions anyway.

>Furthermore, we lose a lot of the bene?ts of the type checker:
>a value of type TH.ExpQ is Haskell abstract syntax for an
>expression, but knowing this tells us nothing about the type of
>the Haskell expression represented by the abstract syntax. This
>expression could be an Integer, a String or have any other
>type?we know only that it is syntactically correct, not that it is
>type correct.

This is a fair criticism: parsing to a value and then converting that into 
an AST fragment may catch some potential errors in a parser. However, this 
safety could also be obtained by creating the value and the AST in 
parallel, and simply discarding the data structure when parsing is 
finished. This may not be as "neat" as deriving the AST from the value, but 
it is also requires no special support.




From yminsky at janestreet.com  Mon Jan 28 18:29:19 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 28 Jan 2013 13:29:19 -0500
Subject: [wg-camlp4] How Jane Street uses camlp4
Message-ID: <CACLX4jRa6rp1LxiUPA7fgq4pUdEJBBq5y1JRgj7J_jvsELfg4A@mail.gmail.com>

Let me rattle a few off:

- type-conv style extensions.

  These include bin-prot, sexplib, fieldslib, variantslib, pa_compare...

  A few things to note about these:

  - generators may take argument, like [type t = ... with
    typehash(abstract)]. The generator is one that specifies how to
    parse the arguments (although they have to be well
    parenthesized). In the examples I can think of, either a few
    identifiers are accepted or, in a couple of cases, arbitrary
    expressions are accepted.
  - there can be generators (with optional argument too) on record
    field:

         type t =
           { a : int with default(2), sexp_drop_if(fun x -> x = 2);
           } with sexp

  - We also have some that rely only on quotations. The inside of
    quotations are usually types, sometimes expressions.

- pa_ounit: this gives a lightweight syntax for unit-testing.  You can
  write:

      TEST = <some expression>

  and it does a bunch of camlp4 magic, including capturing the text
  and location of the expression, as part of reporting a unit test
  failure effectively.  A test that runs the code is registered, but
  the actual code isn't run except when unit tests are run.

  You can also do:

      TEST_MODULE = struct ... end

  to create a whole module that won't be instantiated except within
  the running of a unit test.

- pa_nonrec: this is a small extension that adds the ability to
  define a type non-recursively.  Thus, you can write:

      type t
      module M = struct type nonrec t = t list end

  rather than the more annoying:

      type t
      module M = struct type z = t type t = z list end

- pa_pipebang: this converts

     <expr1> |! <expr2>

  into

    <expr2> (expr1)

  which is faster than a naively implemented |! operator

- pa_here: this converts the string _here_ to a source-code location.

- pa_custom_printf: If you put ! before a format string, it allows the
  use of a spec like "%{<Module>}" in the format string.  For example,
  using "%{Time}" wraps [Time.to_string] around the appropriate
  argument.

  It also allows different formats for a given type:
  "%{<Module>.<identifier>}" wraps <Module>.Format.<identifier> around
  the appropriate argument.  For example, "%{Float.pretty}" would wrap
  [Float.Format.pretty] around the appropriate argument.

From hongboz at seas.upenn.edu  Mon Jan 28 19:02:55 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 14:02:55 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301281825400.19837@hermes-1.csi.cam.ac.uk>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
 <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>
 <Prayer.1.3.5.1301281825400.19837@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu42_eJhD-WkQBzAXq9xdTnp9u_tnxVopCUHnDZcmb9DyA@mail.gmail.com>

3 parsers actually.
The original parser, the parser to patt, the parser to expr.
Besides, every user has to maintain 3 parsers if they want to use the
quotation, not only the compiler maintainer.
I would be happy to see a prototype work before other changes

On Mon, Jan 28, 2013 at 1:25 PM, Leo White <lpw25 at cam.ac.uk> wrote:

>
>  I suggest that you might think twice before you think it's a viable option
>> ---------------------------
>> 2. *Copy and paste, creating two new versions of the parser. *One
>>
>> version will directly return Haskell abstract syntax for a Haskell
>> pattern, and the other will return Haskell abstract syntax for an
>> expression.
>> *This is potentially a maintenance nightmare.*
>>
>
> This part is referring to needing two parsing functions: one for the when
> the quotation is used as a pattern and one for when it is used as an
> expression. I don't think that needing two parsing functions is really a
> "maintenance nightmare". Also, with GADTs they don't need to be two
> separate functions anyway.
>
>
>  Furthermore, we lose a lot of the bene?ts of the type checker:
>> a value of type TH.ExpQ is Haskell abstract syntax for an
>> expression, but knowing this tells us nothing about the type of
>> the Haskell expression represented by the abstract syntax. This
>> expression could be an Integer, a String or have any other
>> type?we know only that it is syntactically correct, not that it is
>> type correct.
>>
>
> This is a fair criticism: parsing to a value and then converting that into
> an AST fragment may catch some potential errors in a parser. However, this
> safety could also be obtained by creating the value and the AST in
> parallel, and simply discarding the data structure when parsing is
> finished. This may not be as "neat" as deriving the AST from the value, but
> it is also requires no special support.
>
>
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/198dd668/attachment.html>

From info at gerd-stolpmann.de  Mon Jan 28 20:21:20 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Mon, 28 Jan 2013 21:21:20 +0100
Subject: [wg-camlp4] PG'OCaml and syntax proliferation
In-Reply-To: <51069F34.6000007@frisch.fr> (from alain@frisch.fr on Mon Jan
 28 16:54:28 2013)
Message-ID: <1359404480.10634.6@samsung>

Am 28.01.2013 16:54:28 schrieb(en) Alain Frisch:
> On 01/28/2013 04:10 PM, Dario Teixeira wrote:
>>    let fetch_users dbh =
>>          PGSQL(dbh) "select id, name from users"
>> 
>> This is syntactally incorrect, of course.
> 
> I've written Caml code for 17 years, and it was not clear to me that  
> this is syntactically incorrect, I had to try...
> 
> As an alternative but close enough syntax, I suggest:
> 
> (PGSQL dbh) "select id, name from users"
> 
> or:
> 
> (PGSQL) dbg "select id, name from users"
> 
> Since a constructor never evaluates to a function, it remains clear  
> enough that these two forms are special.
> 
>> I could go on.  Anyway, regardless of choice, one issue comes to  
>> mind.
>> Presently, code using the PG'OCaml syntax extension is conspicuous  
>> by its
>> syntactic incorrectness.    Therefore, someone unfamiliar with
> > PG'OCaml who happened to be looking at code using the syntax
> > extension would immediately suspect something camlp4ish was going  
> on.
> 
> Good point.
> 
> What do you think of the proposals above?  They are "trivially" wrong  
> OCaml code, although not on a strictly syntactic criterion (but a  
> simple local typing criterion is close enough).
> 
>>    let fetch_users dbh =
>>          `PGSQL' (dbh, "select id, name from users")
> 
> This is also an option.  I agree that it's a good idea to reach some  
> consensus about such guidelines (and I know it will be difficult, as  
> for any syntactic choice!).

I think there are actually two points:

  - whether we want special extensions to the Parsetree for
    preprocessing
  - whether we want special notations for these extensions
    (good for tools, bad for my mind because OCaml is already
    so overloaded with notations)

The second point is not obligatory if you choose to implement the  
first. For example, an extension could register PGSQL as extension  
token. Extension tokens would be handled as a separate type of token by  
the parser. We would then allow

   <exttoken> <expr>+

in expressions and

   <exttoken> <pattern>+

in patterns. We could also define more grammar extensions on type,  
structure and signature level. This way we could "relax" the OCaml  
grammar a bit, without introducing too much new syntactical ideas.

Gerd


> 
> 
> 
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From info at gerd-stolpmann.de  Mon Jan 28 20:28:27 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Mon, 28 Jan 2013 21:28:27 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk> (from
 lpw25@cam.ac.uk on Mon Jan 28 18:07:02 2013)
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
Message-ID: <1359404907.10634.7@samsung>

Am 28.01.2013 18:07:02 schrieb(en) Leo White:
>> You would probably want to have "$$" => "$" to escape it, and
>> something similar for "<:" and ">>".
>> 
>> I think you have two sets of alternative levels, i.e. "even" and  
>> "odd" levels, $...$ can only appear in "even" levels, and  
>> <:...<...>> in "odd" levels, so you only need to escape delimiters  
>> in the levels where they can appear, no ?
> 
> I think it would be better to leave parsing anti-quotations to the  
> quotations themselves, rather than forcing everyone to use $...$. For  
> many situations $...$ is much more heavyweight syntax than necessary.

Typographically, $ is a mistake.

Look for something lighter, and it is probably application-dependent  
what the best alternative is. E.g. for my XML preprocessor  
(http://projects.camlcity.org/projects/dl/pxp-1.2.3/doc/manual/html/ref/Intro_preprocessor.html)  
I used (: ... :) for anti-quotations.

I second Leo's idea to leave it to the preprocessor.

Gerd


> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From lpw25 at cam.ac.uk  Mon Jan 28 21:01:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 28 Jan 2013 21:01:12 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu42_eJhD-WkQBzAXq9xdTnp9u_tnxVopCUHnDZcmb9DyA@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
 <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>
 <Prayer.1.3.5.1301281825400.19837@hermes-1.csi.cam.ac.uk>
 <CANcqPu42_eJhD-WkQBzAXq9xdTnp9u_tnxVopCUHnDZcmb9DyA@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301282101120.21455@hermes-1.csi.cam.ac.uk>

>3 parsers actually.
>The original parser, the parser to patt, the parser to expr.

The original parser isn't necessary for the quotation, and of course the 
other two parsers are only both needed if you want the quotation to work as 
both a pattern and an expression.

Anyway, my point is that you do not *need* to implement quotations by 
parsing to a value and then converting to an AST fragment, in fact it is 
often easier not to.

That is not to say that some people might not want to implement their 
quotations by parsing to a value and then converting to an AST fragment. In 
fact, if they want to use an external parser (over which they have little 
control) to parse their quotations then they may have to do it that way.

For these cases I think there are three options:

1. They can implement conversion functions by hand.

2. They could use some kind of type-conv style extension to automatically 
produce the conversion functions. I'm sure such an extension would be 
welcomed by other extension authors.

3. If/when some kind of run-time type representation is added to the 
language, it could be used to create a generic conversion function.


From alain at frisch.fr  Mon Jan 28 21:02:23 2013
From: alain at frisch.fr (Alain Frisch)
Date: Mon, 28 Jan 2013 22:02:23 +0100
Subject: [wg-camlp4] PG'OCaml and syntax proliferation
In-Reply-To: <1359404480.10634.6@samsung>
References: <1359404480.10634.6@samsung>
Message-ID: <5106E75F.10100@frisch.fr>

On 1/28/2013 9:21 PM, Gerd Stolpmann wrote:
> The second point is not obligatory if you choose to implement the first.
> For example, an extension could register PGSQL as extension token.
> Extension tokens would be handled as a separate type of token by the
> parser.

-ppx is about letting external processes rewrite already parsed ASTs. 
This does not sound compatible with this approach, unless I missed your 
point.

Alain

From info at gerd-stolpmann.de  Mon Jan 28 21:12:13 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Mon, 28 Jan 2013 22:12:13 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <51066BCA.1020201@frisch.fr> (from alain@frisch.fr on Mon Jan
 28 13:15:06 2013)
Message-ID: <1359407533.10634.8@samsung>

Am 28.01.2013 13:15:06 schrieb(en) Alain Frisch:
> On 01/24/2013 05:24 PM, Gerd Stolpmann wrote:
>> It's used in the tool, but only for stream parsing. I could also
>> distribute the already-preprocessed file (and maybe I'll do so in the
>> next release).
>> 
>> Stream parsing is certainly one of the topics to discuss.
> 
> I've no idea how widely stream parsing is used.  Has anyone some  
> intuition about this?
> 
> Stream parsers probably fall in the same category as bitstring or  
> sedlex (custom notions of pattern matching).  It seems that stream  
> parsers (which I'm not familiar with) require to be able to write  
> expressions within "left-hand sides", which might require special  
> support.  Or maybe the whole left-hand sides should just be  
> quotations.
> 
> Anyway, for a basic infrastructure tool such as ocamlfind, I'd  
> probably advocate for a "manual" solution which works out of the box  
> with a basic OCaml installation (ocamlyacc or manual top-down  
> parser).  Gerd: does that sound reasonable to you?

Of course. META is easy enough to parse with any tool.

But I'd also like to fight for stream parsers a bit. In general, they  
are a nice way to write top-down parsers. Like for all top-down  
parsers, the class of acceptable grammars is not very powerful (less  
than LALR(1)), but you can easily add things that are nearly impossible  
with bottom-up parsers, like stores or contextuality, and you can  
locally escape from the parsing discipline entirely. Sometimes it is a  
perfect match.

 From an old OCaml manual:

expr ::= ...
         | [< >]
         | [< stream-component {; stream-component} >]
         | parser [pattern] stream-matching
         | match expr with parser [pattern] stream-matching

stream-component ::= ? expr
                    | expr
stream-matching ::= stream-pattern [pattern] -> expr
                     { | stream-pattern [pattern] -> expr}
stream-pattern ::= [< >]
                   | [< stream-pat-comp {; stream-pat-comp [?? expr]} >]
stream-pat-comp ::= ? pattern [when expr]
                   | pattern = expr
                   | ident

Doing this with -ppx is certainly a challenge.

Some ideas:

  - [< >]: Maybe we should simply add several types of brackets to
    the grammar. Syntax as for list, but reserved for extensions.

  - 'expr: This is like a tag. Maybe use I(expr) instead, where "I"
    means "item".

  - pattern = expr: I guess this is what Alain sees as difficulty.
    As quotation it would look strange. What we need here is something
    in the Parsetree that allows us to include expressions into patterns
    (which would look like a "computed pattern"). Maybe `(expr) inside
    patterns. Or another notation...

Gerd


> 
> 
> Alain
> 
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From info at gerd-stolpmann.de  Mon Jan 28 21:18:53 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Mon, 28 Jan 2013 22:18:53 +0100
Subject: [wg-camlp4] PG'OCaml and syntax proliferation
In-Reply-To: <5106E75F.10100@frisch.fr> (from alain@frisch.fr on Mon Jan 28
 22:02:23 2013)
Message-ID: <1359407933.10634.9@samsung>

Am 28.01.2013 22:02:23 schrieb(en) Alain Frisch:
> On 1/28/2013 9:21 PM, Gerd Stolpmann wrote:
>> The second point is not obligatory if you choose to implement the  
>> first.
>> For example, an extension could register PGSQL as extension token.
>> Extension tokens would be handled as a separate type of token by the
>> parser.
> 
> -ppx is about letting external processes rewrite already parsed ASTs.  
> This does not sound compatible with this approach, unless I missed  
> your point.

Right. Even a simple registration of a string is not possible - unless  
you add another command-line switch, or, going further, have  
configuration files.

Maybe something we should keep as an option. I fear that a completely  
static syntax might be too tight.

Gerd


> Alain
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From hongboz at seas.upenn.edu  Mon Jan 28 21:23:19 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 16:23:19 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301282101120.21455@hermes-1.csi.cam.ac.uk>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
 <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>
 <Prayer.1.3.5.1301281825400.19837@hermes-1.csi.cam.ac.uk>
 <CANcqPu42_eJhD-WkQBzAXq9xdTnp9u_tnxVopCUHnDZcmb9DyA@mail.gmail.com>
 <Prayer.1.3.5.1301282101120.21455@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu6nAf79hXpuDZpH6ePsbDh_zLm6dBmZ--BZuCAj5nS9Bg@mail.gmail.com>

After you doing all those stuff,  I am worried that you may find you just
re-implemented a new P4.

*I agree that the complexity of extensible parser should be removed,
 there's a compromise here.*

The ppx* shares the same Intermediate Ast*(It could be improved with more
meaningful tags names)  with camlp4 but uses the built in parser.

The benefit lies in two aspects:
    1. You get the automatically meta filter, quasi-quotation is for free
    2. The camlp4 can works well with ppx, the change is incremental, most
existing library still works under both cases

Introducing an Intermediate Ast also gives you some freedom, the parsetree
does a lot of syntax desguaring(to name a few, range patterns, bigarray,
string access, array access), you may change
the representation of parsetree, but that introduces complexity in other
cases, so my suggestion is that we can separate extensible parser part from
camlp4, that's absolutely doable, then we share the same intermediate Ast

On Mon, Jan 28, 2013 at 4:01 PM, Leo White <lpw25 at cam.ac.uk> wrote:

> 3 parsers actually.
>> The original parser, the parser to patt, the parser to expr.
>>
>
> The original parser isn't necessary for the quotation, and of course the
> other two parsers are only both needed if you want the quotation to work as
> both a pattern and an expression.
>
> Anyway, my point is that you do not *need* to implement quotations by
> parsing to a value and then converting to an AST fragment, in fact it is
> often easier not to.
>
> That is not to say that some people might not want to implement their
> quotations by parsing to a value and then converting to an AST fragment. In
> fact, if they want to use an external parser (over which they have little
> control) to parse their quotations then they may have to do it that way.
>
> For these cases I think there are three options:
>
> 1. They can implement conversion functions by hand.
>
> 2. They could use some kind of type-conv style extension to automatically
> produce the conversion functions. I'm sure such an extension would be
> welcomed by other extension authors.
>
> 3. If/when some kind of run-time type representation is added to the
> language, it could be used to create a generic conversion function.
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/05f95e47/attachment.html>

From hongboz at seas.upenn.edu  Mon Jan 28 21:30:03 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 16:30:03 -0500
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <1359407533.10634.8@samsung>
References: <51066BCA.1020201@frisch.fr>
	<1359407533.10634.8@samsung>
Message-ID: <CANcqPu4MXqeyr3Usu1GL0Fmj6X1eUOjgozRoo4kLiwB-WtbAww@mail.gmail.com>

IIRC, the stream parser is in the old caml, but it is removed later since
Daniel write it in camlp4 with domain specific optimizations

On Mon, Jan 28, 2013 at 4:12 PM, Gerd Stolpmann <info at gerd-stolpmann.de>wrote:

> Am 28.01.2013 13:15:06 schrieb(en) Alain Frisch:
>
>  On 01/24/2013 05:24 PM, Gerd Stolpmann wrote:
>>
>>> It's used in the tool, but only for stream parsing. I could also
>>> distribute the already-preprocessed file (and maybe I'll do so in the
>>> next release).
>>>
>>> Stream parsing is certainly one of the topics to discuss.
>>>
>>
>> I've no idea how widely stream parsing is used.  Has anyone some
>> intuition about this?
>>
>> Stream parsers probably fall in the same category as bitstring or sedlex
>> (custom notions of pattern matching).  It seems that stream parsers (which
>> I'm not familiar with) require to be able to write expressions within
>> "left-hand sides", which might require special support.  Or maybe the whole
>> left-hand sides should just be quotations.
>>
>> Anyway, for a basic infrastructure tool such as ocamlfind, I'd probably
>> advocate for a "manual" solution which works out of the box with a basic
>> OCaml installation (ocamlyacc or manual top-down parser).  Gerd: does that
>> sound reasonable to you?
>>
>
> Of course. META is easy enough to parse with any tool.
>
> But I'd also like to fight for stream parsers a bit. In general, they are
> a nice way to write top-down parsers. Like for all top-down parsers, the
> class of acceptable grammars is not very powerful (less than LALR(1)), but
> you can easily add things that are nearly impossible with bottom-up
> parsers, like stores or contextuality, and you can locally escape from the
> parsing discipline entirely. Sometimes it is a perfect match.
>
> From an old OCaml manual:
>
> expr ::= ...
>         | [< >]
>         | [< stream-component {; stream-component} >]
>         | parser [pattern] stream-matching
>         | match expr with parser [pattern] stream-matching
>
> stream-component ::= ? expr
>                    | expr
> stream-matching ::= stream-pattern [pattern] -> expr
>                     { | stream-pattern [pattern] -> expr}
> stream-pattern ::= [< >]
>                   | [< stream-pat-comp {; stream-pat-comp [?? expr]} >]
> stream-pat-comp ::= ? pattern [when expr]
>                   | pattern = expr
>                   | ident
>
> Doing this with -ppx is certainly a challenge.
>
> Some ideas:
>
>  - [< >]: Maybe we should simply add several types of brackets to
>    the grammar. Syntax as for list, but reserved for extensions.
>
>  - 'expr: This is like a tag. Maybe use I(expr) instead, where "I"
>    means "item".
>
>  - pattern = expr: I guess this is what Alain sees as difficulty.
>    As quotation it would look strange. What we need here is something
>    in the Parsetree that allows us to include expressions into patterns
>    (which would look like a "computed pattern"). Maybe `(expr) inside
>    patterns. Or another notation...
>
> Gerd
>
>
>
>>
>> Alain
>>
>>
>>
>
> --
> ------------------------------**------------------------------
> Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
> Creator of GODI and camlcity.org.
> Contact details:        http://www.camlcity.org/**contact.html<http://www.camlcity.org/contact.html>
> Company homepage:       http://www.gerd-stolpmann.de
> ------------------------------**------------------------------
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/f09d766e/attachment-0001.html>

From hongboz at seas.upenn.edu  Mon Jan 28 21:41:25 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 28 Jan 2013 16:41:25 -0500
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106BB76.6030804@frisch.fr>
References: <CAN8ZjBHgN0U0DxQQv7j86KtEYo+8aAM8x4H4S-vsCzmpJvPQ7g@mail.gmail.com>
 <CAJMfKEUTHbibNMbUEDFfR=BAUDP06c8GD2dDsQNos2RVHO8_KQ@mail.gmail.com>
 <CAN8ZjBEV57pAUD4Urfr19+NQK2yiuo2gVvV7Ef2bp4t2E7iDfA@mail.gmail.com>
 <5106BB76.6030804@frisch.fr>
Message-ID: <CANcqPu6CDf6w8YUTPsMfJeQKmYwK-tE2djHPh-4Y5TBZWx9zqA@mail.gmail.com>

On Mon, Jan 28, 2013 at 12:55 PM, Alain Frisch <alain at frisch.fr> wrote:

> On 01/28/2013 06:13 PM, David Waern wrote:
>
>> OK. I've also wanted similar syntax, but I've noticed that if Alain's
>> "static exceptions" [1] proposal is accepted then encoding such things
>> using existing OCaml syntax becomes a bit lighter:
>>
>> try raise (`Cont expr) with
>> | `Cont n -> expr
>> | handlers
>>
>
> As a side note, this encoding with static exceptions is also much more
> efficient (no allocation required to escape from the exception handler).
>
> I second this suggestion , this is so useful that I can not live without it

> Still, this is a good example.  One might indeed want to use a dedicated
> syntax for this common idiom.  My preference would be for extending the
> official language to support it directly.  If one thinks it is generally
> useful, why not put it in the language itself?  It is not difficult to
> extend OCaml to support it directly.
>
> If the proposal is rejected but we have let-fix operators, one can decide
> to have a -ppx rewriter detecting and rewriting the following form:
>
> let? x = try e1 with p -> e2 in
> e3
>
>
> -- Alain
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130128/83ae2c7d/attachment.html>

From info at gerd-stolpmann.de  Mon Jan 28 21:55:47 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Mon, 28 Jan 2013 22:55:47 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5106694C.3020703@frisch.fr> (from alain@frisch.fr on Mon Jan
 28 13:04:28 2013)
Message-ID: <1359410147.10634.10@samsung>

Am 28.01.2013 13:04:28 schrieb(en) Alain Frisch:
> camlp4.macro:  does this refer to pa_macro?  It seems that this is  
> more about conditional compilation than proper macro expansion.  I  
> suspect that conditional compilation is used rarely enough in OCaml  
> project, so that a slightly more verbose syntax would not a big  
> deal.  Do you confirm?
> 
> See  
> http://www.lexifi.com/blog/syntax-extensions-without-camlp4-lets-do-it  
> for a -ppx based version of conditional compilation.  The syntax is:
> 
>   include IFDEF(SYMBOL)(struct
>      ... (* structure items in case SYMBOL is defined *)
>   end)(struct
>      ... (* structure items in case SYMBOL is not defined *)
>   end)

Conditional compilation is not always on the level of structures.

Here is a recent code snippet from me:

   let func =
     IFDEF SAFE THEN
       ctx.functions_7.(func_idx)
     ELSE
       Array.unsafe_get ctx.functions_7 func_idx
     ENDIF in

i.e. just a fine-grained version of -unsafe. Of course, I can use  
(local) structures here as well, but the whole point is to speed the  
code up once you are sure the code is SAFE.

Macros - in the general sense - would be better handled on the level of  
tokens. That said, we could also do this by a normal -pp preprocessor  
(these are run _before_ -ppx, right?).

Gerd
-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From alain at frisch.fr  Tue Jan 29 07:44:44 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 08:44:44 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <1359407533.10634.8@samsung>
References: <1359407533.10634.8@samsung>
Message-ID: <51077DEC.5060109@frisch.fr>

On 1/28/2013 10:12 PM, Gerd Stolpmann wrote:
> But I'd also like to fight for stream parsers a bit. In general, they
> are a nice way to write top-down parsers. Like for all top-down parsers,
> the class of acceptable grammars is not very powerful (less than
> LALR(1)), but you can easily add things that are nearly impossible with
> bottom-up parsers, like stores or contextuality, and you can locally
> escape from the parsing discipline entirely. Sometimes it is a perfect
> match.

In my experience with top-down parsers, a manually written recursive 
descent with pattern matching on (normal) lists of tokens, plus a few 
"combinators", works also fine.

>  From an old OCaml manual:
>
>...
 >
>
> stream-component ::= ? expr
>                     | expr
> stream-matching ::= stream-pattern [pattern] -> expr
>                      { | stream-pattern [pattern] -> expr}
> stream-pattern ::= [< >]
>                    | [< stream-pat-comp {; stream-pat-comp [?? expr]} >]
> stream-pat-comp ::= ? pattern [when expr]
>                    | pattern = expr
>                    | ident

Let me throw a crazy idea: maybe we could merge the grammar for patterns 
and expressions, and let the type checker reject bad patterns and bad 
expressions from this more admissible class.  This would give plenty of 
space for extensions.

A quick inspection of Parsetree shows that the following syntactic forms 
are available for patterns but not expressions:

  - Alias pattern:  p as x
  - "open record" flag: { l1=p1; _ }
  - or pattern: p1 | p2
  - type pattern: #t
  - range patterns: c1..c2 (currently desugared by the Parser)

It seems possible to enrich the class of parsed expressions with those 
cases without introducing conflicts (to be checked...).

Assuming it is indeed technically possible, do you think it would be a 
good idea to merge the syntactic categories of patterns and expressions?


Alain


>
> Doing this with -ppx is certainly a challenge.
>
> Some ideas:
>
>   - [< >]: Maybe we should simply add several types of brackets to
>     the grammar. Syntax as for list, but reserved for extensions.
>
>   - 'expr: This is like a tag. Maybe use I(expr) instead, where "I"
>     means "item".
>
>   - pattern = expr: I guess this is what Alain sees as difficulty.
>     As quotation it would look strange. What we need here is something
>     in the Parsetree that allows us to include expressions into patterns
>     (which would look like a "computed pattern"). Maybe `(expr) inside
>     patterns. Or another notation...
>
> Gerd
>
>
>>
>>
>> Alain
>>
>>
>
>


From alain at frisch.fr  Tue Jan 29 09:05:09 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 10:05:09 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CANcqPu6nAf79hXpuDZpH6ePsbDh_zLm6dBmZ--BZuCAj5nS9Bg@mail.gmail.com>
References: <BD6BC2F330F5FB42AE6C31E84D7B76D7617B452F@ORSMSX101.amr.corp.intel.com>
 <5102DF28.90802@etorok.net> <5106694C.3020703@frisch.fr>
 <510677E4.2000500@etorok.net> <51068C4C.8090801@frisch.fr>
 <CANcqPu4nEpjESUyA8pqVkjpoTkk9sm8zx+R_+sqvQg1krTmwRQ@mail.gmail.com>
 <Prayer.1.3.5.1301281543180.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Dn=fMOx7WTeCxujbVeDdU0O6nVWrTy7eKxUQDk74zdA@mail.gmail.com>
 <CANcqPu4AJztShx43vFEgd0KSEWofjKx+b6gcvxGXmL8o_3Aeew@mail.gmail.com>
 <Prayer.1.3.5.1301281631370.32043@hermes-1.csi.cam.ac.uk>
 <CANcqPu4p03SE-11rcPpnFP7GcAp2PoPsz3-GQEsLp61ZC4GEpg@mail.gmail.com>
 <Prayer.1.3.5.1301281825400.19837@hermes-1.csi.cam.ac.uk>
 <CANcqPu42_eJhD-WkQBzAXq9xdTnp9u_tnxVopCUHnDZcmb9DyA@mail.gmail.com>
 <Prayer.1.3.5.1301282101120.21455@hermes-1.csi.cam.ac.uk>
 <CANcqPu6nAf79hXpuDZpH6ePsbDh_zLm6dBmZ--BZuCAj5nS9Bg@mail.gmail.com>
Message-ID: <510790C5.8000705@frisch.fr>

I've given it some thought, but I'm not convinced that it really make 
sense to introduce an extra intermediate representation of source code, 
between the parser and the input of the type-checker.  Let's look at 
where the Parsetree representation is actually used:

- Producers:

    the official parser
    ast_mapper and ppx rewriters
    camlp4
    untypeast

- Consumers:

    the type checker
    ast_mapper and ppx rewriters
    depend (could be rewritten to use ast_mapper)
    ocamlprof (could be rewritten to use ast_mapper)

(I've omitted more exotic consumers: pprintast, eqparsetree, addlabels)

The only important producer is the official parser and the only 
important consumer is the type checker, so I don't see clearly the 
benefits of introducing an extra representation in between.  The 
Parsetree could be improved, in particular to do less desugaring in the 
parser itself, but I don't see why we could not do it.  It would not 
increase the complexity of the type checker significantly.

Do you see "big" issues with the Parsetree, which could not be solved 
without the introduction of a different representation?

Alain



On 01/28/2013 10:23 PM, Hongbo Zhang wrote:
>
> After you doing all those stuff,  I am worried that you may find you
> just re-implemented a new P4.
>
> *I agree that the complexity of extensible parser should be removed,
>   there's a compromise here.*
>
> The ppx*shares the same Intermediate Ast*(It could be improved with more
> meaningful tags names)  with camlp4 but uses the built in parser.
>
> The benefit lies in two aspects:
>      1. You get the automatically meta filter, quasi-quotation is for free
>      2. The camlp4 can works well with ppx, the change is incremental,
> most existing library still works under both cases
>
> Introducing an Intermediate Ast also gives you some freedom, the
> parsetree does a lot of syntax desguaring(to name a few, range patterns,
> bigarray, string access, array access), you may change
> the representation of parsetree, but that introduces complexity in other
> cases, so my suggestion is that we can separate extensible parser part
> from camlp4, that's absolutely doable, then we share the same
> intermediate Ast
>
> On Mon, Jan 28, 2013 at 4:01 PM, Leo White <lpw25 at cam.ac.uk
> <mailto:lpw25 at cam.ac.uk>> wrote:
>
>         3 parsers actually.
>         The original parser, the parser to patt, the parser to expr.
>
>
>     The original parser isn't necessary for the quotation, and of course
>     the other two parsers are only both needed if you want the quotation
>     to work as both a pattern and an expression.
>
>     Anyway, my point is that you do not *need* to implement quotations
>     by parsing to a value and then converting to an AST fragment, in
>     fact it is often easier not to.
>
>     That is not to say that some people might not want to implement
>     their quotations by parsing to a value and then converting to an AST
>     fragment. In fact, if they want to use an external parser (over
>     which they have little control) to parse their quotations then they
>     may have to do it that way.
>
>     For these cases I think there are three options:
>
>     1. They can implement conversion functions by hand.
>
>     2. They could use some kind of type-conv style extension to
>     automatically produce the conversion functions. I'm sure such an
>     extension would be welcomed by other extension authors.
>
>     3. If/when some kind of run-time type representation is added to the
>     language, it could be used to create a generic conversion function.
>
>
>
>
> --
> -- Regards, Hongbo


From yallop at gmail.com  Tue Jan 29 09:05:29 2013
From: yallop at gmail.com (Jeremy Yallop)
Date: Tue, 29 Jan 2013 09:05:29 +0000
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <51077DEC.5060109@frisch.fr>
References: <1359407533.10634.8@samsung>
	<51077DEC.5060109@frisch.fr>
Message-ID: <CAAxsn=FMoKcLqd6C=GEAQoxc+fMut7qMOCGQ4BzhLsKmdQKdfg@mail.gmail.com>

On 29 January 2013 07:44, Alain Frisch <alain at frisch.fr> wrote:
> Let me throw a crazy idea: maybe we could merge the grammar for patterns and
> expressions, and let the type checker reject bad patterns and bad
> expressions from this more admissible class.  This would give plenty of
> space for extensions.

Indeed, this opens up lots of possibilities.  For example, consider
the binding form introduced by omonad:

    perform (
       patt <-- expr1;
       expr2
   )

which is desugared to

   bind expr1 (function patt -> expr2
                      | _    -> fail "...")

At the moment the "new" syntax is handled by parsing 'patt' as an
expression and then translating it to a pattern in the AST
transformer:

    https://github.com/danmey/omonad/blob/master/src/ppx_monad.ml#L115-L134

This works pretty well, except for the few pattern forms that don't
look like expressions.  If patterns were parsed as expresssions then
there wouldn't be any such gaps, and the introduction of the new
binding form would be more convincing.

Other campl4 extensions such as Richard Jones' bitstring (Erlang-style
matching over bits) and Martin Jambon's micmatch (pattern matching for
regular expressions) could also be implemented as AST transformers if
the grammars were merged.

> Assuming it is indeed technically possible, do you think it would be a good
> idea to merge the syntactic categories of patterns and expressions?

I think it would be a good idea.  It'd also eliminate a few dozen
productions from the grammar, which is probably no bad thing.

From puyo at doomeer.com  Tue Jan 29 09:33:07 2013
From: puyo at doomeer.com (DooMeeR)
Date: Tue, 29 Jan 2013 10:33:07 +0100
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <51077DEC.5060109@frisch.fr>
References: <1359407533.10634.8@samsung> <51077DEC.5060109@frisch.fr>
Message-ID: <51079753.5090908@doomeer.com>

> Assuming it is indeed technically possible, do you think it would be a
> good idea to merge the syntactic categories of patterns and expressions?

Not only would it be useful for -ppx, it would probably help to produce 
better error messages as well. A message like "you cannot use { f = ?; _ 
} in expressions, this is only for patterns" is a bit better than "parse 
error"?

Not that we cannot do that already with additional rules in the parser, 
but after a merge, the type-checker would kind of be forced to handle 
these cases. (Unless it uses a catch-all.)

Cheers,

-- 
Romain Bardou

From Fabrice.Le_fessant at inria.fr  Tue Jan 29 10:19:52 2013
From: Fabrice.Le_fessant at inria.fr (Fabrice Le Fessant)
Date: Tue, 29 Jan 2013 11:19:52 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <1359404907.10634.7@samsung>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung>
Message-ID: <5107A248.8050809@inria.fr>

On 01/28/2013 09:28 PM, Gerd Stolpmann wrote:
> Typographically, $ is a mistake.

Of course, such a convention can provide different sets of delimiters, 
which use would depend on the delimiters used to introduce them.

For example, <$ ... $> would make $ the delimiter, while <? ... ?> would 
make ? the delimiter (just an idea).

> I second Leo's idea to leave it to the preprocessor.

I would strongly argue for a convention that has to be obeyed by all 
preprocessors. If you leave it to the preprocessor, you will have to 
call the preprocessor during the parsing, not during the typing, i.e. 
you won't have access to the typing environment while expanding macros. 
Consequently, your objectives were to be strictly more powerful, but 
your system would actually be strictly less powerful.

--Fabrice
-------------- next part --------------
A non-text attachment was scrubbed...
Name: fabrice_le_fessant.vcf
Type: text/x-vcard
Size: 380 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130129/0889ea6e/attachment.vcf>

From alain at frisch.fr  Tue Jan 29 10:45:17 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 11:45:17 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5107A248.8050809@inria.fr>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
Message-ID: <5107A83D.2060809@frisch.fr>

On 01/29/2013 11:19 AM, Fabrice Le Fessant wrote:
> I would strongly argue for a convention that has to be obeyed by all
> preprocessors. If you leave it to the preprocessor, you will have to
> call the preprocessor during the parsing, not during the typing, i.e.
> you won't have access to the typing environment while expanding macros.

If we extend the grammar with quotations, they can be rewritten by -ppx 
filters.  This is useful, and not incompatible with OCaml Templates 
(which can interpret remaining quotations, not rewritten by -ppx).  Many 
current uses of quotations really don't need access to typing 
information, and there are advantages in doing the expansion during 
parsing, not type-checking:

  - ocamldep can run the -ppx filters in order to get a precise idea of 
dependencies, after expansion has occurred.

  - OCaml Templates requires to load expanders in the same process as 
the type-checker, but this would force to use Dynlink in the compiler 
(or re-link statically you compilers with your expanders).  Dynlink in 
native code is not available on all platform.

  - An expansion done by a -ppx rewriter can benefit from other 
rewriters applied afterwards.  It is not clear if we should apply the 
-ppx rewriters to each fragment produced by OCaml Templates.


I'm not arguing against OCaml Templates, which has very interesting 
usage scenarios, but it should be thought as an addition to expanders 
implemented with -ppx, for those cases where type information is 
actually required and the downsides mentioned above are not problematic. 
  Of course, we should share the same quotation syntax.


Alain

From lpw25 at cam.ac.uk  Tue Jan 29 10:46:55 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 10:46:55 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5107A248.8050809@inria.fr>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
Message-ID: <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>

>> I second Leo's idea to leave it to the preprocessor.
>
>I would strongly argue for a convention that has to be obeyed by all 
>preprocessors. If you leave it to the preprocessor, you will have to 
>call the preprocessor during the parsing, not during the typing, i.e. 
>you won't have access to the typing environment while expanding macros. 
>Consequently, your objectives were to be strictly more powerful, but 
>your system would actually be strictly less powerful.

There is no reson that you cannot expand the preprocessor during typing. As 
I said in a previous post, all we need to provide is a function that will 
parse an expression upto the next unnested occurence of "$" or whatever the 
preprocessor is using to mark the end of its antiquotations. Preprocessors 
can then simply use this facility to handle their antiquotations 
themselves.


From gabriel.scherer at gmail.com  Tue Jan 29 10:52:56 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 29 Jan 2013 11:52:56 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code for
 syntax extension purposes
Message-ID: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>

Dear wg-camlp4 list,

I have been reading the list discussion and find it very interesting
so far. One point that I am worried about is the seemingly consensual
idea that the way to integrate syntax extensions in a post-camlp4
world is to massage them into syntactically correct OCaml code, to be
parsed by the existing parser and later processed by a -ppx filter.

I think this is a terrible idea. Code with a special semantics should
have a special syntax. Otherwise, how is the user supposed to guess
which syntactically correct code follows the expected OCaml semantics,
and which is in fact to be understood in the context of a specific
syntax extension?

Camlp4 quotations are a generic way to embed foreign pieces of syntax
into an OCaml parstree in a safe, explicit, modular and composable
way. I understand that it is annoying to be forced to "quote" code
that is "mostly valid OCaml code" (eg. encoding type-conv with
continuations would give something as <:type-conv< type foo = ... with
... >>, while we would like to preserve the type declaration and
localize the extension to the "with" part). Sometimes, a full
quotation syntax is also too heavy to make sense in the precise
context (eg. regexp patterns in ulex/xstr/whatever). I think we should
cluster the existing perversions into a small amount of cases that we
add to the existing OCaml syntax (eg. overloadable string literals for
unicode support, xstr and PG'OCaml), as a *different* syntax from what
is currently accepted and well-defined.

(When I say "syntactically valid" this is to be taken relatively to
the future OCaml language: I would be ok with forbidding some
currently accepted corner cases to reuse them for extension purposes.)

This coincides with Fabrice's opinion to agree on a common syntax for
quotations/extensions among extensions. Discipline and robustness at
the cost of generality, that is (imho) the meaningful direction an
out-of-camlp4 work should take. I understand the temptation to express
arbitrary things in the limited (but already useful) -ppx framework as
it stands now, but I think we should resist it.

So that would be my answer: *reject* reuse of syntactically valid code
for extension purposes, and isolate a *few* common cases of extensions
that deserve new extension points to be added to the standard parser
(arbitrary quotations being the maximally expressive, but also
heaviest, tool in this framework, into which all non-otherwise-handled
extension needs would fallback). The question of tool support (Tuareg
indentation, etc.) is solved by updating tools to support those few
extension points, no masquerade new semantics under old syntax.

What do you think of embeddings of syntax extension into syntactically
valid syntax ?

On Mon, Jan 28, 2013 at 4:10 PM, Dario Teixeira <darioteixeira at yahoo.com> wrote:
> Hi,
>
>
> Another syntax extension to consider is PG'OCaml's.  Though it seems like
> it can easily be adapted to the ppx system, it does raise an issue which I
> think ought to be discussed.
>
> Here's how code making use of embedded SQL in PG'OCaml currently looks like:
> (the dbh parameter is the database handle)
>
>   let fetch_users dbh =
>         PGSQL(dbh) "select id, name from users"
>
> This is syntactally incorrect, of course.  Therefore, any adaptation to the
> ppx system will necessarily be backwards-incompatible with existing code
> (not a big problem for me personally, but others may disagree).  As for
> the new syntax, several possibilities exist.  A straightforward one would
> be to lowercase the "PGSQL" token; embedded SQL statements would thus take
> the form of fake function calls:
>
>   let fetch_users dbh =
>         pgsql(dbh) "select id, name from users"
>
> Another possiblity would be for the SQL statements to be arguments to a fake
> variant type constructor:
>
>   let fetch_users dbh =
>         PGSQL (dbh, "select id, name from users")
>
> I could go on.  Anyway, regardless of choice, one issue comes to mind.
> Presently, code using the PG'OCaml syntax extension is conspicuous by its
> syntactic incorrectness.  Therefore, someone unfamiliar with PG'OCaml who
> happened to be looking at code using the syntax extension would immediately
> suspect something camlp4ish was going on.  With ppx, this signaling would
> go away.  This could make code harder to read if several syntax extensions
> are simultaneously used, particularly if syntax extensions become more
> popular because ppx makes it so much easier to write them.
>
> One solution is for the community to adopt conventions that make syntax
> extensions stand out to the naked eye (syntax highlighters in Vim or Emacs
> could also take advantage of these conventions).  For example: the fake variant
> constructor could be instead a fake PV constructor ending in "'" (prime).
> It should not be hard for editors to highlight this code in a special way:
>
>   let fetch_users dbh =
>         `PGSQL' (dbh, "select id, name from users")
>
> What do you think?
>
> Best regards,
> Dario Teixeira
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From lpw25 at cam.ac.uk  Tue Jan 29 11:15:34 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 11:15:34 +0000
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301291115340.19279@hermes-1.csi.cam.ac.uk>

I would just like to say that I mostly agree with Gabriel. Where possible I 
think we should try to choose syntaxes that are obviously syntax 
extensions.

For example, I don't think that:

let rec expr =
  <:parser <
      If; x = expr; Then; y = expr; Else; z = expr -> "if"
    | Let; Ident x; Equal; x = expr; In; y = expr -> "let" >>

is really worse than

let rec expr =
  parser
    [< 'If; x = expr; 'Then; y = expr; 'Else; z = expr >] -> "if"
  | [< 'Let; 'Ident x; 'Equal; x = expr; 'In; y = expr >] -> "let"

and it makes it very clear that it is using an extension.

In some cases it seems sensible to use an obviously wrong syntax (e.g. 
!"asdf"), but in general I think we should try to use new syntax for 
extensions.

In particular I think that the following forms can cover many cases:

* Camlp4-style quotations: <:foo < arg >> 

* Some kind of quotation that looks like a type constructor and is quietly 
  ignored by the main compiler. I personally like the syntax "%foo" and 
  "%bar(arg)".

* Type-conv style annotations: type t = int with foo, bar(arg) 

* Allowing let and maybe some other keywords to be suffixed by some symbols 
  (e.g. let*)

* Allowing top-level style directives in ml files (e.g. "#ifdef ;;").


From info at gerd-stolpmann.de  Tue Jan 29 11:27:21 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Tue, 29 Jan 2013 12:27:21 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 (from gabriel.scherer@gmail.com on Tue Jan 29 11:52:56 2013)
Message-ID: <1359458841.10634.11@samsung>

So that would go into the direction of marking _all_ extensions, even  
those that reuse the OCaml syntax. That would pick up the idea of  
having special tokens to initiate extension phrases, e.g. (just picking  
a notation)

<PGSQL> pat-or-expr

This would definitely make life easier in the tool universe. Basically,  
this means we'd have only a few ways of extension:

  - a lightweight one starting with an extension token, and always
    reusing existing syntax (for various points in the syntax)
  - a heavyweight one: quotations

I have the feeling that we could focus in this direction, but it is too  
early to say whether it is sufficient. Anyway, I don't see how we can  
forbid to transform any OCaml syntax with the ppx mechanism. Once the  
Parsetree is accessible, it is accessible for everything. So, it would  
be convention only to stay away from inline (unmarked) extensions.

Gerd

Am 29.01.2013 11:52:56 schrieb(en) Gabriel Scherer:
> Dear wg-camlp4 list,
> 
> I have been reading the list discussion and find it very interesting
> so far. One point that I am worried about is the seemingly consensual
> idea that the way to integrate syntax extensions in a post-camlp4
> world is to massage them into syntactically correct OCaml code, to be
> parsed by the existing parser and later processed by a -ppx filter.
> 
> I think this is a terrible idea. Code with a special semantics should
> have a special syntax. Otherwise, how is the user supposed to guess
> which syntactically correct code follows the expected OCaml semantics,
> and which is in fact to be understood in the context of a specific
> syntax extension?
> 
> Camlp4 quotations are a generic way to embed foreign pieces of syntax
> into an OCaml parstree in a safe, explicit, modular and composable
> way. I understand that it is annoying to be forced to "quote" code
> that is "mostly valid OCaml code" (eg. encoding type-conv with
> continuations would give something as <:type-conv< type foo = ... with
> ... >>, while we would like to preserve the type declaration and
> localize the extension to the "with" part). Sometimes, a full
> quotation syntax is also too heavy to make sense in the precise
> context (eg. regexp patterns in ulex/xstr/whatever). I think we should
> cluster the existing perversions into a small amount of cases that we
> add to the existing OCaml syntax (eg. overloadable string literals for
> unicode support, xstr and PG'OCaml), as a *different* syntax from what
> is currently accepted and well-defined.
> 
> (When I say "syntactically valid" this is to be taken relatively to
> the future OCaml language: I would be ok with forbidding some
> currently accepted corner cases to reuse them for extension purposes.)
> 
> This coincides with Fabrice's opinion to agree on a common syntax for
> quotations/extensions among extensions. Discipline and robustness at
> the cost of generality, that is (imho) the meaningful direction an
> out-of-camlp4 work should take. I understand the temptation to express
> arbitrary things in the limited (but already useful) -ppx framework as
> it stands now, but I think we should resist it.
> 
> So that would be my answer: *reject* reuse of syntactically valid code
> for extension purposes, and isolate a *few* common cases of extensions
> that deserve new extension points to be added to the standard parser
> (arbitrary quotations being the maximally expressive, but also
> heaviest, tool in this framework, into which all non-otherwise-handled
> extension needs would fallback). The question of tool support (Tuareg
> indentation, etc.) is solved by updating tools to support those few
> extension points, no masquerade new semantics under old syntax.
> 
> What do you think of embeddings of syntax extension into syntactically
> valid syntax ?
> 
> On Mon, Jan 28, 2013 at 4:10 PM, Dario Teixeira  
> <darioteixeira at yahoo.com> wrote:
> > Hi,
> >
> >
> > Another syntax extension to consider is PG'OCaml's.  Though it  
> seems like
> > it can easily be adapted to the ppx system, it does raise an issue  
> which I
> > think ought to be discussed.
> >
> > Here's how code making use of embedded SQL in PG'OCaml currently  
> looks like:
> > (the dbh parameter is the database handle)
> >
> >   let fetch_users dbh =
> >         PGSQL(dbh) "select id, name from users"
> >
> > This is syntactally incorrect, of course.  Therefore, any  
> adaptation to the
> > ppx system will necessarily be backwards-incompatible with existing  
> code
> > (not a big problem for me personally, but others may disagree).  As  
> for
> > the new syntax, several possibilities exist.  A straightforward one  
> would
> > be to lowercase the "PGSQL" token; embedded SQL statements would  
> thus take
> > the form of fake function calls:
> >
> >   let fetch_users dbh =
> >         pgsql(dbh) "select id, name from users"
> >
> > Another possiblity would be for the SQL statements to be arguments  
> to a fake
> > variant type constructor:
> >
> >   let fetch_users dbh =
> >         PGSQL (dbh, "select id, name from users")
> >
> > I could go on.  Anyway, regardless of choice, one issue comes to  
> mind.
> > Presently, code using the PG'OCaml syntax extension is conspicuous  
> by its
> > syntactic incorrectness.  Therefore, someone unfamiliar with  
> PG'OCaml who
> > happened to be looking at code using the syntax extension would  
> immediately
> > suspect something camlp4ish was going on.  With ppx, this signaling  
> would
> > go away.  This could make code harder to read if several syntax  
> extensions
> > are simultaneously used, particularly if syntax extensions become  
> more
> > popular because ppx makes it so much easier to write them.
> >
> > One solution is for the community to adopt conventions that make  
> syntax
> > extensions stand out to the naked eye (syntax highlighters in Vim  
> or Emacs
> > could also take advantage of these conventions).  For example: the  
> fake variant
> > constructor could be instead a fake PV constructor ending in "'"  
> (prime).
> > It should not be hard for editors to highlight this code in a  
> special way:
> >
> >   let fetch_users dbh =
> >         `PGSQL' (dbh, "select id, name from users")
> >
> > What do you think?
> >
> > Best regards,
> > Dario Teixeira
> >
> > _______________________________________________
> > wg-camlp4 mailing list
> > wg-camlp4 at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/wg-camlp4
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From alain at frisch.fr  Tue Jan 29 11:37:33 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 12:37:33 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <1359410147.10634.10@samsung>
References: <1359410147.10634.10@samsung>
Message-ID: <5107B47D.5080300@frisch.fr>

On 01/28/2013 10:55 PM, Gerd Stolpmann wrote:
> Here is a recent code snippet from me:
>
>    let func =
>      IFDEF SAFE THEN
>        ctx.functions_7.(func_idx)
>      ELSE
>        Array.unsafe_get ctx.functions_7 func_idx
>      ENDIF in
>
> i.e. just a fine-grained version of -unsafe. Of course, I can use
> (local) structures here as well, but the whole point is to speed the
> code up once you are sure the code is SAFE.

Yes, we can come up with a syntax for conditional compilation an 
expressions as well.  For instance:

   if DEF(SYMBOL) then e1 else e2

> Macros - in the general sense - would be better handled on the level of
> tokens. That said, we could also do this by a normal -pp preprocessor
> (these are run _before_ -ppx, right?).

Yes, but be careful that -pp preprocessors cannot be chained (they map 
concrete syntax to abstract one).

-- Alain


From alain at frisch.fr  Tue Jan 29 12:21:51 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 13:21:51 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
Message-ID: <5107BEDF.6040907@frisch.fr>

On 01/29/2013 11:52 AM, Gabriel Scherer wrote:
> Code with a special semantics should
> have a special syntax.

I agree, for most cases, although I don't think this should be a hard 
constraint.  Generic extension points are parts of the plan!

It is a good objective to make clear that an extension is used, but it 
is also quite important to keep good support from editors (coloring, 
indentation, parentheses matching), which is quite contradictory with 
the notion of quotation.  Also, relying on already parsed fragments 
discourage the creation of sub-languages with ad hoc grammar, and this 
is good (in particular, users don't need to learn new precedence rules).

I propose to start discussing the addition of attributes to most 
syntactic categories (expressions, type expressions, patterns, type 
declarations, module expressions, structure/signature items, etc).  I 
suggest to adopt "expressions" as the (default) nature of attribute's 
content, because the syntax for expressions is quite flexible.  We need 
some syntax to attach such an attribute to various syntactic categories. 
  It might be a good idea to support both prefix and postfix attributes. 
  Personally I don't care too much about the choice of syntax, and I'm 
very bad at picking good syntax.  Good proposal are welcome!  To avoid 
ambiguities, one might need to use different syntaxes for attributes on 
structure/signature items and other components.

To illustrate the idea, though, let's assume the following syntax:

   postfix:    .... (% e)
   prefix:     (@ e) ....

on structure/signature items:

   postfix:    .... (%% e)
   prefix:     (@@ e) ....


So one could write:

  (@PGSQL) dbh "select id, name from users"

  type t = { a : int (% default(2), sexp_drop_if (fun x -> x = 2)) }

  type f = {foo:int} (%sexp)

  let () = (@TEST) expr

  module M = (@ifdef SYMBOL)(struct ... end)(struct ... end)

  (@@nonrec) type t = ...


   val foo: int -> int  (%% DEPRECATED)


Alain


From Fabrice.Le_fessant at inria.fr  Tue Jan 29 12:33:39 2013
From: Fabrice.Le_fessant at inria.fr (Fabrice Le Fessant)
Date: Tue, 29 Jan 2013 13:33:39 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
Message-ID: <5107C1A3.1010800@inria.fr>

On 01/29/2013 11:47 AM, Leo White wrote:
>>> I second Leo's idea to leave it to the preprocessor.
>>
>> I would strongly argue for a convention that has to be obeyed by all
>> preprocessors. If you leave it to the preprocessor, you will have to
>> call the preprocessor during the parsing, not during the typing, i.e.
>> you won't have access to the typing environment while expanding
>> macros. Consequently, your objectives were to be strictly more
>> powerful, but your system would actually be strictly less powerful.
>
> There is no reson that you cannot expand the preprocessor during typing.
> As I said in a previous post, all we need to provide is a function that
> will parse an expression upto the next unnested occurence of "$" or
> whatever the preprocessor is using to mark the end of its
> antiquotations. Preprocessors can then simply use this facility to
> handle their antiquotations themselves.

Ok, there are two debates here : one is about the implementation, the 
other one is about the accessibility.

 From the implementation point-of-view, you have to know all the parsers 
at parsing time, because you need the function to recognize their 
antiquotations. In my implementation of ocaml-templates, there was a 
parser to load new parsers (<:dynlink<pa_to_string>>). These new parsers 
would be loaded while parsing the string inside the quotation, i.e. 
during typing, not during parsing. In your case, you would not be able 
to do that, unless you provide natively this mechanism to load parsers 
dring parsing.

 From the accessibility point-of-view, having a convention for 
quotations/anti-quotations is both simpler for users (they can 
understand more of what is happening even if they don't know the syntax 
extensions, because anti-quotations are always written in the same way), 
and for developers (they don't need to provide a function to recognize 
their own anti-quotations, and actually, they don't even need to think 
about which delimiters to use for their syntax).

During such debates, I always think about Ruby's "convention over 
configuration", and why some languages are widely adopted while they are 
actually less powerful than OCaml (and Camlp4 is very powerful...).

--Fabrice

-------------- next part --------------
A non-text attachment was scrubbed...
Name: fabrice_le_fessant.vcf
Type: text/x-vcard
Size: 380 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130129/8cd94159/attachment.vcf>

From info at gerd-stolpmann.de  Tue Jan 29 12:56:59 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Tue, 29 Jan 2013 13:56:59 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5107C1A3.1010800@inria.fr> (from Fabrice.Le_fessant@inria.fr
 on Tue Jan 29 13:33:39 2013)
Message-ID: <1359464219.10634.12@samsung>

Am 29.01.2013 13:33:39 schrieb(en) Fabrice Le Fessant:
> From the accessibility point-of-view, having a convention for  
> quotations/anti-quotations is both simpler for users (they can  
> understand more of what is happening even if they don't know the  
> syntax extensions, because anti-quotations are always written in the  
> same way), and for developers (they don't need to provide a function  
> to recognize their own anti-quotations, and actually, they don't even  
> need to think about which delimiters to use for their syntax).

Regarding developers: no, I don't agree. I think it is too restrictive,  
and you would then force the developers to work around limitations,  
making it more complicated than just calling a sub parser.

So far I see it, quotations are about totally foreign syntax, and this  
already applies to the level of tokens. This also means that strings,  
comments, etc. may be defined in a totally different way than in OCaml.  
The lexical conventions may be very different. E.g. if I want to run  
shell commands as quotation, I'm probably not happy with $ as  
antiquotation delimiter, and also I'd like to recognize the delimiters  
only in some contexts, and in other contexts they should be ignored  
(e.g., continuing the shell example, inside single quotes). I'm citing  
shell as example, especially because it has weird lexical rules.

Of course, this means that it is more difficult (or even impossible)  
for tools to recognize anti-quotations. I'd pay this price -  
antiquotations are often only short expressions.

Btw, we can still meet in the middle - just provide some utility  
functions to find the preferred anti-quotation style, and many  
developers will use them. This would not make it impossible to deviate  
from that rule if there is good reason.

Gerd


> 
> During such debates, I always think about Ruby's "convention over  
> configuration", and why some languages are widely adopted while they  
> are actually less powerful than OCaml (and Camlp4 is very  
> powerful...).
> 
> --Fabrice
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From lpw25 at cam.ac.uk  Tue Jan 29 13:17:19 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 13:17:19 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5107C1A3.1010800@inria.fr>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
Message-ID: <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>

> From the implementation point-of-view, you have to know all the parsers 
>at parsing time, because you need the function to recognize their 
>antiquotations.

I don't think that this is the case. I think that with a bit of care you 
can provide a function like:

anti-expr: (char Stream.t -> bool) -> char Stream.t -> Parsetree.expression

where the first argument is a predicate that tests for the end of the 
anti-quotation.

This function could be used by an extension whether it is expanded before 
or during type-checking.

> From the accessibility point-of-view, having a convention for 
>quotations/anti-quotations is both simpler for users (they can 
>understand more of what is happening even if they don't know the syntax 
>extensions, because anti-quotations are always written in the same way)

This seems to assume that quotations are for a sub-language that is nothing 
like OCaml, and so anti-quotations should be clearly marked. However, 
quotations should also be used in for extensions that are, as Gabriel put 
it, "mostly valid OCaml code". In these cases "anti-quotations" actually 
make up the majority of the text, and forcing an unnecessary heavyweight 
syntax for them will make these quotations very unwieldy.

For example (a quotation for Haskell's arrow notation):

<:proc < x -> 
           y <- f -< x + 1;
           g -< 2 * y;
           t <- h -< x * (x + y);
           return -< t + y >>

is definitely preferable to:

<:proc < $x$ -> 
           y <- $f$ -< $x + 1$;
           $g$ -< $2 * y$;
           t <- $h$ -< $x * (x + y)$;
           $return$ -< $t + y$ >>


From wojciech.meyer at gmail.com  Tue Jan 29 13:23:01 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Tue, 29 Jan 2013 13:23:01 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
Message-ID: <CAOg1smCnyC=2=VywQqJsMMTgPdfTOJkXdrYS0OPWuQyr4yHdyg@mail.gmail.com>

> For example (a quotation for Haskell's arrow notation):
>
> <:proc < x ->           y <- f -< x + 1;
>           g -< 2 * y;
>           t <- h -< x * (x + y);
>           return -< t + y >>
>
> is definitely preferable to:
>
> <:proc < $x$ ->           y <- $f$ -< $x + 1$;
>           $g$ -< $2 * y$;
>           t <- $h$ -< $x * (x + y)$;
>           $return$ -< $t + y$ >>
>

FWIW: You can generate the second from former, by making a pass over the AST.

-Wojciech

From alain at frisch.fr  Tue Jan 29 13:37:37 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 14:37:37 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
Message-ID: <5107D0A1.9000409@frisch.fr>

On 01/29/2013 02:17 PM, Leo White wrote:
> However, quotations should also be used in for extensions that are, as
> Gabriel put it, "mostly valid OCaml code". In these cases
> "anti-quotations" actually make up the majority of the text, and forcing
> an unnecessary heavyweight syntax for them will make these quotations
> very unwieldy.
>
> For example (a quotation for Haskell's arrow notation):
>
> <:proc < x ->           y <- f -< x + 1;
>            g -< 2 * y;
>            t <- h -< x * (x + y);
>            return -< t + y >>

I don't like this use of quotations for "mostly valid OCaml code": you 
loose all support from your editor, who has no way to recognize valid 
fragments of OCaml code inside the quotation.  For those case, I'd 
rather use a special marker (an attribute or something else) to identify 
a syntactic scope under which some existing constructions are re-used 
with a different meaning.  As long as the special marker is visible 
enough, I think it is fine to do so.  For instance, js_of_ocaml could 
support code like:

   (@js) (o.property)
   (@js) (o # method foobar)


I find quotations very well suited to embed fragments of existing 
foreign languages (XML, shell) while keeping their own syntax, including 
lexical conventions.  But in those cases, anti-quotations are often 
quite trivial (simple identifiers, field projection, simple function calls).


Alain

From lpw25 at cam.ac.uk  Tue Jan 29 13:58:04 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 13:58:04 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <5107D0A1.9000409@frisch.fr>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <5107D0A1.9000409@frisch.fr>
Message-ID: <Prayer.1.3.5.1301291358040.22588@hermes-1.csi.cam.ac.uk>

>I don't like this use of quotations for "mostly valid OCaml code": you 
>loose all support from your editor, who has no way to recognize valid 
>fragments of OCaml code inside the quotation.  For those case, I'd 
>rather use a special marker (an attribute or something else) to identify 
>a syntactic scope under which some existing constructions are re-used 
>with a different meaning.  

Perhaps arrow notation was a bad example. I hadn't noticed that it is 
probably already a valid AST. I was thinking of those extensions that are 
mostly valid but not quite.

You could also allow anti-quotations to be surrounded by optional 
delimiters to indicate to their text editor that the contents should be 
highlighted. However, I would rather the syntax was easy for people to read 
than for tools to read.

> As long as the special marker is visible 
>enough, I think it is fine to do so.  For instance, js_of_ocaml could 
>support code like:
>
>   (@js) (o.property)
>   (@js) (o # method foobar)
>

I agree this is a good example of when a quotation is unnecessary. 


From yallop at gmail.com  Tue Jan 29 14:00:46 2013
From: yallop at gmail.com (Jeremy Yallop)
Date: Tue, 29 Jan 2013 14:00:46 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
Message-ID: <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>

On 29 January 2013 13:17, Leo White <lpw25 at cam.ac.uk> wrote:
> quotations should also be used in for extensions that are, as Gabriel put
> it, "mostly valid OCaml code".

I'd like to offer an opposing view: quotations are for use in
metaprogramming, and should not appear in user code (including code
that makes use of syntax extensions) at all.

Quotations turn code into values that can be processed by user code.
The idea of a quotation is to prevent code being evaluated
immediately, instead making it available to the quoting program as a
manipulable value.  I don't think that's what we're aiming for here;
instead, we're aiming to make it easier to hook syntax transformers
into the compiler.

Perhaps some examples will make the distinction clearer.

Here's a Campl4 quotation that builds an AST fragment:

      let x = <:expr< y + 1 >>

The value bound to x is now available for use in the program in which
the quotation appears.  You can analyse it, embed it in a larger AST,
print it, etc.

Here's a MetaOCaml quotation that builds a code value:

      let x = .< y + 1 >.

Again, the value bound to x is now available for use in the program in
which the quotation appears.  You can compile it, include it in a
larger piece of code, etc.

Here's a string quotation:

      let x = " y + 1 "

Once again, the value bound to x is available for use in the program
in which the quotation appears.  You can tokenize it, print it, etc.

In each case above, omitting the quotation delimiters would cause
immediate evaluation of the quoted code.  The reason for quoting is to
prevent evaluation and make the code available as a value instead.

Now consider the arrow notation example:

      let g = <:proc< x -> y <- f -< x + 1;
                           return -< y + 2 >>

Here the aim is quite different: we don't want to prevent immediate
evaluation; instead, we want to transform the syntax *for* immediate
evaluation.  We don't want g to be bound to some user-manipulable
representation of the code.  Instead, we want the *implementation* to
consume the desugared notation, type check it and bind the result of
evaluating it to g.  The distinction between user-consumable and
implementation-consumable code is obscured if we use quotations for
both in the source language.  Both quotations and syntax extensions
are useful, but let's use different notations for them.  For example,
using Alain's proposal, we might write the following for the arrow
notation fragment:

      let g = (@proc) x => (y <= f =< x + 1;
                            return =< y + 2)

Jeremy

From lpw25 at cam.ac.uk  Tue Jan 29 14:17:33 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 14:17:33 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>


>In each case above, omitting the quotation delimiters would cause
>immediate evaluation of the quoted code.  The reason for quoting is to
>prevent evaluation and make the code available as a value instead.

I think this a pretty dubious claim for both the camlp4 quotation and the 
string. In both cases those are simply extra syntax for representing 
values. For instance I could replace the camlp4 quotation with ordinary 
OCaml constructors. They do not delay execution because they are never 
executed.

>Now consider the arrow notation example:
>
>      let g = <:proc< x -> y <- f -< x + 1;
>                           return -< y + 2 >>
>
>Here the aim is quite different: we don't want to prevent immediate
>evaluation; instead, we want to transform the syntax *for* immediate
>evaluation.  We don't want g to be bound to some user-manipulable
>representation of the code.  Instead, we want the *implementation* to
>consume the desugared notation, type check it and bind the result of
>evaluating it to g.

You are making an arbitrary distinction between functions and other values.

let g x = <:proc< x -> y <- f -< x + 1;
                       return -< y + 2 >>

provides a value (in this case a function) to be used by the program just 
as

let blah = <:expr < let f = foo >>

provides a value to be used by the program.



From wojciech.meyer at gmail.com  Tue Jan 29 14:17:40 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Tue, 29 Jan 2013 14:17:40 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
Message-ID: <CAOg1smDk1CMDRhYCjcAJ8Lb=dugpyg_gwMO3cnTVyjsj08xj4Q@mail.gmail.com>

On Tue, Jan 29, 2013 at 2:00 PM, Jeremy Yallop <yallop at gmail.com> wrote:
> Here the aim is quite different: we don't want to prevent immediate
> evaluation; instead, we want to transform the syntax *for* immediate
> evaluation.  We don't want g to be bound to some user-manipulable
> representation of the code.  Instead, we want the *implementation* to
> consume the desugared notation, type check it and bind the result of
> evaluating it to g.  The distinction between user-consumable and
> implementation-consumable code is obscured if we use quotations for
> both in the source language.  Both quotations and syntax extensions
> are useful, but let's use different notations for them.  For example,
> using Alain's proposal, we might write the following for the arrow
> notation fragment:
>
>       let g = (@proc) x => (y <= f =< x + 1;
>                             return =< y + 2)
>

I tend to head our general perception, that we should have different
syntax for introducing lightweight extensions to the language (list
comprehensions, monads, arrows etc.) but as well full blown quotes
that have separate parser or even lexer. As implicitly mentioned by
Jeremy, the line that distinguish these two should be:
- if we treat the code inside the delimiters as first class value or not?
- if the quasi-quotes are needed?

These two give an indication which machinery too choose, but it might
be not clear in the begining for the users however?

-Wojciech

From info at gerd-stolpmann.de  Tue Jan 29 14:19:13 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Tue, 29 Jan 2013 15:19:13 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
 (from yallop@gmail.com on Tue Jan 29 15:00:46 2013)
Message-ID: <1359469153.10634.13@samsung>

Am 29.01.2013 15:00:46 schrieb(en) Jeremy Yallop:
> On 29 January 2013 13:17, Leo White <lpw25 at cam.ac.uk> wrote:
> > quotations should also be used in for extensions that are, as  
> Gabriel put
> > it, "mostly valid OCaml code".
> 
> I'd like to offer an opposing view: quotations are for use in
> metaprogramming, and should not appear in user code (including code
> that makes use of syntax extensions) at all.
> 
> Quotations turn code into values that can be processed by user code.
> The idea of a quotation is to prevent code being evaluated
> immediately, instead making it available to the quoting program as a
> manipulable value.  I don't think that's what we're aiming for here;
> instead, we're aiming to make it easier to hook syntax transformers
> into the compiler.

I don't think you can really separate this if it comes to really  
foreign syntax. I need to parse it anyway, and of course I get then a  
manipulable value. I can easily provide e.g.

   <:sql< ... >>

and

   <:sqltree< ... >>

at the same time (the latter would just return the parsed syntax tree,  
whereas the former would directly execute the foreign expression).

Object level and meta level are only separated by one "exec" call.

If your intention is to reserve the quotation notation for the meta  
level, I don't see the benefit.

Gerd

> Perhaps some examples will make the distinction clearer.
> 
> Here's a Campl4 quotation that builds an AST fragment:
> 
>       let x = <:expr< y + 1 >>
> 
> The value bound to x is now available for use in the program in which
> the quotation appears.  You can analyse it, embed it in a larger AST,
> print it, etc.
> 
> Here's a MetaOCaml quotation that builds a code value:
> 
>       let x = .< y + 1 >.
> 
> Again, the value bound to x is now available for use in the program in
> which the quotation appears.  You can compile it, include it in a
> larger piece of code, etc.
> 
> Here's a string quotation:
> 
>       let x = " y + 1 "
> 
> Once again, the value bound to x is available for use in the program
> in which the quotation appears.  You can tokenize it, print it, etc.
> 
> In each case above, omitting the quotation delimiters would cause
> immediate evaluation of the quoted code.  The reason for quoting is to
> prevent evaluation and make the code available as a value instead.
> 
> Now consider the arrow notation example:
> 
>       let g = <:proc< x -> y <- f -< x + 1;
>                            return -< y + 2 >>
> 
> Here the aim is quite different: we don't want to prevent immediate
> evaluation; instead, we want to transform the syntax *for* immediate
> evaluation.  We don't want g to be bound to some user-manipulable
> representation of the code.  Instead, we want the *implementation* to
> consume the desugared notation, type check it and bind the result of
> evaluating it to g.  The distinction between user-consumable and
> implementation-consumable code is obscured if we use quotations for
> both in the source language.  Both quotations and syntax extensions
> are useful, but let's use different notations for them.  For example,
> using Alain's proposal, we might write the following for the arrow
> notation fragment:
> 
>       let g = (@proc) x => (y <= f =< x + 1;
>                             return =< y + 2)
> 
> Jeremy
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From lpw25 at cam.ac.uk  Tue Jan 29 14:21:28 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 14:21:28 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
 <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
Message-ID: <Prayer.1.3.5.1301291421280.22588@hermes-1.csi.cam.ac.uk>

I just realized that I had slightly misunderstood Jeremy's point in my 
previous post.

It seems that you are suggesting that quotations should only be used to 
surround code that is already syntactically correct.

This ignores most of the existing uses of quotations (both camlp4 and 
string).


From yallop at gmail.com  Tue Jan 29 14:28:05 2013
From: yallop at gmail.com (Jeremy Yallop)
Date: Tue, 29 Jan 2013 14:28:05 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
 <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
Message-ID: <CAAxsn=Eg9m2cEf+Vgrf7vL81Rn598mvUcfBhsGQmcFoBRT5D4A@mail.gmail.com>

On 29 January 2013 14:17, Leo White <lpw25 at cam.ac.uk> wrote:
> You are making an arbitrary distinction between functions and other values.

Actually, this has nothing at all to do with functions.

The "tl;dr" is: syntax extensions are about notation, while quotations
are about distinguishing using and mentioning.

From lpw25 at cam.ac.uk  Tue Jan 29 14:47:38 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 14:47:38 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAAxsn=Eg9m2cEf+Vgrf7vL81Rn598mvUcfBhsGQmcFoBRT5D4A@mail.gmail.com>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
 <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=Eg9m2cEf+Vgrf7vL81Rn598mvUcfBhsGQmcFoBRT5D4A@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301291447380.22588@hermes-1.csi.cam.ac.uk>

On Jan 29 2013, Jeremy Yallop wrote:

>On 29 January 2013 14:17, Leo White <lpw25 at cam.ac.uk> wrote:
>> You are making an arbitrary distinction between functions and other 
>> values.
>
>Actually, this has nothing at all to do with functions.
>
>The "tl;dr" is: syntax extensions are about notation, while quotations
>are about distinguishing using and mentioning.
>

The difference between using and mentioning is fairly philosophical. 

As far as I'm concerned <:expr < 3 + 4 >> is simply a syntactic short hand 
for something like AstPlus(AstConstInt 3, AstConstInt 4). That fact that 
these constructors in some way refer to another thing is not particularly 
relevant.

My point about functions was that you seemed to be defining "using" as 
executing, which is obviously only possible for a quotation that represents 
OCaml functions.


From jun.furuse at gmail.com  Tue Jan 29 15:03:41 2013
From: jun.furuse at gmail.com (Jun Furuse)
Date: Tue, 29 Jan 2013 23:03:41 +0800
Subject: [wg-camlp4] My P4 uses
Message-ID: <CAAoLEWsqBqOtXxWXafUV1GTSv1Xp21DMJwjyGLPPmd4JX_0cmg@mail.gmail.com>

Hi,

Here are the things I do with CamlP4. Lots are just simple variants of
the already reported things, though.

pa_monad for "perform" notation
===================================

URL: https://bitbucket.org/camlspotter/pa_monad_custom

I modified the original pa_monad so that I can write I/O code easily inside
perform:

    perform
      ...;
      let () = prerr_endline "debug" in     (* Writing  let () = ... in  is
boring *)
      ...;

    peform
      ...;
      \ prerr_endline "debug";          (* It is not unit monad, but a
simple unit *)
      ...;

Here \ behaves like a prefix operator with very low power,
less than function application.
I wish -ppx could provide an easy way to handle those operators with
custom connectivity configurations, including pa_monad's <--.

Code generations from data type definitions
======================================================

I have bunch of type_conv based pa modules, such as meta_conv, and other
iterator/visitor/mapper generators. I believe they can be easily ported
from
type_conv to -ppx, if we could do for sexplib.

Record like syntax
======================================================

URL: https://bitbucket.org/camlspotter/ocaml-pure-polyrecord

I introduced record like syntax for pure polymorphic records
(they are not objects so they can be marshalled). The syntax is like:

    let r = {| x = 1; y = "hello"; |}

    let x = r..x

So this is a variant of js_of_ocaml's javascript object syntax.

Perl/Python/Shell like string literals
======================================================

URL: https://bitbucket.org/camlspotter/orakuda

ORakuda provides some scripting language like string literals like:

    $/^(.*)\.mli$/                                   (* Regexp. See \ is
not doubled. *)
    $s/template/replace/g
    let myname = "Jun" in $"My name is $myname and my age is %d" 42
 (* printf *)
    let dir = Sys.getenv "HOME" in $`ls $dir`

It is very useful to write quick one time OCaml scripts, however, it
requires
a patch to CamlP4 to modify its lexer. CamlP4 can actually replace its
lexer, but
it is not integrated into pa_*.cmo framework.

So without the patch, the above must be written:

    <:m<^(.*)\.mli$>>
    <:s<template/replace/g>>
    let myname = "Jun" in <:qq<My name is $myname and my age is %d>> 42
    let dir = Sys.getenv "HOME" in <:qx<ls $dir>>

It is a bit cumbersome to type <:< >> around, but still they are useful to
me.
Note that $ is NOT used as anti-quotation for these quotes.
So I think fixing anti-quotation symbol to some character like $
uniformly is a bad idea.

I do not expect -ppx is going to handle lexer hacks like $/.../, however,
I hope it could be simple enough to write a patch to support $/.../. :-)

Partial evaluation
======================================================

In Planck LL parser library, I wrote a small pa module to partial-evaluate
monadic binds for optimzation. This is purely a program transformation,
so there should be no problem to do the same thing in -ppx.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130129/12b179b0/attachment.html>

From yallop at gmail.com  Tue Jan 29 15:27:31 2013
From: yallop at gmail.com (Jeremy Yallop)
Date: Tue, 29 Jan 2013 15:27:31 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <Prayer.1.3.5.1301291447380.22588@hermes-1.csi.cam.ac.uk>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
 <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=Eg9m2cEf+Vgrf7vL81Rn598mvUcfBhsGQmcFoBRT5D4A@mail.gmail.com>
 <Prayer.1.3.5.1301291447380.22588@hermes-1.csi.cam.ac.uk>
Message-ID: <CAAxsn=G-V+qGz-Frjjrgb_ADkaNHV_PUwKLDr1=bMpAzddOpmQ@mail.gmail.com>

On 29 January 2013 14:47, Leo White <lpw25 at cam.ac.uk> wrote:
> As far as I'm concerned <:expr < 3 + 4 >> is simply a syntactic short hand
> for something like AstPlus(AstConstInt 3, AstConstInt 4).

Yes.  That's exactly why quotations belong in programs that process
ASTs (e.g. in compilers or metaprograms), not in programs that only
process the result of evaluating ASTs (i.e. in user code).  User code
doesn't typically deal with AstPlus and AstConstInt, but it might well
need to add numbers.

> My point about functions was that you seemed to be defining "using" as
> executing, which is obviously only possible for a quotation that represents
> OCaml functions.

Actuially, that's not what I mean by "using".  Evaluating is indeed a
form of using, but evaluating function syntax creates a function
value; it doesn't call the function.  Quoting prevents evaluation for
functions, just as for everything else, so when you quote function
syntax you get some kind of code representation rather than a function
value.  There's really nothing special about functions here.

From xavier.clerc at inria.fr  Tue Jan 29 15:37:22 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Tue, 29 Jan 2013 16:37:22 +0100 (CET)
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5106AA6A.8090006@frisch.fr>
Message-ID: <687334906.960850.1359473842585.JavaMail.root@inria.fr>



----- Mail original -----
> On 01/28/2013 04:17 PM, Xavier Clerc wrote:
> >    3- in Mascot (style tool), camlp4 is used to get either
> >       a stream of lexical tokens or an AST, both being used
> >       to detect code smells;
> ...
> > Case 3 may appear as a perfect fit for ppx, but indeed
> > it is quite pleasant to write some code smell in OCaml
> > syntax (through quotations), rather than by matching
> > against a bare AST. The latter becomes very verbose,
> > and very hard to read/maintain to say the least.
> 
> I've the intuition that matching AST with patterns in a concrete
> syntax
> is a source of never lasting problems.  But it seems you disagree, so
> I'm very much interested in your experience!
> 
> Let me explain my point.
> 
> First, the parsing (concrete syntax -> AST) has some built-in
> ambiguities and resolution mechanism that the programmer does not
> even
> need to be aware of.  For instance, I cannot tell how a pattern like
> "p1
> | p2 | p3" or an expression "e1 || e2 || e3" is parsed without
> | looking
> at the parser (or most probably, playing with -dparsetree).  Is the
> pattern parsed like "(p1 | p2) | p3" or "p1 | (p2 | p3)"?  The
> problem
> is that you might need to know such information if you write AST
> transformation/matching with concrete syntax.
> 
> Second, you need some special extra "concrete" syntax to be able to
> specify whether you care or not about some features.  For instance,
> you
> need to be able to write a pattern which matches a recursive let
> binding, or non-recursive let binding, or any kind of let binding
> (recursive or not).  In the latter case, you probably want to be able
> to
> extract the recursive flag for later use.  You need to introduce some
> syntax for that.  Similarly, we need some expert knowledge and
> specific
> syntax to know exactly what your "free variables" stand for: you need
> to
> be able to say that you want to match an arbitrary constructor or a
> constructor with no module prefix.  This is the source for a lot of
> complexity related to anti-quotations in camlp4, in my opinion.
> 
> Third, working on concrete syntax gives a false feeling that you
> don't
> need to master the abstract syntax, but this is wrong.  You need to
> know
> if "M.(e)" and "let open M in e" map to the same AST or not, if
> record
> punning is implemented in the parser or if is represented in the AST
> (exercise: define a "code smell rule" to detect missed punning
> opportunity, i.e. an instance of a record field "l = l"), etc.
> 
> Fourth, working with concrete syntax requires to master a new
> sub-language (with quotations, anti-quotations), which is far from
> trivial, and which looks like the real OCaml syntax but is not really
> the same.  There is a learning curve here, which should not be
> neglected.
> 
> 
> At the end of the day, I find it both simpler and more robust to work
> on
> abstract syntax, even if this is marginally more verbose.  Some
> actions
> can reduce the syntactic overhead of working with abstract syntax:
> cleaning up the Parsetree (and removing prefixes) and improvements to
> our beloved host language itself (such as
> http://caml.inria.fr/mantis/view.php?id=5667 or even more ambitious
> extensions).  I'd rather see time invested in such improvements than
> on
> providing support for working with (almost-)concrete syntax.  But
> YMMV,
> and I'm very much interested to hear about the opinion and experience
> of
> other people on this topic.  (And of course, once quotations are
> supported, nothing prevent some -ppx rewriter to provide support for
> concrete-syntax matching, to be used for compiling other -ppx
> rewriters...)


Well Alain, I basically agree about the different points you raise.
They closely describe my experience in writing Mascot!
As of today, most checks are written by matching against AST bits,
because as you pointed out it is a tad safer. However, during development,
it was a time-saver to be able to easily express and experiment new
ideas by manipulating "bits of the actual language". Camlp4 was kind
enough to translate them for me into AST code which I had to check.

When expressing a complex pattern, I think this turns out to be really
useful. I even keep some of these patterns in a (non-public) directory
for development. As you said, the release version has to be polished by
checking some ambiguities.

To sum up, I totally agree on "robustness" but not quite on "easiness".


Regards,

Xavier

From lpw25 at cam.ac.uk  Tue Jan 29 15:47:48 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 15:47:48 +0000
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAAxsn=G-V+qGz-Frjjrgb_ADkaNHV_PUwKLDr1=bMpAzddOpmQ@mail.gmail.com>
References: <5106AEDA.4050305@inria.fr>
 <Prayer.1.3.5.1301281707020.32043@hermes-1.csi.cam.ac.uk>
 <1359404907.10634.7@samsung> <5107A248.8050809@inria.fr>
 <Prayer.1.3.5.1301291046550.19279@hermes-1.csi.cam.ac.uk>
 <5107C1A3.1010800@inria.fr>
 <Prayer.1.3.5.1301291317190.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=EUjsGSEfiPRZehZwT-uqiuoL_w3P32B9uAzB9WyQMHXw@mail.gmail.com>
 <Prayer.1.3.5.1301291417330.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=Eg9m2cEf+Vgrf7vL81Rn598mvUcfBhsGQmcFoBRT5D4A@mail.gmail.com>
 <Prayer.1.3.5.1301291447380.22588@hermes-1.csi.cam.ac.uk>
 <CAAxsn=G-V+qGz-Frjjrgb_ADkaNHV_PUwKLDr1=bMpAzddOpmQ@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1301291547480.23651@hermes-1.csi.cam.ac.uk>

>On 29 January 2013 14:47, Leo White <lpw25 at cam.ac.uk> wrote:
>> As far as I'm concerned <:expr < 3 + 4 >> is simply a syntactic short 
>> hand for something like AstPlus(AstConstInt 3, AstConstInt 4).
>
>Yes.  That's exactly why quotations belong in programs that process
>ASTs (e.g. in compilers or metaprograms), not in programs that only
>process the result of evaluating ASTs (i.e. in user code).  User code
>doesn't typically deal with AstPlus and AstConstInt, but it might well
>need to add numbers.

But user code does deal with the results of other quotations, like HTML and 
SQL quotations. I don't see a real difference between using a quotation to 
define some constructors representing HTML and using a quotation to define 
a function. Just because the function will at some point get called.

I think this all comes from the confluence of the word quotation as in a 
string quotation (e.g. "a string"), which is something that must be lexed 
separately from the rest of the language, and the use of ' (or "quote") in 
lisp to delay evaluation. MetaOCaml's quotations are an example of this 
second type.

You want to reserve the camlp4 quotation syntax for use as the second kind 
of quotation. However, both the camlp4 tutorial 
(http://caml.inria.fr/pub/docs/tutorial-camlp4/tutorial004.html) and many 
of the common uses of camlp4 quotations treat them as the first kind.


From info at gerd-stolpmann.de  Tue Jan 29 15:56:09 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Tue, 29 Jan 2013 16:56:09 +0100
Subject: [wg-camlp4] My uses of syntax extension
In-Reply-To: <CAAxsn=G-V+qGz-Frjjrgb_ADkaNHV_PUwKLDr1=bMpAzddOpmQ@mail.gmail.com>
 (from yallop@gmail.com on Tue Jan 29 16:27:31 2013)
Message-ID: <1359474969.10634.14@samsung>

I've the impression that Jeremy's point is just that we call it the  
wrong way. We shouldn't say "quotation" when we mean an escape clause  
(escaping from the normal syntax). I mean the term "quotation" got only  
popular because the first use of this notation were Camlp4 quotations  
(which are real quotations). But I've the feeling most people here just  
want to keep the notation without implying anything - hence my  
suggestion to rename it for avoiding any confusion.

Gerd


Am 29.01.2013 16:27:31 schrieb(en) Jeremy Yallop:
> On 29 January 2013 14:47, Leo White <lpw25 at cam.ac.uk> wrote:
> > As far as I'm concerned <:expr < 3 + 4 >> is simply a syntactic  
> short hand
> > for something like AstPlus(AstConstInt 3, AstConstInt 4).
> 
> Yes.  That's exactly why quotations belong in programs that process
> ASTs (e.g. in compilers or metaprograms), not in programs that only
> process the result of evaluating ASTs (i.e. in user code).  User code
> doesn't typically deal with AstPlus and AstConstInt, but it might well
> need to add numbers.
> 
> > My point about functions was that you seemed to be defining "using"  
> as
> > executing, which is obviously only possible for a quotation that  
> represents
> > OCaml functions.
> 
> Actuially, that's not what I mean by "using".  Evaluating is indeed a
> form of using, but evaluating function syntax creates a function
> value; it doesn't call the function.  Quoting prevents evaluation for
> functions, just as for everything else, so when you quote function
> syntax you get some kind of code representation rather than a function
> value.  There's really nothing special about functions here.
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From alain at frisch.fr  Tue Jan 29 16:22:38 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 17:22:38 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
References: <687334906.960850.1359473842585.JavaMail.root@inria.fr>
Message-ID: <5107F74E.8010603@frisch.fr>

On 01/29/2013 04:37 PM, Xavier Clerc wrote:
> However, during development,
> it was a time-saver to be able to easily express and experiment new
> ideas by manipulating "bits of the actual language". Camlp4 was kind
> enough to translate them for me into AST code which I had to check.

What about having a tool (either stand-alone or part of the compilers) 
which dumps the Parsetree representation of some code fragment in as 
textual OCaml values (probably without locations)?

So you can type your "model" as source code and obtain quickly the 
Parsetree representation, copy/paste it into a nice pattern and replace 
some parts with variables.

Alain


From xavier.clerc at inria.fr  Tue Jan 29 16:30:44 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Tue, 29 Jan 2013 17:30:44 +0100 (CET)
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5107F74E.8010603@frisch.fr>
Message-ID: <39365578.998998.1359477044777.JavaMail.root@inria.fr>



----- Mail original -----
> On 01/29/2013 04:37 PM, Xavier Clerc wrote:
> > However, during development,
> > it was a time-saver to be able to easily express and experiment new
> > ideas by manipulating "bits of the actual language". Camlp4 was
> > kind
> > enough to translate them for me into AST code which I had to check.
> 
> What about having a tool (either stand-alone or part of the
> compilers)
> which dumps the Parsetree representation of some code fragment in as
> textual OCaml values (probably without locations)?
> 
> So you can type your "model" as source code and obtain quickly the
> Parsetree representation, copy/paste it into a nice pattern and
> replace
> some parts with variables.

Yes, such a tool would do the trick.

I juste realized that it would probably not be very different
from the "-dsource" option you added to compilers...


Regards,

Xavier

From alain at frisch.fr  Tue Jan 29 16:33:55 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 29 Jan 2013 17:33:55 +0100
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <39365578.998998.1359477044777.JavaMail.root@inria.fr>
References: <39365578.998998.1359477044777.JavaMail.root@inria.fr>
Message-ID: <5107F9F3.1010700@frisch.fr>

On 01/29/2013 05:30 PM, Xavier Clerc wrote:
> I juste realized that it would probably not be very different
> from the "-dsource" option you added to compilers...

This would be the lifted version of -dsource.  -dsource displays a 
source code which would be parsed to the same Parsetree (modulo 
locations).  Here we are talking about displaying code which would 
*evaluate* to the same Parsetree (if it had quotations).


-- Alain

From xavier.clerc at inria.fr  Tue Jan 29 16:37:28 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Tue, 29 Jan 2013 17:37:28 +0100 (CET)
Subject: [wg-camlp4] Matching on concrete syntax (was: Re: Camlp4 uses)
In-Reply-To: <5107F9F3.1010700@frisch.fr>
Message-ID: <1123543212.1001007.1359477448410.JavaMail.root@inria.fr>



----- Mail original -----
> On 01/29/2013 05:30 PM, Xavier Clerc wrote:
> > I juste realized that it would probably not be very different
> > from the "-dsource" option you added to compilers...
> 
> This would be the lifted version of -dsource.  -dsource displays a
> source code which would be parsed to the same Parsetree (modulo
> locations).  Here we are talking about displaying code which would
> *evaluate* to the same Parsetree (if it had quotations).

Yes, of course.


Xavier Clerc

From lpw25 at cam.ac.uk  Tue Jan 29 18:16:21 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 29 Jan 2013 18:16:21 +0000
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5107BEDF.6040907@frisch.fr>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
Message-ID: <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>

>I propose to start discussing the addition of attributes to most 
>syntactic categories (expressions, type expressions, patterns, type 
>declarations, module expressions, structure/signature items, etc).  I 
>suggest to adopt "expressions" as the (default) nature of attribute's 
>content, because the syntax for expressions is quite flexible.  We need 
>some syntax to attach such an attribute to various syntactic categories. 
>  It might be a good idea to support both prefix and postfix attributes. 
>  Personally I don't care too much about the choice of syntax, and I'm 
>very bad at picking good syntax.  Good proposal are welcome! 

How about allowing {: foo }, {% foo }, {@ foo },
 <: foo < bar >>, <% foo < bar >>  and <@ foo < bar >> ?

The idea is that "{" means it is a valid OCaml expression as oppossed to 
"<" which means it is an unlexed string.

":" means that it is an expression/pattern/type on its own and the 
type-checker should raise an error if it still exists after all 
preprocessing is done.

"%" means it is a postfix attribute that can safely be ignored by the 
type-checker.

"@" means it is a prefix attribute that can safely be ignored by the type 
checker.

This seems fairly systematic and covers many possible use cases.


From gabriel.scherer at gmail.com  Tue Jan 29 18:53:34 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 29 Jan 2013 19:53:34 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
Message-ID: <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>

I was going to suggest a related idea, having two syntaxes for "should
be tool-handled as valid OCaml code inside" and "should be
tool-handled as strings".

I'm not sure the idea of having "postfix" and "prefix" annotations
makes sense for all grammar rules (and mixing them with a modality of
"external or ocaml-syntax" feels like conflating separate concerns).
I'd rather consider where annotation may happen for grammar rules
individually. For example, in the case of "let p = e1 in e2", I'm
quite sure we may want to annotate either the whole expression or
specifically the declaration, and while I see how prefix and postfix
both make sense for the whole expression, I'm not sure they would both
make sense to annotate the binding, and considering only those cases
could lead them to being dropped.

Still in this case 'let p = e1 in e2', how should we distinguish:
- an annotation on the expressions 'e1' and 'e2'
- an annotation on the pattern 'p' (possibly seen as an expressions)
- an annotation on the binding itself
- an annotation on the expression as a whole?

In the case of embeddings of external syntaxes, it seems to be enough
to be able to embed into the expression and pattern syntactic classes
only (and not bindings in this example). I think annotations are
fairly different beasts.

On Tue, Jan 29, 2013 at 7:16 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>> I propose to start discussing the addition of attributes to most syntactic
>> categories (expressions, type expressions, patterns, type declarations,
>> module expressions, structure/signature items, etc).  I suggest to adopt
>> "expressions" as the (default) nature of attribute's content, because the
>> syntax for expressions is quite flexible.  We need some syntax to attach
>> such an attribute to various syntactic categories.  It might be a good idea
>> to support both prefix and postfix attributes.  Personally I don't care too
>> much about the choice of syntax, and I'm very bad at picking good syntax.
>> Good proposal are welcome!
>
>
> How about allowing {: foo }, {% foo }, {@ foo },
> <: foo < bar >>, <% foo < bar >>  and <@ foo < bar >> ?
>
> The idea is that "{" means it is a valid OCaml expression as opposed to "<"
> which means it is an unlexed string.
>
> ":" means that it is an expression/pattern/type on its own and the
> type-checker should raise an error if it still exists after all
> preprocessing is done.
>
> "%" means it is a postfix attribute that can safely be ignored by the
> type-checker.
>
> "@" means it is a prefix attribute that can safely be ignored by the type
> checker.
>
> This seems fairly systematic and covers many possible use cases.
>

From hongboz at seas.upenn.edu  Tue Jan 29 19:05:19 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 29 Jan 2013 14:05:19 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
Message-ID: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>

Dear wg-camp4 users,

    So far,  the discussion is really interesting and quite helpful, but I
want to talk about the meta-programming *from the point of the view of
implementation side,* features are easy to propose, but maybe only the
compiler/library writers know how hard to implement, I do appreciate that
you can sit dow and read the long email, I am also starting to blog(
http://hongboz.wordpress.com/) about how to do syntactic meta programming
(SMP) in a right way.
   I rewrite the whole camlP4(named Fan) from scratch, building the
quotation kit and throw away the crappy grammar parser, so plz believe me *that
I do understand the whole technology stack of camlP4*, if we could reach
some consensus, I would be happy to handle over the maintaining of  Fan,
Fan does not loose any feature compared with camlP4, in fact it has more
interesting featrues.

   Let's begin with some easy, not too technical parts which has a
significant effect on user experience though:
   1. Performance
          Performance does matter, it's a shame that  the most time spent
in compiling the ocaml compiler is dedicated to camlP4, but it is an
engineering problem, currently compiling Fan only takes less than 20s, and
it can be improved further
   2. Building issues
        The design of having side effects by dynamic loading is generically
a bad idea, in Fan* the dynamic loading only register some functionality
the Fan support,* it *does not have any other side effec*t, each file
stands alone says which (ppx , or filters, or syntax) it want to use with a
good default option. so the building is always something like '-pp fan
pluging1 plugin2 plugin3', *the order of pulgings does not matter*,
also, l*oading
all the plugins you have does not have any side effect, even better, you
can do the static linking all the plugins you collected, the building
process is simplified.  *
* * 3. Grammar Extension (*Language namespace*)
*       *I concur that grammar extension arbitrarily is a bad idea, and I
agree with Gabrier that so far only the quotation(Here  quotation means
delimited DSL, quosi-quotation means Lisp style macros) is modular,
composable, and  I also agree with Gabrier -ppx* should not be used to do
syntax overriding (this should not be called syntax extension
actually), *that's
a terrible idea to do syntax overriding, since the user never understand
what's going on underly without reading the Makefile. So here some my
suggestion is that some really conevenient syntax extesion, i.e, (let try..
in) should be merged to the built in parser. quotations does not bring too
much heavy syntax (imho). In Fan, we proposed the concept of a hierarchical
language name space, since once quotation is heavily used, it's really easy
to introduce conflict, *the language namespace querying is exactly like
java package namespace,* you can import, close import to save some typing.
    Here is a taste

 -----------------------------------------------------------------------------------------------
     {:.Fan.Lang.Meta.expr| a + b |} ------>
      `App (`App ((`Id (`Lid "+")), (`Id (`Lid "a")))), (`Id (`Lid "b")))
     {:.Fan.Lang.Meta.N.expr| a + b |}  ----->
      `App
    (_loc,
      (`App
         (_loc, (`Id (_loc, (`Lid (_loc, "+")))),
           (`Id (_loc, (`Lid (_loc, "a")))))),
      (`Id (_loc, (`Lid (_loc, "b")))))
 -----------------------------------------------------------------------------------------------
 the .Fan.Lang.Meta.expr the first '.' means it's from the absolute
namespace,  the *N.expr shares exactly the same syntax without location*,
though

   4. Portable to diffierrent compiler extensions(like LexiFi's fork of
ocaml)
       I am pretty sure it's pretty easy to do in Fan, only Ast2pt (dumping
the intemediate Ast into Parsetree) part need to be changed to diffierent
compilers.

----------------------------------------------------------------------------------------------------------------
Now let's talk about some internal parts of SMP.
Quasi-Quotation is the essential part of SMP,  I am surprised so far that
the discussion *silently ignores the quasi-quotation,* Leo's answer of
writing   three parsers is neither satisfying nor practical(imho).

Camlp4 is mainly composed of two parts, one is the extensible parser and *the
other significant part is Ast Lifting*. Since we all agree that extensible
parser increases the complexity too much, let's simply ignore that part.

The Ast Lifting are tightly coupled *with the design of the Abstract Syntax
Tree.*  People complain about that Camlp4 Ast is hard to learn and using
quasi-quotation to do the pattern match is a bad idea.

Let me explain the topic a bit:
    Camlp4Ast is hard to learn, I agree, it has some alien names that
nobody understand what it  means, quosi-quotation *is definitely a great
idea* to boom the meta-programming, but my experience here is *for very
very small Ast fragment, using the Abstract Syntax Tree directly,* otherwise
Quasi-quotation is a life saver to do the meta programming.
   Luckily the quotation kit has nothing to do with the parser part, it's
simply several functions(I did some simplify a bit) which turns a normal
runtime
value into an Ast node generically, *such kind functions are neither easy
to write nor easy to read*, *the idea case is that it should be generated
once for all, and all the data types in normal ocaml* *should be derived
automatically*(some ADT with functions can not be derived). *I bet it's
mostly likely a nightmare if we maintain 3 parsers for the ocaml grammar
while two other parsers dumping to a meta-level*

   So, how to make Ast Lifting easier,
        The first guideline is *"Don't mixing with records", *
*         *Once you encoding AST with records, you have to encode the
records in the meta level which increases the complexity without bringing
any new features, *it's simply not worthwhile.*
*
*
*       * The second guideline is "Don't do *any *syntax desugaring" ,
syntax desguaring makes the semantics of syntax meta programming a bit
weird. Syntax desguaring happens everywhere in Parsetree, think about the
list literals, it uses the syntax desuaring, if you don't use any syntax
desugaring, for example, you want to match the bigarray access, you simply
needed to match `Bigarray(..)' instead of

Pexp_apply
        ({pexp_desc=Pexp_ident
                     {txt= Ldot (Ldot (Lident "Bigarray", array),
("get"|"set" as gs)) ;_};_},
         label_exprs)
----------------------------
       The third guideline is to* *make it *as uniform as possible*
*       *This not only helps the user, but *it helps the meta-programming
over types to derive some utility types. *Take a look at my Ast encoding in
Fan https://github.com/bobzhang/Fan/blob/master/src/Ast.ml (it needs to be
polished, plz don't panic when you see variants I use here)
*      *The initial Ast has locations and ant support, but* here we derive
3 other Asts thanks to my very regular design*.* AstN is the Ast without
locations*, the locations are important, but it is simply not too much
helpful when you only do the code generation, but it complicates the
expanded code a lot), *AstA is the Ast without antiquotations(simply remove
the ant branch), *it is a subtype of Ast(thanks to the choice we use
variants here), *AstNA is the Ast without neither locations nor
antiquotations*), it is a subtype of AstN.  *In practice, I found the Ast
without locations is particular helpful when you only do the code
generation, it simplifies this part significantly. The beautif**ul part is
that  all the four Ast share the same grammar with the same quosiquotatoin
mechanism, as I showed .Fan.Lang.N.expr and .Fan.Lang.expr*
    I don't know how many parsers you have to maintain to reach such a goal
or it's never going to happen.
    Using variants to encode the intermediate ast has a lots of other
benefits, but I don't want to cover it in such a short mail.

   So,* my proposal is that the community design an Intermediate Ast
together, and write a built-in parser to such Intermediate Ast then dump to
Parsetree, but I am for that Parsetree still needs to be cleaned a bit but
not too much change .  *I do appreciate you can take something away from
Fan, I think the Parsetree is* not the ideal part* to do SMP, HTH

-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130129/0fda1561/attachment-0001.html>

From wojciech.meyer at gmail.com  Tue Jan 29 22:50:40 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Tue, 29 Jan 2013 22:50:40 +0000
Subject: [wg-camlp4] Mix-fix notation
Message-ID: <wftxpz38ov.fsf@gmail.com>

Dear list,

I'd like to take an opportunity to discuss possibility of a mix-fix
notation as a part of the core language.

For those who've never heard about mix-fix notation, it's a notation
belonging to class of light syntactical abstractions that allows to
encode bigger range of embedded DSLs than user defined infix operators
purely using usual functional abstractions - and not meta programming in
particular. Essentially, it's a super-class of infix operators where any
numbers of arguments denoted by special placeholders can be separated by
any number of tokens.

Mix-fix notation has successfully been used by some modern dependently
typed functional languages like Agda, or in some way is used to extend
the syntax in Coq via. Notation to implement for instance monads.

On this occasion, I'd like also discuss changes to the language
involving possibility of relaxing infix operators, and extending them
(like in Caml-light) with user defined precedence. With these
relaxations it might appear that the language will become more
expressive.

Also, I'd like to focus on reusing mix-fix syntax to provide
meta-programming facilities - in particular defining new grammar entry
points using mix-fix.

So the mixfix notation in OCaml might look like this:

let _>>=_ m f = (* here a bind operator for a monad! *)

or if we are fancy for these technique in extending the syntax:

syntax _<--_-<_ pat e1 e2 = (* here is a code generator for an arrow! *)

Surely OCaml is strictly evaluated so all the usual tricks that can be
used in a language where evaluation strategy or order does not matter,
will not work, however it opens brand new doors for making combinator
based libraries. Also, it's very convenient and safe syntax for defining
grammar rules, instead of using BNF or even PEG and extending the
grammar by changing the rules in place.

I agree it would be a serious change to the language, therefore I
welcome an open discussion. Perhaps in extreme variant such change would
require writing a custom parser and lexer, and would render the OCaml
syntax incompatible, but having discussions about the quotations
mechanism, essentially embedding a DSL inside Caml, I'd like to shift
focus on safe and still expressive various applications of mix-fix and
possibility of providing such an abstraction to the OCaml world.

All the best,

-Wojciech

From hongboz at seas.upenn.edu  Wed Jan 30 02:34:02 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 29 Jan 2013 21:34:02 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
Message-ID: <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>

Quotations(Deliminated  DSL) works reasonably well instead of ppx, here is
my version of ulex in Fan(an improvement compared with ulex or sedlex is t*hat
it works well on toplevel*).

let rec token enc =  {:lex|
   "<utf8>" -> begin enc := Ulexing.Utf8; token enc lexbuf end
  | "<latin1>" -> begin enc := Ulexing.Latin1; token enc lexbuf end
  | xml_letter+ -> Printf.sprintf "word(%s)" (Ulexing.utf8_lexeme lexbuf)
  | number -> "number"
  | eof -> exit 0
  | [1234-1246] -> "bla"
  | "(" ->  begin
      Ulexing.rollback lexbuf; (* Puts the lexeme back into the buffer *)
      {| "(" [^ '(']* ")" -> Ulexing.utf8_lexeme lexbuf |} lexbuf
      (* Note the use of an inline lexer *)
  end
  | "(*" -> begin comment lexbuf; "comment" end
  | ' ' -> "whitespace"
  | _ -> "???" |}
and comment = {:lex|
   "*)" -> ()
  | eof -> failwith "comment"
  | _ -> let _lexeme = Ulexing.lexeme lexbuf in
    comment lexbuf |}
On Tue, Jan 29, 2013 at 2:05 PM, Hongbo Zhang <hongboz at seas.upenn.edu>wrote:

> Dear wg-camp4 users,
>
>     So far,  the discussion is really interesting and quite helpful, but I
> want to talk about the meta-programming *from the point of the view of
> implementation side,* features are easy to propose, but maybe only the
> compiler/library writers know how hard to implement, I do appreciate that
> you can sit dow and read the long email, I am also starting to blog(
> http://hongboz.wordpress.com/) about how to do syntactic meta programming
> (SMP) in a right way.
>    I rewrite the whole camlP4(named Fan) from scratch, building the
> quotation kit and throw away the crappy grammar parser, so plz believe me
> *that I do understand the whole technology stack of camlP4*, if we could
> reach some consensus, I would be happy to handle over the maintaining of
>  Fan, Fan does not loose any feature compared with camlP4, in fact it has
> more interesting featrues.
>
>    Let's begin with some easy, not too technical parts which has a
> significant effect on user experience though:
>    1. Performance
>           Performance does matter, it's a shame that  the most time spent
> in compiling the ocaml compiler is dedicated to camlP4, but it is an
> engineering problem, currently compiling Fan only takes less than 20s, and
> it can be improved further
>    2. Building issues
>         The design of having side effects by dynamic loading is
> generically a bad idea, in Fan* the dynamic loading only register some
> functionality the Fan support,* it *does not have any other side effec*t,
> each file stands alone says which (ppx , or filters, or syntax) it want to
> use with a good default option. so the building is always something like
> '-pp fan pluging1 plugin2 plugin3', *the order of pulgings does not matter
> *, also, l*oading all the plugins you have does not have any side effect,
> even better, you can do the static linking all the plugins you collected,
> the building process is simplified.  *
> * * 3. Grammar Extension (*Language namespace*)
> *       *I concur that grammar extension arbitrarily is a bad idea, and I
> agree with Gabrier that so far only the quotation(Here  quotation means
> delimited DSL, quosi-quotation means Lisp style macros) is modular,
> composable, and  I also agree with Gabrier -ppx* should not be used to do
> syntax overriding (this should not be called syntax extension actually), *that's
> a terrible idea to do syntax overriding, since the user never understand
> what's going on underly without reading the Makefile. So here some my
> suggestion is that some really conevenient syntax extesion, i.e, (let try..
> in) should be merged to the built in parser. quotations does not bring too
> much heavy syntax (imho). In Fan, we proposed the concept of a hierarchical
> language name space, since once quotation is heavily used, it's really easy
> to introduce conflict, *the language namespace querying is exactly like
> java package namespace,* you can import, close import to save some typing.
>     Here is a taste
>
>  -----------------------------------------------------------------------------------------------
>      {:.Fan.Lang.Meta.expr| a + b |} ------>
>       `App (`App ((`Id (`Lid "+")), (`Id (`Lid "a")))), (`Id (`Lid "b")))
>      {:.Fan.Lang.Meta.N.expr| a + b |}  ----->
>       `App
>     (_loc,
>       (`App
>          (_loc, (`Id (_loc, (`Lid (_loc, "+")))),
>            (`Id (_loc, (`Lid (_loc, "a")))))),
>       (`Id (_loc, (`Lid (_loc, "b")))))
>
>  -----------------------------------------------------------------------------------------------
>  the .Fan.Lang.Meta.expr the first '.' means it's from the absolute
> namespace,  the *N.expr shares exactly the same syntax without location*,
> though
>
>    4. Portable to diffierrent compiler extensions(like LexiFi's fork of
> ocaml)
>        I am pretty sure it's pretty easy to do in Fan, only Ast2pt
> (dumping the intemediate Ast into Parsetree) part need to be changed to
> diffierent compilers.
>
>
> ----------------------------------------------------------------------------------------------------------------
> Now let's talk about some internal parts of SMP.
> Quasi-Quotation is the essential part of SMP,  I am surprised so far that
> the discussion *silently ignores the quasi-quotation,* Leo's answer of
> writing   three parsers is neither satisfying nor practical(imho).
>
> Camlp4 is mainly composed of two parts, one is the extensible parser and *the
> other significant part is Ast Lifting*. Since we all agree that
> extensible parser increases the complexity too much, let's simply ignore
> that part.
>
> The Ast Lifting are tightly coupled *with the design of the Abstract
> Syntax Tree.*  People complain about that Camlp4 Ast is hard to learn and
> using quasi-quotation to do the pattern match is a bad idea.
>
> Let me explain the topic a bit:
>     Camlp4Ast is hard to learn, I agree, it has some alien names that
> nobody understand what it  means, quosi-quotation *is definitely a great
> idea* to boom the meta-programming, but my experience here is *for very
> very small Ast fragment, using the Abstract Syntax Tree directly,* otherwise
> Quasi-quotation is a life saver to do the meta programming.
>    Luckily the quotation kit has nothing to do with the parser part, it's
> simply several functions(I did some simplify a bit) which turns a normal
> runtime
> value into an Ast node generically, *such kind functions are neither easy
> to write nor easy to read*, *the idea case is that it should be generated
> once for all, and all the data types in normal ocaml* *should be derived
> automatically*(some ADT with functions can not be derived). *I bet it's
> mostly likely a nightmare if we maintain 3 parsers for the ocaml grammar
> while two other parsers dumping to a meta-level*
>
>    So, how to make Ast Lifting easier,
>         The first guideline is *"Don't mixing with records", *
> *         *Once you encoding AST with records, you have to encode the
> records in the meta level which increases the complexity without bringing
> any new features, *it's simply not worthwhile.*
> *
> *
> *       * The second guideline is "Don't do *any *syntax desugaring" ,
> syntax desguaring makes the semantics of syntax meta programming a bit
> weird. Syntax desguaring happens everywhere in Parsetree, think about the
> list literals, it uses the syntax desuaring, if you don't use any syntax
> desugaring, for example, you want to match the bigarray access, you simply
> needed to match `Bigarray(..)' instead of
>
> Pexp_apply
>         ({pexp_desc=Pexp_ident
>                      {txt= Ldot (Ldot (Lident "Bigarray", array),
> ("get"|"set" as gs)) ;_};_},
>          label_exprs)
> ----------------------------
>        The third guideline is to* *make it *as uniform as possible*
> *       *This not only helps the user, but *it helps the meta-programming
> over types to derive some utility types. *Take a look at my Ast encoding
> in Fan https://github.com/bobzhang/Fan/blob/master/src/Ast.ml (it needs
> to be polished, plz don't panic when you see variants I use here)
> *      *The initial Ast has locations and ant support, but* here we
> derive 3 other Asts thanks to my very regular design*.* AstN is the Ast
> without locations*, the locations are important, but it is simply not too
> much helpful when you only do the code generation, but it complicates the
> expanded code a lot), *AstA is the Ast without antiquotations(simply
> remove the ant branch), *it is a subtype of Ast(thanks to the choice we
> use variants here), *AstNA is the Ast without neither locations nor
> antiquotations*), it is a subtype of AstN.  *In practice, I found the Ast
> without locations is particular helpful when you only do the code
> generation, it simplifies this part significantly. The beautif**ul part
> is that  all the four Ast share the same grammar with the same
> quosiquotatoin mechanism, as I showed .Fan.Lang.N.expr and .Fan.Lang.expr*
>     I don't know how many parsers you have to maintain to reach such a
> goal or it's never going to happen.
>     Using variants to encode the intermediate ast has a lots of other
> benefits, but I don't want to cover it in such a short mail.
>
>    So,* my proposal is that the community design an Intermediate Ast
> together, and write a built-in parser to such Intermediate Ast then dump to
> Parsetree, but I am for that Parsetree still needs to be cleaned a bit but
> not too much change .  *I do appreciate you can take something away from
> Fan, I think the Parsetree is* not the ideal part* to do SMP, HTH
>
> --
> -- Regards, Hongbo
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130129/ce5cc0d5/attachment-0001.html>

From alain at frisch.fr  Wed Jan 30 06:17:30 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 07:17:30 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
Message-ID: <5108BAFA.5020206@frisch.fr>

On 1/29/2013 7:53 PM, Gabriel Scherer wrote:
> I'm not sure the idea of having "postfix" and "prefix" annotations
> makes sense for all grammar rules (and mixing them with a modality of
> "external or ocaml-syntax" feels like conflating separate concerns).

I agree.  If we have a syntax for embedding arbitrary syntax (basically, 
a new kind of string literals in expressions and patterns, with 
adifferent lexing rules, and rejected by the type-checker), let's say {{ 
... }}, we could use it either as a stand-alone expression

  {{ ... }}

or as an attribute on another expression:

  (@{{ ... }}) e

So I don't think we need to provide parsed and non-parsed variants of 
attributes.

What makes sense is maybe to distinguish attributes which can be dropped 
silently by the compiler (but used by other tools like ocamldoc, for 
instance) and those on which the type-checker needs to fail.  This is 
not strictly necessary if we already have a new kind of expressions on 
which the type-checkers fail, and it does not really bring much security 
because the user could easily use the other syntax of attributes and get 
(probably) simply a type error instead of a "remaining attribute" error.


> I'd rather consider where annotation may happen for grammar rules
> individually. For example, in the case of "let p = e1 in e2", I'm
> quite sure we may want to annotate either the whole expression or
> specifically the declaration, and while I see how prefix and postfix
> both make sense for the whole expression, I'm not sure they would both
> make sense to annotate the binding, and considering only those cases
> could lead them to being dropped.


>
> Still in this case 'let p = e1 in e2', how should we distinguish:
> - an annotation on the expressions 'e1' and 'e2'
> - an annotation on the pattern 'p' (possibly seen as an expressions)
> - an annotation on the binding itself
> - an annotation on the expression as a whole?

We need of course to define priority rules, but I don't see why postfix 
and prefix couldn't make sense for all constructions (maybe with some 
more parentheses):

On the whole expression:
  (@ ..) (let p = e1 in e2)
  (let p = e1 in e2) (% ..)

On the pattern:
  let (@ ..) p = e1 in e2
  let p (% ..) = e1 in e2

On e1:
  let p = (@ ..) e1 in e2
  let p = e1 (% ..) in e2

On e2:
  let p = e1 in (@ ..) e2
  let p = e1 in e2 (% ..)

What's missing is maybe the ability to annotate either the binding 
itself as opposed to the whole expression (more interesting when the 
whole expression has multiple bindings: let p1 = e1 and p2 = e2 and 
...).  But is that really necessary?  One can always use the convention 
that an annotation on the binding would actually need to be put at the 
toplevel of the pattern itself.



Alain

From gabriel.scherer at gmail.com  Wed Jan 30 06:31:17 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Wed, 30 Jan 2013 07:31:17 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108BAFA.5020206@frisch.fr>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
Message-ID: <CAPFanBE+X=M3C+CHWq024zAFLEHnrp1hDT-FNLv3aJN8LontVw@mail.gmail.com>

> What's missing is maybe the ability to annotate either the binding itself as
> opposed to the whole expression (more interesting when the whole expression
> has multiple bindings: let p1 = e1 and p2 = e2 and ...).  But is that really
> necessary?  One can always use the convention that an annotation on the
> binding would actually need to be put at the toplevel of the pattern itself.

My understanding is that this is precisely what type-conv does:
annotate the type declaration itself, rather than the type expression
or the whole phrase. I'm not sure what kind of annotations are being
considered here, but a pragma-style @ignore_unused_variable for
example should be bound to the declaration itself. Finally, using a
convention to annotate the pattern may give rise to critical pairs /
ambiguities where the semantics of the program depends of whether we
consider the annotation to cover the pattern or the declaration (for
annotations that make sense in both, eg. @profile).

On Wed, Jan 30, 2013 at 7:17 AM, Alain Frisch <alain at frisch.fr> wrote:
> On 1/29/2013 7:53 PM, Gabriel Scherer wrote:
>>
>> I'm not sure the idea of having "postfix" and "prefix" annotations
>> makes sense for all grammar rules (and mixing them with a modality of
>> "external or ocaml-syntax" feels like conflating separate concerns).
>
>
> I agree.  If we have a syntax for embedding arbitrary syntax (basically, a
> new kind of string literals in expressions and patterns, with adifferent
> lexing rules, and rejected by the type-checker), let's say {{ ... }}, we
> could use it either as a stand-alone expression
>
>  {{ ... }}
>
> or as an attribute on another expression:
>
>  (@{{ ... }}) e
>
> So I don't think we need to provide parsed and non-parsed variants of
> attributes.
>
> What makes sense is maybe to distinguish attributes which can be dropped
> silently by the compiler (but used by other tools like ocamldoc, for
> instance) and those on which the type-checker needs to fail.  This is not
> strictly necessary if we already have a new kind of expressions on which the
> type-checkers fail, and it does not really bring much security because the
> user could easily use the other syntax of attributes and get (probably)
> simply a type error instead of a "remaining attribute" error.
>
>
>
>> I'd rather consider where annotation may happen for grammar rules
>> individually. For example, in the case of "let p = e1 in e2", I'm
>> quite sure we may want to annotate either the whole expression or
>> specifically the declaration, and while I see how prefix and postfix
>> both make sense for the whole expression, I'm not sure they would both
>> make sense to annotate the binding, and considering only those cases
>> could lead them to being dropped.
>
>
>
>>
>> Still in this case 'let p = e1 in e2', how should we distinguish:
>> - an annotation on the expressions 'e1' and 'e2'
>> - an annotation on the pattern 'p' (possibly seen as an expressions)
>> - an annotation on the binding itself
>> - an annotation on the expression as a whole?
>
>
> We need of course to define priority rules, but I don't see why postfix and
> prefix couldn't make sense for all constructions (maybe with some more
> parentheses):
>
> On the whole expression:
>  (@ ..) (let p = e1 in e2)
>  (let p = e1 in e2) (% ..)
>
> On the pattern:
>  let (@ ..) p = e1 in e2
>  let p (% ..) = e1 in e2
>
> On e1:
>  let p = (@ ..) e1 in e2
>  let p = e1 (% ..) in e2
>
> On e2:
>  let p = e1 in (@ ..) e2
>  let p = e1 in e2 (% ..)
>
> What's missing is maybe the ability to annotate either the binding itself as
> opposed to the whole expression (more interesting when the whole expression
> has multiple bindings: let p1 = e1 and p2 = e2 and ...).  But is that really
> necessary?  One can always use the convention that an annotation on the
> binding would actually need to be put at the toplevel of the pattern itself.
>
>
>
> Alain

From alain at frisch.fr  Wed Jan 30 08:33:02 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 09:33:02 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <CAPFanBE+X=M3C+CHWq024zAFLEHnrp1hDT-FNLv3aJN8LontVw@mail.gmail.com>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
 <CAPFanBE+X=M3C+CHWq024zAFLEHnrp1hDT-FNLv3aJN8LontVw@mail.gmail.com>
Message-ID: <5108DABE.9020601@frisch.fr>

On 01/30/2013 07:31 AM, Gabriel Scherer wrote:
> My understanding is that this is precisely what type-conv does:
> annotate the type declaration itself, rather than the type expression
> or the whole phrase.

I agree it make sense to allow attaching attributes to various syntactic 
constructions, including those which are not "algebra", and type 
declaration are a good candidate for that.  Note that when I proposed 
attributes, I wrote:

> I propose to start discussing the addition of attributes to most syntactic categories (expressions, type expressions, patterns, type declarations, module expressions, structure/signature items, etc).

I'm not sure we need to allow attributes on specific parts of expression 
kinds (e.g. annotate the "for" itself, or each binding in a "let"). I'm 
not fundamentally opposed to it, but it will add a lot of complexity to 
the Parsetree with no obvious benefit.  This probably needs to be 
discussed on a case-by-case basis.

> Finally, using a
> convention to annotate the pattern may give rise to critical pairs /
> ambiguities where the semantics of the program depends of whether we
> consider the annotation to cover the pattern or the declaration (for
> annotations that make sense in both, eg. @profile).

Yes, but it does not seem difficult to have a different convention for 
something related to the pattern itself and something related to the 
binding, if the same general notion need to apply to both.

Alain

From lpw25 at cam.ac.uk  Wed Jan 30 08:36:47 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 08:36:47 +0000
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108BAFA.5020206@frisch.fr>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
Message-ID: <Prayer.1.3.5.1301300836470.10317@hermes-1.csi.cam.ac.uk>

>What makes sense is maybe to distinguish attributes which can be dropped 
>silently by the compiler (but used by other tools like ocamldoc, for 
>instance) and those on which the type-checker needs to fail.  This is 
>not strictly necessary if we already have a new kind of expressions on 
>which the type-checkers fail, and it does not really bring much security 
>because the user could easily use the other syntax of attributes and get 
>(probably) simply a type error instead of a "remaining attribute" error.

An extension could only support {: foo } style attributes (the ones that 
the type-checker fails on), so then there would be no risk of a typo or 
missed ppx option causing a silent fail or an unhelpful error message.

I also think that it will make it easy to read code: If you see {: ... } 
then that will be translated into an expression/patter/..., if you see {% 
... } then you know that the expression it is attached to will be 
translated.

For instance, "foo bar {: ... }" means that foo will be called with bar and 
whatever that attribute becomes as arguments. "foo bar {% ... }" means that 
foo and bar are going to be translated in some way.

And since we're probably supporting <: ... >, I see no harm in supporting 
<% ... > as well, especially if we support {: ... } and {% ... } (or (: ... 
) and (% ... ) if you prefer).


From alain at frisch.fr  Wed Jan 30 09:12:03 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 10:12:03 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
Message-ID: <5108E3E3.307@frisch.fr>

On 01/30/2013 03:34 AM, Hongbo Zhang wrote:
> let rec token enc =  {:lex|
>     "<utf8>" -> begin enc := Ulexing.Utf8; token enc lexbuf end
>    | "<latin1>" -> begin enc := Ulexing.Latin1; token enc lexbuf end
>    | xml_letter+ -> Printf.sprintf "word(%s)" (Ulexing.utf8_lexeme lexbuf)
>    | number -> "number"
>    | eof -> exit 0
>    | [1234-1246] -> "bla"
>    | "(" ->  begin
>        Ulexing.rollback lexbuf; (* Puts the lexeme back into the buffer *)
>        {| "(" [^ '(']* ")" -> Ulexing.utf8_lexeme lexbuf |} lexbuf
>        (* Note the use of an inline lexer *)
>    end
>    | "(*" -> begin comment lexbuf; "comment" end
>    | ' ' -> "whitespace"
>    | _ -> "???" |}
> and comment = {:lex|
>     "*)" -> ()
>    | eof -> failwith "comment"
>    | _ -> let _lexeme = Ulexing.lexeme lexbuf in
>      comment lexbuf |}

This looks very bad to me:

1. You loose all support from your editor (indentation, coloring, 
parentheses matching).  Am I the only one who finds this really 
problematic?  With quotations, my emacs looks like notepad... 
Indentation and coloring do find typos on the fly; automatic indentation 
makes it easy to copy/paste code from one context to another one.

2. Quotation "with OCaml code in them" does not combine well with other 
AST rewriters.  If you have a -ppx filter implementing, say, macro 
expansion (in patterns and expressions), would you apply it before or 
after the one expanding the {:lex| ... |} quotations?  Probably both. 
(And won't be able to benefit of macro on patterns for the "regexps".)

3. How do you implement the expander?  Somehow, you need to parse the 
content of the quotation (stored as a string in the AST), which involves 
non trivial stuff, like a parser being able to parse OCaml code mixed 
with something else.  Personally, I don't know how to implement the 
quotation expander with the parsing technologies I'm familiar with.


For me quotations (in position of expression) are useful only for one 
thing: escape from the lexical conventions of OCaml string literals. 
Otherwise, strings are just fine.  There are very few cases where with 
actually matters.  A decent example might be something like Pa_tyxml, 
allowing to write XML code in XML syntax within OCaml sources.  But even 
there, I'm not absolutely sure that quotations are the best solution: 
would it really be so bad to use normal OCaml strings (with an attribute):

   (@xml)"<div>xyz</div>"

or OCaml syntax interpreted specially:

   (@xml)(div "xyz")

instead of the current:

  <:html5< <div>xyz</div> >>


But maybe for some cases (embedding a language with a lot of double 
quoted and backslashes), escaping from the lexical conventions of OCaml 
string literals might really be useful.  This could be actually be the 
case for standard string literals, with no special syntactic processing. 
  So why not simply address this need by allowing an alternative syntax 
for string literals, where no special character is interpreted?  The 
opening delimiter would define the closing delimiter.  For instance:

   {xxx{ ..... }xxx}

(here I've assumed that { } are hard-coded, but xxx could be replaced 
say, by any sequence of identifier/digit/operator characters). In the 
AST, this could be represented as a normal string literal (or maybe we 
should keep the "xxx" annotation, to avoid having to put an extra 
attribute in front of the literal).


I've yet to be convinced that quotations really have other interesting 
uses than escaping from lexical conventions of OCaml string literals...


Alain

From alain at frisch.fr  Wed Jan 30 09:23:57 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 10:23:57 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <Prayer.1.3.5.1301300836470.10317@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
 <Prayer.1.3.5.1301300836470.10317@hermes-1.csi.cam.ac.uk>
Message-ID: <5108E6AD.7030508@frisch.fr>

On 01/30/2013 09:36 AM, Leo White wrote:
> An extension could only support {: foo } style attributes (the ones that
> the type-checker fails on), so then there would be no risk of a typo or
> missed ppx option causing a silent fail or an unhelpful error message.

The risk is that the user writes {@ foo} instead of {@ foo}.  This does 
not sound much less probable than the user writing {@ foox} instead of 
{: foo}.  But I will not fight against non-ignorable attributes!

> For instance, "foo bar {: ... }" means that foo will be called with bar
> and whatever that attribute becomes as arguments.

This was not my understanding.  You seem to imply that {: ... } here is 
not really a (postfix) attribute on the expression "foo bar", but that 
it is a stand-alone expression.  So actually, it is not attached on 
anything, it is not an attribute. I'd rather write it:

   foo bar ((@marker) e)

where the @marker attribute is to be detected by the "expander" and e is 
its argument.  If we want to make it clear that "e" will be interpreted 
in a non-trivial way and that (@marker) must be treated (and otherwise 
the type-checker should complain by mentioning it explicitly), we could 
write:

  foo bar ((:marker) e)

(Assuming now that (:...) is in prefix position.)


Alain

From xavier.clerc at inria.fr  Wed Jan 30 09:27:52 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 30 Jan 2013 10:27:52 +0100 (CET)
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108DABE.9020601@frisch.fr>
Message-ID: <1725284723.1172415.1359538069788.JavaMail.root@inria.fr>

----- Mail original -----
> On 01/30/2013 07:31 AM, Gabriel Scherer wrote:
> > My understanding is that this is precisely what type-conv does:
> > annotate the type declaration itself, rather than the type
> > expression
> > or the whole phrase.
> 
> I agree it make sense to allow attaching attributes to various
> syntactic
> constructions, including those which are not "algebra", and type
> declaration are a good candidate for that.  Note that when I proposed
> attributes, I wrote:
> 
> > I propose to start discussing the addition of attributes to most
> > syntactic categories (expressions, type expressions, patterns,
> > type declarations, module expressions, structure/signature items,
> > etc).
> 
> I'm not sure we need to allow attributes on specific parts of
> expression
> kinds (e.g. annotate the "for" itself, or each binding in a "let").
> I'm
> not fundamentally opposed to it, but it will add a lot of complexity
> to
> the Parsetree with no obvious benefit.  This probably needs to be
> discussed on a case-by-case basis.

I have several questions related to attributes, regardless of their
actual syntax. The questions stem from my limited knowledge of their
Java equivalent.

1- should attributes be declared before use ? and if so, should the
contents of attributes be typed? To be concrete, in Java, you are
allowed to annotate something with "@MyAnnot(a=1, b="two")" iff
"MyAnnot" has been declared with fields "a" (of type "int") and "b"
(of type "string").

2- if you declare attributes before use, would it be desirable to
be able to select which syntactic constructs they can annotate ?
To be concrete, you might decide that a "@profile" attribute can
be used with expressions, but not with types.

3- should annotations be stored (e. g. in cmi/cmo/cmx files) in
order for an attribute processor to be able to access attributes
of other modules ?


Personally, I think that declaring attributes with their fields
and types is pretty useful. This protects the user from some
typos and other obvious errors, and avoid boiler-plate code in
the attribute processors.

Do list readers have strong opinions on these questions ?


Xavier Clerc

From lpw25 at cam.ac.uk  Wed Jan 30 09:31:51 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 09:31:51 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <5108E3E3.307@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
Message-ID: <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>

I don't really see the difference between:

>   {xxx{ ..... }xxx}

and

>  <:html5< <div>xyz</div> >>

except that the second one forces you to name your quotation which is 
definitely a good thing. It also makes it much easier in the future to add 
something like Fabrice's Templates.

In fact, I would be tempted to suggest that anything like {: ... } might 
also require a name (not for {% ... } as I can think of cases where this 
would be too restrictive).


From lpw25 at cam.ac.uk  Wed Jan 30 09:40:08 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 09:40:08 +0000
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108E6AD.7030508@frisch.fr>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
 <Prayer.1.3.5.1301300836470.10317@hermes-1.csi.cam.ac.uk>
 <5108E6AD.7030508@frisch.fr>
Message-ID: <Prayer.1.3.5.1301300940080.9358@hermes-1.csi.cam.ac.uk>

>This was not my understanding.  You seem to imply that {: ... } here is 
>not really a (postfix) attribute on the expression "foo bar", but that 
>it is a stand-alone expression.  

Yes, that is the idea. It is also why they must be non-ignorable.

> So actually, it is not attached on 
>anything, it is not an attribute. 

Indeed, but for lack of a better word I'll stick with attribute.

> I'd rather write it:
>
>   foo bar ((@marker) e)

I would prefer it to have its own syntax, because I would like to encourage 
its use. I think that it is easier to read than a normal attribute because 
it clearly declares its scope, and since it cannot be ignored it is also 
safer. I would also like this syntax to be similar to <: ... > since they 
have similar uses.


From alain at frisch.fr  Wed Jan 30 09:44:29 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 10:44:29 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <1725284723.1172415.1359538069788.JavaMail.root@inria.fr>
References: <1725284723.1172415.1359538069788.JavaMail.root@inria.fr>
Message-ID: <5108EB7D.2090701@frisch.fr>

On 01/30/2013 10:27 AM, Xavier Clerc wrote:
> Personally, I think that declaring attributes with their fields
> and types is pretty useful.

I don't see how to do that without introducing a lot of complexity in 
the system.  Do you mean we should run the OCaml type-checker on 
attribute arguments before they are processed?  Or that we should 
restrict attribute arguments to be pure constant data (records, 
constructors, literals)?  This seems overly restrictive.  It make sense 
to allow full expressions within attributes (e.g. some uses of type-conv 
requires to annotate types with functions), and I don't see how to 
type-check that.


> This protects the user from some
> typos and other obvious errors, and avoid boiler-plate code in
> the attribute processors.

I don't expect a lot of tedious boiler-plate code in the processors 
(OCaml is not so bad at pattern matching, after all) if they need to 
check some "constraints" on their arguments (not really type-checking, 
but rather checking simple things like the fact that they come with a 
string literal argument).


Alain

From xavier.clerc at inria.fr  Wed Jan 30 10:09:21 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 30 Jan 2013 11:09:21 +0100 (CET)
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108DABE.9020601@frisch.fr>
Message-ID: <876180034.10800.1359540560709.JavaMail.root@inria.fr>



----- Mail original -----
> On 01/30/2013 07:31 AM, Gabriel Scherer wrote:
> > My understanding is that this is precisely what type-conv does:
> > annotate the type declaration itself, rather than the type
> > expression
> > or the whole phrase.
> 
> I agree it make sense to allow attaching attributes to various
> syntactic
> constructions, including those which are not "algebra", and type
> declaration are a good candidate for that.  Note that when I proposed
> attributes, I wrote:
> 
> > I propose to start discussing the addition of attributes to most
> > syntactic categories (expressions, type expressions, patterns,
> > type declarations, module expressions, structure/signature items,
> > etc).
> 
> I'm not sure we need to allow attributes on specific parts of
> expression
> kinds (e.g. annotate the "for" itself, or each binding in a "let").
> I'm
> not fundamentally opposed to it, but it will add a lot of complexity
> to
> the Parsetree with no obvious benefit.  This probably needs to be
> discussed on a case-by-case basis.

I have several questions related to attributes, regardless of their
actual syntax. The questions stem from my limited knowledge of their
Java equivalent.

1- should attributes be declared before use ? and if so, should the
contents of attributes be typed? To be concrete, in Java, you are
allowed to annotate something with "@MyAnnot(a=1, b="two")" iff
"MyAnnot" has been declared with fields "a" (of type "int") and "b"
(of type "string").

2- if you declare attributes before use, would it be desirable to
be able to select which syntactic constructs they can annotate ?
To be concrete, you might decide that a "@profile" attribute can
be used with expressions, but not with types.

3- should annotations be stored (e. g. in cmi/cmo/cmx files) in
order for an attribute processor to be able to access attributes
of other modules ?


Personally, I think that declaring attributes with their fields
and types is pretty useful. This protects the user from some
typos and other obvious errors, and avoid boiler-plate code in
the attribute processors.

Do list readers have strong opinions on these questions ?


Xavier Clerc

From xavier.clerc at inria.fr  Wed Jan 30 10:24:02 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 30 Jan 2013 11:24:02 +0100 (CET)
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108EB7D.2090701@frisch.fr>
Message-ID: <1008548475.13786.1359541398143.JavaMail.root@inria.fr>



----- Mail original -----
> On 01/30/2013 10:27 AM, Xavier Clerc wrote:
> > Personally, I think that declaring attributes with their fields
> > and types is pretty useful.
> 
> I don't see how to do that without introducing a lot of complexity in
> the system.  Do you mean we should run the OCaml type-checker on
> attribute arguments before they are processed?  Or that we should
> restrict attribute arguments to be pure constant data (records,
> constructors, literals)?  This seems overly restrictive.  It make
> sense
> to allow full expressions within attributes (e.g. some uses of
> type-conv
> requires to annotate types with functions), and I don't see how to
> type-check that.

Java made the choice to restrict to constants.
This is indeed restrictive, but make sure that it is easy to check
whether an annotation is correct, and also to store it for future
use.


> > This protects the user from some
> > typos and other obvious errors, and avoid boiler-plate code in
> > the attribute processors.
> 
> I don't expect a lot of tedious boiler-plate code in the processors
> (OCaml is not so bad at pattern matching, after all) if they need to
> check some "constraints" on their arguments (not really
> type-checking,
> but rather checking simple things like the fact that they come with a
> string literal argument).

Well, there are two things: the boiler-plate code (maybe not such
a big problem in OCaml, as you point out), and the fact that if the
constraints are always checked by the same piece of code, error message
presented to the end-user will be uniform.


Xavier Clerc

From alain at frisch.fr  Wed Jan 30 10:46:37 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 11:46:37 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
Message-ID: <5108FA0D.5010802@frisch.fr>

On 01/30/2013 10:31 AM, Leo White wrote:
> I don't really see the difference between:
>
>>   {xxx{ ..... }xxx}
>
> and
>
>>  <:html5< <div>xyz</div> >>

The differences are:

  - The closing delimiter is defined by the opening one, so you don't 
need any escaping convention.  (Imagine you want to write HTML code 
containing ">>".)

  - This is usable for regular strings, independently from any -ppx 
manipulation.  In my experience, I faced quite often situations where it 
would have been convenient to write string literals but without OCaml's 
lexical convention.

For instance, imagine that instead of relying on OCaml patterns for 
writing Sedlex's regular expressions, I wanted to use a more compact 
notation.  I could simply use strings:

  (@sedlex) match lexbuf with
   | "xml_letter+" -> ...
   | ...

And I would probably arrange to reduce the need for using the double 
quote character, allowing to write string literals with single quotes:

  (@sedlex) match lexbuf with
   | "'with'" -> ...
   | ...

But I could as well prefer to allow double quotes, using the alternative 
syntax for string literals:

  (@sedlex) match lexbuf with
   | {{ xml_letter+ }} -> ...
   | {{ "with" }} -> ...
   | ...

if "xxx" is allowed to be empty in {xxx{...}xxx}.  There is no quotation 
to name here, this is implied by the surrounding attribute @sedlex 
(which could be made non-ignorable).

As a side note, whatever syntax we choose for quotations / non-parsed 
strings, we should avoid the one currently used by Camlp4, because for 
some time, people will continue to use both Camlp4 and -ppx rewriters.


Alain

From xavier.clerc at inria.fr  Wed Jan 30 11:00:34 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 30 Jan 2013 12:00:34 +0100 (CET)
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5108EB7D.2090701@frisch.fr>
Message-ID: <268527069.23397.1359543612595.JavaMail.root@inria.fr>



----- Mail original -----
> On 01/30/2013 10:27 AM, Xavier Clerc wrote:
> > Personally, I think that declaring attributes with their fields
> > and types is pretty useful.
> 
> I don't see how to do that without introducing a lot of complexity in
> the system.  Do you mean we should run the OCaml type-checker on
> attribute arguments before they are processed?  Or that we should
> restrict attribute arguments to be pure constant data (records,
> constructors, literals)?  This seems overly restrictive.  It make
> sense
> to allow full expressions within attributes (e.g. some uses of
> type-conv
> requires to annotate types with functions), and I don't see how to
> type-check that.

Java made the choice to restrict to constants.
This is indeed restrictive, but make sure that it is easy to check
whether an annotation is correct, and also to store it for future
use.



> > This protects the user from some
> > typos and other obvious errors, and avoid boiler-plate code in
> > the attribute processors.
> 
> I don't expect a lot of tedious boiler-plate code in the processors
> (OCaml is not so bad at pattern matching, after all) if they need to
> check some "constraints" on their arguments (not really
> type-checking,
> but rather checking simple things like the fact that they come with a
> string literal argument).

Well, there are two things: the boiler-plate code (maybe not such
a big problem in OCaml, as you point out), and the fact that if the
constraints are always checked by the same piece of code, error messages
presented to the end-user will be uniform.


Xavier Clerc

From alain at frisch.fr  Wed Jan 30 11:14:34 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 12:14:34 +0100
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <Prayer.1.3.5.1301300940080.9358@hermes-1.csi.cam.ac.uk>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
 <Prayer.1.3.5.1301300836470.10317@hermes-1.csi.cam.ac.uk>
 <5108E6AD.7030508@frisch.fr>
 <Prayer.1.3.5.1301300940080.9358@hermes-1.csi.cam.ac.uk>
Message-ID: <5109009A.8010400@frisch.fr>

On 01/30/2013 10:40 AM, Leo White wrote:
>> I'd rather write it:
>>
>>   foo bar ((@marker) e)
>
> I would prefer it to have its own syntax, because I would like to
> encourage its use. I think that it is easier to read than a normal
> attribute because it clearly declares its scope

I don't see the point: the scope of an attribute must be quite explicit 
as well (but maybe the current syntax is not clear enough).

-- Alain

From edwin+ml-ocaml at etorok.net  Wed Jan 30 11:19:30 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Wed, 30 Jan 2013 13:19:30 +0200
Subject: [wg-camlp4] Editor support for syntax extensions
In-Reply-To: <5108E3E3.307@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
Message-ID: <510901C2.2050603@etorok.net>

On 01/30/2013 11:12 AM, Alain Frisch wrote:
> On 01/30/2013 03:34 AM, Hongbo Zhang wrote:
>> let rec token enc =  {:lex|
>>     "<utf8>" -> begin enc := Ulexing.Utf8; token enc lexbuf end
>>    | "<latin1>" -> begin enc := Ulexing.Latin1; token enc lexbuf end
>>    | xml_letter+ -> Printf.sprintf "word(%s)" (Ulexing.utf8_lexeme lexbuf)
>>    | number -> "number"
>>    | eof -> exit 0
>>    | [1234-1246] -> "bla"
>>    | "(" ->  begin
>>        Ulexing.rollback lexbuf; (* Puts the lexeme back into the buffer *)
>>        {| "(" [^ '(']* ")" -> Ulexing.utf8_lexeme lexbuf |} lexbuf
>>        (* Note the use of an inline lexer *)
>>    end
>>    | "(*" -> begin comment lexbuf; "comment" end
>>    | ' ' -> "whitespace"
>>    | _ -> "???" |}
>> and comment = {:lex|
>>     "*)" -> ()
>>    | eof -> failwith "comment"
>>    | _ -> let _lexeme = Ulexing.lexeme lexbuf in
>>      comment lexbuf |}
> 
> This looks very bad to me:
> 
> 1. You loose all support from your editor (indentation, coloring, parentheses matching).  Am I the only one who finds this really problematic?  With quotations, my emacs looks like notepad...

I still get syntax highlighting and matching parens in both vim and emacs for the above (although maybe antiquotations would confuse it):
http://www.pasteall.org/pic/show.php?id=44586
http://www.pasteall.org/pic/show.php?id=44587

I do agree that editor support is less reliable once you start using syntax extensions. A common way to define quotations and anti-quotations could probably
help editors cope with syntax extensions better though.

> Indentation and coloring do find typos on the fly; automatic indentation makes it easy to copy/paste code from one context to another one.

Editor support is something that I meant discuss.

1. Auto-completion support.

This already exists for Emacs in the form of Typerex's ocp-complete I think.
It might be possible to adapt it for Vim, for example see how ClangComplete works here for C: http://llvm.org/viewvc/llvm-project/llvm/trunk/utils/vim/vimrc?view=markup.

I'd like to have this idea extended to syntax extensions too, where the syntax extension *itself* provides the possible completions.
For example: a lexer/parser extensions could provide completion based on available tokens, a monadic syntax extensions would provide completion
based on available monad variables, etc.

And of course once you go back to original OCaml syntax inside a quotation it should provide the regular OCaml completions.

2. Syntax highlighting support

Currently each editor has its own syntax highlighting rules, but there are some (corner) cases
where even with no syntax extensions it gets it wrong (ok, maybe I should file bugs about those).

What I had in mind is that (optionally) the Vim syntax highlighter script passes the source code through an external process and gets back
markers for syntax highlighting, and it uses that to override its built-in highlighter:
@1,5-1,17 Keyword
@1,17-3,28 Comment
...

Not sure how hard would it be to write such a Vim (or Emacs) script, and how well it'd work in practice (you probably
wouldn't want to do this for every character the user types, maybe only do this on file load/during idle times/after entering a complete line/saving/etc.).
This is again probably similar to what Typerex already does for the OCaml syntax.

As for the external process, it'd use compiler-libs to parse the source code, run any -ppx/camlp4 extensions on it, take the locations from the original parsetree
and output these syntax markers.

To take your IFDEF example:
    | {pmod_desc = Pmod_apply(
         {pmod_desc = Pmod_apply(
          {pmod_desc = Pmod_apply(
           {pmod_desc = Pmod_ident {txt = Lident "IFDEF"}, pmod_loc = ifdef_loc},
           {pmod_desc = Pmod_ident {txt = Lident sym}}
          )},
          body_def)}, body_not_def)} ->
            self#highlight ifdef_loc `Keyword;
            if getenv sym <> "" then this # module_expr body_def
            else this # module_expr body_not_def
 ....

Then astmapper could have two kinds of outputs:
* by default it outputs the new parsetree
* if there is a '--highlight' command-line it throws away the parsetree and prints instead the highlight marker collected by self#highlight, and then uses default
OCaml highlighting to output markers for parsetree nodes that didn't get self#highlight called.

3. Syntax checking support

Something similar to gcc's -fsyntax-only, but better. Currently you need to compile a fake .cmi or ask for a fake .inferred.mli to get syntax + type errors for the current file,
which is time consuming sometimes.

The above tool could have a flag to also output syntax errors (since it has to parse the source code anyway, and it knows what syntax extensions are used), _and_
it could also try to show type errors based on the current file, and any already existing .cmi files.

4. What syntax extensions to use => define in the source code

This has already been mentioned that the source file could define what syntax extensions it uses, so it works for all build systems (ocamlbuild, makefiles, omake), etc.
It may not even need special support from the compiler: there could be a -ppx that finds these pragmas and loads those other -ppx on its own!

Best regards,
--Edwin







From lpw25 at cam.ac.uk  Wed Jan 30 11:21:55 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 11:21:55 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <5108FA0D.5010802@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
Message-ID: <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>

>  - The closing delimiter is defined by the opening one, so you don't 
>need any escaping convention.  (Imagine you want to write HTML code 
>containing ">>".)

As I suggested in an earlier post, it is simple to allow this for <: ... >.

>  (@sedlex) match lexbuf with
>   | {{ xml_letter+ }} -> ...
>   | {{ "with" }} -> ...
>   | ...

I suppose that it is sometimes useful to have an unnamed quotation. For 
this I think that camlp4 has "<< ... >>", so we could just allow that.

>As a side note, whatever syntax we choose for quotations / non-parsed 
>strings, we should avoid the one currently used by Camlp4, because for 
>some time, people will continue to use both Camlp4 and -ppx rewriters.

I disagree with this. It is not at all difficult to tell camlp4 to pass 
through unrecognised quotations onto the main compiler (and so to the other 
preprocessors). It would then be simple for quotation extensions to 
seamlessly switch from -pp to -ppx.


From lpw25 at cam.ac.uk  Wed Jan 30 11:43:51 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 11:43:51 +0000
Subject: [wg-camlp4] Against the use of syntactically-valid OCaml code
 for syntax extension purposes
In-Reply-To: <5109009A.8010400@frisch.fr>
References: <CAPFanBEFN6CUZTvVamx+QMOZogm8WtPT8b4bC8qDrajJGv78uA@mail.gmail.com>
 <5107BEDF.6040907@frisch.fr>
 <Prayer.1.3.5.1301291816210.2941@hermes-1.csi.cam.ac.uk>
 <CAPFanBF6cFWUMTpBgLt_cUtKpayW5Pxv3gJ258i0X-jok5irfQ@mail.gmail.com>
 <5108BAFA.5020206@frisch.fr>
 <Prayer.1.3.5.1301300836470.10317@hermes-1.csi.cam.ac.uk>
 <5108E6AD.7030508@frisch.fr>
 <Prayer.1.3.5.1301300940080.9358@hermes-1.csi.cam.ac.uk>
 <5109009A.8010400@frisch.fr>
Message-ID: <Prayer.1.3.5.1301301143510.2899@hermes-1.csi.cam.ac.uk>

On Jan 30 2013, Alain Frisch wrote:

>On 01/30/2013 10:40 AM, Leo White wrote:
>>> I'd rather write it:
>>>
>>>   foo bar ((@marker) e)
>>
>> I would prefer it to have its own syntax, because I would like to
>> encourage its use. I think that it is easier to read than a normal
>> attribute because it clearly declares its scope
>
>I don't see the point: the scope of an attribute must be quite explicit 
>as well (but maybe the current syntax is not clear enough).

The point is that there are fundamentally two kinds of extension.

The first kind are things which themselves represent 
expressions/patterns/... . For example:

<:html < <body> ... </body> >> 

{:PGSQL dbh "select id, name from users"}

and the second kind are those that act on an existing 
expression/pattern/... . For example:

val foo: int -> int  {%depreciated}

In the first case, the syntax inside the brackets may look like OCaml but 
it will be translated. In the second kind the expression that the attribute 
is attached to *is* OCaml code. It may be acted on in some way (e.g. placed 
inside some boilerplate) but it fundamentally is OCaml code.

Failure to translate the first kind must raise an error. Failure to 
translate the second kind does not necessarily require an error.

I think that these differences is enough to justify separate (but similar) 
syntaxes. I don't think that everyone using the first kind of extension 
should have to use a syntax more suited to the second kind.



From anil at recoil.org  Wed Jan 30 12:35:57 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Wed, 30 Jan 2013 12:35:57 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <5108E3E3.307@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
Message-ID: <20130130123557.GB19728@dark.recoil.org>

On Wed, Jan 30, 2013 at 10:12:03AM +0100, Alain Frisch wrote:
> 
> 1. You loose all support from your editor (indentation, coloring,
> parentheses matching).  Am I the only one who finds this really
> problematic?  With quotations, my emacs looks like notepad...
> Indentation and coloring do find typos on the fly; automatic
> indentation makes it easy to copy/paste code from one context to
> another one.

Better editor support is the single biggest feature I'd like from the
switch to a more specialised ppx.  I've looked at customising the superb
Cloud9 Javascript editor, and the major blocker is having to run
everything through camlp4 all the time.

-- 
Anil Madhavapeddy                                 http://anil.recoil.org

From hongboz at seas.upenn.edu  Wed Jan 30 13:18:25 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Wed, 30 Jan 2013 08:18:25 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <5108E3E3.307@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
Message-ID: <CANcqPu4CnjsJcVWTK3N0Q9iEMLWzHWtRM41u6EKRYX2T1we0wQ@mail.gmail.com>

On Wed, Jan 30, 2013 at 4:12 AM, Alain Frisch <alain at frisch.fr> wrote:

> On 01/30/2013 03:34 AM, Hongbo Zhang wrote:
>
>>
>> This looks very bad to me:
>
> 1. You loose all support from your editor (indentation, coloring,
> parentheses matching).  Am I the only one who finds this really
> problematic?  With quotations, my emacs looks like notepad... Indentation
> and coloring do find typos on the fly; automatic indentation makes it easy
> to copy/paste code from one context to another one.
>
Weird, my emacs works pretty well for me, I choose "{| |}" since it's more
friendly to emacs. *On the contrary, quotation is great for IDE
integration, since when you type {:lex||}, the IDE knows the context already
*

>
> 2. Quotation "with OCaml code in them" does not combine well with other
> AST rewriters.  If you have a -ppx filter implementing, say, macro
> expansion (in patterns and expressions), would you apply it before or after
> the one expanding the {:lex| ... |} quotations?  Probably both. (And won't
> be able to benefit of macro on patterns for the "regexps".)
>
Ast Rewriter is *bad *for arbitrary code generation, its neat case is
something like bisect. And Ast Rewriter is not composable at  all, suppose
you have two AST Rewriters A,B ,there are no guarantee that  A.B == B.A, it
just gives you an illusion that it works, probably it silently fails.

>
> 3. How do you implement the expander?  Somehow, you need to parse the
> content of the quotation (stored as a string in the AST), which involves
> non trivial stuff, like a parser being able to parse OCaml code mixed with
> something else.  Personally, I don't know how to implement the quotation
> expander with the parsing technologies I'm familiar with.
>
> when you design your DSL, the left part is pretty easy to parse, when you
see the delimiter "->", invoking an existing parser.

>
> For me quotations (in position of expression) are useful only for one
> thing: escape from the lexical conventions of OCaml string literals.
> Otherwise, strings are just fine.  There are very few cases where with
> actually matters.  A decent example might be something like Pa_tyxml,
> allowing to write XML code in XML syntax within OCaml sources.  But even
> there, I'm not absolutely sure that quotations are the best solution: would
> it really be so bad to use normal OCaml strings (with an attribute):
>
>   (@xml)"<div>xyz</div>"
>
> or OCaml syntax interpreted specially:
>
>   (@xml)(div "xyz")
>
> instead of the current:
>
>  <:html5< <div>xyz</div> >>
>
>
> They all work great for me, but since they all work, why not only
introduce one,* I am happy to see the less ad-hoc rules.*
I did not mention that in Fan, we already support {:|?  ?|} , like Perl you
can supply an extra matching char to handle more complex cases.

Anyway, I think it would great to get the Abstract Syntax right before the
details on concrete syntax.

> But maybe for some cases (embedding a language with a lot of double quoted
> and backslashes), escaping from the lexical conventions of OCaml string
> literals might really be useful.  This could be actually be the case for
> standard string literals, with no special syntactic processing.  So why not
> simply address this need by allowing an alternative syntax for string
> literals, where no special character is interpreted?  The opening delimiter
> would define the closing delimiter.  For instance:
>
>   {xxx{ ..... }xxx}
>
> (here I've assumed that { } are hard-coded, but xxx could be replaced say,
> by any sequence of identifier/digit/operator characters). In the AST, this
> could be represented as a normal string literal (or maybe we should keep
> the "xxx" annotation, to avoid having to put an extra attribute in front of
> the literal).
>
>
> I've yet to be convinced that quotations really have other interesting
> uses than escaping from lexical conventions of OCaml string literals...
>
>
> Alain
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130130/39d29a7c/attachment.html>

From alain at frisch.fr  Wed Jan 30 14:21:20 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 15:21:20 +0100
Subject: [wg-camlp4] Editor support for syntax extensions
In-Reply-To: <510901C2.2050603@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr> <510901C2.2050603@etorok.net>
Message-ID: <51092C60.5000003@frisch.fr>

On 01/30/2013 12:19 PM, T?r?k Edwin wrote:
> I still get syntax highlighting and matching parens in both vim and emacs for the above (although maybe antiquotations would confuse it):

Highlighting gets completely wrong as soon as you start e.g. using 
double quotes. And indentation is just impossible if the editor isn't 
aware of the grammar implemented by the extensions.  One could certainly 
try to fix this and introduce more tools, complexity and border cases. 
But I still fail to see the real benefits of allowing very customized 
syntax which would justify such efforts.  The whole point of -ppx versus 
camlp4 is precisely to stop messing up with the concrete syntax: define 
some generic enough extension points, and just work with a fixed 
concrete syntax.  I'd prefer to see dead simple solutions adopted for 
-ppx, and more advanced stuff (based on concrete syntax) left to camlp4/fan.

> 4. What syntax extensions to use => define in the source code
>
> This has already been mentioned that the source file could define what syntax extensions it uses, so it works for all build systems (ocamlbuild, makefiles, omake), etc.
> It may not even need special support from the compiler: there could be a -ppx that finds these pragmas and loads those other -ppx on its own!

I've started something along these lines:

https://github.com/alainfrisch/ppx_drivers

Exactly how this works with ocamlfind needs to be discussed.  I know 
Gerd has some ideas!


Alain

From alain at frisch.fr  Wed Jan 30 14:41:23 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 15:41:23 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
Message-ID: <51093113.1080906@frisch.fr>

On 01/30/2013 12:21 PM, Leo White wrote:
>>  - The closing delimiter is defined by the opening one, so you don't
>> need any escaping convention.  (Imagine you want to write HTML code
>> containing ">>".)
>
> As I suggested in an earlier post, it is simple to allow this for <: ... >.
>
>>  (@sedlex) match lexbuf with
>>   | {{ xml_letter+ }} -> ...
>>   | {{ "with" }} -> ...
>>   | ...
>
> I suppose that it is sometimes useful to have an unnamed quotation. For
> this I think that camlp4 has "<< ... >>", so we could just allow that.

The important point is not the fact that the quotation is unnamed, but 
that it's scope is restricted to the smallest fragment which requires a 
custom parser (left-hand side).  I'm fine if those regexps cannot be 
highlighted very cleverly.  But what is important is that the right-hand 
side, which are normal OCaml expressions, are understood as such by the 
editor.  This cannot be the case with Hongbo's proposal of having the 
whole think inside a quotation:

{:lex|
    xml_letter+ -> ...
  | "with" -> ...
|}


So in this example:

   (@sedlex) match lexbuf with
    | {{ xml_letter+ }} -> ...
    | {{ "with" }} -> ...
    | ...

the role of {{...}} is not to introduce something which will expand to 
an expression or a pattern, it's just a way to avoid lexical rules on 
OCaml string literals (so that we don't need to escape the ").  The 
important part is the (@sedlex) attribute, and I wouldn't be shocked to 
use a different syntax to indicate that it really changes the 
interpretation of the underlying expression (the whole match statement), 
as opposed to some piece of information added to that expression.  The 
syntax could be simply changing (@sedlex) to (:sedlex), or maybe to have 
it look more like a delimiter with a clear scope:

  (:sedlex
     match lexbuf with
     | {{ xml_letter+ }} -> ...
     | {{ "with" }} -> ...
     | ...
  )

but the content would still be parsed as an expression, unlike camlp4 
quotations.


>> As a side note, whatever syntax we choose for quotations / non-parsed
>> strings, we should avoid the one currently used by Camlp4, because for
>> some time, people will continue to use both Camlp4 and -ppx rewriters.
>
> I disagree with this. It is not at all difficult to tell camlp4 to pass
> through unrecognised quotations onto the main compiler (and so to the
> other preprocessors). It would then be simple for quotation extensions
> to seamlessly switch from -pp to -ppx.

Ok, why not.  I still believe that real uses of "quotations" should be 
really limited and that most interesting uses of -ppx would not need 
them (or be independent from them, i.e. they should allow regular string 
literals as well).


Alain

From lpw25 at cam.ac.uk  Wed Jan 30 15:11:47 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 15:11:47 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <51093113.1080906@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
Message-ID: <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>

>The 
>syntax could be simply changing (@sedlex) to (:sedlex), or maybe to have 
>it look more like a delimiter with a clear scope:
>
>  (:sedlex
>     match lexbuf with
>     | {{ xml_letter+ }} -> ...
>     | {{ "with" }} -> ...
>     | ...
>  )
>
>but the content would still be parsed as an expression, unlike camlp4 
>quotations.
>

How about we broaden "quotations" (which to avoid confusion I'm going to 
start calling "templates") to allow the following two forms:

* <: lid expr >
* <: lid ?< unlexed-text >?>

(where ? can be any symbol or alpha-numberic character or empty)

The second form would essentially be syntactic sugar for <: lid {{ }} >. It 
is there for convenience and to preserve backward compatibility with 
camlp4.

Notice that they require an identifier. I think that this is a good thing 
because it helps prevent name clashes. It is also probably necessary for 
supporting <:foo < .. >> in the same construct.

Separate from this we also support "attributes" like (@ expr).

This should still allow you to use:

<:sedlex
     match lexbuf with
     | {{ xml_letter+ }} -> ...
     | {{ "with" }} -> ...
     | ...
  >

or even

   (@sedlex) match lexbuf with
    | {{ xml_letter+ }} -> ...
    | {{ "with" }} -> ...
    | ...

if you prefer it.


From alain at frisch.fr  Wed Jan 30 15:36:21 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 16:36:21 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
Message-ID: <51093DF5.9080306@frisch.fr>

On 01/30/2013 04:11 PM, Leo White wrote:
> How about we broaden "quotations" (which to avoid confusion I'm going to
> start calling "templates") to allow the following two forms:
>
> * <: lid expr >
> * <: lid ?< unlexed-text >?>
>
> (where ? can be any symbol or alpha-numberic character or empty)
>
> The second form would essentially be syntactic sugar for <: lid {{ }} >.
> It is there for convenience and to preserve backward compatibility with
> camlp4.

Do you really mean using a single > as the closing delimiter in the 
first case?  This seems rather bad to me, as it introduces useless 
ambiguity in the grammar. How do you parse:

<:lid 3 > 4 > 5

?

 >> is also a valid binary operator, by the way.

I'd rather drop compatibility with camlp4, and prefer characters which 
are already used as delimiters by OCaml and not binary operators.  If we 
drop compatibility with camlp4, there is no reason to prefer:

  <: lid xx< ... >xx>

over, say:

  (:lid {xx{ ... }xx})

which would often become:

  (:lid {{...}})


Alain

From lpw25 at cam.ac.uk  Wed Jan 30 16:13:54 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 30 Jan 2013 16:13:54 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <51093DF5.9080306@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
Message-ID: <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>

>Do you really mean using a single > as the closing delimiter in the 
>first case? 

You're right that should really be ">>".

>
> >> is also a valid binary operator, by the way.
>

Yes, but it is also listed as a keyword, so it is probably fine to 
appropriate it.

>I'd rather drop compatibility with camlp4, and prefer characters which 
>are already used as delimiters by OCaml and not binary operators.  If we 
>drop compatibility with camlp4, there is no reason to prefer:
>
>  <: lid xx< ... >xx>
>
>over, say:
>
>  (:lid {xx{ ... }xx})

I think that I prefer <: .. >> in part because it is not already used as a 
delimiter (at least not for expressions). I think that these things should 
stand out. I also think that, if there are no real issues with it, we 
should be compatible with camlp4.


From alain at frisch.fr  Wed Jan 30 17:07:48 2013
From: alain at frisch.fr (Alain Frisch)
Date: Wed, 30 Jan 2013 18:07:48 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
Message-ID: <51095364.9080001@frisch.fr>

On 01/30/2013 05:13 PM, Leo White wrote:
>> Do you really mean using a single > as the closing delimiter in the
>> first case?
>
> You're right that should really be ">>".

Same problem:

let ( >> ) = ( lsr ) in
<< foo >> 2 >>

>> >> is also a valid binary operator, by the way.
>>
>
> Yes, but it is also listed as a keyword, so it is probably fine to
> appropriate it.

The manual says:

""
Note that the following identifiers are keywords of the Camlp4 
extensions and should be avoided for compatibility reasons.

     parser    <<    <:    >>    $     $$    $:
""

 >> and << are really not keywords of OCaml, and I wouldn't be surprised 
they are actually used as operators.  I prefer breaking compatibility 
with camlp4 than with OCaml.


-- Alain

From gabriel.scherer at gmail.com  Wed Jan 30 17:21:54 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Wed, 30 Jan 2013 18:21:54 +0100
Subject: [wg-camlp4] A set of synthetic use cases to help discussions
Message-ID: <CAPFanBG_UpSjurNeu_y8YcUhhTJStJEhxsuHw5JB7d3g3nKwkA@mail.gmail.com>

One problem with the current debate(s) is that people have fairly
different syntaxes and semantics in mind regarding "syntax
extensions".

I think we should gather somewhere small snippets of "representative"
syntax extensions (for example under their current form, which
includes the Camlp4 syntax extensions but also eg. Lexifi's custom
attributes syntax or the imaginary quotation system of your liking),
so that people could refer to those example and concretely demonstrate
which cases their proposed semantics would capture, and with which
syntax.

I have started to put up some examples on the following wiki page,
mostly by accumulating what has been mentioned during the discussions
so far:

  https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases

I have made up the categories as I collected the examples, so they're
certainly suboptimal.

The page should be open for editing (let me know if the right aren't
set correctly), so that you can update it with new examples if you
think they are representative of some need that wasn't exposed before.
Please remember that the page is there to collect use cases for the
discussion here, rather than contain argumentation/opinion/judgments
itself.

From edwin+ml-ocaml at etorok.net  Wed Jan 30 17:32:12 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Wed, 30 Jan 2013 19:32:12 +0200
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <51095364.9080001@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
Message-ID: <5109591C.8060108@etorok.net>

On 01/30/2013 07:07 PM, Alain Frisch wrote:
> On 01/30/2013 05:13 PM, Leo White wrote:
>>> Do you really mean using a single > as the closing delimiter in the
>>> first case?
>>
>> You're right that should really be ">>".
> 
> Same problem:
> 
> let ( >> ) = ( lsr ) in
> << foo >> 2 >>
> 
>>> >> is also a valid binary operator, by the way.
>>>
>>
>> Yes, but it is also listed as a keyword, so it is probably fine to
>> appropriate it.
> 
> The manual says:
> 
> ""
> Note that the following identifiers are keywords of the Camlp4 extensions and should be avoided for compatibility reasons.
> 
>     parser    <<    <:    >>    $     $$    $:
> ""
> 
>>> and << are really not keywords of OCaml, and I wouldn't be surprised they are actually used as operators.

>> is used by OCamlnet:
http://projects.camlcity.org/projects/dl/ocamlnet-3.5.1/doc/html-main/Uq_engines.Operators.html


--Edwin

From info at gerd-stolpmann.de  Wed Jan 30 19:03:49 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Wed, 30 Jan 2013 20:03:49 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <5109591C.8060108@etorok.net> (from edwin+ml-ocaml@etorok.net
 on Wed Jan 30 18:32:12 2013)
References: <51095364.9080001@frisch.fr> <5109591C.8060108@etorok.net>
Message-ID: <1359572629.10634.16@samsung>

Am 30.01.2013 18:32:12 schrieb(en) T?r?k Edwin:
> On 01/30/2013 07:07 PM, Alain Frisch wrote:
> > On 01/30/2013 05:13 PM, Leo White wrote:
> >>> Do you really mean using a single > as the closing delimiter in  
> the
> >>> first case?
> >>
> >> You're right that should really be ">>".
> >
> > Same problem:
> >
> > let ( >> ) = ( lsr ) in
> > << foo >> 2 >>
> >
> >>> >> is also a valid binary operator, by the way.
> >>>
> >>
> >> Yes, but it is also listed as a keyword, so it is probably fine to
> >> appropriate it.
> >
> > The manual says:
> >
> > ""
> > Note that the following identifiers are keywords of the Camlp4  
> extensions and should be avoided for compatibility reasons.
> >
> >     parser    <<    <:    >>    $     $$    $:
> > ""
> >
> >>> and << are really not keywords of OCaml, and I wouldn't be  
> surprised they are actually used as operators.
> 
> >> is used by OCamlnet:
> http://projects.camlcity.org/projects/dl/ocamlnet-3.5.1/doc/html-main/Uq_engines.Operators.html

I was not aware of the problem when choosing operators - I looked more  
at precedence and associativity.

I think we shouldn't make the choice dependent on individual cases.  
Just figure something out that is consistent in itself, good to read,  
and permits enough freedom.

Gerd


> 
> --Edwin
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From info at gerd-stolpmann.de  Wed Jan 30 19:27:13 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Wed, 30 Jan 2013 20:27:13 +0100
Subject: [wg-camlp4] Editor support for syntax extensions
In-Reply-To: <51092C60.5000003@frisch.fr> (from alain@frisch.fr on Wed Jan
 30 15:21:20 2013)
Message-ID: <1359574033.10634.17@samsung>

Am 30.01.2013 15:21:20 schrieb(en) Alain Frisch:
> On 01/30/2013 12:19 PM, T?r?k Edwin wrote:
>> I still get syntax highlighting and matching parens in both vim and  
>> emacs for the above (although maybe antiquotations would confuse it):
> 
> Highlighting gets completely wrong as soon as you start e.g. using  
> double quotes. And indentation is just impossible if the editor isn't  
> aware of the grammar implemented by the extensions.  One could  
> certainly try to fix this and introduce more tools, complexity and  
> border cases. But I still fail to see the real benefits of allowing  
> very customized syntax which would justify such efforts.  The whole  
> point of -ppx versus camlp4 is precisely to stop messing up with the  
> concrete syntax: define some generic enough extension points, and  
> just work with a fixed concrete syntax.  I'd prefer to see dead  
> simple solutions adopted for -ppx, and more advanced stuff (based on  
> concrete syntax) left to camlp4/fan.
> 
>> 4. What syntax extensions to use => define in the source code
>> 
>> This has already been mentioned that the source file could define  
>> what syntax extensions it uses, so it works for all build systems  
>> (ocamlbuild, makefiles, omake), etc.
>> It may not even need special support from the compiler: there could  
>> be a -ppx that finds these pragmas and loads those other -ppx on its  
>> own!
> 
> I've started something along these lines:
> 
> https://github.com/alainfrisch/ppx_drivers
> 
> Exactly how this works with ocamlfind needs to be discussed.  I know  
> Gerd has some ideas!

Well, I had some private discussions with Alain before this list  
started.

A central point is that the ppx driver and ocamlfind remain separate  
software projects. You need the ability to use ppx preprocessors  
without ocamlfind, and the role of ocamlfind is "only" to make it more  
user-friendly. This should be similar to normal library lookup - where  
ocamlfind finally generates only a command where many details are  
filled in.

Alain had the idea to include the names of the preprocessors directly  
in the source text. He chose the syntax

include PPX(First_ppx_processor)(Second_ppx_processor)

Well, we probably can now select something better, not reusing the  
"include" notation for something that is not "include". Maybe let's  
prefer now

(:PPX "first_ppx_preprocessor" "second_ppx_preprocessor")

just to pick the current discussion up. The task of the ppx driver is  
to interpret these directives, and to run the preprocessors in the  
right order as subcommands (or, if the platform supports it, as  
plugins).

Ocamlfind integration: The problem here is that such a directive needs  
to be forwarded to ocamlfind in order to figure the details out. This  
would need a relatively tight coupling between the ppx driver and  
ocamlfind. In order to avoid that the ppx driver calls ocamlfind for  
every activated preprocessor, the idea is to make the ppx driver a  
library, maybe with a single function

preprocess : (string -> string) -> in_channel -> out_channel

The string->string function is the lookup function. It takes a string  
like "first_ppx_preprocessor" and returns the command to run.

So, that enables us to provide two utilities:

  - ocamlppx: This would be part of the OCaml distribution, and would be
    limited in functionality. In particular, it interprets the ppx  
strings
    directly as commands (identity as lookup function):

    (:PPX "/path/to/my/ppx/executable maybe arguments")

  - ocamlfind ppx: This version provides extended lookup features.
    You would just use

    (:PPX "package-name")

    and it is ocamlfind's task to look the executable up (or,  
optionally,
    load a plugin, but the details of the mechanism are hidden from the
    simple user).

Gerd


> 
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From bobzhang1988 at gmail.com  Wed Jan 30 19:40:03 2013
From: bobzhang1988 at gmail.com (Hongbo Zhang)
Date: Wed, 30 Jan 2013 14:40:03 -0500
Subject: [wg-camlp4] Editor support for syntax extensions
In-Reply-To: <1359574033.10634.17@samsung>
References: <1359574033.10634.17@samsung>
Message-ID: <51097713.2090602@gmail.com>

On 1/30/13 2:27 PM, Gerd Stolpmann wrote:
Hi Gerd,
    I think delegating ocamlfind for (ppx/camlp4/fan) is a mistake. IMO 
the right way is that
the file itself tells the preprocessor which syntax or plugin it 
wants(with the good default option),
that's how Fan adopted.
> Am 30.01.2013 15:21:20 schrieb(en) Alain Frisch:
>> On 01/30/2013 12:19 PM, T?r?k Edwin wrote:
>>> I still get syntax highlighting and matching parens in both vim and 
>>> emacs for the above (although maybe antiquotations would confuse it):
>>
>> Highlighting gets completely wrong as soon as you start e.g. using 
>> double quotes. And indentation is just impossible if the editor isn't 
>> aware of the grammar implemented by the extensions.  One could 
>> certainly try to fix this and introduce more tools, complexity and 
>> border cases. But I still fail to see the real benefits of allowing 
>> very customized syntax which would justify such efforts.  The whole 
>> point of -ppx versus camlp4 is precisely to stop messing up with the 
>> concrete syntax: define some generic enough extension points, and 
>> just work with a fixed concrete syntax.  I'd prefer to see dead 
>> simple solutions adopted for -ppx, and more advanced stuff (based on 
>> concrete syntax) left to camlp4/fan.
>>
>>> 4. What syntax extensions to use => define in the source code
>>>
>>> This has already been mentioned that the source file could define 
>>> what syntax extensions it uses, so it works for all build systems 
>>> (ocamlbuild, makefiles, omake), etc.
>>> It may not even need special support from the compiler: there could 
>>> be a -ppx that finds these pragmas and loads those other -ppx on its 
>>> own!
>>
>> I've started something along these lines:
>>
>> https://github.com/alainfrisch/ppx_drivers
>>
>> Exactly how this works with ocamlfind needs to be discussed.  I know 
>> Gerd has some ideas!
>
> Well, I had some private discussions with Alain before this list started.
>
> A central point is that the ppx driver and ocamlfind remain separate 
> software projects. You need the ability to use ppx preprocessors 
> without ocamlfind, and the role of ocamlfind is "only" to make it more 
> user-friendly. This should be similar to normal library lookup - where 
> ocamlfind finally generates only a command where many details are 
> filled in.
>
> Alain had the idea to include the names of the preprocessors directly 
> in the source text. He chose the syntax
>
> include PPX(First_ppx_processor)(Second_ppx_processor)
>
> Well, we probably can now select something better, not reusing the 
> "include" notation for something that is not "include". Maybe let's 
> prefer now
>
> (:PPX "first_ppx_preprocessor" "second_ppx_preprocessor")
>
> just to pick the current discussion up. The task of the ppx driver is 
> to interpret these directives, and to run the preprocessors in the 
> right order as subcommands (or, if the platform supports it, as plugins).
>
> Ocamlfind integration: The problem here is that such a directive needs 
> to be forwarded to ocamlfind in order to figure the details out. This 
> would need a relatively tight coupling between the ppx driver and 
> ocamlfind. In order to avoid that the ppx driver calls ocamlfind for 
> every activated preprocessor, the idea is to make the ppx driver a 
> library, maybe with a single function
>
> preprocess : (string -> string) -> in_channel -> out_channel
>
> The string->string function is the lookup function. It takes a string 
> like "first_ppx_preprocessor" and returns the command to run.
>
> So, that enables us to provide two utilities:
>
>  - ocamlppx: This would be part of the OCaml distribution, and would be
>    limited in functionality. In particular, it interprets the ppx strings
>    directly as commands (identity as lookup function):
>
>    (:PPX "/path/to/my/ppx/executable maybe arguments")
>
>  - ocamlfind ppx: This version provides extended lookup features.
>    You would just use
>
>    (:PPX "package-name")
>
>    and it is ocamlfind's task to look the executable up (or, optionally,
>    load a plugin, but the details of the mechanism are hidden from the
>    simple user).
>
> Gerd
>
>
>>
>> Alain
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>>
>
>


From info at gerd-stolpmann.de  Wed Jan 30 19:52:09 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Wed, 30 Jan 2013 20:52:09 +0100
Subject: [wg-camlp4] Editor support for syntax extensions
In-Reply-To: <51097713.2090602@gmail.com> (from bobzhang1988@gmail.com on
 Wed Jan 30 20:40:03 2013)
References: <1359574033.10634.17@samsung> <51097713.2090602@gmail.com>
Message-ID: <1359575529.10634.18@samsung>

Am 30.01.2013 20:40:03 schrieb(en) Hongbo Zhang:
> On 1/30/13 2:27 PM, Gerd Stolpmann wrote:
> Hi Gerd,
>    I think delegating ocamlfind for (ppx/camlp4/fan) is a mistake.  
> IMO the right way is that
> the file itself tells the preprocessor which syntax or plugin it wants

Ahem, that's what I described. ocamlfind's task is only to figure out  
the details (especially where the command or plugin is installed).

Gerd

> (with the good default option),
> that's how Fan adopted.
>> Am 30.01.2013 15:21:20 schrieb(en) Alain Frisch:
>>> On 01/30/2013 12:19 PM, T?r?k Edwin wrote:
>>>> I still get syntax highlighting and matching parens in both vim  
>>>> and emacs for the above (although maybe antiquotations would  
>>>> confuse it):
>>> 
>>> Highlighting gets completely wrong as soon as you start e.g. using  
>>> double quotes. And indentation is just impossible if the editor  
>>> isn't aware of the grammar implemented by the extensions.  One  
>>> could certainly try to fix this and introduce more tools,  
>>> complexity and border cases. But I still fail to see the real  
>>> benefits of allowing very customized syntax which would justify  
>>> such efforts.  The whole point of -ppx versus camlp4 is precisely  
>>> to stop messing up with the concrete syntax: define some generic  
>>> enough extension points, and just work with a fixed concrete  
>>> syntax.  I'd prefer to see dead simple solutions adopted for -ppx,  
>>> and more advanced stuff (based on concrete syntax) left to  
>>> camlp4/fan.
>>> 
>>>> 4. What syntax extensions to use => define in the source code
>>>> 
>>>> This has already been mentioned that the source file could define  
>>>> what syntax extensions it uses, so it works for all build systems  
>>>> (ocamlbuild, makefiles, omake), etc.
>>>> It may not even need special support from the compiler: there  
>>>> could be a -ppx that finds these pragmas and loads those other  
>>>> -ppx on its own!
>>> 
>>> I've started something along these lines:
>>> 
>>> https://github.com/alainfrisch/ppx_drivers
>>> 
>>> Exactly how this works with ocamlfind needs to be discussed.  I  
>>> know Gerd has some ideas!
>> 
>> Well, I had some private discussions with Alain before this list  
>> started.
>> 
>> A central point is that the ppx driver and ocamlfind remain separate  
>> software projects. You need the ability to use ppx preprocessors  
>> without ocamlfind, and the role of ocamlfind is "only" to make it  
>> more user-friendly. This should be similar to normal library lookup  
>> - where ocamlfind finally generates only a command where many  
>> details are filled in.
>> 
>> Alain had the idea to include the names of the preprocessors  
>> directly in the source text. He chose the syntax
>> 
>> include PPX(First_ppx_processor)(Second_ppx_processor)
>> 
>> Well, we probably can now select something better, not reusing the  
>> "include" notation for something that is not "include". Maybe let's  
>> prefer now
>> 
>> (:PPX "first_ppx_preprocessor" "second_ppx_preprocessor")
>> 
>> just to pick the current discussion up. The task of the ppx driver  
>> is to interpret these directives, and to run the preprocessors in  
>> the right order as subcommands (or, if the platform supports it, as  
>> plugins).
>> 
>> Ocamlfind integration: The problem here is that such a directive  
>> needs to be forwarded to ocamlfind in order to figure the details  
>> out. This would need a relatively tight coupling between the ppx  
>> driver and ocamlfind. In order to avoid that the ppx driver calls  
>> ocamlfind for every activated preprocessor, the idea is to make the  
>> ppx driver a library, maybe with a single function
>> 
>> preprocess : (string -> string) -> in_channel -> out_channel
>> 
>> The string->string function is the lookup function. It takes a  
>> string like "first_ppx_preprocessor" and returns the command to run.
>> 
>> So, that enables us to provide two utilities:
>> 
>>  - ocamlppx: This would be part of the OCaml distribution, and would  
>> be
>>    limited in functionality. In particular, it interprets the ppx  
>> strings
>>    directly as commands (identity as lookup function):
>> 
>>    (:PPX "/path/to/my/ppx/executable maybe arguments")
>> 
>>  - ocamlfind ppx: This version provides extended lookup features.
>>    You would just use
>> 
>>    (:PPX "package-name")
>> 
>>    and it is ocamlfind's task to look the executable up (or,  
>> optionally,
>>    load a plugin, but the details of the mechanism are hidden from  
>> the
>>    simple user).
>> 
>> Gerd
>> 
>> 
>>> 
>>> Alain
>>> _______________________________________________
>>> wg-camlp4 mailing list
>>> wg-camlp4 at lists.ocaml.org
>>> http://lists.ocaml.org/listinfo/wg-camlp4
>>> 
>> 
>> 
> 
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From anil at recoil.org  Wed Jan 30 20:16:45 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Wed, 30 Jan 2013 20:16:45 +0000
Subject: [wg-camlp4] A set of synthetic use cases to help discussions
In-Reply-To: <CAPFanBG_UpSjurNeu_y8YcUhhTJStJEhxsuHw5JB7d3g3nKwkA@mail.gmail.com>
References: <CAPFanBG_UpSjurNeu_y8YcUhhTJStJEhxsuHw5JB7d3g3nKwkA@mail.gmail.com>
Message-ID: <EA439449-2017-4062-A23B-F43A8869840C@recoil.org>

I've started approaching this from the other end by instrumenting OPAM
to log all the camlp4 invocations during a bulk build.

https://github.com/avsm/opam-camlp4-analysis/wiki

has the raw data of all the *.{cma,cmo,cmx} files mentioned during a
build, and the packages.

This data still needs cleanup, but there are definitely some extensions in
there I don't immediately recognise, so it would be useful to update your
(far more structured) list from this.

-anil

On 30 Jan 2013, at 17:21, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> One problem with the current debate(s) is that people have fairly
> different syntaxes and semantics in mind regarding "syntax
> extensions".
> 
> I think we should gather somewhere small snippets of "representative"
> syntax extensions (for example under their current form, which
> includes the Camlp4 syntax extensions but also eg. Lexifi's custom
> attributes syntax or the imaginary quotation system of your liking),
> so that people could refer to those example and concretely demonstrate
> which cases their proposed semantics would capture, and with which
> syntax.
> 
> I have started to put up some examples on the following wiki page,
> mostly by accumulating what has been mentioned during the discussions
> so far:
> 
>  https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases
> 
> I have made up the categories as I collected the examples, so they're
> certainly suboptimal.
> 
> The page should be open for editing (let me know if the right aren't
> set correctly), so that you can update it with new examples if you
> think they are representative of some need that wasn't exposed before.
> Please remember that the page is there to collect use cases for the
> discussion here, rather than contain argumentation/opinion/judgments
> itself.
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 


From anil at recoil.org  Wed Jan 30 20:17:34 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Wed, 30 Jan 2013 20:17:34 +0000
Subject: [wg-camlp4] A set of synthetic use cases to help discussions
In-Reply-To: <EA439449-2017-4062-A23B-F43A8869840C@recoil.org>
References: <CAPFanBG_UpSjurNeu_y8YcUhhTJStJEhxsuHw5JB7d3g3nKwkA@mail.gmail.com>
 <EA439449-2017-4062-A23B-F43A8869840C@recoil.org>
Message-ID: <9A1E1B47-A726-4102-BB90-6290538EE96E@recoil.org>

Incidentally, the raw logs are also in the repository at:
https://github.com/avsm/opam-camlp4-analysis/tree/master/logs

If anyone needs any more detail of the camlp4 invocations.

-anil

On 30 Jan 2013, at 20:16, Anil Madhavapeddy <anil at recoil.org> wrote:

> I've started approaching this from the other end by instrumenting OPAM
> to log all the camlp4 invocations during a bulk build.
> 
> https://github.com/avsm/opam-camlp4-analysis/wiki
> 
> has the raw data of all the *.{cma,cmo,cmx} files mentioned during a
> build, and the packages.
> 
> This data still needs cleanup, but there are definitely some extensions in
> there I don't immediately recognise, so it would be useful to update your
> (far more structured) list from this.
> 
> -anil
> 
> On 30 Jan 2013, at 17:21, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
> 
>> One problem with the current debate(s) is that people have fairly
>> different syntaxes and semantics in mind regarding "syntax
>> extensions".
>> 
>> I think we should gather somewhere small snippets of "representative"
>> syntax extensions (for example under their current form, which
>> includes the Camlp4 syntax extensions but also eg. Lexifi's custom
>> attributes syntax or the imaginary quotation system of your liking),
>> so that people could refer to those example and concretely demonstrate
>> which cases their proposed semantics would capture, and with which
>> syntax.
>> 
>> I have started to put up some examples on the following wiki page,
>> mostly by accumulating what has been mentioned during the discussions
>> so far:
>> 
>> https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases
>> 
>> I have made up the categories as I collected the examples, so they're
>> certainly suboptimal.
>> 
>> The page should be open for editing (let me know if the right aren't
>> set correctly), so that you can update it with new examples if you
>> think they are representative of some need that wasn't exposed before.
>> Please remember that the page is there to collect use cases for the
>> discussion here, rather than contain argumentation/opinion/judgments
>> itself.
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>> 
> 


From hongboz at seas.upenn.edu  Thu Jan 31 04:41:31 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Wed, 30 Jan 2013 23:41:31 -0500
Subject: [wg-camlp4] Some challenges when ast rewriter is widely used
Message-ID: <CANcqPu6UrCeWcr2tqRV76LfAsLcC-o4315FJug0b+TJ87BNqHg@mail.gmail.com>

Dear all,

    I summarized some possible pitfalls people may encounter here(Ast
Rewriter is also freely available
in Fan but used only in some areas similar to  *bisect*):

* *   1. composition semantics unclear
        suppose we have three plugins A, B, C  which does the Ast rewriting.
        What's the difference between the composition A.B.C  and B.C.A?
        Suppose A a very naive plugin to remove all the unsafe expression,
but B happens to
        introduces an unsafe expression? What should we expect here?

    2. compiling performance downgrading
       so far, Ast Rewriter is always doing global ast transformation which
does a lot of un-necessary transformation,
       suppose you have a series of plugins which does global
transformation ? Maybe it could be improved, but I don't
       see a clever way to fuse plugins.

    3. inconsistent semantics between compiling and toplevel module
        we could also do the Ast transformation in the toplevel, but the
semantics is a bit different, this is also due to the fact
        that we are doing global transformation

    4. upgrading compatibility
        I suggest introducing an Intermediate Ast (for lots of good reasons
I ever mentioned), if we *expose* too much compiler
        API, any change will break all existing plugins. Even though you
use some nice utility like ast_mapper, people
        still use the Constructor name explicitly.
-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130130/e7e36146/attachment.html>

From alain at frisch.fr  Thu Jan 31 08:52:34 2013
From: alain at frisch.fr (Alain Frisch)
Date: Thu, 31 Jan 2013 09:52:34 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <5109591C.8060108@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr> <5109591C.8060108@etorok.net>
Message-ID: <510A30D2.8080209@frisch.fr>

On 01/30/2013 06:32 PM, T?r?k Edwin wrote:
>>> is used by OCamlnet:
> http://projects.camlcity.org/projects/dl/ocamlnet-3.5.1/doc/html-main/Uq_engines.Operators.html

  >>=  and =<< are used by Lwt.

I've given it some thought and I don't really buy the argument about a 
smooth transition from camlp4 to -ppx based on implementing exactly the 
same syntax for a given "extension" implemented with both systems and 
then switching from one implementation to another.  First, because few 
Camlp4 extensions are purely implemented with quotations; those who 
actually modify the grammar will require changes to the user side 
anyway.  Second, I strongly believe that -ppx should put less emphasis 
on quotations / unparsed strings, so even things which are currently 
implemented with camlp4 quotations would probably benefit from a switch 
to parsed stuff (attributes or others).  Third, because changing a set 
of delimiters to something else, if really needed, is not too difficult 
to automate.

Alain

From lpw25 at cam.ac.uk  Thu Jan 31 11:48:32 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 11:48:32 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <51095364.9080001@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
Message-ID: <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>

> >> and << are really not keywords of OCaml, and I wouldn't be surprised 
>they are actually used as operators.  I prefer breaking compatibility 
>with camlp4 than with OCaml.

Thinking about it "<:" is not entirely unproblematic. Since "[<" is a 
single token, [<:foo< .. >>] would be awkward for the lexer.

Even if we abandon the camlp4 syntax for quotations, I still think that 
{:lid {x{ string }x}} is too heavy and inflexible for traditional 
quotations. For example, a JSON quotation would look like:

{:json {<{ {"streetAddress": "21 2nd Street"} }>}}

So I propose the we include 3 template forms:

{: lid expr }
{: lid x< string >x}            (where x is an optional symbol character)
{: lid x| string |x}            (where x is an optional symbol character)

these should be flexible enough to provide a light syntax for all the 
traditional quotations that I know of.

The JSON one can then be:

{:json < {"streetAddress": "21 2nd Street"} >}

As a side-note, I think that we should use {: .. } rather than (: .. ) 
because it stands out more. If you remove the ":" ( lid expr ) is still a 
valid expression but { lid expr } isn't.


From alain at frisch.fr  Thu Jan 31 12:28:18 2013
From: alain at frisch.fr (Alain Frisch)
Date: Thu, 31 Jan 2013 13:28:18 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
Message-ID: <510A6362.8070504@frisch.fr>

On 01/31/2013 12:48 PM, Leo White wrote:
>> >> and << are really not keywords of OCaml, and I wouldn't be
>> surprised they are actually used as operators.  I prefer breaking
>> compatibility with camlp4 than with OCaml.
>
> Thinking about it "<:" is not entirely unproblematic. Since "[<" is a
> single token, [<:foo< .. >>] would be awkward for the lexer.
>
> Even if we abandon the camlp4 syntax for quotations

Hurrah :-)

>, I still think that
> {:lid {x{ string }x}} is too heavy and inflexible for traditional
> quotations. For example, a JSON quotation would look like:
>
> {:json {<{ {"streetAddress": "21 2nd Street"} }>}}

I would write this:

(:json {{ {"streetAddress": "21 2nd Street"} }})

And if we keep the "end marker" in the AST, this could be:

{json{ {"streetAddress": "21 2nd Street"} }json}


But maybe we should take a step back, and really ask ourselves why we 
should use concrete JSON syntax here.  Other possibilities:


1. Write the JSON AST directly as regular OCaml code:

  Json.(M["streetAdress", S "21 2snd Street"])

  (assuming module Json export constructors M and S.)

2. Use "parsed" OCaml syntax, with some -ppx filter mapping it to JSON AST:

  (:json { streetAddress: "21 2snd Street" })

(which would expand to the version above)


3. Use a JSON parser (if we don't need "anti-quotations"):

   parse_json "{\"streetAddress\": \"21 2nd Street\"}"

   or:

   parse_json {{ {"streetAddress: "21 2nd Street"} }}


 From all the uses of Camlp4 I've seen listed since the beginning of 
this discussion, I can imagine using at some point almost each of them, 
except those which are basically "just" about quoting fragments of 
external languages in their native syntax.  I just don't see the real 
benefits.

It would be useful to get feedback from users: do people actually use 
pa_tyxml, pa_json, etc, and do they consider this is really better than 
proposed alternatives?


Alain

From lpw25 at cam.ac.uk  Thu Jan 31 12:42:47 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 12:42:47 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A6362.8070504@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
Message-ID: <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>


>> {:json {<{ {"streetAddress": "21 2nd Street"} }>}}
>
>I would write this:
>
>(:json {{ {"streetAddress": "21 2nd Street"} }})
>

My original example included a "}}" in the JSON itself, I removed it by 
accident when shortening the example.


From gabriel.scherer at gmail.com  Thu Jan 31 12:44:59 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 31 Jan 2013 13:44:59 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
Message-ID: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>

> From all the uses of Camlp4 I've seen listed since the beginning of this
> discussion, I can imagine using at some point almost each of them, except
> those which are basically "just" about quoting fragments of external
> languages in their native syntax.  I just don't see the real benefits.
>
> It would be useful to get feedback from users: do people actually use
> pa_tyxml, pa_json, etc, and do they consider this is really better than
> proposed alternatives?
>
>
> Alain

The point of quoting foreign languages is to translate them into a
form that exercize the OCaml type-checker to produce rich typing
information. With (parse_json "...") you have no static typing
information on the parsed value, while with a quotation you can expect
to get, say, a (< streetAdress : string > Json.t) expression.
Supporting antiquotations there allows you to write those foreign
values in a composable way, eg. using <:json< { streetAddress: $addr$
} >> with (addr : string Json.t).

This is essentially a nice concrete syntax on top of the typed
combinators (point 1. in your message quoted below); indeed, good
extensions should embed as few domain knowledge as possible and defer
that to the pure-ocaml library providing the combinators. That is not
always possible, however, when you want to express rich binding
structures in a typed way (for example the support of GROUP BY in a
finely-typed way in Macaque relies on clever Camlp4 expansion
strategies.

Furthermore, the bare approach of using combinators directly is not
always desirable in situations where you want the code to be used by
non-domain-experts. "Templates" in web programming are an entire
cottage industry made of preprocessing HTML-looking quasiquotations,
to help the role separation between designers and programmers. More
generally, if there is a widely accepted domain-specific notation,
your domain-specific library should have a way to support it (so that
you can, for example, call over SQL tuning experts to comment on the
performance optimization of the database queries embedded in your
OCaml code).

This is maybe less visible for non-programmable data description
languages such as JSON, but I suspect this still holds. For example,
if you distribute a protocol library built on top of JSON and bridging
over many programming languages, you want the same maintainer to be
able to quickly reflect changes to the protocol schema over all
implements. This is vastly easier if they respect the domain-specific
syntax instead of each having an embedding following the concrete
syntax of the corresponding language.

On Thu, Jan 31, 2013 at 1:28 PM, Alain Frisch <alain at frisch.fr> wrote:
> On 01/31/2013 12:48 PM, Leo White wrote:
>>>
>>> >> and << are really not keywords of OCaml, and I wouldn't be
>>> surprised they are actually used as operators.  I prefer breaking
>>> compatibility with camlp4 than with OCaml.
>>
>>
>> Thinking about it "<:" is not entirely unproblematic. Since "[<" is a
>> single token, [<:foo< .. >>] would be awkward for the lexer.
>>
>> Even if we abandon the camlp4 syntax for quotations
>
>
> Hurrah :-)
>
>
>> , I still think that
>> {:lid {x{ string }x}} is too heavy and inflexible for traditional
>> quotations. For example, a JSON quotation would look like:
>>
>> {:json {<{ {"streetAddress": "21 2nd Street"} }>}}
>
>
> I would write this:
>
> (:json {{ {"streetAddress": "21 2nd Street"} }})
>
> And if we keep the "end marker" in the AST, this could be:
>
> {json{ {"streetAddress": "21 2nd Street"} }json}
>
>
> But maybe we should take a step back, and really ask ourselves why we should
> use concrete JSON syntax here.  Other possibilities:
>
>
> 1. Write the JSON AST directly as regular OCaml code:
>
>  Json.(M["streetAdress", S "21 2snd Street"])
>
>  (assuming module Json export constructors M and S.)
>
> 2. Use "parsed" OCaml syntax, with some -ppx filter mapping it to JSON AST:
>
>  (:json { streetAddress: "21 2snd Street" })
>
> (which would expand to the version above)
>
>
> 3. Use a JSON parser (if we don't need "anti-quotations"):
>
>   parse_json "{\"streetAddress\": \"21 2nd Street\"}"
>
>   or:
>
>   parse_json {{ {"streetAddress: "21 2nd Street"} }}
>
>
> From all the uses of Camlp4 I've seen listed since the beginning of this
> discussion, I can imagine using at some point almost each of them, except
> those which are basically "just" about quoting fragments of external
> languages in their native syntax.  I just don't see the real benefits.
>
> It would be useful to get feedback from users: do people actually use
> pa_tyxml, pa_json, etc, and do they consider this is really better than
> proposed alternatives?
>
>
> Alain
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From hongboz at seas.upenn.edu  Thu Jan 31 12:46:59 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 07:46:59 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>

why should we introduce so many  concrete syntax notation here?

In Fan,
{:json| ... |}
if "|}" is used inside,* the user (optionally) can introduce a new
separator following "|" immediately*
{:json|/ ... /|}

On Thu, Jan 31, 2013 at 7:42 AM, Leo White <lpw25 at cam.ac.uk> wrote:

>
>  {:json {<{ {"streetAddress": "21 2nd Street"} }>}}
>>>
>>
>> I would write this:
>>
>> (:json {{ {"streetAddress": "21 2nd Street"} }})
>>
>>
> My original example included a "}}" in the JSON itself, I removed it by
> accident when shortening the example.
>
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/ccc848b8/attachment.html>

From alain.frisch at lexifi.com  Thu Jan 31 12:54:33 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 31 Jan 2013 13:54:33 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CANcqPu4CnjsJcVWTK3N0Q9iEMLWzHWtRM41u6EKRYX2T1we0wQ@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <CANcqPu4CnjsJcVWTK3N0Q9iEMLWzHWtRM41u6EKRYX2T1we0wQ@mail.gmail.com>
Message-ID: <510A6989.80706@lexifi.com>

On 01/30/2013 02:18 PM, Hongbo Zhang wrote:
> Ast Rewriter is *bad *for arbitrary code generation, its neat case is
> something like bisect.

One of the most widely used kind of Camlp4 extensions today is about 
code generation based on type declarations (plus some annotations), ? la 
type-conv or deriving.  This seems to be a perfect match for AST 
rewriters plus attributes.  Don't you agree?

> And Ast Rewriter is not composable at  all,
> suppose you have two AST Rewriters A,B ,there are no guarantee that  A.B
> == B.A, it just gives you an illusion that it works, probably it
> silently fails.

I don't agree.  A and B are functions from AST to AST, so there is a 
very nice notion of composition: the composition of functions.  It is 
true that A.B and B.A don't have the same behavior but at least, I can 
understand what A.B and B.A will do as soon as I know how A and B behave 
individually, without having to know anything about their implementation.

This is very different from camlp4's model of letting extensions patch a 
common grammar in place, by removing rules and injecting new ones which 
can (partially) hide existing ones.  The order in which those updates to 
the grammar are applied also matters, and it is impossible to know how 
the combination of two extension behaves without knowing precisely how 
they are implemented.

I know you have projects to provide a cleaner functional API for 
grammars, but I don't see how modifications of the concrete syntax can 
be combined, in full generality, in a predictable way.  It seems you 
also have plans to get rid of the ability to modify the concrete syntax. 
  This sounds very reasonable to me.

>     3. How do you implement the expander?  Somehow, you need to parse
>     the content of the quotation (stored as a string in the AST), which
>     involves non trivial stuff, like a parser being able to parse OCaml
>     code mixed with something else.  Personally, I don't know how to
>     implement the quotation expander with the parsing technologies I'm
>     familiar with.
>
> when you design your DSL, the left part is pretty easy to parse, when
> you see the delimiter "->", invoking an existing parser.

So you need to:

  - Write a custom parser for left parts (regexps), which stops at "->".
To write this parser, you need to use ocamlyacc, menhir, or another 
tool. (And probably plug the official OCaml lexer?)
  - Call the official(?) OCaml parser on its "expr" entry and hope that 
it stops exactly when it encounters the next "|" (does this really work?).
  - Adapt the locations returned by this parser, or be careful to 
initialize the lexbuf with locations that match exactly the concrete 
location of the corresponding part in the original source code.

This seems much more complex than the current implementation of sedlex 
(or a variant of it where regexps would be written with some concrete 
syntax), for no obvious benefit.


Alain



From hongboz at seas.upenn.edu  Thu Jan 31 13:07:24 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 08:07:24 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A6989.80706@lexifi.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <CANcqPu4CnjsJcVWTK3N0Q9iEMLWzHWtRM41u6EKRYX2T1we0wQ@mail.gmail.com>
 <510A6989.80706@lexifi.com>
Message-ID: <CANcqPu6pHKxgbXoqLBVJ-ZCsOMu46PbHZrW-jNNdWpJTfK8t5A@mail.gmail.com>

On Thu, Jan 31, 2013 at 7:54 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 01/30/2013 02:18 PM, Hongbo Zhang wrote:
>
>> Ast Rewriter is *bad *for arbitrary code generation, its neat case is
>> something like bisect.
>>
>
> One of the most widely used kind of Camlp4 extensions today is about code
> generation based on type declarations (plus some annotations), ? la
> type-conv or deriving.  This seems to be a perfect match for AST rewriters
> plus attributes.  Don't you agree?

This could have a even better solution (not global Ast rewriting) in Fan
without introducing any global Ast rewriting.
{:ocaml|
type t = A of int
|}
{:derive|(Print,Eq,Meata,...)|}


>
>  And Ast Rewriter is not composable at  all,
>> suppose you have two AST Rewriters A,B ,there are no guarantee that  A.B
>> == B.A, it just gives you an illusion that it works, probably it
>> silently fails.
>>
>
> I don't agree.  A and B are functions from AST to AST, so there is a very
> nice notion of composition: the composition of functions.  It is true that
> A.B and B.A don't have the same behavior but at least, I can understand
> what A.B and B.A will do as soon as I know how A and B behave individually,
> without having to know anything about their implementation.
>
> For any nontrivial Ast Rewriter, I totally get lost, maybe I am dumb and
you use objects here(ast_mapper) suppose both ast_mapper try to inject some
bindings at the beginning, what do you expect here? Besides, there's no
reason that Ast Rewriter should be pure, once is impure, how shall I reason
the program?

> I know you have projects to provide a cleaner functional API for grammars,
> but I don't see how modifications of the concrete syntax can be combined,
> in full generality, in a predictable way.  It seems you also have plans to
> get rid of the ability to modify the concrete syntax.  This sounds very
> reasonable to me.
>
> We have provided purely functional grammars API which helps a lot to limit
the scope of the syntax extension*, if people don't like it, just not
expose it, or write another frontend with fixed grammar.* But we do have a
lot of things that Ast Rewriter does not provide, quasiquotation(which I
think is a *fundamental* difference from ppx), quotation(delimited DSL),
ast rewriter(the same as ppx), type hook(the example I gave before), lexer
hook, and lots other stuff

>
>      3. How do you implement the expander?  Somehow, you need to parse
>>     the content of the quotation (stored as a string in the AST), which
>>     involves non trivial stuff, like a parser being able to parse OCaml
>>     code mixed with something else.  Personally, I don't know how to
>>     implement the quotation expander with the parsing technologies I'm
>>     familiar with.
>>
>> when you design your DSL, the left part is pretty easy to parse, when
>> you see the delimiter "->", invoking an existing parser.
>>
>
> So you need to:
>
>  - Write a custom parser for left parts (regexps), which stops at "->".
> To write this parser, you need to use ocamlyacc, menhir, or another tool.
> (And probably plug the official OCaml lexer?)
>  - Call the official(?) OCaml parser on its "expr" entry and hope that it
> stops exactly when it encounters the next "|" (does this really work?).
>  - Adapt the locations returned by this parser, or be careful to
> initialize the lexbuf with locations that match exactly the concrete
> location of the corresponding part in the original source code.
>
> This is *already implemented in Fan within tens of lines of code,* you
are much more experienced than me, so I bet you definitely could parse it!
(I don't consider tens of lines of code is complex.. ) my taste shows that
its notation is much more elegant than sedlex (imho)

> This seems much more complex than the current implementation of sedlex (or
> a variant of it where regexps would be written with some concrete syntax),
> for no obvious benefit.
>
>
> Alain
>
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/ca4fee97/attachment-0001.html>

From alain.frisch at lexifi.com  Thu Jan 31 13:11:37 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 31 Jan 2013 14:11:37 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
Message-ID: <510A6D89.9000507@lexifi.com>

On 01/31/2013 01:44 PM, Gabriel Scherer wrote:
> The point of quoting foreign languages is to translate them into a
> form that exercize the OCaml type-checker to produce rich typing
> information. With (parse_json "...") you have no static typing
> information on the parsed value, while with a quotation you can expect
> to get, say, a (< streetAdress : string > Json.t) expression.
> Supporting antiquotations there allows you to write those foreign
> values in a composable way, eg. using <:json< { streetAddress: $addr$
> } >> with (addr : string Json.t).
>
> This is essentially a nice concrete syntax on top of the typed
> combinators (point 1. in your message quoted below); indeed, good
> extensions should embed as few domain knowledge as possible and defer
> that to the pure-ocaml library providing the combinators.

There are two very different topic here: syntax and type-checking.

Clever type-checking of the DSL can be done either with combinators, and 
when this is not possible, it makes sense to have some "pre-processors" 
doing clever stuff like adding type annotations.  When we write:

  (:json { streetAddress: "21 2snd Street" })

or even:

  (:json M["streetAdress", S "21 2snd Street"])

this can be expanded to something more clever than just untyped 
constructors.  But there is no reason to force using the concrete syntax 
of the foreign language (which is not really true, because you want to 
allow anti-quotations which are not part of that syntax).  The syntax of 
OCaml is rich enough that a lot of other languages can be encoded in it. 
  The downside is that we need to make it clear syntactically that a 
fragment will be interpreted in a special way.  The upside is that no 
"parsing technology" is involved, which simplifies the design (choice of 
a syntax for anti-quotations), the implementation (writing a parser and 
calling back the OCaml parser on anti-quotations, with careful tracking 
of locations) and the user experience (support from editors, learning 
details of a concrete syntax [you might want to write JSON producers on 
an abstract level, and benefit from clever type-checking, but without 
knowing exactly how strings have to be escaped in concrete JSON]).

> Furthermore, the bare approach of using combinators directly is not
> always desirable in situations where you want the code to be used by
> non-domain-experts. "Templates" in web programming are an entire
> cottage industry made of preprocessing HTML-looking quasiquotations,
> to help the role separation between designers and programmers.

When non-programmers have to write some HTML code, this code rarely ends 
up in OCaml source code.  Usually, it stays in its own HTML file, which 
is then processed (statically or dynamically) by the (OCaml) code.

When fragments of JSON/XML/etc are created programatically, this is 
often done "piece by piece", with very small fragments involving a high 
density of anti-quotations.  The benefits of using the foreign syntax 
here are not clear to me.


> This is maybe less visible for non-programmable data description
> languages such as JSON, but I suspect this still holds. For example,
> if you distribute a protocol library built on top of JSON and bridging
> over many programming languages, you want the same maintainer to be
> able to quickly reflect changes to the protocol schema over all
> implements. This is vastly easier if they respect the domain-specific
> syntax instead of each having an embedding following the concrete
> syntax of the corresponding language.

I understand the theoretical argument, but I don't think it would apply 
in practice to many OCaml projects.


Alain

From philippe.veber at gmail.com  Thu Jan 31 13:16:53 2013
From: philippe.veber at gmail.com (Philippe Veber)
Date: Thu, 31 Jan 2013 14:16:53 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
Message-ID: <CAOOOohRzCVwjqk1Ta7zEy476qT6ieStNmSesTGKUBSRpnLcZqw@mail.gmail.com>

Not much to add to this, I just wanted to emphasize that the point Gabriel
makes is especially relevant in web programming or database interaction,
because in those area ocaml is not often the first option that comes to
mind. So being able to quote json, sql, html etc in an ocaml source without
unplugging the type checker is real feature. Of course, there are cases
when you build those "foreign" values programmatically, in that case I
concur you're better off without the syntax extension (maybe not always, if
the guest language has some real nice support than cannot be rendered
concisely with ocaml), but there are many times when the antiquotation part
is really small compared to the "constant" fragments. In that case, it may
be desirable to have non-ocaml-programmers work directly on the ml source.

2013/1/31 Gabriel Scherer <gabriel.scherer at gmail.com>

> > From all the uses of Camlp4 I've seen listed since the beginning of this
> > discussion, I can imagine using at some point almost each of them, except
> > those which are basically "just" about quoting fragments of external
> > languages in their native syntax.  I just don't see the real benefits.
> >
> > It would be useful to get feedback from users: do people actually use
> > pa_tyxml, pa_json, etc, and do they consider this is really better than
> > proposed alternatives?
> >
> >
> > Alain
>
> The point of quoting foreign languages is to translate them into a
> form that exercize the OCaml type-checker to produce rich typing
> information. With (parse_json "...") you have no static typing
> information on the parsed value, while with a quotation you can expect
> to get, say, a (< streetAdress : string > Json.t) expression.
> Supporting antiquotations there allows you to write those foreign
> values in a composable way, eg. using <:json< { streetAddress: $addr$
> } >> with (addr : string Json.t).
>
> This is essentially a nice concrete syntax on top of the typed
> combinators (point 1. in your message quoted below); indeed, good
> extensions should embed as few domain knowledge as possible and defer
> that to the pure-ocaml library providing the combinators. That is not
> always possible, however, when you want to express rich binding
> structures in a typed way (for example the support of GROUP BY in a
> finely-typed way in Macaque relies on clever Camlp4 expansion
> strategies.
>
> Furthermore, the bare approach of using combinators directly is not
> always desirable in situations where you want the code to be used by
> non-domain-experts. "Templates" in web programming are an entire
> cottage industry made of preprocessing HTML-looking quasiquotations,
> to help the role separation between designers and programmers. More
> generally, if there is a widely accepted domain-specific notation,
> your domain-specific library should have a way to support it (so that
> you can, for example, call over SQL tuning experts to comment on the
> performance optimization of the database queries embedded in your
> OCaml code).
>
> This is maybe less visible for non-programmable data description
> languages such as JSON, but I suspect this still holds. For example,
> if you distribute a protocol library built on top of JSON and bridging
> over many programming languages, you want the same maintainer to be
> able to quickly reflect changes to the protocol schema over all
> implements. This is vastly easier if they respect the domain-specific
> syntax instead of each having an embedding following the concrete
> syntax of the corresponding language.
>
> On Thu, Jan 31, 2013 at 1:28 PM, Alain Frisch <alain at frisch.fr> wrote:
> > On 01/31/2013 12:48 PM, Leo White wrote:
> >>>
> >>> >> and << are really not keywords of OCaml, and I wouldn't be
> >>> surprised they are actually used as operators.  I prefer breaking
> >>> compatibility with camlp4 than with OCaml.
> >>
> >>
> >> Thinking about it "<:" is not entirely unproblematic. Since "[<" is a
> >> single token, [<:foo< .. >>] would be awkward for the lexer.
> >>
> >> Even if we abandon the camlp4 syntax for quotations
> >
> >
> > Hurrah :-)
> >
> >
> >> , I still think that
> >> {:lid {x{ string }x}} is too heavy and inflexible for traditional
> >> quotations. For example, a JSON quotation would look like:
> >>
> >> {:json {<{ {"streetAddress": "21 2nd Street"} }>}}
> >
> >
> > I would write this:
> >
> > (:json {{ {"streetAddress": "21 2nd Street"} }})
> >
> > And if we keep the "end marker" in the AST, this could be:
> >
> > {json{ {"streetAddress": "21 2nd Street"} }json}
> >
> >
> > But maybe we should take a step back, and really ask ourselves why we
> should
> > use concrete JSON syntax here.  Other possibilities:
> >
> >
> > 1. Write the JSON AST directly as regular OCaml code:
> >
> >  Json.(M["streetAdress", S "21 2snd Street"])
> >
> >  (assuming module Json export constructors M and S.)
> >
> > 2. Use "parsed" OCaml syntax, with some -ppx filter mapping it to JSON
> AST:
> >
> >  (:json { streetAddress: "21 2snd Street" })
> >
> > (which would expand to the version above)
> >
> >
> > 3. Use a JSON parser (if we don't need "anti-quotations"):
> >
> >   parse_json "{\"streetAddress\": \"21 2nd Street\"}"
> >
> >   or:
> >
> >   parse_json {{ {"streetAddress: "21 2nd Street"} }}
> >
> >
> > From all the uses of Camlp4 I've seen listed since the beginning of this
> > discussion, I can imagine using at some point almost each of them, except
> > those which are basically "just" about quoting fragments of external
> > languages in their native syntax.  I just don't see the real benefits.
> >
> > It would be useful to get feedback from users: do people actually use
> > pa_tyxml, pa_json, etc, and do they consider this is really better than
> > proposed alternatives?
> >
> >
> > Alain
> >
> > _______________________________________________
> > wg-camlp4 mailing list
> > wg-camlp4 at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/wg-camlp4
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/6effd0e9/attachment.html>

From edwin+ml-ocaml at etorok.net  Thu Jan 31 13:21:46 2013
From: edwin+ml-ocaml at etorok.net (=?UTF-8?B?VMO2csO2ayBFZHdpbg==?=)
Date: Thu, 31 Jan 2013 15:21:46 +0200
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
Message-ID: <510A6FEA.3080807@etorok.net>

On 01/31/2013 01:48 PM, Leo White wrote:
> So I propose the we include 3 template forms:
> {: lid x| string |x}            (where x is an optional symbol character)

I'd be in favour of just 1 syntax, its less confusing for users.

On 01/31/2013 02:46 PM, Hongbo Zhang wrote:
> why should we introduce so many  concrete syntax notation here?
> 
> In Fan,
> {:json| ... |}
> if "|}" is used inside,*the user (optionally) can introduce a new separator following "|" immediately*
> {:json|/ ... /|}  

So this would be similar to Leo's proposal but with the optional symbol on the inside, a mandatory whitespace
after the symbol, and no whitespace after the : right?
{:lid|x?string x|}

I actually prefer this one because:
 + easier for editors to highlight beginning/end of quote
 + easier to grep for end of quote
 + easier to grep for what syntax extensions are used in a project: grep -Eo "{:[^|]+|"

FWIW Haskell is quite rigid, its syntax for (quasi)quotations is just [expr|...|].

Best regards,
--Edwin


From anil at recoil.org  Thu Jan 31 13:22:08 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 31 Jan 2013 13:22:08 +0000
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510A6D89.9000507@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
Message-ID: <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>

On 31 Jan 2013, at 13:11, Alain Frisch <alain.frisch at lexifi.com> wrote:

> When non-programmers have to write some HTML code, this code rarely ends up in OCaml source code.  Usually, it stays in its own HTML file, which is then processed (statically or dynamically) by the (OCaml) code.
> 
> When fragments of JSON/XML/etc are created programatically, this is often done "piece by piece", with very small fragments involving a high density of anti-quotations.  The benefits of using the foreign syntax here are not clear to me.

This does match my experience with pa_css, pa_json, pa_xml while building the Mirage website.  For example:

https://github.com/mirage/mirage-www/blob/master/src/style.ml#L71
https://github.com/mirage/mirage-www/blob/master/src/wiki.ml

are both either flat templates, or fairly dense with antiquotations.  It is quite nice that I can paste in some HTML code and get type errors from the XMLM parser.

More recently, I've been using Martin Jambon's new tools that perform external code generation instead, and it's quite a pleasant experience.  For example, the Github bindings use his ATD tool which auto-generates the parsing code into separate OCaml modules:

https://github.com/avsm/ocaml-github/blob/master/lib/github.atd

With ATD, you retain type safety, but lose other benefits of embedding code (most notably, using modules to control the visibility of the generated types).  The build system integration also took some thought, although this is ocamlbuild's fault.

I can't immediately think of a good case where programmatic fragments of JSON/XML really need the current quotation/antiquotation mechanism.  If it simplifies editor support, I'd be happy enough to lose this functionality.

-anil

From hongboz at seas.upenn.edu  Thu Jan 31 13:27:56 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 08:27:56 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A6FEA.3080807@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
Message-ID: <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>

> In Fan,
> > {:json| ... |}
> > if "|}" is used inside,*the user (optionally) can introduce a new
> separator following "|" immediately*
> > {:json|/ ... /|}
>
> So this would be similar to Leo's proposal but with the optional symbol on
> the inside, a mandatory whitespace
> after the symbol, and no whitespace after the : right?
> {:lid|x?string x|}
>
> no whitespace, we need the *precise location*, whitespace will introduce
trouble here
The optional *character set is limited to [/+-] (serveral more)*, only
those optional characters will be recgonized.
so you can still write {:json|{a;b}|}
but {:json|/{a;b|}}/|} also works

I actually prefer this one because:
>  + easier for editors to highlight beginning/end of quote
>  + easier to grep for end of quote
>  + easier to grep for what syntax extensions are used in a project: grep
> -Eo "{:[^|]+|"
>
> FWIW Haskell is quite rigid, its syntax for (quasi)quotations is just
> [expr|...|].
>
> Best regards,
> --Edwin
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/54c3c14a/attachment.html>

From hongboz at seas.upenn.edu  Thu Jan 31 13:32:04 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 08:32:04 -0500
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
Message-ID: <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>

On Thu, Jan 31, 2013 at 8:22 AM, Anil Madhavapeddy <anil at recoil.org> wrote:

> On 31 Jan 2013, at 13:11, Alain Frisch <alain.frisch at lexifi.com> wrote:
> I can't immediately think of a good case where programmatic fragments of
> JSON/XML really need the current quotation/antiquotation mechanism.  If it
> simplifies editor support, I'd be happy enough to lose this functionality.
>
Would you mind elaborating a bit why it will complex editor support? the
quotation introduces enough
information that the IDE should recognize(imho) and it's delimited which is
awesome in my Emacs (with paren mode)

>
> -anil
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/20b4e310/attachment.html>

From alain.frisch at lexifi.com  Thu Jan 31 13:32:08 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 31 Jan 2013 14:32:08 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CANcqPu6pHKxgbXoqLBVJ-ZCsOMu46PbHZrW-jNNdWpJTfK8t5A@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <CANcqPu4CnjsJcVWTK3N0Q9iEMLWzHWtRM41u6EKRYX2T1we0wQ@mail.gmail.com>
 <510A6989.80706@lexifi.com>
 <CANcqPu6pHKxgbXoqLBVJ-ZCsOMu46PbHZrW-jNNdWpJTfK8t5A@mail.gmail.com>
Message-ID: <510A7258.1070300@lexifi.com>

On 01/31/2013 02:07 PM, Hongbo Zhang wrote:
> For any nontrivial Ast Rewriter, I totally get lost, maybe I am dumb and
> you use objects here(ast_mapper) suppose both ast_mapper try to inject
> some bindings at the beginning, what do you expect here? Besides,
> there's no reason that Ast Rewriter should be pure, once is impure, how
> shall I reason the program?

As soon as you use OCaml code to specify some actions on the AST, you 
have potential problems with impure code.  ppx does not change anything, 
except maybe that each ppx rewriter in run in a separate process, which 
limits the risk of bad interaction between them.

To reason about two ppx rewriters both trying to inject code at the 
beginning, this is easy, just think in terms of functions.  The first 
transformer to be applied adds code to the beginning.  The second one 
adds more code to the beginning.  At the end, the code starts by the 
prefix added by the second ppx rewriter, then the prefix added by the 
first one, then the rest of the code.

> But we do
> have a lot of things that Ast Rewriter does not provide,

Agreed!

> This is *already implemented in Fan within tens of lines of code,* you
> are much more experienced than me, so I bet you definitely could parse
> it! (I don't consider tens of lines of code is complex.. ) my taste
> shows that its notation is much more elegant than sedlex (imho)

I strongly suspect you don't use the official OCaml parser but a 
specific parser which is part of Fan (and rely on a different parsing 
technology and a different AST).  So if I want to use your version of 
sedlex, I will add to update Fan to match my local extensions of OCaml 
(or MetaOCaml, or the next cool extension of Camlp4).  And if I wanted 
to be able to implement that version, I would have had to learn about 
Fan, its parsing technology, and its interpretation of the OCaml AST.
All that would be worth the extra effort and trouble if the benefits 
were clear enough, but I still don't see any benefit.

Alain

From thomas at ocamlpro.com  Thu Jan 31 13:33:25 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Thu, 31 Jan 2013 13:33:25 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A6362.8070504@frisch.fr>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
Message-ID: <CEF81BAE-6B70-4A8C-B49A-BBA61983C94B@ocamlpro.com>

> It would be useful to get feedback from users: do people actually use pa_tyxml, pa_json, etc, and do they consider this is really better than proposed alternatives?

I definitely use (and like) quotations to write web applications. with https://github.com/mirage/ocaml-cow. This is used for instance to generate mirage (https://github.com/mirage/mirage-www/blob/master/src/blog.ml) and OPAM (https://github.com/OCamlPro/opam2web) websites.

If you look at the code source there, I use anti-quotations more like a templating system (and I'm fine if I can only do that) and quotations as simple multi-line & auto-escaping strings. In some source files, I mix HTML and CSS quotations, where the CSS is actually rewritten to unnest nested blocks by the quotation system and where some HTML antiquotations are CSS values.

If you have a simple way to add that in your new system I will be quite happy (and I don't really care about the syntax, I would simply prefer a light one such as <:html*.. *> where '*' is any character instead of having to write {foo{bar{...}}foo} but that's not really important to me).

 --
Thomas


> 
> 
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From hongboz at seas.upenn.edu  Thu Jan 31 13:41:01 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 08:41:01 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A7258.1070300@lexifi.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <CANcqPu4CnjsJcVWTK3N0Q9iEMLWzHWtRM41u6EKRYX2T1we0wQ@mail.gmail.com>
 <510A6989.80706@lexifi.com>
 <CANcqPu6pHKxgbXoqLBVJ-ZCsOMu46PbHZrW-jNNdWpJTfK8t5A@mail.gmail.com>
 <510A7258.1070300@lexifi.com>
Message-ID: <CANcqPu5WXUGSqczxhyeAgZAL1MOO1m+Cv0oBuQaa5Lw94M3+_w@mail.gmail.com>

On Thu, Jan 31, 2013 at 8:32 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

>
>> I strongly suspect you don't use the official OCaml parser but a specific
> parser which is part of Fan (and rely on a different parsing technology and
> a different AST).  So if I want to use your version of sedlex, I will add
> to update Fan to match my local extensions of OCaml (or MetaOCaml, or the
> next cool extension of Camlp4).  And if I wanted to be able to implement
> that version, I would have had to learn about Fan, its parsing technology,
> and its interpretation of the OCaml AST.
> All that would be worth the extra effort and trouble if the benefits were
> clear enough, but I still don't see any benefit.
>
> To be fair, suppose people who don't understand either Fan or ppx, I think
it's much easier to learn Fan. Fan's grammar's semantics is really
clear(its kernel is *only 200 lines *without comments), and we
provide a graphic module to *visualize the tree structure*...
Anyway you can still use Fan* without sticking to Fan's parsing tech*, the
only thing you need is to accept the proposal* which introduces a
Intermediate Ast*

> Alain
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/17af443c/attachment-0001.html>

From alain.frisch at lexifi.com  Thu Jan 31 13:42:04 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 31 Jan 2013 14:42:04 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
Message-ID: <510A74AC.4070302@lexifi.com>

On 01/31/2013 02:32 PM, Hongbo Zhang wrote:
> Would you mind elaborating a bit why it will complex editor support?

The content of a quotation can use arbitrary grammar and even arbitrary 
lexical rules.

If the editor cannot lex the content of the quotation, it cannot produce 
nice colors for lexical entities in it.  If emacs produce decent colors 
on some example with quotation, it is only because it does not know 
anything about quotation and the example is simple enough so that 
applying OCaml rules works quite well.  But if the content of the 
quotation follows other lexical rules, emacs gets confused. Write:

   let x = foo << " >> bar

and emacs will color ">> bar" as if it were a string.  The only decent 
think an editor could do with a quotation is to understand where it 
stops and not try to do anything clever with it.  If we adapt the OCaml 
emacs mode to recognize camlp4's quotation and do that, you won't get 
any colors within quotations (correct behavior, but not if you write 
non-trivial multi-line OCaml expressions in it, as in your 'sedlex' 
version).

Even if the lexical conventions are right, the editor cannot produce 
correct indentation if it doesn't know the grammar used inside the 
quotation.


Alain


From edwin+ml-ocaml at etorok.net  Thu Jan 31 13:43:37 2013
From: edwin+ml-ocaml at etorok.net (=?UTF-8?B?VMO2csO2ayBFZHdpbg==?=)
Date: Thu, 31 Jan 2013 15:43:37 +0200
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
Message-ID: <510A7509.1000007@etorok.net>

On 01/31/2013 03:27 PM, Hongbo Zhang wrote:
> 
> 
>     > In Fan,
>     > {:json| ... |}
>     > if "|}" is used inside,*the user (optionally) can introduce a new separator following "|" immediately*
>     > {:json|/ ... /|}
> 
>     So this would be similar to Leo's proposal but with the optional symbol on the inside, a mandatory whitespace
>     after the symbol, and no whitespace after the : right?
>     {:lid|x?string x|}
> 
> no whitespace, we need the *precise location*, whitespace will introduce trouble here 
> The optional *character set is limited to [/+-] (serveral more)*, only those optional characters will be recgonized.
> so you can still write {:json|{a;b}|}
> but {:json|/{a;b|}}/|} also works

Without a whitespace how do you know if the '/' is your optional character or part of the quoted syntax?
(unless you restrict the quoted syntax's first character to be something else than the optional characters)

What do you think of this syntax:
{:lid|...|lid:}

Its still quite easy to find where quotation's bounds are, it is symmetric, and the end marker should be long enough
to not cause false matches inside the quotation.

Best regards,
--Edwin

From edwin at etorok.net  Thu Jan 31 13:45:06 2013
From: edwin at etorok.net (=?UTF-8?B?VMO2csO2ayBFZHdpbg==?=)
Date: Thu, 31 Jan 2013 15:45:06 +0200
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A7509.1000007@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
Message-ID: <510A7562.3030209@etorok.net>

On 01/31/2013 03:43 PM, T?r?k Edwin wrote:
> On 01/31/2013 03:27 PM, Hongbo Zhang wrote:
>>
>>
>>     > In Fan,
>>     > {:json| ... |}
>>     > if "|}" is used inside,*the user (optionally) can introduce a new separator following "|" immediately*
>>     > {:json|/ ... /|}
>>
>>     So this would be similar to Leo's proposal but with the optional symbol on the inside, a mandatory whitespace
>>     after the symbol, and no whitespace after the : right?
>>     {:lid|x?string x|}
>>
>> no whitespace, we need the *precise location*, whitespace will introduce trouble here 
>> The optional *character set is limited to [/+-] (serveral more)*, only those optional characters will be recgonized.
>> so you can still write {:json|{a;b}|}
>> but {:json|/{a;b|}}/|} also works
> 
> Without a whitespace how do you know if the '/' is your optional character or part of the quoted syntax?
> (unless you restrict the quoted syntax's first character to be something else than the optional characters)
> 
> What do you think of this syntax:
> {:lid|...|lid:}
> 
> Its still quite easy to find where quotation's bounds are, it is symmetric, and the end marker should be long enough
> to not cause false matches inside the quotation.

Forgot to add: the ending 'lid' would be optional, so one could write either:
{:lid|...|:}
{:lid|...|lid:}

--Edwin

From hongboz at seas.upenn.edu  Thu Jan 31 13:46:35 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 08:46:35 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A7509.1000007@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
Message-ID: <CANcqPu4Lru71Z86x6B9AbDP_=vU4U5EpXkNchyvPZsjbJYRepQ@mail.gmail.com>

On Thu, Jan 31, 2013 at 8:43 AM, T?r?k Edwin <edwin+ml-ocaml at etorok.net>wrote:

> On 01/31/2013 03:27 PM, Hongbo Zhang wrote:
> >
> >
> >     > In Fan,
> >     > {:json| ... |}
> >     > if "|}" is used inside,*the user (optionally) can introduce a new
> separator following "|" immediately*
> >     > {:json|/ ... /|}
> >
> >     So this would be similar to Leo's proposal but with the optional
> symbol on the inside, a mandatory whitespace
> >     after the symbol, and no whitespace after the : right?
> >     {:lid|x?string x|}
> >
> > no whitespace, we need the *precise location*, whitespace will introduce
> trouble here
> > The optional *character set is limited to [/+-] (serveral more)*, only
> those optional characters will be recgonized.
> > so you can still write {:json|{a;b}|}
> > but {:json|/{a;b|}}/|} also works
>
> Without a whitespace how do you know if the '/' is your optional character
> or part of the quoted syntax?
> (unless you restrict the quoted syntax's first character to be something
> else than the optional characters)
>
> exactly( optional chars is a limited set, but is enough in
practice,(stolen from perl)

> What do you think of this syntax:
> {:lid|...|lid:}
>
> no, we introduce Language namespace, sometimes you can write unamed
quotations XD

> Its still quite easy to find where quotation's bounds are, it is
> symmetric, and the end marker should be long enough
> to not cause false matches inside the quotation.
>
> Best regards,
> --Edwin
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/022f8d19/attachment.html>

From gabriel.scherer at gmail.com  Thu Jan 31 13:48:31 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 31 Jan 2013 14:48:31 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510A6D89.9000507@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
Message-ID: <CAPFanBH+0kyAqBZCqmzM9jiEC=ikM1fO30h3F4jV3QvEK2EN9g@mail.gmail.com>

> When fragments of JSON/XML/etc are created programatically, this is often done "piece by piece",
> with very small fragments involving a high density of anti-quotations.
> The benefits of using the foreign syntax here are not clear to me.

This is an argument that I would very much like to be convinced of,
but that does not really match my experience. I have found this style
of piece-by-piece code difficult to understand and maintain, and when
I find the time to do things properly I very much try to have a
central piece of code that reflects the foreign structure (as a
quasiquotation when possible, or a dense expression using combinators
otherwise), preceded by the auxiliary definitions. (It's not always
possible or easy when you need data to flow from some part of the
generated AST to others).

As an example, you are probably familiar with the following piece of
code in the OCaml type-checker, that builds a non-trivial part of
typedtree in a semi-piecewise way to handle a corner case of optional
argument functions (and is probably going away someday), from L2784 to
L2813 here:
  https://github.com/ocaml/ocaml/blob/1b5d02346c8e477dbe38dd883d3b6f430924190d/typing/typecore.ml#L2784

This code is, quite frankly, quite painful to make sense of, and I
think this is in a large part related by the fact that it builds the
typedtree piecewise (relatively; it could be even more fine-grained)
instead of building the entire expression, that is (in approximative
Camlp{4,5} syntax)
  <:texp<
     let $x,tty$ = $texp$ in
     (fun $y,targ$ -> $x$ $list:zip labels none$ $y,targ$)
  >>;
that said, a smart combinator library could produce an equally (or
more, or less, depending on who you ask) readable example, for
example:
  tlet x tty (fun x ->
    tfun y targ (fun y ->
      tnapp x (zip labels none @ [y])))
and in this case the "domain-specific syntax" argument does not hold.


Anil's counter-point (converting specialized embeddings to build-time
code generation) is interesting as well. He did not (by modesty?) cite
his ocaml-orm-sqlite project (
https://github.com/avsm/ocaml-orm-sqlite ) which is doing much of the
same thing in the database field. Maybe my "Use cases for syntax
extensions" wikipage could be augmented with "Non-use cases for syntax
extensions" example?

On Thu, Jan 31, 2013 at 2:11 PM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 01/31/2013 01:44 PM, Gabriel Scherer wrote:
>>
>> The point of quoting foreign languages is to translate them into a
>> form that exercize the OCaml type-checker to produce rich typing
>> information. With (parse_json "...") you have no static typing
>> information on the parsed value, while with a quotation you can expect
>> to get, say, a (< streetAdress : string > Json.t) expression.
>> Supporting antiquotations there allows you to write those foreign
>> values in a composable way, eg. using <:json< { streetAddress: $addr$
>> } >> with (addr : string Json.t).
>>
>> This is essentially a nice concrete syntax on top of the typed
>> combinators (point 1. in your message quoted below); indeed, good
>> extensions should embed as few domain knowledge as possible and defer
>> that to the pure-ocaml library providing the combinators.
>
>
> There are two very different topic here: syntax and type-checking.
>
>
> Clever type-checking of the DSL can be done either with combinators, and
> when this is not possible, it makes sense to have some "pre-processors"
> doing clever stuff like adding type annotations.  When we write:
>
>  (:json { streetAddress: "21 2snd Street" })
>
> or even:
>
>  (:json M["streetAdress", S "21 2snd Street"])
>
> this can be expanded to something more clever than just untyped
> constructors.  But there is no reason to force using the concrete syntax of
> the foreign language (which is not really true, because you want to allow
> anti-quotations which are not part of that syntax).  The syntax of OCaml is
> rich enough that a lot of other languages can be encoded in it.  The
> downside is that we need to make it clear syntactically that a fragment will
> be interpreted in a special way.  The upside is that no "parsing technology"
> is involved, which simplifies the design (choice of a syntax for
> anti-quotations), the implementation (writing a parser and calling back the
> OCaml parser on anti-quotations, with careful tracking of locations) and the
> user experience (support from editors, learning details of a concrete syntax
> [you might want to write JSON producers on an abstract level, and benefit
> from clever type-checking, but without knowing exactly how strings have to
> be escaped in concrete JSON]).
>
>
>> Furthermore, the bare approach of using combinators directly is not
>> always desirable in situations where you want the code to be used by
>> non-domain-experts. "Templates" in web programming are an entire
>> cottage industry made of preprocessing HTML-looking quasiquotations,
>> to help the role separation between designers and programmers.
>
>
> When non-programmers have to write some HTML code, this code rarely ends up
> in OCaml source code.  Usually, it stays in its own HTML file, which is then
> processed (statically or dynamically) by the (OCaml) code.
>
> When fragments of JSON/XML/etc are created programatically, this is often
> done "piece by piece", with very small fragments involving a high density of
> anti-quotations.  The benefits of using the foreign syntax here are not
> clear to me.
>
>
>
>> This is maybe less visible for non-programmable data description
>> languages such as JSON, but I suspect this still holds. For example,
>> if you distribute a protocol library built on top of JSON and bridging
>> over many programming languages, you want the same maintainer to be
>> able to quickly reflect changes to the protocol schema over all
>> implements. This is vastly easier if they respect the domain-specific
>> syntax instead of each having an embedding following the concrete
>> syntax of the corresponding language.
>
>
> I understand the theoretical argument, but I don't think it would apply in
> practice to many OCaml projects.
>
>
> Alain

From lpw25 at cam.ac.uk  Thu Jan 31 13:56:30 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 13:56:30 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A7509.1000007@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
Message-ID: <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>

>What do you think of this syntax:
>{:lid|...|lid:}

What about nested uses of the same quotation?

From hongboz at seas.upenn.edu  Thu Jan 31 13:57:51 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 08:57:51 -0500
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510A74AC.4070302@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
Message-ID: <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>

On Thu, Jan 31, 2013 at 8:42 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 01/31/2013 02:32 PM, Hongbo Zhang wrote:
>
>> Would you mind elaborating a bit why it will complex editor support?
>>
>
> The content of a quotation can use arbitrary grammar and even arbitrary
> lexical rules.
>
> If the editor cannot lex the content of the quotation, it cannot produce
> nice colors for lexical entities in it.  If emacs produce decent colors on
> some example with quotation, it is only because it does not know anything
> about quotation and the example is simple enough so that applying OCaml
> rules works quite well.  But if the content of the quotation follows other
> lexical rules, emacs gets confused. Write:
>
>   let x = foo << " >> bar
>
> This is unfair, how do you overcome this problem in ppx. The same thing,
except that you don't use it

> and emacs will color ">> bar" as if it were a string.  The only decent
> think an editor could do with a quotation is to understand where it stops
> and not try to do anything clever with it.  If we adapt the OCaml emacs
> mode to recognize camlp4's quotation and do that, you won't get any colors
> within quotations (correct behavior, but not if you write non-trivial
> multi-line OCaml expressions in it, as in your 'sedlex' version).
>
> Even if the lexical conventions are right, the editor cannot produce
> correct indentation if it doesn't know the grammar used inside the
> quotation.
>
>
> Alain
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/94a4aa89/attachment.html>

From edwin+ml-ocaml at etorok.net  Thu Jan 31 13:57:52 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Thu, 31 Jan 2013 15:57:52 +0200
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
 <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>
Message-ID: <510A7860.1060505@etorok.net>

On 01/31/2013 03:56 PM, Leo White wrote:
>> What do you think of this syntax:
>> {:lid|...|lid:}
> 
> What about nested uses of the same quotation?
> 

Handled like nested comments, assuming the lexer knows where the anti-quotations are.

--Edwin

From lpw25 at cam.ac.uk  Thu Jan 31 14:02:02 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 14:02:02 +0000
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <510A7860.1060505@etorok.net>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
 <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>
 <510A7860.1060505@etorok.net>
Message-ID: <Prayer.1.3.5.1301311402020.2838@hermes-1.csi.cam.ac.uk>

On Jan 31 2013, T?r?k Edwin wrote:

>On 01/31/2013 03:56 PM, Leo White wrote:
>>> What do you think of this syntax:
>>> {:lid|...|lid:}
>> 
>> What about nested uses of the same quotation?
>> 
>
> Handled like nested comments, assuming the lexer knows where the 
> anti-quotations are.

An assumption that I really don't think we should make. It involves forcing 
a particular style of anti-quotation on all extensions. Besides it is 
easier to simply use a syntax that supports unique delimiters.


From lpw25 at cam.ac.uk  Thu Jan 31 14:19:28 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 14:19:28 +0000
Subject: [wg-camlp4] Supporting traditional quotations
In-Reply-To: <510A74AC.4070302@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
Message-ID: <Prayer.1.3.5.1301311419280.10608@hermes-1.csi.cam.ac.uk>

Since what we are currently debating is whether to add a lightweight syntax 
for a type of syntax extension that is used by a number of extensions and 
appreciated by a number of people, is there any real issue with including 
it?

I don't think that "I don't like using those kind of extensions" is a good 
reason to prevent them (or make them more awkward) for the people who do 
like using them.

Similarly, I think that we should support the type-conv style syntax:

type foo =
  | Foo of int
with sexp, bin_io

Sure, this could be changed to use the attribute syntax:

type foo =
  | Foo of int
(@ sexp)
(@ bin_io)

but the original is convenient, already used for a number of extensions and 
has proved popular.

In general there is little harm in supporting syntaxes/extensions that are 
already widespread.


From edwin+ml-ocaml at etorok.net  Thu Jan 31 14:27:50 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Thu, 31 Jan 2013 16:27:50 +0200
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301311402020.2838@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
 <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>
 <510A7860.1060505@etorok.net>
 <Prayer.1.3.5.1301311402020.2838@hermes-1.csi.cam.ac.uk>
Message-ID: <510A7F66.2080409@etorok.net>

On 01/31/2013 04:02 PM, Leo White wrote:
> On Jan 31 2013, T?r?k Edwin wrote:
> 
>> On 01/31/2013 03:56 PM, Leo White wrote:
>>>> What do you think of this syntax:
>>>> {:lid|...|lid:}
>>>
>>> What about nested uses of the same quotation?
>>>
>>
>> Handled like nested comments, assuming the lexer knows where the anti-quotations are.
> 
> An assumption that I really don't think we should make. It involves forcing a particular style of anti-quotation on all extensions. Besides it is easier to simply use a syntax that supports unique
> delimiters.
> 

Even without a defined syntax for anti-quotations you could detect both {:lid| and |lid:} inside quotations:

{:foo| something $
  {:foo| something-else |foo:}
 ...$ ...
|foo:}

But I agree that this might be confusing for users, and introduce unnnecesary limitation on what you can use inside a quotation, so
your user-defined delimiter is probably a better idea.

Best regards,
--Edwin





From gabriel.scherer at gmail.com  Thu Jan 31 14:29:40 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 31 Jan 2013 15:29:40 +0100
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <Prayer.1.3.5.1301311402020.2838@hermes-1.csi.cam.ac.uk>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
 <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>
 <510A7860.1060505@etorok.net>
 <Prayer.1.3.5.1301311402020.2838@hermes-1.csi.cam.ac.uk>
Message-ID: <CAPFanBGN0WOr_TgvH8G_K-5704a23ct8+1h3XHmNa-hjL6ef2Q@mail.gmail.com>

>>> What about nested uses of the same quotation?
>>>
>> Handled like nested comments, assuming the lexer knows where the
>> anti-quotations are.
>
> An assumption that I really don't think we should make. It involves forcing
> a particular style of anti-quotation on all extensions. Besides it is easier
> to simply use a syntax that supports unique delimiters.

Note that there is a nice continuum in the design space for
compromises between syntactic flexibility and easy tool support
(assuming non-smart, non-extensible tools that know how to handle
OCaml code):

0) Pure OCaml syntax : combinator libraries, etc. (note: this is where
the mixfix discussion fits)
1) Alain's style of all-OCaml expressions, using annotations to denote
the domain-specific semantics (tool support for the whole expression)
2) Quotations with an agreed-upon antiquotation syntax (tool support
inside antiquotations)
3) Quotations with extension-custom antiquotation syntax (no tool
support; treated like a string)

I would be interested in seeing which use cases can be satisfyingly
encoded under which approaches. I personally suspect that for
small-scale syntax supports (say, regexps), the outer quotation syntax
being too heavy is more problematic that any antiquotation syntax
considerations (because if it needs to be short it probably doesn't
have antiquotations besides possibly a custom syntax to denote OCaml
variables, that need no editor support).

(Note: to my knowledge, Hongbo was the first to remark (
http://caml.inria.fr/mantis/view.php?id=5665 ) that the Camlp4 syntax
for antiquotations was problematic for nested *antiquotations*. That's
a cogent point that can also be taken into consideration, and
something I like about his work on Fan. The use cases for this are
however quite specialized, so it will be easy to counter-argue that
those considerations are for the Fan-class of preprocessing, not the
included-in-the-language-itself one.)

On Thu, Jan 31, 2013 at 3:02 PM, Leo White <lpw25 at cam.ac.uk> wrote:
> On Jan 31 2013, T?r?k Edwin wrote:
>
>> On 01/31/2013 03:56 PM, Leo White wrote:
>>>>
>>>> What do you think of this syntax:
>>>> {:lid|...|lid:}
>>>
>>>
>>> What about nested uses of the same quotation?
>>>
>>
>> Handled like nested comments, assuming the lexer knows where the
>> anti-quotations are.
>
>
> An assumption that I really don't think we should make. It involves forcing
> a particular style of anti-quotation on all extensions. Besides it is easier
> to simply use a syntax that supports unique delimiters.
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From hongboz at seas.upenn.edu  Thu Jan 31 14:46:48 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 09:46:48 -0500
Subject: [wg-camlp4] Meta Programming from the view of the implementaion
In-Reply-To: <CAPFanBGN0WOr_TgvH8G_K-5704a23ct8+1h3XHmNa-hjL6ef2Q@mail.gmail.com>
References: <CANcqPu7+B+kch9eGVBfNyLmsZNP38qD81RML=DuzD+xAgVhGBw@mail.gmail.com>
 <CANcqPu5YXiZZqN7uH1u_8dQ6VxKTSELSRhvfSkaOnqJGKAo5Ow@mail.gmail.com>
 <5108E3E3.307@frisch.fr>
 <Prayer.1.3.5.1301300931510.9358@hermes-1.csi.cam.ac.uk>
 <5108FA0D.5010802@frisch.fr>
 <Prayer.1.3.5.1301301121550.2899@hermes-1.csi.cam.ac.uk>
 <51093113.1080906@frisch.fr>
 <Prayer.1.3.5.1301301511470.25451@hermes-1.csi.cam.ac.uk>
 <51093DF5.9080306@frisch.fr>
 <Prayer.1.3.5.1301301613540.31905@hermes-1.csi.cam.ac.uk>
 <51095364.9080001@frisch.fr>
 <Prayer.1.3.5.1301311148320.23992@hermes-1.csi.cam.ac.uk>
 <510A6362.8070504@frisch.fr>
 <Prayer.1.3.5.1301311242470.25787@hermes-1.csi.cam.ac.uk>
 <CANcqPu5disPNwgYFdMvr003rh9odgx47u5zsGDT3sGQMve9Mqw@mail.gmail.com>
 <510A6FEA.3080807@etorok.net>
 <CANcqPu5AvgRhyZRwocfA2AMH-HRY9pFk+agG8FgDNAdYiZkhCg@mail.gmail.com>
 <510A7509.1000007@etorok.net>
 <Prayer.1.3.5.1301311356300.2838@hermes-1.csi.cam.ac.uk>
 <510A7860.1060505@etorok.net>
 <Prayer.1.3.5.1301311402020.2838@hermes-1.csi.cam.ac.uk>
 <CAPFanBGN0WOr_TgvH8G_K-5704a23ct8+1h3XHmNa-hjL6ef2Q@mail.gmail.com>
Message-ID: <CANcqPu6vGKXUGzJu=oQ8n8qP=X4wgAy6MvoFA5RArg26ZdGrDQ@mail.gmail.com>

Besides, I would really appreciate that we don't introduce *too many ad-hoc
rules*. typing several more characters is ok, typing hundred lines of code
does matter.

Haskell already suffers from its too flexible syntaxes, think about
haskell-src-meta which is a Haskell front-end, can not parse Haskell
correctly due to the fact that haskell's operator precedence is dynamic.

So far, to my best knowledge, all the feature requests should be not too
hard to implement or already exist  in Fan(without changing the grammar),
so I do hope that we don't introduce too much complexity in Parsetree for
little benefit or *making tooling too hard.*

Only one syntax extension I think revised syntax did in a write way is
match with [ ... ], the closed brackets really helps to avoid a lot of bugs.

On Thu, Jan 31, 2013 at 9:29 AM, Gabriel Scherer
<gabriel.scherer at gmail.com>wrote:

> >>> What about nested uses of the same quotation?
> >>>
> >> Handled like nested comments, assuming the lexer knows where the
> >> anti-quotations are.
> >
> > An assumption that I really don't think we should make. It involves
> forcing
> > a particular style of anti-quotation on all extensions. Besides it is
> easier
> > to simply use a syntax that supports unique delimiters.
>
> Note that there is a nice continuum in the design space for
> compromises between syntactic flexibility and easy tool support
> (assuming non-smart, non-extensible tools that know how to handle
> OCaml code):
>
> 0) Pure OCaml syntax : combinator libraries, etc. (note: this is where
> the mixfix discussion fits)
> 1) Alain's style of all-OCaml expressions, using annotations to denote
> the domain-specific semantics (tool support for the whole expression)
> 2) Quotations with an agreed-upon antiquotation syntax (tool support
> inside antiquotations)
> 3) Quotations with extension-custom antiquotation syntax (no tool
> support; treated like a string)
>
> I would be interested in seeing which use cases can be satisfyingly
> encoded under which approaches. I personally suspect that for
> small-scale syntax supports (say, regexps), the outer quotation syntax
> being too heavy is more problematic that any antiquotation syntax
> considerations (because if it needs to be short it probably doesn't
> have antiquotations besides possibly a custom syntax to denote OCaml
> variables, that need no editor support).
>
> (Note: to my knowledge, Hongbo was the first to remark (
> http://caml.inria.fr/mantis/view.php?id=5665 ) that the Camlp4 syntax
> for antiquotations was problematic for nested *antiquotations*. That's
> a cogent point that can also be taken into consideration, and
> something I like about his work on Fan. The use cases for this are
> however quite specialized, so it will be easy to counter-argue that
> those considerations are for the Fan-class of preprocessing, not the
> included-in-the-language-itself one.)
>
> On Thu, Jan 31, 2013 at 3:02 PM, Leo White <lpw25 at cam.ac.uk> wrote:
> > On Jan 31 2013, T?r?k Edwin wrote:
> >
> >> On 01/31/2013 03:56 PM, Leo White wrote:
> >>>>
> >>>> What do you think of this syntax:
> >>>> {:lid|...|lid:}
> >>>
> >>>
> >>> What about nested uses of the same quotation?
> >>>
> >>
> >> Handled like nested comments, assuming the lexer knows where the
> >> anti-quotations are.
> >
> >
> > An assumption that I really don't think we should make. It involves
> forcing
> > a particular style of anti-quotation on all extensions. Besides it is
> easier
> > to simply use a syntax that supports unique delimiters.
> >
> >
> > _______________________________________________
> > wg-camlp4 mailing list
> > wg-camlp4 at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/wg-camlp4
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/388452b1/attachment.html>

From alain.frisch at lexifi.com  Thu Jan 31 15:22:59 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 31 Jan 2013 16:22:59 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
Message-ID: <510A8C53.7080903@lexifi.com>

On 01/31/2013 02:57 PM, Hongbo Zhang wrote:
>
>        let x = foo << " >> bar
>
> This is unfair, how do you overcome this problem in ppx. The same thing,
> except that you don't use it

The discussion here is not about ppx vs camlp4, but whether it is a good 
idea to use quotations with "ocaml code in them".  My argument is that 
it is a very bad idea, because the only decent way to support quotation 
in editor modes is to ignore them (which is not currently the case).

I hope, for instance, that the ocaml emacs mode will be adapted to 
whatever syntax for quotation we choose to support natively in OCaml. 
Once this is done, emacs will no longer be confused with examples as the 
one above (good!), but it will no longer provide any assistance if OCaml 
code had to be written inside the quotation (bad! but only if we 
implement sedlex as you suggest, with a big quotation around the whole 
lexer definition, including actions).  If quotations are purely used to 
inject code in foreign syntax (with very simple anti-quotations which 
don't really benefit from editor support), this correct behavior of 
editors is no longer a problem.

Let me clarify my position about quotations:

The whole point of quotations, for me, is to escape from OCaml lexical 
convention.  If we have to embed fragments of foreign language syntax 
which works fine with OCaml rules (e.g. fragments which don't need 
double quotes or backslashes), strings are just fine:

fun x -> (:sql "select * from table where id = $x")

So the most important criterion of the syntax for quotations is that 
they actually allow to write an arbitrary piece of foreign syntax, and 
the simplest way to achieve that is to avoid putting any constraint on 
the closing delimiter.  That's why I suggest that the opening delimiter 
defines what the closing delimiter is explicitly, without too much 
restriction.

  {!{ ... }!}
  {x{ ... }x}
  {{ ... }}     assuming the content does not use }}


I'm not against quotations per se, but I argue:

  - Against their use such as the one suggested by Honbgo for sedlex 
(including the whole lexer definition, including potentially large OCaml 
expressions, inside a big quotation).

  - Against the idea that the syntactic aspect of quotations has 
anything to do with the notion of extension node to be expanded to AST 
fragments by some code.  They are just independent notions:

     * if the extension node can benefit from the OCaml syntax, this is 
really good (no need to write any parsing code in the "expander", and 
good editor support);

    begin(:sedlex) match lexbuf with
    | ... -> e1
    end

(I've used a syntax which make it clearer what the scope of the 
extension node is, and which dissociates the extension marker e1 from 
its content e2:  begin(:e1) e2 end)

     * quotations can be useful independently from any "expander", 
simply because they provide a different convenient style of writing 
strings which does not require escaping of double quotes and backslashes:

     failwith {{I "like" double quotes.}}

     * both notions can be combined if needed (an extension node whose 
content really has to be written in foreign syntax with a lot of double 
quotes or backslashes)

    begin(:sedlex) begin match lexbuf with
    | {{ '"' }} -> QUOTE
    | {{ '\' }} -> BACKSLASH
    | {{ [a-z]+ }} -> IDENT
    end

    or:

    ((:html) {{ <div class="$x"> }})

    (a lighter syntax with parentheses)

-- Alain

From hongboz at seas.upenn.edu  Thu Jan 31 16:03:12 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 31 Jan 2013 11:03:12 -0500
Subject: [wg-camlp4] Why Quotation is a good idea with decent Editor support
Message-ID: <CANcqPu7UdH3UBhxyhiRxxi8r+U6RZ7qi4uijn0kuOf2sirXdag@mail.gmail.com>

Dear all,

   The functionality of Editor lies in two aspects:
   1. Semantic analysis (auto completion, go to definition, etc)
   2. layout, syntax coloring

For the first part, quotation works perfect with editor support, since when
you goto a delimited
language {:lex| .... |} , the IDE gets enough information to do the
auto-completion. Besides, the
code is *readable, semantics is clear,* you know  the exactly scope where
the language lies.
If you use something like sedlex, I really don't know how to read the code.
It gives you an illusion that
it is normal ocaml, but it is not, should there be anything worse than this?

Also, since any exception to normal oaml is clearly delimited, *you can
select the region, see the expanded*
*code on the fly with the ide support.*

For the second part, namespace came to rescue, for example if we want the
lay out rules still follow
the caml syntax, put the language you defined in Fan.Lang.Caml namespace.
If we want the syntax highlighting
like javascript, we can put it in Fan.Lang.Js namespace, like
http://www.emacswiki.org/emacs/MmmMode
This solves the problem once for all, instead just ignore it


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130131/4760415b/attachment.html>

From lpw25 at cam.ac.uk  Thu Jan 31 16:27:28 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 16:27:28 +0000
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510A8C53.7080903@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
Message-ID: <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>

>  - Against the idea that the syntactic aspect of quotations has 
>anything to do with the notion of extension node to be expanded to AST 
>fragments by some code.  They are just independent notions:

Just because quotations do not need to be part of an extension and 
extensions do not need to use quotations does not change the fact that they 
are frequently used together, so a convenient syntax would be appreciated.

I really don't understand your objection to including all of the following:

* A quotation syntax: {x{ string }x}
* A template syntax: {:lid expr}
* A convenient quotation template syntax: {:lid x| |x}

The quotation template is more lightweight than combining the other two, 
and adds flexibility/clarity for quotations that contain many "}"s. Its 
simply a case of providing a simple syntax for a common use case. Just 
because you don't like that use case doesn't make it not common.

>    begin(:sedlex) match lexbuf with
>    | ... -> e1
>    end

I think that this was better as a template:

{:sedlex 
  match lexbuf with
    | ... -> e1
}

From alain.frisch at lexifi.com  Thu Jan 31 16:48:10 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 31 Jan 2013 17:48:10 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
Message-ID: <510AA04A.1010906@lexifi.com>

On 01/31/2013 05:27 PM, Leo White wrote:
>>  - Against the idea that the syntactic aspect of quotations has
>> anything to do with the notion of extension node to be expanded to AST
>> fragments by some code.  They are just independent notions:
>
> Just because quotations do not need to be part of an extension and
> extensions do not need to use quotations does not change the fact that
> they are frequently used together, so a convenient syntax would be
> appreciated.
>
> I really don't understand your objection to including all of the following:
>
> * A quotation syntax: {x{ string }x}
> * A template syntax: {:lid expr}
> * A convenient quotation template syntax: {:lid x| |x}

Ok, so:
   {:lid x|..|x}
is strictly equivalent to:
   {:lid {x{...}x} }
?

Also also equivalent to:
   {:lid "..."}
as long as the string "..." does not contain any special character?

(i.e. the various forms are not distinguished in the Parsetree.)

I won't fight against this syntactic sugar, but I don't like it because:

   1. It adds even more syntax (to be supported by editors, in 
particular), even with a new character (I find the choice of |
as part of a delimiter cognitively dangerous since it is usually used as 
in separator in OCaml syntax).

   2. It creates confusion by conflating two concepts (and I'm not sure 
they will be so commonly used together), and encourage a style of 
expanders based on concrete syntax which, IMO, should rather be discouraged.

> Just
> because you don't like that use case doesn't make it not common.

It is not common at all: the system does not exist yet.  During the 
migration from camlp4 to ppx, it is not bad that people have to think 
twice before choosing a design which forces to combine "expander + 
quotation".

It seems to me that the cases where concrete foreign syntax might be 
useful (copy/paste of large chunks of code) do not necessarily require a 
very compact syntax, and that for shorter "expanders" with a 
high-density of anti-quotations, avoiding concrete syntax is preferable.

But if there is enough demand and if it can help in the transition, I 
won't fight any more against the combined "expander + quotation" 
approach. (I will just cross my fingers so that the developers of tools 
I'll like to use don't force me to use concrete syntax + anti-quotations 
for no good reason.)

>>    begin(:sedlex) match lexbuf with
>>    | ... -> e1
>>    end
>
> I think that this was better as a template:
>
> {:sedlex  match lexbuf with
>     | ... -> e1
> }

Ok, just a different syntax.


-- Alain

From lpw25 at cam.ac.uk  Thu Jan 31 18:04:55 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 31 Jan 2013 18:04:55 +0000
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510AA04A.1010906@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
Message-ID: <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>

>Ok, so:
>   {:lid x|..|x}
>is strictly equivalent to:
>   {:lid {x{...}x} }
>?
>
>Also also equivalent to:
>   {:lid "..."}
>as long as the string "..." does not contain any special character?
>
>(i.e. the various forms are not distinguished in the Parsetree.)

This comes back to how we feel about syntactic sugar in the Parsetree. 
Personally I like keeping things separate if they look different, but not 
if it involves too much hassle.

> (I find the choice of |
>as part of a delimiter cognitively dangerous since it is usually used as 
>in separator in OCaml syntax).

I would be perfectly happy with "<" + ">" instead of |, or anything else 
which doesn't interfere with the {:lid expr } syntax. As long as its a 
single-character and it is not "{" + "}".

> (I will just cross my fingers so that the developers of tools 
>I'll like to use don't force me to use concrete syntax + anti-quotations 
>for no good reason.)

Considering a parser is probably more effort to write than an AST 
transformer, I don't think you need to worry too much. If it can be done 
sensibly without concrete syntax (i.e it is not a "foreign syntax") it 
probably will be. And of course there is nothing to stop conscientious 
extension authors from providing both styles.


From gabriel.scherer at gmail.com  Thu Jan 31 21:13:52 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 31 Jan 2013 22:13:52 +0100
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
Message-ID: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>

I like Leo's idea of distinguishing three different forms of syntax
extensions (I'm not discussing concrete syntax):

1. structured comments, which as the name indicates do not directly
  influence the semantics of the OCaml source file

  (users that don't have the corresponding extension can still use the
  source file)

  example in Use Cases
  ( https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases
),
  Bisect comments

  match List.map foo [x; a x; b x] with
  | [y1; y2; y3] -> tata
  | _ -> (*BISECT-VISIT*) assert false

  (Of course the concrete syntax does not need to be OCaml comments,
  and in fact it would be nice to parse them as OCaml code rather than
  raw strings; but this does not cover all "annotations", only those
  that can effectively be turned into comments and leave
  a semantically correct file.)


2. shallow embeddings, which is the style of lightweight marking
  (in mostly valid OCaml syntax) of -ppx rewrites that Alain promotes

  (the writer of said extension expects an OCaml syntax tree as input)

  example in Use Cases : "modified sedlex" (modified by me following
  the spirit of the compromises suggested by Alain in the "not valid
  OCaml syntax" discussion)

   (:sedlex
     let:regexp letter = ('a'..'z'|'A'..'Z') in
     match:lexer buf with
     | number -> Printf.printf "Number %s\n" (Sedlexing.Latin1.lexeme
buf); token buf
     | letter, Star ('A'..'Z' | 'a'..'z' | digit) -> Printf.printf
"Ident %s\n" (Sedlexing.Latin1.lexeme buf); token buf
   )

  (or possibly {{$letter([A-Z]|[a-z]|$digit)*}} -> ...)

3. deep embeddings, which uses a camlp4-like mechanism of
   quasiquotations to inject arbitrary syntax, and antiquotations to
   locally return to standard OCaml code with standard semantics
   (sorry Jeremy, I'm using the "quotation" name for this potentially
   improper usage, but I can't find a good matching pair for
   "antiquotations" otherwise)

  (the writer of said extensions expects a string to parse, with
  library support to get OCaml syntax trees out of the antiquotations)

  example in Use Cases: Cass

  let button = <:css<
     .button {
       $Css.gradient ~low:color2 ~high:color1$;
       color: white;
       $Css.top_rounded$;
   >>

(It's not an exhaustive categorization: I'm not discussing arbitrary
extensions of the OCaml grammar such as "let open" here. Nobody on
wg-camlp4 seems to be discussing those anyway.)




I would like to follow up with some questions:


- What is the breadth of structured comments?

  Which use cases can this form cover?  It's clear that it is adapted
  for compiler pragmas (say local warning/error selection, which we
  have wanted for a long time in OCaml) and more generally local
  configuration of analysis tools (mascot, find-bisect, whatever)

  Anil's remark on "tools that perform external code generations" can
  also be understood in this form:
  https://github.com/avsm/ocaml-github/blob/master/lib/github.atd
  could fairly easily be translated in this style.


- What can user assume of the semantics of shallow embeddings?

  I think having a global marker (here a "prefix annotation" in
  Leo's taxonomy) to denote a piece of OCaml syntax with non-standard
  semantics is important. But that does not resolve all
  questions. Will only the topmost "match" construction be
  interepreted as a lexer, or does this reinterpretation applies
  recursively in depth? (In my snippet I marked concerned matches with
  a :lexer annotation).

  I have the impression that some choices may lead to extensions that
  compose as well as the deep quasiquotations, but that some other may
  result in extensions as fragile as unrestricted grammar
  extension.

  Besides, the concrete syntax is important here: a (match:lexer
  ... with ...) annotation is clearly local to this one match
  construct, while I would tend to understand (:sedlex match .. with
  ...) as being a modality over the expression as a whole.


- What are good concrete syntaxes for these forms?

  (So far: Leo's suggestions, Alain snippets, and existing choices in
  existing syntax extension frameworks)

  It's not clear that shallow embeddings and foreign quasiquotations
  should have radically distinct syntaxes. It's important for the
  extension developper to specify the minimum amount of syntactic
  freedom needed, but does the user care which is used?


- Which forms could/should be *eventually* proposed for adoption by
  the compiler's OCaml definition, which are best relegated to a more
  sophisticated external tool like Fan?

