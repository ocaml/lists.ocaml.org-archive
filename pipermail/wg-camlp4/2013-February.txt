From alain.frisch at lexifi.com  Fri Feb  1 07:38:18 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Feb 2013 08:38:18 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
 <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
Message-ID: <510B70EA.1040102@lexifi.com>

On 1/31/2013 7:04 PM, Leo White wrote:
>>   {:lid x|..|x}
> I would be perfectly happy with "<" + ">" instead of |, or anything else
> which doesn't interfere with the {:lid expr } syntax. As long as its a
> single-character and it is not "{" + "}".

In OCaml, delimiters are built from those symbols:  {...}, (...), [...], 
sometimes combined with other characters as in [|...|].  It is probably 
a good idea to keep using one of these kinds of parentheses as outer 
delimiters, both to make it clear in the syntax that they are indeed 
matched delimiters, and also to benefit from basic editor support (for 
matching parentheses), when quotations are not recognized as such.  I 
don't have a concrete proposal for a syntax, though.

Something else: I suggest that the "marker" (lid in your examples) for 
extension node (whether they are combined with quotations or not) could 
rather be a general expression than just an identifier (maybe with a 
lighter syntax for the simple identifier case).  (In the Parsetree, we 
would have "Pexp_extension of expression * expression" instead of 
"Pexp_extension string * expression".)  This is to support passing 
arguments to the "expander".  Of course, those arguments could be 
encoded in the "content", but I believe it makes sense to distinguish 
those two concepts.  In particular, if you use the combined extension + 
quotation form, you probably want parsed arguments even with unparsed 
content:

  {:(html ~strict ~antiquot:'$') |<div class=$x/>|}


> Considering a parser is probably more effort to write than an AST
> transformer, I don't think you need to worry too much.

(Requiring more effort is unfortunately often valued as a good thing!)


Alain

From alain at frisch.fr  Fri Feb  1 07:50:24 2013
From: alain at frisch.fr (Alain Frisch)
Date: Fri, 01 Feb 2013 08:50:24 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
Message-ID: <510B73C0.5090700@frisch.fr>

On 1/31/2013 10:13 PM, Gabriel Scherer wrote:
> I like Leo's idea of distinguishing three different forms of syntax
> extensions (I'm not discussing concrete syntax):
>
> 1. structured comments
> 2. shallow embeddings
> 3. deep embeddings

In which category would you put code generators based on type 
declaration (a la type-conv) also fall in this category?  For me, this 
is one of the most important use case of -ppx (the other being 
instrumentation of code, covered by 1 I guess).  Basically, they only 
require the ability to add annotations on type declaration and type 
expressions (and one needs to be able to include OCaml expressions in 
the annotations).  If/when runtime types are added to OCaml, they will 
hopefully also benefit from those annotations.

I guess that 1 is excluded because those annotations are required to 
compile to program and 3 is excluded, because this has nothing to do 
with syntax.  But 2 does not seem to apply either.

-- Alain

From alain at frisch.fr  Fri Feb  1 09:15:16 2013
From: alain at frisch.fr (Alain Frisch)
Date: Fri, 01 Feb 2013 10:15:16 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510B70EA.1040102@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
 <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
 <510B70EA.1040102@lexifi.com>
Message-ID: <510B87A4.8010502@frisch.fr>

On 02/01/2013 08:38 AM, Alain Frisch wrote:
> (In the Parsetree, we
> would have "Pexp_extension of expression * expression" instead of
> "Pexp_extension string * expression".)  This is to support passing
> arguments to the "expander".

After some more thought, I've changed my mind.

Following one of Hongbo's suggestions, let's try to think in terms of 
abstract syntax first to clarify the concepts.

I believe we need two "modalities" for generic placeholders in the AST: 
  annotations and extensions.  An attribute annotate an existing 
fragment of the AST and can technically be ignored simply by dropping 
it.  An extension is something which does not have any built-in meaning 
and has to be expanded during the AST transformation (or maybe during 
type-checking to support OCaml Templates-like processing).  Here is a 
minimalistic way to support this in Parsetree like:

  | Ptyp_annotation of core_type * annotation
  | Ptyp_extension of extension

  | Ppat_annotation of pattern * annotation
  | Ppat_extension of extension

  | Pmod_annotation of module_expr * annotation
  | Pmod_extension of extension

  | Ptype_annotation of type_kind * annotation
  | Ptype_extension of extension

  | Pexp_annotation of expression * annotation
  | Pexp_extension of extension

  | ...


We can choose:

type annotation = expression
and extension = expression

or maybe:

type annotation = string * expression
and extension = string * expression

I think I prefer to use bare expressions, and encode in them the 
"markers", because this does not force to hard-code the nature of 
markers. An argument in favor of keeping an explicit "string" is to 
define more explicitly the "namespace" of the extension, though.


I don't believe we should add a further distinction between the 
annotations which can actually be ignored by the compiler and those on 
which the type-checker must complain.  This can be left to a choice of
syntax which combines an annotation and an extension.

Similarly, I'm not sure we should hard-code/enforce the fact that an AST 
mapper should only be able to expand "under" extensions.  Extensions 
could also be used as markers which can trigger "local enough" 
rewriting. (See examples "Bolt" and "PG'OCaml" below.)


Only to fix the ideas, let's give some examples, assuming the following 
syntax:

   (# e)       ->  extension
   ... (+ e)   ->  annotation (with light postfix syntax)
   (@ e) ...   ->  annotation (with light prefix syntax)

   (@(e) ...)  ->  annotation (explicit scope, prefix syntax)

and maybe a derived "non-ignorable annotation":

   ... (& e)  ===  ... (+ (# e))

and syntactic variants such as:

   let(+e) p = ... === (@ e)(let p = ...)

and also something which combine an extension + quotation:

   (:id x[...]x)   === (# id {x{...}x})



Some examples:

   "Bisect"

         let f x =
           match List.map foo [x; a x; b x] with
           | [y1; y2; y3] -> tata
           | _ -> (@ Bisect.visit) assert false


         (@(Bisect.ignore)
           let unused = ()
         )


   "type-conv"

type t = {
   x : int (+ default 42);
   y : int (+ default 3) (+ sexp_drop_default);
   z : int (+ default 3) (+ sexp_drop_if z_test);
} (+ sexp)


   "map/fold generators"

type variable = string
  and term =
   | Var of variable
   | Lam of variable * term
   | App of term * term


class map = (# (Generate.map : term))


   "lwt"

let(+lwt) x = ...
and y = ...
in
try(+lwt) ...
with Killed -> ...


   "Bolt"

let funct n =
   (#LOG) "funct(%d)" n LEVEL DEBUG;
(*or: (#LOG "funct(%d)" n LEVEL DEBUG); *)
   for i = 1 to n do
     print_endline "..."
   done

   "bitstring"

let bits = Bitstring.bitstring_of_file "/bin/ls" in
match(&bitmatch) bits with
| (# [ 0x7f, 8; "ELF", 24, string; (* ELF magic number *)
        e_ident, 12*8, bitstring;    (* ELF identifier *)
        e_type, 16, littleendian;    (* object file type *)
        e_machine, 16, littleendian  (* architecture *)
   ]) ->
   printf "This is an ELF binary, type %d, arch %d\n"
     e_type e_machine;

(* here I've used (&...) instead of (+...) because the interpretation of 
the pattern really depends on this annotation *)
(*  note: without the 12*8 sub-expression, this would also have been
     a valid pattern and we could have avoided the extra (# ...) used
     here only to allow an expression in place of a pattern.  If we can
     somehow bring expressions and patterns closed in the syntax,
     we could avoid this extra little overhead. *)


   "PG'OCaml"

let fetch_users dbh =
   (#PGSQL dbh) "select id, name from users"
(*
   or: (#PGSQL) dbh "select id, name from users"
   or: (#PGSQL dbh "select id, name from users")
*)


  "Cass"

let button = (:css [
    .button {
      $Css.gradient ~low:color2 ~high:color1$;
      color: white;
      $Css.top_rounded$;
  ])



-- Alain

From info at gerd-stolpmann.de  Fri Feb  1 09:34:10 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Fri, 01 Feb 2013 10:34:10 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510B70EA.1040102@lexifi.com> (from alain.frisch@lexifi.com on
 Fri Feb  1 08:38:18 2013)
Message-ID: <1359711250.10634.21@samsung>

Am 01.02.2013 08:38:18 schrieb(en) Alain Frisch:
> Something else: I suggest that the "marker" (lid in your examples)  
> for extension node (whether they are combined with quotations or not)  
> could rather be a general expression than just an identifier (maybe  
> with a lighter syntax for the simple identifier case).  (In the  
> Parsetree, we would have "Pexp_extension of expression * expression"  
> instead of "Pexp_extension string * expression".)  This is to support  
> passing arguments to the "expander".  Of course, those arguments  
> could be encoded in the "content", but I believe it makes sense to  
> distinguish those two concepts.  In particular, if you use the  
> combined extension + quotation form, you probably want parsed  
> arguments even with unparsed content:
> 
>  {:(html ~strict ~antiquot:'$') |<div class=$x/>|}

I don't think users would like this style in general - you don't want  
to repeat configuration aspects like ~strict and ~antiquot in every  
quotation. Normally the same configuration applies to a whole  
subexpression or even the whole file.

For the few camlp4 parsers I wrote I used special configuration  
quotations for this purpose, i.e. here

{:html_config ~strict ~antiquot:'$'}

and this would apply "for the rest" whatever this is. But this was rare  
so far, I can remember there was one such configuration for the  
character set of generated XML docs.

Gerd



> 
> 
>> Considering a parser is probably more effort to write than an AST
>> transformer, I don't think you need to worry too much.
> 
> (Requiring more effort is unfortunately often valued as a good thing!)
> 
> 
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 


-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From lpw25 at cam.ac.uk  Fri Feb  1 10:35:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 01 Feb 2013 10:35:12 +0000
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510B70EA.1040102@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
 <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
 <510B70EA.1040102@lexifi.com>
Message-ID: <Prayer.1.3.5.1302011035120.25380@hermes-1.csi.cam.ac.uk>

>
>  {:(html ~strict ~antiquot:'$') |<div class=$x/>|}
>

I think that this is probably too much of a pain to lex. This is perhaps 
the point at which you should switch to the non-abbreviated form:

  {:html ~strict ~antiquot:'$' {{<div class=$x/>}}}

From lpw25 at cam.ac.uk  Fri Feb  1 11:02:55 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 01 Feb 2013 11:02:55 +0000
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510B87A4.8010502@frisch.fr>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
 <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
 <510B70EA.1040102@lexifi.com> <510B87A4.8010502@frisch.fr>
Message-ID: <Prayer.1.3.5.1302011102550.25380@hermes-1.csi.cam.ac.uk>

>We can choose:
>
>type annotation = expression
>and extension = expression
>
>or maybe:
>
>type annotation = string * expression
>and extension = string * expression
>
>I think I prefer to use bare expressions, and encode in them the 
>"markers", because this does not force to hard-code the nature of 
>markers. An argument in favor of keeping an explicit "string" is to 
>define more explicitly the "namespace" of the extension, though.

I think that it is very important to define the "namespace" of extensions. 
I was thinking something like:

type annotation = expression
and extension = longident * expression option

So the extension has the same type as a constructor application. I don't 
think annotations should necessarily be namespaced because they will 
probably be very useful within an extension, in which case they will 
already be namespaced by that extension.


>I don't believe we should add a further distinction between the 
>annotations which can actually be ignored by the compiler and those on 
>which the type-checker must complain.  This can be left to a choice of
>syntax which combines an annotation and an extension.

I agree.

>Similarly, I'm not sure we should hard-code/enforce the fact that an AST 
>mapper should only be able to expand "under" extensions.  Extensions 
>could also be used as markers which can trigger "local enough" 
>rewriting. (See examples "Bolt" and "PG'OCaml" below.)

I agree.

>Only to fix the ideas, let's give some examples, assuming the following 
>syntax:
>
>   (# e)       ->  extension
>   ... (+ e)   ->  annotation (with light postfix syntax)
>   (@ e) ...   ->  annotation (with light prefix syntax)
>
>   (@(e) ...)  ->  annotation (explicit scope, prefix syntax)
>
>and maybe a derived "non-ignorable annotation":
>
>   ... (& e)  ===  ... (+ (# e))
>
>and syntactic variants such as:
>
>   let(+e) p = ... === (@ e)(let p = ...)
>
>and also something which combine an extension + quotation:
>
>   (:id x[...]x)   === (# id {x{...}x})


This certainly seems to be along the right lines. If we really prefer {, ( 
or [ for delimiters then perhaps:

Quotation:  {x{ ... }x} 

Extension:  (:longid expr)

Annotation:  (@ expr)  (and maybe others for prefix etc.)

Then some abbreviated forms for common cases:

Quotation Extension:  
  {:longid x{ ... }x}  ==  (:longid {x{ .. {x})

Let Extension:  
  let:longid foo = ... in ...  
    ==  (:longid let foo = ... in ...)

Match Extension: 
  match:longid expr with ...  
   ==  (:longid match expr with ...)

Type-Conv Annotation: 
  type foo = ... with longid( expr ), longid ... 
   == type foo = ... (@ longid expr) (@ longid) ...

We could provide special-cases in ast_mapper to make these abbreviated 
forms particularly easy to work with.

The downside of this abbreviated syntax for quotation extensions (as 
opposed to {:foo| ... |} )is that it does not provide an alternative 
delimiter to "}". However it probably fits in better.


From alain.frisch at lexifi.com  Fri Feb  1 12:08:01 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 01 Feb 2013 13:08:01 +0100
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <Prayer.1.3.5.1302011102550.25380@hermes-1.csi.cam.ac.uk>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
 <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
 <510B70EA.1040102@lexifi.com> <510B87A4.8010502@frisch.fr>
 <Prayer.1.3.5.1302011102550.25380@hermes-1.csi.cam.ac.uk>
Message-ID: <510BB021.8010105@lexifi.com>

On 02/01/2013 12:02 PM, Leo White wrote:
> I think that it is very important to define the "namespace" of
> extensions. I was thinking something like:
>
> type annotation = expression
> and extension = longident * expression option
>
> So the extension has the same type as a constructor application. I don't
> think annotations should necessarily be namespaced because they will
> probably be very useful within an extension, in which case they will
> already be namespaced by that extension.

I can see cases where the notion of "extension" is only used to inject 
syntactic expressions in a different category (module, pattern, type) 
but is also "scoped" by an outer extension which provides the namespace. 
See the "bitstring" example, where we need to put an expression inside a 
pattern, but the interpretation of this is given by the surrounding 
marker on the pattern matching.

Note that even if we choose "type extension = expression", we can 
provide a special namespaced syntax.  E.g.:

  (:lid e)   ====>  (# lid (e))

(i.e. we inject the lid/expression pair into either a function or 
constructor application.)  But the syntactic gain is rather small.

Alternatively, if we choose to make "type extension = longident * 
expression option" as you suggest, we can also support a different syntax:

  (# e)  ====>  (* empty identifier in the Parsetree *)

but this sounds a little bit less natural to me.  I like the 
minimalistic approach of having "extension = expression" in all 
syntactic categories (including expression themselves).  But I will 
certainly not fight the other solution.


-- Alain


>
>
>> I don't believe we should add a further distinction between the
>> annotations which can actually be ignored by the compiler and those on
>> which the type-checker must complain.  This can be left to a choice of
>> syntax which combines an annotation and an extension.
>
> I agree.
>
>> Similarly, I'm not sure we should hard-code/enforce the fact that an
>> AST mapper should only be able to expand "under" extensions.
>> Extensions could also be used as markers which can trigger "local
>> enough" rewriting. (See examples "Bolt" and "PG'OCaml" below.)
>
> I agree.
>
>> Only to fix the ideas, let's give some examples, assuming the
>> following syntax:
>>
>>   (# e)       ->  extension
>>   ... (+ e)   ->  annotation (with light postfix syntax)
>>   (@ e) ...   ->  annotation (with light prefix syntax)
>>
>>   (@(e) ...)  ->  annotation (explicit scope, prefix syntax)
>>
>> and maybe a derived "non-ignorable annotation":
>>
>>   ... (& e)  ===  ... (+ (# e))
>>
>> and syntactic variants such as:
>>
>>   let(+e) p = ... === (@ e)(let p = ...)
>>
>> and also something which combine an extension + quotation:
>>
>>   (:id x[...]x)   === (# id {x{...}x})
>
>
> This certainly seems to be along the right lines. If we really prefer {,
> ( or [ for delimiters then perhaps:
>
> Quotation:  {x{ ... }x}
> Extension:  (:longid expr)
>
> Annotation:  (@ expr)  (and maybe others for prefix etc.)
>
> Then some abbreviated forms for common cases:
>
> Quotation Extension:  {:longid x{ ... }x}  ==  (:longid {x{ .. {x})
>
> Let Extension:  let:longid foo = ... in ...    ==  (:longid let foo =
> ... in ...)
>
> Match Extension:  match:longid expr with ...   ==  (:longid match expr
> with ...)
>
> Type-Conv Annotation:  type foo = ... with longid( expr ), longid ...
> == type foo = ... (@ longid expr) (@ longid) ...
>
> We could provide special-cases in ast_mapper to make these abbreviated
> forms particularly easy to work with.
>
> The downside of this abbreviated syntax for quotation extensions (as
> opposed to {:foo| ... |} )is that it does not provide an alternative
> delimiter to "}". However it probably fits in better.
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From lpw25 at cam.ac.uk  Fri Feb  1 13:55:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 01 Feb 2013 13:55:12 +0000
Subject: [wg-camlp4] On domain-specific foreign syntaxes
In-Reply-To: <510BB021.8010105@lexifi.com>
References: <CAPFanBE-uKv-V+0W1hf9iJS6fGQzjU-LFO3uaLGY50wzpEbAdQ@mail.gmail.com>
 <510A6D89.9000507@lexifi.com>
 <FB5C1A21-6ACB-45D1-83D6-7D685A612332@recoil.org>
 <CANcqPu6te1UCB_MRAR8yebenoZhOozKgHMJwRra-Pkem5wKBnw@mail.gmail.com>
 <510A74AC.4070302@lexifi.com>
 <CANcqPu5pBTwP59qTQzfYVVO_nUXatCh3FNxifyyPQB369U8EaQ@mail.gmail.com>
 <510A8C53.7080903@lexifi.com>
 <Prayer.1.3.5.1301311627280.13866@hermes-1.csi.cam.ac.uk>
 <510AA04A.1010906@lexifi.com>
 <Prayer.1.3.5.1301311804550.1375@hermes-1.csi.cam.ac.uk>
 <510B70EA.1040102@lexifi.com> <510B87A4.8010502@frisch.fr>
 <Prayer.1.3.5.1302011102550.25380@hermes-1.csi.cam.ac.uk>
 <510BB021.8010105@lexifi.com>
Message-ID: <Prayer.1.3.5.1302011355120.2236@hermes-1.csi.cam.ac.uk>

>Alternatively, if we choose to make "type extension = longident * 
>expression option" as you suggest, we can also support a different syntax:
>
>  (# e)  ====>  (* empty identifier in the Parsetree *)
>
>but this sounds a little bit less natural to me.  I like the 
>minimalistic approach of having "extension = expression" in all 
>syntactic categories (including expression themselves).  But I will 
>certainly not fight the other solution.

If you don't particularly mind, I would prefer this way as I think that it 
will encourage people to name their extensions.


From gabriel.scherer at gmail.com  Fri Feb  1 15:38:59 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Fri, 1 Feb 2013 16:38:59 +0100
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <510B73C0.5090700@frisch.fr>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
Message-ID: <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>

> In which category would you put code generators based on type declaration (a
> la type-conv) also fall in this category?

I think it depends on the "phase" in which the code generation results
are needed.

You could shoehorn type-conv into structured comments by saying that
the type definitions present in foo.ml, annotated with structured
comments, result in the production of a derived foo_with.ml file
(containing the generated stuff) -- that could later be used in your
project along with foo.ml

(Note: this seems somehow related to a change Hongbo made to the
Camlp4 map/fold/filter generators in Fan, that I'm not sure I
completely understand or like, and was discussed in
http://old.nabble.com/Some-utilities-about-camlp4-td33360537.html )

However, this mode of use puts constraints on the use of the
extension: you cannot in a same file have a type-conv-using
declaration, and refer to the (morally, not yet produced) result of
the boilerplate generation. I believe most people would rather see
type-conv in the second category of "shallow embeddings", under a
syntax in the spirit of

  (@deriving Eq Hash Print)
  type foo =
    ...
  ;;

I would have liked to choose a postfix syntax, but there is in general
no end delimiter to attach to unambiguously: in (type foo = Bar of baz
(+ blah)), the annotation may attach either to the constructor
argument type expression, or to the whole phrase. The real syntax
extension in fact adds an additional optional terminal, "with". The
only "end-closed" type declarations are record declarations, and this
is only because record types are not first-class type expressions.

Thanks you for your detailed syntax examples in the other topic. I
have taken the liberty to put them on the wiki:
  https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases-using-light-annotations

Regarding concrete syntax, I would be tempted to suggest that (prefix
or postfix) annotations be attached to non-terminals (including
parenthesis). I believe there is an important difference between
"modulating this AST node" and "modulating the whole enclosed
expression" that would relevant for reasoning on the locality and
composability of syntactic extensions. I'm not sure yet what's the
best way to go (I'll try to see what Leo and you suggest).

Finally, I think -ppx + arbitrary annotations, without any further
restriction, is too free-form for robust syntax extensions: one
important problem with Camlp4 is that it allowed syntax extension
writers to modify the syntax in very bad way that hurt robustness. As
already discussed, I have a strong distaste for extensions that only
piggyback on existing syntax (without adding any explicit marker); I
would feel safer if the extension *mechanism* disallowed such
unstructured extensions, or at least made them less rewarding to write
than the composable ones. (For example by only passing to the
extension writer the part(s) of the AST that have been annotated).
Unfortunately, I don't see how Bisect would fit any such restriction.
Maybe that's a problem best solved by socialization (writing a
documentation on good practices, and yelling on people), but I sort of
doubt it -- I don't know how many time I've had to argue for *not*
globally changing the associativity of infix operators through Camlp4
in Batteries.

On Fri, Feb 1, 2013 at 8:50 AM, Alain Frisch <alain at frisch.fr> wrote:
> On 1/31/2013 10:13 PM, Gabriel Scherer wrote:
>>
>> I like Leo's idea of distinguishing three different forms of syntax
>> extensions (I'm not discussing concrete syntax):
>>
>> 1. structured comments
>> 2. shallow embeddings
>> 3. deep embeddings
>
>
> In which category would you put code generators based on type declaration (a
> la type-conv) also fall in this category?  For me, this is one of the most
> important use case of -ppx (the other being instrumentation of code, covered
> by 1 I guess).  Basically, they only require the ability to add annotations
> on type declaration and type expressions (and one needs to be able to
> include OCaml expressions in the annotations).  If/when runtime types are
> added to OCaml, they will hopefully also benefit from those annotations.
>
> I guess that 1 is excluded because those annotations are required to compile
> to program and 3 is excluded, because this has nothing to do with syntax.
> But 2 does not seem to apply either.
>
> -- Alain

From yallop at gmail.com  Sat Feb  2 16:17:14 2013
From: yallop at gmail.com (Jeremy Yallop)
Date: Sat, 2 Feb 2013 16:17:14 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
Message-ID: <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>

On 1 February 2013 15:38, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
> Finally, I think -ppx + arbitrary annotations, without any further
> restriction, is too free-form for robust syntax extensions: one
> important problem with Camlp4 is that it allowed syntax extension
> writers to modify the syntax in very bad way that hurt robustness. As
> already discussed, I have a strong distaste for extensions that only
> piggyback on existing syntax (without adding any explicit marker); I
> would feel safer if the extension *mechanism* disallowed such
> unstructured extensions, or at least made them less rewarding to write
> than the composable ones. (For example by only passing to the
> extension writer the part(s) of the AST that have been annotated).
> Unfortunately, I don't see how Bisect would fit any such restriction.
> Maybe that's a problem best solved by socialization (writing a
> documentation on good practices, and yelling on people), but I sort of
> doubt it -- I don't know how many time I've had to argue for *not*
> globally changing the associativity of infix operators through Camlp4
> in Batteries.

I agree with Gabriel.  Actually, I think that a small tweak to the
design of -ppx could address both this and a number of problems that
others have raised during the discussion here.

The -ppx approach applies one or more global transformations to the
ASTs of OCaml source files; these transformations can be parameterized
by attributes attached at particular points in the syntax tree.  This
is a significant improvement over the Camlp4 approach, largely because
it exchanges the (unnecessary) ability to change the concrete syntax
for a number of valuable guarantees, which make extensions easier to
write and code that uses extensions easier to understand.

We can go further in this direction, and give up more (unnecessary)
power in return for further guarantees.  As Gabriel says, since -ppx
extensions can arbitrarily transform the AST, it's not possible to
understand any part of a program that uses extensions without
understanding every aspect of the behaviour of every extension.  We
could, of course, seek to solve this by convention and social
pressure, but there seems to be an emerging consensus that this isn't
really satisfactory.  One of the nice things about functional
programming is that you have strong guarantees (via parametricity,
immutability, and so on) about the effects of calling a particular
function. We should strive to make it possible to reason in the same
manner about the effects of syntax extensions.

There are other legitimate concerns with the current proposal.  As
Xavier Clerc and others point out, attributes are apparently
undeclared (i.e. global) and untyped.  Alain rightly notes that it
seems to be difficult to introduce declarations and types for
attributes without significant complexity.  Still, as OCaml
programmers we're used to the benefits of precisely-scoped names and
strongly-typed data, and it seems a shame to give these benefits up if
we can find a way to keep them.

Hongbo Zhang raises a further concern: when syntax extensions are
global transformations on the whole file, the order in which
extensions are applied becomes significant.  This is a fairly serious
matter, I think: the semantics of code that uses syntax extensions is
now dependent on external factors, since we need to look for the flags
passed to OCaml in the build configuration in order to understand the
source.

I think we can address all these concerns with a small adjustment in
perspective.  Instead of globally-scoped, untyped attributes processed
by file-level externally-specified transformations, we might add a
single node to the OCaml grammar for statically-executed AST
rewriters.  Using the same syntax already proposed for attributes, we
might write, for example:

   (@deriving ["sexp"; "json"])
   type t = F of int | G of s
    and s = H of (t * t)

or

    (@perform)
       (x <-- m;
        y <-- n;
        return (x y))

In order for this to be valid code, 'deriving' and 'perform' should
resolve to functions of appropriate types:

    val deriving : string list -> Parsetree.structure_item ->
Parsetree.structure_item

    val perform : Parsetree.expression -> Parsetree.expression

Either during parsing or in a post parsing phase, the ASTs following
'@deriving ["sexp"; "json"]' and '@perform' are passed to those
functions and the results are inserted in place into the AST.
Gabriel's concern is addressed, because there's no way for @perform
(say) to access other parts of the AST: its effects are purely local.
Xavier's concern is addressed, since AST rewriters, unlike attributes
are declared and typed (and hence scoped). Hongbo's concern is
addressed, since composition is explicit:

    (@deriving ["sexp"])
    (@nonrec)
    type t = C of t

(Here '@deriving ["sexp"]' is applied to the result of applying '@nonrec'.)

It should be possible to write almost all extensions in this manner.
A variant of the stream parser syntax fits easily:

    (@parser)
       ([ `If; x = expr; `Then; y = expr; `Else; z = expr ] => "if";
        [ `Let; `Ident x; `Equal; x = expr; In; y = expr ] => "let")

as does Anil's cstruct extension:

    (@cstruct ~endianness:little)
    type pcap_header = {
       uint32_t magic_number;   (* magic number *)
       uint16_t version_major;  (* major version number *)
       ...
    }

Other extensions such as ifdef, js_of_ocaml, and pgsql could be
handled in the same sort of way.

Jeremy.

[I'm deliberately avoiding the interesting but orthogonal questions of
custom lexical syntax, and benign annotations for tools here.]

From lpw25 at cam.ac.uk  Sat Feb  2 19:25:00 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 02 Feb 2013 19:25:00 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>

>   (@deriving ["sexp"; "json"])
>   type t = F of int | G of s
>    and s = H of (t * t)
>
>or
>
>    (@perform)
>       (x <-- m;
>        y <-- n;
>        return (x y))
>
>In order for this to be valid code, 'deriving' and 'perform' should
>resolve to functions of appropriate types:
>
>    val deriving : string list -> Parsetree.structure_item ->
>Parsetree.structure_item
>
>    val perform : Parsetree.expression -> Parsetree.expression
>

I have a broader proposal that is along these lines, which is intended to 
be the second part of my earlier blog post. There are in general some 
difficulties with just calling functions during parsing, but I think the 
general idea of declared extensions is the right way to do things.

The reason I haven't mentioned this proposal yet, is that it is a more long 
term proposal. We can easily implement the changes needed to support ppx 
before the next OCaml release. Whereas full support for declared extensions 
will require more time, and probably a lot more debate before it can be 
included.

Since moving an extension from ppx to some kind of declared mechanism would 
require only minimal work, I see no harm in promoting ppx in the 
short/medium term, while also developing a more complete solution.

In particular I think that the extension/template syntaxes ( "(: lid 
expr)", "{: lid { string }}", etc.) that have been discussed so far will be 
a very good match for a declaration based mechanism. It is also another 
argument for forcing extensions to have names.

I will try to put my own proposals in that blog post early next week.

From philippe.veber at gmail.com  Sun Feb  3 09:57:36 2013
From: philippe.veber at gmail.com (Philippe Veber)
Date: Sun, 3 Feb 2013 10:57:36 +0100
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
Message-ID: <CAOOOohQStOb=DkGFzyc99KBVekLUmjSVUiPyJ6bJw+WozyQaZw@mail.gmail.com>

Hi all,

I find Jeremy's proposal very convincing : it's very clean and seems to fit
with a lot of situations. One of its main strengths is that the functions
called at ppx time are only passed the annotated expression/item (maybe
that was proposed before, but I did not see it). I think this is a major
improvement from the current ppx option, which deals with the whole parsed
tree each time, and makes extension composition a lot more difficult to
grasp. Having extensions mapped to functions (like deriving or perform) is
also a very nice way to prevent conflicting extensions.

So as a potential user, I'd buy it without hesitation, but maybe there is
some limitation I overlooked?

Another great thing I think is that it may also simplify the build process
: writing an extension is as easy as providing a cma to the compiler,
containing Parsedtree rewriter functions, which are called through the @
notation. One just has to be careful giving cma to ocamlc/ocamlopt and cmxa
to ocamlc.opt/ocamlopt.opt.

ph.

2013/2/2 Leo White <lpw25 at cam.ac.uk>

>    (@deriving ["sexp"; "json"])
>>   type t = F of int | G of s
>>    and s = H of (t * t)
>>
>> or
>>
>>    (@perform)
>>       (x <-- m;
>>        y <-- n;
>>        return (x y))
>>
>> In order for this to be valid code, 'deriving' and 'perform' should
>> resolve to functions of appropriate types:
>>
>>    val deriving : string list -> Parsetree.structure_item ->
>> Parsetree.structure_item
>>
>>    val perform : Parsetree.expression -> Parsetree.expression
>>
>>
> I have a broader proposal that is along these lines, which is intended to
> be the second part of my earlier blog post. There are in general some
> difficulties with just calling functions during parsing, but I think the
> general idea of declared extensions is the right way to do things.
>
> The reason I haven't mentioned this proposal yet, is that it is a more
> long term proposal. We can easily implement the changes needed to support
> ppx before the next OCaml release. Whereas full support for declared
> extensions will require more time, and probably a lot more debate before it
> can be included.
>
> Since moving an extension from ppx to some kind of declared mechanism
> would require only minimal work, I see no harm in promoting ppx in the
> short/medium term, while also developing a more complete solution.
>
> In particular I think that the extension/template syntaxes ( "(: lid
> expr)", "{: lid { string }}", etc.) that have been discussed so far will be
> a very good match for a declaration based mechanism. It is also another
> argument for forcing extensions to have names.
>
> I will try to put my own proposals in that blog post early next week.
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130203/a8887181/attachment.html>

From anil at recoil.org  Mon Feb  4 19:20:41 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 4 Feb 2013 19:20:41 +0000
Subject: [wg-camlp4] Fwd: [Caml-list] View patterns
References: <02b901ce0309$c555da10$50018e30$@ffconsultancy.com>
Message-ID: <F0B3CD2A-5968-43E0-868B-CB79D2008F0E@recoil.org>

Begin forwarded message:

> From: "Jon Harrop" <jon at ffconsultancy.com>
> Date: 4 February 2013 18:59:32 GMT
> To: "Caml List" <caml-list at inria.fr>
> Subject: [Caml-list] View patterns
> 
> 
> FWIW, two of the most common camlp4 parsers in the wild, stream parsers and
> bitstring, are solved in F# using view patterns. I suspect many other
> applications of camlp4 would be written in terms of view patterns. Moreover,
> it strikes me that consideration so far on things like F#-like attributes is
> an orthogonal issue so perhaps support for that and support for view
> patterns would do a much better job of displacing camlp4.
> 
> I use view patterns to write parsers in F# but I would prefer a camlp4-like
> technology to write parsers in-line.
> 
> -- 
> Dr Jon Harrop, Flying Frog Consultancy Ltd.
> http://www.ffconsultancy.com
> 
> 
> -- 
> Caml-list mailing list.  Subscription management and archives:
> https://sympa.inria.fr/sympa/arc/caml-list
> Beginner's list: http://groups.yahoo.com/group/ocaml_beginners
> Bug reports: http://caml.inria.fr/bin/caml-bugs
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130204/ebcd0db3/attachment.html>

From alain at frisch.fr  Tue Feb  5 06:53:03 2013
From: alain at frisch.fr (Alain Frisch)
Date: Tue, 05 Feb 2013 07:53:03 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
Message-ID: <5110AC4F.6010209@frisch.fr>

On 2/1/2013 4:38 PM, Gabriel Scherer wrote:
> Regarding concrete syntax, I would be tempted to suggest that (prefix
> or postfix) annotations be attached to non-terminals (including
> parenthesis). I believe there is an important difference between
> "modulating this AST node" and "modulating the whole enclosed
> expression" that would relevant for reasoning on the locality and
> composability of syntactic extensions. I'm not sure yet what's the
> best way to go (I'll try to see what Leo and you suggest).

I don't see the benefits of allowing annotations on parenthesis (and 
why, not, comments), or individual tokens (the "for" "=" "to" or "do" in 
"for i = 1 to 10 do"), only extra complexity in the definition of the 
Parsetree.

Can you give an example where putting an annotation on e.g. a 
parenthesis would be the right thing to do?


> (For example by only passing to the
> extension writer the part(s) of the AST that have been annotated).
> Unfortunately, I don't see how Bisect would fit any such restriction.
> Maybe that's a problem best solved by socialization (writing a
> documentation on good practices, and yelling on people)

I'm strongly in favor of solving that by socialization, if any problem 
actually occur, rather than restricting technically what an AST rewriter 
can do.  My arguments:

1.  I don't think there will be any problem in practice.  At least this 
discussion should be motivated by some concrete problems to be expected 
in the interaction of common extensions.  For instance, the bad 
interaction between type-conv and deriving as of today would disappear, 
and I don't see how they could be written to introduce other problems 
(and if they do and some people want to use both, this should be easy to 
fix).

2.  Jeremy's proposal more or less requires all rewriters to be in the 
same process.  This requires either Dynlink (which is not available 
under all platforms in native code;  in the past there has been a strong 
resistance to have the compiler and basic tools depend on it) or custom 
static linking (which is not very "build system" friendly).

3.  Some very legitimate uses of ppx don't work nicely with the 
constraint that they can operate only on a marked fragment.  You cite 
Bisect, but this is already the case for Sedlex, which injects some 
shared declarations at the beginning of the unit.  Yes, if two 
"extensions" do that, the order in which they will be applied will 
produce different result, but I cannot imagine a case where this would 
be problematic.  I can see a lot more situations where injecting code 
non-locally makes sense.  Just as an example, consider an extension to 
mark some methods as "memoized":

    object
      ...
      (@memoized) method foo = ....
      ...
    end


   ===>

    object
      ...
      val mutable foo_memo = None
      method foo =
         match foo_memo with
         | Some x -> x
         | None -> let r = ... in foo_memo <- Some r; r
      ...
    end

   Here we need to inject code "just above".  In other cases, one might 
want to inject code "at the beginning" or "at the end"  (of the whole 
unit, of the current structure, etc), or at a completely different place 
(example: macro expansion).


4. Having "registered" expanders called when they are identified by a 
specific marker during a top-down traversal hard-codes a top-down 
rewriting strategy.  There are cases where this is not optimal. 
Consider for instance the interaction between a macro system (or 
conditional compilation) and other extensions.  I can easily imagine 
cases where one really wants macros to be expanded before other 
extensions operate on the AST (e.g. because the result of macro 
expansion generate extension markers / attributes).  Sedlex could for 
instance benefit from a macro system on patterns (in order to replace 
it's hard-coded notion of declared regexps).  One should at least allow 
each expander to apply explicitly the "complete rewriting" on a sub-tree 
and inspect the result (allowing bottom-up rewriting on demand).  But 
then we loose all nice reasoning properties.

5. It is always possible to add a marker at the top of the compilation 
unit and do all the rewriting there, so bad things are still possible.

6. Order in which ppx rewriters are applied matters, but I don't believe 
it is difficult to reason on the resulting composition, nor to devise a 
"good" order for most cases.  At least, the behavior of the composition 
only depends on the behavior of each rewriter (which can be observed 
with the -dsource compiler option).  Users don't have to understand how 
an extension is implemented, but only what it does (in terms of AST 
rewriting), in order to understand how it will compose with other 
extensions.  I'm not sure that reasoning on nested rewriting, especially 
if expanders are allowed to call other expanders on sub-terms and 
post-process the result, will be any simpler.  In practice, I suspect 
that simple priority rules between ppx rewriting would be enough to 
eliminate most problems (e.g. run first all "macro expanders / 
conditional compilation", most of the other extensions would interact 
nicely in whichever order they are applied).

7.  A nice property of "ppx" is that it is not a "system", which reduces 
the risks of over engineering and design mistakes, and simplifies the 
learning curve.  I suggest to keep to extra layers / libraries the role 
of providing higher level APIs with a more restricted semantics but 
stronger invariants.  Nothing prevent people from proposing such systems 
on top of the current -ppx flag and syntactic extensions being 
discussed, but those extensions should not be tightly coupled with these 
systems.



Alain

From alain.frisch at lexifi.com  Tue Feb  5 09:28:28 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Feb 2013 10:28:28 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <5110AC4F.6010209@frisch.fr>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <5110AC4F.6010209@frisch.fr>
Message-ID: <5110D0BC.2040102@lexifi.com>

On 02/05/2013 07:53 AM, Alain Frisch wrote:
> 3.  Some very legitimate uses of ppx don't work nicely with the
> constraint that they can operate only on a marked fragment.

I've given examples where the expander needs to inject code 
"non-locally", but there are also cases where:

  1) one simply wants the expander to have access to its "context" (the 
rest of the unit);

  2) several occurrences of the "expansion marker" need to share some state.

This does not combine well with the idea that each expansion marker is 
treated "locally"


Alain

From yminsky at janestreet.com  Tue Feb  5 12:43:10 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 5 Feb 2013 07:43:10 -0500
Subject: [wg-camlp4] Time for a summary?
Message-ID: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>

There have been so many detailed and thoughtful emails that it's hard
to keep up with the deluge.  I would humbly submit that this would be
a good time for one of the organizers (Leo or Alain) to put together a
summary of the different positions that have been expressed about how
ppx might work, so that one could read over and think through those.
Right now, I have a hard time keeping the current state of the
conversation in my head, and I'm pretty sure I'm not alone.

y

From daniel.buenzli at erratique.ch  Tue Feb  5 12:55:12 2013
From: daniel.buenzli at erratique.ch (=?utf-8?Q?Daniel_B=C3=BCnzli?=)
Date: Tue, 5 Feb 2013 13:55:12 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
Message-ID: <A78CB84641DA4DB992B3E8DBBFBA410F@erratique.ch>

Le mardi, 5 f?vrier 2013 ? 13:43, Yaron Minsky a ?crit :
> Right now, I have a hard time keeping the current state of the
> conversation in my head, and I'm pretty sure I'm not alone.

I was also quickly lost. For me the message from Jeremy Yallop provided a good summary of the situation (along with a proposal that seems much cleaner to me).

Best,

Daniel

From gabriel.scherer at gmail.com  Tue Feb  5 13:05:09 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 5 Feb 2013 14:05:09 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
Message-ID: <CAPFanBH25hXwDdjnSGTFxmy1OCXdB09GNKnEojfpxmD0b0ByQg@mail.gmail.com>

There have been very good inputs by Alain, Leo, Hongbo and Jeremy.
I've considered doing a summary as you request (after all, I have a
blog to feed), but Leo promises that he has some more ideas that he
would expose "early this week", so I've mostly been waiting for that.

My opinionated one-paragraph (in fact one-list) take-away would be:
- nobody apparently objects to Alain's idea of using lightweight
quotations and annotations to mimic most existing extensions, and him
and Leo have been busy discussing concrete syntax for that (see
Alain's examples here :
https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases-using-light-annotations
)
- there is an ongoing discussion on the robustness of global rewrites
and possible restrictions (Alain promotes the immediately available,
low-tech social approach, Jeremy has a nice technical suggestion, Leo
is going to write something, and a compromise *is* probably possible
along the lines of encapsulating common local use cases as a strongly
suggested library (like type-conv did for type-derived boilerplate))
- Hongbo has been asking for a discussion on the AST definition at the
core of syntax manipulations, but so far nobody had the courage to
look in details into the polymorphic variant solution of Fan
- relatedly, there is no consensus on the neededness and
implementation of antiquotations; so far we're heading towards a
solution where they are not well supported

Hope that helped.

On Tue, Feb 5, 2013 at 1:43 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> There have been so many detailed and thoughtful emails that it's hard
> to keep up with the deluge.  I would humbly submit that this would be
> a good time for one of the organizers (Leo or Alain) to put together a
> summary of the different positions that have been expressed about how
> ppx might work, so that one could read over and think through those.
> Right now, I have a hard time keeping the current state of the
> conversation in my head, and I'm pretty sure I'm not alone.
>
> y
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From lpw25 at cam.ac.uk  Tue Feb  5 13:50:54 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Feb 2013 13:50:54 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
Message-ID: <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>

>I will try to put my own proposals in that blog post early next week.

That blog post is now up:

http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html

Please respond to it on this list rather than in its comment box.

From hongboz at seas.upenn.edu  Tue Feb  5 14:15:34 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 5 Feb 2013 09:15:34 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CAPFanBH25hXwDdjnSGTFxmy1OCXdB09GNKnEojfpxmD0b0ByQg@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <CAPFanBH25hXwDdjnSGTFxmy1OCXdB09GNKnEojfpxmD0b0ByQg@mail.gmail.com>
Message-ID: <CANcqPu5GmqPr+Me4a5b=fOMY1JDND3Nhh=EGRb-mauaRpbOwCw@mail.gmail.com>

A cursory look at this proposal seems to me that it's beautiful. But I
guess it is not easy to give a robust implementation

On Tue, Feb 5, 2013 at 8:05 AM, Gabriel Scherer
<gabriel.scherer at gmail.com>wrote:

> There have been very good inputs by Alain, Leo, Hongbo and Jeremy.
> I've considered doing a summary as you request (after all, I have a
> blog to feed), but Leo promises that he has some more ideas that he
> would expose "early this week", so I've mostly been waiting for that.
>
> My opinionated one-paragraph (in fact one-list) take-away would be:
> - nobody apparently objects to Alain's idea of using lightweight
> quotations and annotations to mimic most existing extensions, and him
> and Leo have been busy discussing concrete syntax for that (see
> Alain's examples here :
>
> https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases-using-light-annotations
> )
> - there is an ongoing discussion on the robustness of global rewrites
> and possible restrictions (Alain promotes the immediately available,
> low-tech social approach, Jeremy has a nice technical suggestion, Leo
> is going to write something, and a compromise *is* probably possible
> along the lines of encapsulating common local use cases as a strongly
> suggested library (like type-conv did for type-derived boilerplate))
> - Hongbo has been asking for a discussion on the AST definition at the
> core of syntax manipulations, but so far nobody had the courage to
> look in details into the polymorphic variant solution of Fan
> - relatedly, there is no consensus on the neededness and
> implementation of antiquotations; so far we're heading towards a
> solution where they are not well supported
>
> Hope that helped.
>
> On Tue, Feb 5, 2013 at 1:43 PM, Yaron Minsky <yminsky at janestreet.com>
> wrote:
> > There have been so many detailed and thoughtful emails that it's hard
> > to keep up with the deluge.  I would humbly submit that this would be
> > a good time for one of the organizers (Leo or Alain) to put together a
> > summary of the different positions that have been expressed about how
> > ppx might work, so that one could read over and think through those.
> > Right now, I have a hard time keeping the current state of the
> > conversation in my head, and I'm pretty sure I'm not alone.
> >
> > y
> > _______________________________________________
> > wg-camlp4 mailing list
> > wg-camlp4 at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/wg-camlp4
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130205/314459e6/attachment.html>

From hongboz at seas.upenn.edu  Tue Feb  5 14:19:28 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 5 Feb 2013 09:19:28 -0500
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>

We have the same ideas. ;-)
proposals 1, 2, 3, 4 are implemented in Fan as well.

For Proposal 4, we introduced overloaded quotations,
{:Ast.expr| 1 + $x |} can expand to ast with or without locations. Ast with
locations introduce a lot of unnecessary complexity when people are just
doing code generation

Proposal 3 is applied in camlp4 itself(see the quotation module)
On Tue, Feb 5, 2013 at 8:50 AM, Leo White <lpw25 at cam.ac.uk> wrote:

> I will try to put my own proposals in that blog post early next week.
>>
>
> That blog post is now up:
>
> http://www.lpw25.net/2013/02/**05/camlp4-alternative-part-2.**html<http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html>
>
> Please respond to it on this list rather than in its comment box.
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130205/2a4562c7/attachment-0001.html>

From gabriel.scherer at gmail.com  Tue Feb  5 14:51:07 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Tue, 5 Feb 2013 15:51:07 +0100
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
Message-ID: <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>

I don't really like Leo's proposal.

On the semantic side, I very much like Jeremy's idea, even if it still
has shortcomings pointed out by Alain, and partially addressed by Leo,
such as the need to get contextual information when applying a syntax
extension. I'm interested in seeing if we can go further in that
direction.

On the practical side, adding a notion of staged compilation and
namespaces to handle syntax extensions seems really overkill. I
believe I was in the same room as Alain and Leo when namespaces where
last discussed, and my personal impression was really not that they
were "likely to be included in the language in the near future" (I
would actually be surprised to see them before a monadic notation!);
there is little agreement on that.

Alain's ppx mechanism has the property of doing away with the idea
that syntax extensions have to be linked together, and I believe he is
right in pointing that out as a practical advantage. Even the previous
camlp4 mechanism had a stronger separation between syntax-time and
compile-time than in Leo's proposal, as the linking happened against
an *external* executable (which allowed other fairly independent
preprocessors to reuse the -pp option without being camlp4-related).
My gut feeling is that less coupling, rather than more, is the right
way to go -- which is not contradictory with an approach favoring
locality such as Jeremy and Leo's proposal of representing macros as
functions. I'm ready to discuss the advantages of such integration,
but I find it unlikely that their are worth tying syntax extensions to
such semantic behemoths as staged compilation and namespaces.

A reasonable compromise I would see between the point of view of Alain
and Jeremy/Leo is to have an "unsafe" interface for global
preprocessing, which we would discourage people from using by being
very good at breaking backward compatibility (we can do better than
Camlp4!), and *maintaining* at the same time one or several safer
entry point that provide the local structure and conventional syntax
that we think will bring more robustness to syntax extensions (like
type-conv can currently be seen as a protective hub around type-driven
boilerplate generation). I would have several questions:
- can Fan make use of the same unsafe interface as everyone else? I've
been impressed by some of the work done by Hongbo so far
(reimplementing the parsing stack on top of dypgen is no small feat),
and I wouldn't want this brand of work to be alienated from the
"practical" syntax extensibility people.
- what safe interface could we provide (I imagine something based on
Jeremy's proposal (plus good concrete syntax choices) with a notion of
context as in Leo's proposal; Leo, I'm a bit unclear on what kind of
GADT you're thinking of, could you elaborate? If it's as good a use of
GADTs as Alain's runtime type representations, I'm all ears.
- how should extensions built upon the safe interface be composed?
Must we link extension functions together, or use program/process
boundaries as in the wider -ppx framework? What are the
advantage/costs of either choices?
- Leo suggests using an in-language feature (namespaces) to handle
addressing of syntax extensions; what is the picture of
outside-language tools to do this? I've had reasonable luck using
'ocamlfind' as a backbone for plugin discovery in Stog. Is this what
Alain imagine users will use? Is it portable to Windows-land?

On Tue, Feb 5, 2013 at 3:19 PM, Hongbo Zhang <hongboz at seas.upenn.edu> wrote:
>
> We have the same ideas. ;-)
> proposals 1, 2, 3, 4 are implemented in Fan as well.
>
> For Proposal 4, we introduced overloaded quotations,
> {:Ast.expr| 1 + $x |} can expand to ast with or without locations. Ast with
> locations introduce a lot of unnecessary complexity when people are just
> doing code generation
>
> Proposal 3 is applied in camlp4 itself(see the quotation module)
>
> On Tue, Feb 5, 2013 at 8:50 AM, Leo White <lpw25 at cam.ac.uk> wrote:
>>>
>>> I will try to put my own proposals in that blog post early next week.
>>
>>
>> That blog post is now up:
>>
>> http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html
>>
>> Please respond to it on this list rather than in its comment box.
>>
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>
>
>
>
> --
> -- Regards, Hongbo
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>

From mark at three-tuns.net  Tue Feb  5 15:06:03 2013
From: mark at three-tuns.net (Mark Shinwell)
Date: Tue, 5 Feb 2013 15:06:03 +0000
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
Message-ID: <20130205150603.GV13082@three-tuns.net>

On Tue, Feb 05, 2013 at 07:43:10AM -0500, Yaron Minsky wrote:
> There have been so many detailed and thoughtful emails that it's hard
> to keep up with the deluge.  I would humbly submit that this would be
> a good time for one of the organizers (Leo or Alain) to put together a
> summary of the different positions that have been expressed about how
> ppx might work, so that one could read over and think through those.
> Right now, I have a hard time keeping the current state of the
> conversation in my head, and I'm pretty sure I'm not alone.

You are not alone.  I also think a summary would be very useful.

Mark

From sebastien.mondet at gmail.com  Tue Feb  5 15:29:11 2013
From: sebastien.mondet at gmail.com (Sebastien Mondet)
Date: Tue, 5 Feb 2013 10:29:11 -0500
Subject: [wg-camlp4] Runtime types and no -pp(x)
Message-ID: <CALScVY=R-hVdJ91WX4irx5ZTB+QLhBnMV9m=qhHjh6aQ-Te8Fw@mail.gmail.com>

Hi

Yet Another Proposal ?  :)

Here, at NYU-Bio we use camlp4 in two ways:

1. All the code is JaneSt-Core-styled and uses sexplib.syntax and
bin_prot.syntax

We also use an ('a, 'b) Result.t Lwt.t  monad everywhere but there is no
need for camlp4, monadic programming is perfectly fine with normal OCaml
syntax.

2. The web-app is fully Eliom-based: it uses the eliom{dep,c,opt}
tool-chain, so it is incompatible with sexplib.syntax (because it imposes
deriving) and takes ages to compile.
(if I had to start again the project, I think I would not use the syntax
part of ocsigen or at least limit it to one single file).


I think I have already lost too many hours of my life fixing camlp4-related
problems just for using type_conv, so:


The proposal:

Get something like dyntype [1] or what Pierre Chambart and Gr?goire Henry
presented at OUD [2], into the main compiler.

type_conv and deriving will become obsolete.

Then, most people can get rid of any kind of syntactic preprocessing for
95% of their problems.

For the remaining 5%, they can use camlp4, camlp5, Fan, or write their own
code generator without imposing it to anyone else.



Cheers
Seb



[1] https://github.com/mirage/dyntype
[2] http://oud.ocaml.org/2012/#program
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130205/9383d591/attachment.html>

From alain.frisch at lexifi.com  Tue Feb  5 15:34:33 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Feb 2013 16:34:33 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
Message-ID: <51112689.5010606@lexifi.com>

Hi Gabriel,

On 02/05/2013 03:51 PM, Gabriel Scherer wrote:
> A reasonable compromise I would see between the point of view of Alain
> and Jeremy/Leo is to have an "unsafe" interface for global
> preprocessing, which we would discourage people from using by being
> very good at breaking backward compatibility (we can do better than
> Camlp4!), and *maintaining* at the same time one or several safer
> entry point that provide the local structure and conventional syntax
> that we think will bring more robustness to syntax extensions (like
> type-conv can currently be seen as a protective hub around type-driven
> boilerplate generation)

Why not, but I'm still not convinced that the "unsafe" interface will 
create actual interaction problems between extensions, which cannot be 
solved by a proper ordering between -ppx rewriters.

Can we try to come up with some realistic example of potential problems 
before considering solutions to address those problems?

> - Leo suggests using an in-language feature (namespaces) to handle
> addressing of syntax extensions; what is the picture of
> outside-language tools to do this? I've had reasonable luck using
> 'ocamlfind' as a backbone for plugin discovery in Stog. Is this what
> Alain imagine users will use? Is it portable to Windows-land?

As long as ppx rewriters are specified purely on the command-line, 
ocamlfind do the lookup quite easily:

ocamlfind ocamlc -c -package sedlex -ppx "ocamlfind sedlex/sedlex.exe" 
my_file.ml

(this already works)

I don't see any Windows-specific problem here (but I've not tried to use 
ocamlfind under Windows for a long time).

A more ambitious proposal is to let rewriters be specified in the source 
code.  Gerd has described a way to combine this with ocamlfind without 
forcing a dependency on ocamlfind.  I'm still undecided on whether it is 
good or not to specify rewriters in the source code.

Alain

From hongboz at seas.upenn.edu  Tue Feb  5 15:39:30 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 5 Feb 2013 10:39:30 -0500
Subject: [wg-camlp4] Runtime types and no -pp(x)
In-Reply-To: <CALScVY=R-hVdJ91WX4irx5ZTB+QLhBnMV9m=qhHjh6aQ-Te8Fw@mail.gmail.com>
References: <CALScVY=R-hVdJ91WX4irx5ZTB+QLhBnMV9m=qhHjh6aQ-Te8Fw@mail.gmail.com>
Message-ID: <CANcqPu7dT5Av2R=JxvH1-whmAAA9PGL3bwFcxL-BRGJbkVx8dQ@mail.gmail.com>

Hi Sebastien,
   I agree with you that adding run-time types. To clarify a bit, Fan is
not invasive as Camlp* or ppx(the current ppx proposal seems to be quite
large change to the compiler), it does not need any change to the compiler,
so it does not impose you to use it.
For the deriving and type_conv syntax extension conflict, this is not the
Fault of Camlp*, you can avoid
it while still using Camlp*, the solution is adopted by Fan
{:ocaml|
type u = A of int
|}
{:derive| whatever you like|}
On Tue, Feb 5, 2013 at 10:29 AM, Sebastien Mondet <
sebastien.mondet at gmail.com> wrote:

>
> Hi
>
> Yet Another Proposal ?  :)
>
> Here, at NYU-Bio we use camlp4 in two ways:
>
> 1. All the code is JaneSt-Core-styled and uses sexplib.syntax and
> bin_prot.syntax
>
> We also use an ('a, 'b) Result.t Lwt.t  monad everywhere but there is no
> need for camlp4, monadic programming is perfectly fine with normal OCaml
> syntax.
>
> 2. The web-app is fully Eliom-based: it uses the eliom{dep,c,opt}
> tool-chain, so it is incompatible with sexplib.syntax (because it imposes
> deriving) and takes ages to compile.
> (if I had to start again the project, I think I would not use the syntax
> part of ocsigen or at least limit it to one single file).
>
>
> I think I have already lost too many hours of my life fixing
> camlp4-related problems just for using type_conv, so:
>
>
> The proposal:
>
> Get something like dyntype [1] or what Pierre Chambart and Gr?goire Henry
> presented at OUD [2], into the main compiler.
>
> type_conv and deriving will become obsolete.
>
> Then, most people can get rid of any kind of syntactic preprocessing for
> 95% of their problems.
>
> For the remaining 5%, they can use camlp4, camlp5, Fan, or write their own
> code generator without imposing it to anyone else.
>
>
>
> Cheers
> Seb
>
>
>
> [1] https://github.com/mirage/dyntype
> [2] http://oud.ocaml.org/2012/#program
>
>
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130205/f31510c7/attachment-0001.html>

From markus.mottl at gmail.com  Tue Feb  5 15:46:58 2013
From: markus.mottl at gmail.com (Markus Mottl)
Date: Tue, 5 Feb 2013 10:46:58 -0500
Subject: [wg-camlp4] Runtime types and no -pp(x)
In-Reply-To: <CALScVY=R-hVdJ91WX4irx5ZTB+QLhBnMV9m=qhHjh6aQ-Te8Fw@mail.gmail.com>
References: <CALScVY=R-hVdJ91WX4irx5ZTB+QLhBnMV9m=qhHjh6aQ-Te8Fw@mail.gmail.com>
Message-ID: <CAP_800q=uM0pT9_vOqXUYb13tANW91sZvekz_a3hW4zkUcDz+g@mail.gmail.com>

On Tue, Feb 5, 2013 at 10:29 AM, Sebastien Mondet
<sebastien.mondet at gmail.com> wrote:
> The proposal:
>
> Get something like dyntype [1] or what Pierre Chambart and Gr?goire Henry
> presented at OUD [2], into the main compiler.
>
> type_conv and deriving will become obsolete.

I'd be happy to see cleaner and simpler solutions than ones based on
camlp4.  The latter is powerful, but quite a beast.  I'd also love to
see support for runtime type representations in the compiler.  But I
don't think the latter will fill everybody's needs, especially when it
comes to performance.  E.g. knowing the number of constructors in a
type gives great opportunities for optimizing protocols and the code
used to handle them.  This cannot be easily done without prohibitively
high costs at runtime.  Unless, maybe, we also manage to get runtime
code generation into the compiler in the spirit of MetaOCaml, but
that's a whole different story.

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com

From lpw25 at cam.ac.uk  Tue Feb  5 15:57:30 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Feb 2013 15:57:30 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>

>I don't really like Leo's proposal.
>
>On the semantic side, I very much like Jeremy's idea

There is no fundamental difference between the two ideas. There are 
problems with trying to use functions within modules as extensions. My 
proposal is simply that we can get around this by attaching the functions 
to namespaces.

>On the practical side, adding a notion of staged compilation

I'm not suggesting any notion of staged compilation. The whole point of 
separating functions for extensions from modules is to avoid this issue.

>namespaces to handle syntax extensions seems really overkill.

Namespaces are going to be included anyway, there is no harm in using them 
to help make syntax extensions easier.
 
>A reasonable compromise I would see between the point of view of Alain
>and Jeremy/Leo is to have an "unsafe" interface for global
>preprocessing, which we would discourage people from using by being
>very good at breaking backward compatibility (we can do better than
>Camlp4!), and *maintaining* at the same time one or several safer
>entry point that provide the local structure and conventional syntax
>that we think will bring more robustness to syntax extensions (like
>type-conv can currently be seen as a protective hub around type-driven
>boilerplate generation). 

I agree. My proposal is not instead of ppx. It is a safer and easier-to-use 
alternative for a large subset of the extensions ppx can support. It is a 
more long-term option, for the short/medium-term we should use ppx.

>Leo, I'm a bit unclear on what kind of
>GADT you're thinking of, could you elaborate? 

Nothing fancy, just something like:

  type 'a ctx = 
    ExprQuot: string -> Ast.expr ctx
    PattQuot: string -> Ast.patt ctx
    ...
    ExprAst: Ast.expr -> Ast.expr ctx
    PattAst: Ast.expr -> Ast.patt ctx
    ...

>Must we link extension functions together

I'm not sure I understand what you mean by this. Could you expand?


From lpw25 at cam.ac.uk  Tue Feb  5 16:01:18 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Feb 2013 16:01:18 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302051601180.13899@hermes-1.csi.cam.ac.uk>

On Feb 5 2013, Hongbo Zhang wrote:

>We have the same ideas. ;-)
>proposals 1, 2, 3, 4 are implemented in Fan as well.

Well it is supposed to provide a subset of camlp4. However, my proposal 
uses the compiler's own parser.

>Proposal 3 is applied in camlp4 itself(see the quotation module)

It is similar but not the same. Camlp4 requires you to register a different 
function for each different quotation context.


From hongboz at seas.upenn.edu  Tue Feb  5 16:05:53 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 5 Feb 2013 11:05:53 -0500
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302051601180.13899@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <Prayer.1.3.5.1302051601180.13899@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu4jskxTA02Rj=d1JkSgGR-nSERa3n_0+gS+u7+iFxmodw@mail.gmail.com>

On Tue, Feb 5, 2013 at 11:01 AM, Leo White <lpw25 at cam.ac.uk> wrote:

> On Feb 5 2013, Hongbo Zhang wrote:\
> It is similar but not the same. Camlp4 requires you to register a
> different function for each different quotation context.
>
It's necessary, the semantics are different in  different syntax categories



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130205/6f9d8e4c/attachment.html>

From alain.frisch at lexifi.com  Tue Feb  5 16:17:15 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Feb 2013 17:17:15 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
 <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
Message-ID: <5111308B.3080903@lexifi.com>

On 02/05/2013 04:57 PM, Leo White wrote:
> There is no fundamental difference between the two ideas. There are
> problems with trying to use functions within modules as extensions. My
> proposal is simply that we can get around this by attaching the
> functions to namespaces.

I don't see why this notion of quotation expander is linked to 
namespaces.  The problem is not that the code for expanders is attached 
to module, but simply that it this code needs to run during compilation, 
and must thus have been compiled in an early stage of the build process 
(and then linked statically/dynamically in the compiler or pre-processor 
driver).  I don't think we need namespaces nor a new file extension to 
do that.  Quotations expander are just regular OCaml code, with the full 
expressive power of the language, and as any OCaml code to be compiled, 
they need to be part of some module.  I don't see any problem here.

> I'm not suggesting any notion of staged compilation. The whole point of
> separating functions for extensions from modules is to avoid this issue.

The OCaml code in .mlq files need to be compiled before any unit which 
uses this expander, and it will be run somehow during the compilation of 
that unit.  "User-land" code executed during compilation of another 
piece of code look like staged compilation.



Alain

From lpw25 at cam.ac.uk  Tue Feb  5 16:35:42 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Feb 2013 16:35:42 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <5111308B.3080903@lexifi.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
 <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
 <5111308B.3080903@lexifi.com>
Message-ID: <Prayer.1.3.5.1302051635420.23883@hermes-1.csi.cam.ac.uk>

>I don't see why this notion of quotation expander is linked to 
>namespaces.  The problem is not that the code for expanders is attached 
>to module, but simply that it this code needs to run during compilation, 
>and must thus have been compiled in an early stage of the build process 
>(and then linked statically/dynamically in the compiler or pre-processor 
>driver).  I don't think we need namespaces nor a new file extension to 
>do that.  Quotations expander are just regular OCaml code, with the full 
>expressive power of the language, and as any OCaml code to be compiled, 
>they need to be part of some module.  I don't see any problem here.

As I have tried to explain in the post, the problem is with combining code 
to be run at compile-time with code to be run at run-time. Trying to simply 
look in your current environment for an extension, as in Jeremy's proposal, 
means having just such a combination.

If the extension is part of a module then using it requires you to 
initialise that whole module at compile-time. This includes initialising 
(and so potentially executing) code in the module that is intended for 
run-time.

To prevent this from happening we can simply not allow extensions to be 
part of modules. However, we then have no means of referring to that 
extension. So in order to refer to these extensions we allow them to be 
members of namespaces.

>The OCaml code in .mlq files need to be compiled before any unit which 
>uses this expander, and it will be run somehow during the compilation of 
>that unit.  "User-land" code executed during compilation of another 
>piece of code look like staged compilation.

Only in the same way that a ppx extension is staged compilation.

By staged compilation I had assumed Gabriel had meant explicit in-language 
specification of what code is for compile-time and what code is for 
run-time. Similar to how a macro system based on MetaOCaml might look.

By not allowing extensions to be part of modules we avoid this issue, since 
only modules can be linked together to create a program.


From alain.frisch at lexifi.com  Tue Feb  5 16:43:09 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Feb 2013 17:43:09 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302051635420.23883@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
 <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
 <5111308B.3080903@lexifi.com>
 <Prayer.1.3.5.1302051635420.23883@hermes-1.csi.cam.ac.uk>
Message-ID: <5111369D.5050704@lexifi.com>

On 02/05/2013 05:35 PM, Leo White wrote:
> If the extension is part of a module then using it requires you to
> initialise that whole module at compile-time. This includes initialising
> (and so potentially executing) code in the module that is intended for
> run-time.
>
> To prevent this from happening we can simply not allow extensions to be
> part of modules. However, we then have no means of referring to that
> extension. So in order to refer to these extensions we allow them to be
> members of namespaces.

I don't follow.  The problem, as I see it, is not that code for the 
extension is in *some* module, but that it is in the *same* module as 
the unit on which it needs to apply.

Can you clarify how you see compilation/execution being organized in 
your proposal?  Would the code for .mlq would be compiled manually 
before its expanders can be used, or would this compilation happen 
automatically?  Which technology would then be used to run this code 
(Dynlink, static linking, toplevel-like technology for in-process 
compilation/execution)?

Alain

From lpw25 at cam.ac.uk  Tue Feb  5 17:22:55 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Feb 2013 17:22:55 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <5111369D.5050704@lexifi.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
 <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
 <5111308B.3080903@lexifi.com>
 <Prayer.1.3.5.1302051635420.23883@hermes-1.csi.cam.ac.uk>
 <5111369D.5050704@lexifi.com>
Message-ID: <Prayer.1.3.5.1302051722550.14752@hermes-1.csi.cam.ac.uk>

On Feb 5 2013, Alain Frisch wrote:

>On 02/05/2013 05:35 PM, Leo White wrote:
>> If the extension is part of a module then using it requires you to
>> initialise that whole module at compile-time. This includes initialising
>> (and so potentially executing) code in the module that is intended for
>> run-time.
>>
>> To prevent this from happening we can simply not allow extensions to be
>> part of modules. However, we then have no means of referring to that
>> extension. So in order to refer to these extensions we allow them to be
>> members of namespaces.
>
>I don't follow.  The problem, as I see it, is not that code for the 
>extension is in *some* module, but that it is in the *same* module as 
>the unit on which it needs to apply.

While obviously using an extension from the same module is a problem, it is 
not the problem I am talking about.

The problem is that the quotation is in a module that is part of the 
program. This module will be initialised at both compile-time and run-time. 
Any effects of initialising the module will occur both times. Since an 
OCaml program's run-time behaviour is basically defined as the effects of 
initialising its modules this will cause confusion and bugs.

By separating the extensions from modules we prevent this almost certainly 
undesired behaviour because only modules can be linked into a program.

One of the strong points of the camlp4/ppx model of creating preprocessors 
for implementing extensions is that it is very clear what is executed at 
compile-time and what is executed at run-time. The ".mlq" files provide 
similar clarity to extensions implemented within the language itself.

>Would the code for .mlq would be compiled manually 
>before its expanders can be used, or would this compilation happen 
>automatically?  

They would need to be compiled, just like ".mli" files.

> Which technology would then be used to run this code 
>(Dynlink, static linking, toplevel-like technology for in-process 
>compilation/execution)?

Probably the same technology as the top-level.


From alain.frisch at lexifi.com  Tue Feb  5 17:39:44 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Tue, 05 Feb 2013 18:39:44 +0100
Subject: [wg-camlp4] Structured comments,
 shallow embeddings and deep quasiquotations
In-Reply-To: <Prayer.1.3.5.1302051722550.14752@hermes-1.csi.cam.ac.uk>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
 <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
 <5111308B.3080903@lexifi.com>
 <Prayer.1.3.5.1302051635420.23883@hermes-1.csi.cam.ac.uk>
 <5111369D.5050704@lexifi.com>
 <Prayer.1.3.5.1302051722550.14752@hermes-1.csi.cam.ac.uk>
Message-ID: <511143E0.7070400@lexifi.com>

On 02/05/2013 06:22 PM, Leo White wrote:
> The problem is that the quotation is in a module that is part of the
> program. This module will be initialised at both compile-time and
> run-time. Any effects of initialising the module will occur both times.
> Since an OCaml program's run-time behaviour is basically defined as the
> effects of initialising its modules this will cause confusion and bugs.

As I see it, the problem is not that the code for the extension is in a 
module, but that it is in a module which will be linked with your target 
program.  You propose to avoid any such potential confusion by 
segregating those modules which contain extension code from other 
"regular modules".  Conceptually, this is not very different than 
choosing a module prefix (e.g. "pb_", the successor of "pa_") and simply 
ensuring in the compiler that they refuse to link pb_* modules into 
programs; those module can only be loaded (dynamically?) in a specific 
context (a particular "ppx" driver). It's just that you declare that 
these pb_* units are not real modules (and introduce a specific file 
extension instead of a prefix).

But fundamentally, I still don't agree that there is a clear separation 
between "extension code" and "program code".  In particular, an 
extension might very well use a third-party library (e.g. an XML parser) 
or share some code with the target program.  Why should we enforce a 
strong separation, in particular if this implies some ad hoc rules in 
the compilers?


> >> Would the code for .mlq would be compiled manually before its
>> expanders can be used, or would this compilation happen automatically?
>
> They would need to be compiled, just like ".mli" files.

They contain code, so I guess you meant: just like ".ml" files?

>> Which technology would then be used to run this code (Dynlink, static
>> linking, toplevel-like technology for in-process compilation/execution)?
>
> Probably the same technology as the top-level.

This seems to contradict the "need to be compiled" above.


Alain


From lpw25 at cam.ac.uk  Tue Feb  5 18:30:48 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 05 Feb 2013 18:30:48 +0000
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <511143E0.7070400@lexifi.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
 <Prayer.1.3.5.1302021925001.337@hermes-1.csi.cam.ac.uk>
 <Prayer.1.3.5.1302051350540.19661@hermes-1.csi.cam.ac.uk>
 <CANcqPu4Kh8K=4dS=nS1MoATr+iXB5v56XOrb1kWre34GvzUKbg@mail.gmail.com>
 <CAPFanBG=LHDGQ=DV3nahSpL0+tOLkuOwGPivFXFDPPrLOFOTyA@mail.gmail.com>
 <Prayer.1.3.5.1302051557300.13899@hermes-1.csi.cam.ac.uk>
 <5111308B.3080903@lexifi.com>
 <Prayer.1.3.5.1302051635420.23883@hermes-1.csi.cam.ac.uk>
 <5111369D.5050704@lexifi.com>
 <Prayer.1.3.5.1302051722550.14752@hermes-1.csi.cam.ac.uk>
 <511143E0.7070400@lexifi.com>
Message-ID: <Prayer.1.3.5.1302051830480.21589@hermes-1.csi.cam.ac.uk>

On Feb 5 2013, Alain Frisch wrote:

>On 02/05/2013 06:22 PM, Leo White wrote:
>> The problem is that the quotation is in a module that is part of the
>> program. This module will be initialised at both compile-time and
>> run-time. Any effects of initialising the module will occur both times.
>> Since an OCaml program's run-time behaviour is basically defined as the
>> effects of initialising its modules this will cause confusion and bugs.
>
>As I see it, the problem is not that the code for the extension is in a 
>module, but that it is in a module which will be linked with your target 
>program.  You propose to avoid any such potential confusion by 
>segregating those modules which contain extension code from other 
>"regular modules".  Conceptually, this is not very different than 
>choosing a module prefix (e.g. "pb_", the successor of "pa_") and simply 
>ensuring in the compiler that they refuse to link pb_* modules into 
>programs; those module can only be loaded (dynamically?) in a specific 
>context (a particular "ppx" driver). It's just that you declare that 
>these pb_* units are not real modules (and introduce a specific file 
>extension instead of a prefix).

That's about right.

>But fundamentally, I still don't agree that there is a clear separation 
>between "extension code" and "program code".  In particular, an 
>extension might very well use a third-party library (e.g. an XML parser) 
>or share some code with the target program. 

Yes, it is not a hard separation between the two.

Why should we enforce a 
>strong separation, in particular if this implies some ad hoc rules in 
>the compilers?

My proposal was for a system that made extensions simple for non-experts. I 
think that it is easier to explain that extensions are like 
mini-preprocessors that live in ".mlq" files, than to explain that they are 
normal functions, but you can't use them in the same module, and you 
shouldn't include them in a module intended for run-time execution, and the 
side-effects of running the function will not be preserved etc.

Note that Haskell does not have the last two conditions because it manages 
all side-effects.

>> >> Would the code for .mlq would be compiled manually before its
>>> expanders can be used, or would this compilation happen automatically?
>>
>> They would need to be compiled, just like ".mli" files.
>
>They contain code, so I guess you meant: just like ".ml" files?

I meant that they were like ".mli" files in that they must be compiled 
before a module that refers to them can be compiled.

>>> Which technology would then be used to run this code (Dynlink, static
>>> linking, toplevel-like technology for in-process compilation/execution)?
>>
>> Probably the same technology as the top-level.
>
>This seems to contradict the "need to be compiled" above.
>

Sorry, I meant the technology that the top-level uses to do "#load" 
directives. This is probably the same as Dynlink.


From yminsky at janestreet.com  Tue Feb  5 18:41:15 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 5 Feb 2013 13:41:15 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <20130205150603.GV13082@three-tuns.net>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
Message-ID: <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>

Leo's post is welcome, but it would be nice for an overview of what
the other proposals floating around are.  Maybe a single post
summarizing the main proposals and points of contention?

y

On Tue, Feb 5, 2013 at 10:06 AM, Mark Shinwell <mark at three-tuns.net> wrote:
> On Tue, Feb 05, 2013 at 07:43:10AM -0500, Yaron Minsky wrote:
>> There have been so many detailed and thoughtful emails that it's hard
>> to keep up with the deluge.  I would humbly submit that this would be
>> a good time for one of the organizers (Leo or Alain) to put together a
>> summary of the different positions that have been expressed about how
>> ppx might work, so that one could read over and think through those.
>> Right now, I have a hard time keeping the current state of the
>> conversation in my head, and I'm pretty sure I'm not alone.
>
> You are not alone.  I also think a summary would be very useful.
>
> Mark

From hongboz at seas.upenn.edu  Wed Feb  6 00:27:25 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 5 Feb 2013 19:27:25 -0500
Subject: [wg-camlp4] Structured comments,
	shallow embeddings and deep quasiquotations
In-Reply-To: <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
References: <CAPFanBHJP1xgNvSCDpYYFbBHwnPKPyODPjZUpkwOTs8ToU9ijQ@mail.gmail.com>
 <510B73C0.5090700@frisch.fr>
 <CAPFanBGWLmjhXD+zGVich5mPd50NKGgHknwtL40rU-z05ycbqw@mail.gmail.com>
 <CAAxsn=F-6FMk+BJqphG18O-a5=Ld__zsePjBHAbp8qJgpaXWNQ@mail.gmail.com>
Message-ID: <CANcqPu61U03NNsx0J=P2ReKQpm4edAfQo-sN=ViLKgOcVTZCoQ@mail.gmail.com>

Hi, Jeremy,
   I like your ideas, ;-). Fan adopt the same approach as you proposed.
Instead of
    (@deriving ["sexp"; "json"])
   type t = F of int | G of s
    and s = H of (t * t)

I used the notation
{:ocaml|
type t = F of int | G of s
and s = H of (t * t)
|}
{:derive| (sexp,json)|}
But the semantics are essentially the same,
should we take a serious look at Fan? As a much more advanced tool, Fan,
compared with ppx, while it does not require any change to the compiler,
and porting other camlp4 based library is much easier, I see a lot of
benefits here.

If we change the compiler a lot for little benefit in the internal
compiler, that makes life too hard for more advanced tools, are we a bit
short-sighted here? I really like some other features like run-time types
in the compiler instead, my 2 cents


On Sat, Feb 2, 2013 at 11:17 AM, Jeremy Yallop <yallop at gmail.com> wrote:

> On 1 February 2013 15:38, Gabriel Scherer <gabriel.scherer at gmail.com>
> wrote:
> > Finally, I think -ppx + arbitrary annotations, without any further
> > restriction, is too free-form for robust syntax extensions: one
> > important problem with Camlp4 is that it allowed syntax extension
> > writers to modify the syntax in very bad way that hurt robustness. As
> > already discussed, I have a strong distaste for extensions that only
> > piggyback on existing syntax (without adding any explicit marker); I
> > would feel safer if the extension *mechanism* disallowed such
> > unstructured extensions, or at least made them less rewarding to write
> > than the composable ones. (For example by only passing to the
> > extension writer the part(s) of the AST that have been annotated).
> > Unfortunately, I don't see how Bisect would fit any such restriction.
> > Maybe that's a problem best solved by socialization (writing a
> > documentation on good practices, and yelling on people), but I sort of
> > doubt it -- I don't know how many time I've had to argue for *not*
> > globally changing the associativity of infix operators through Camlp4
> > in Batteries.
>
> I agree with Gabriel.  Actually, I think that a small tweak to the
> design of -ppx could address both this and a number of problems that
> others have raised during the discussion here.
>
> The -ppx approach applies one or more global transformations to the
> ASTs of OCaml source files; these transformations can be parameterized
> by attributes attached at particular points in the syntax tree.  This
> is a significant improvement over the Camlp4 approach, largely because
> it exchanges the (unnecessary) ability to change the concrete syntax
> for a number of valuable guarantees, which make extensions easier to
> write and code that uses extensions easier to understand.
>
> We can go further in this direction, and give up more (unnecessary)
> power in return for further guarantees.  As Gabriel says, since -ppx
> extensions can arbitrarily transform the AST, it's not possible to
> understand any part of a program that uses extensions without
> understanding every aspect of the behaviour of every extension.  We
> could, of course, seek to solve this by convention and social
> pressure, but there seems to be an emerging consensus that this isn't
> really satisfactory.  One of the nice things about functional
> programming is that you have strong guarantees (via parametricity,
> immutability, and so on) about the effects of calling a particular
> function. We should strive to make it possible to reason in the same
> manner about the effects of syntax extensions.
>
> There are other legitimate concerns with the current proposal.  As
> Xavier Clerc and others point out, attributes are apparently
> undeclared (i.e. global) and untyped.  Alain rightly notes that it
> seems to be difficult to introduce declarations and types for
> attributes without significant complexity.  Still, as OCaml
> programmers we're used to the benefits of precisely-scoped names and
> strongly-typed data, and it seems a shame to give these benefits up if
> we can find a way to keep them.
>
> Hongbo Zhang raises a further concern: when syntax extensions are
> global transformations on the whole file, the order in which
> extensions are applied becomes significant.  This is a fairly serious
> matter, I think: the semantics of code that uses syntax extensions is
> now dependent on external factors, since we need to look for the flags
> passed to OCaml in the build configuration in order to understand the
> source.
>
> I think we can address all these concerns with a small adjustment in
> perspective.  Instead of globally-scoped, untyped attributes processed
> by file-level externally-specified transformations, we might add a
> single node to the OCaml grammar for statically-executed AST
> rewriters.  Using the same syntax already proposed for attributes, we
> might write, for example:
>
>    (@deriving ["sexp"; "json"])
>    type t = F of int | G of s
>     and s = H of (t * t)
>
> or
>
>     (@perform)
>        (x <-- m;
>         y <-- n;
>         return (x y))
>
> In order for this to be valid code, 'deriving' and 'perform' should
> resolve to functions of appropriate types:
>
>     val deriving : string list -> Parsetree.structure_item ->
> Parsetree.structure_item
>
>     val perform : Parsetree.expression -> Parsetree.expression
>
> Either during parsing or in a post parsing phase, the ASTs following
> '@deriving ["sexp"; "json"]' and '@perform' are passed to those
> functions and the results are inserted in place into the AST.
> Gabriel's concern is addressed, because there's no way for @perform
> (say) to access other parts of the AST: its effects are purely local.
> Xavier's concern is addressed, since AST rewriters, unlike attributes
> are declared and typed (and hence scoped). Hongbo's concern is
> addressed, since composition is explicit:
>
>     (@deriving ["sexp"])
>     (@nonrec)
>     type t = C of t
>
> (Here '@deriving ["sexp"]' is applied to the result of applying '@nonrec'.)
>
> It should be possible to write almost all extensions in this manner.
> A variant of the stream parser syntax fits easily:
>
>     (@parser)
>        ([ `If; x = expr; `Then; y = expr; `Else; z = expr ] => "if";
>         [ `Let; `Ident x; `Equal; x = expr; In; y = expr ] => "let")
>
> as does Anil's cstruct extension:
>
>     (@cstruct ~endianness:little)
>     type pcap_header = {
>        uint32_t magic_number;   (* magic number *)
>        uint16_t version_major;  (* major version number *)
>        ...
>     }
>
> Other extensions such as ifdef, js_of_ocaml, and pgsql could be
> handled in the same sort of way.
>
> Jeremy.
>
> [I'm deliberately avoiding the interesting but orthogonal questions of
> custom lexical syntax, and benign annotations for tools here.]
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130205/d6323145/attachment-0001.html>

From lpw25 at cam.ac.uk  Wed Feb  6 13:05:19 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 06 Feb 2013 13:05:19 +0000
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302061305190.1975@hermes-1.csi.cam.ac.uk>

On Feb 5 2013, Yaron Minsky wrote:

>Maybe a single post
>summarizing the main proposals and points of contention?

I'll try to post a summary this afternoon.

From lpw25 at cam.ac.uk  Wed Feb  6 18:11:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 06 Feb 2013 18:11:12 +0000
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
Message-ID: <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>

> Maybe a single post
>summarizing the main proposals and points of contention?

I will attempt a summary of the parts of the discussion that I remember. In 
no particular order the following has been discussed:


1. Current uses of camlp4

 There were many examples of current uses of camlp4 given. Gabriel put a 
 summary of them on a wiki:

  https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases

 Anil also posted a list of all the extensions used by OPAM packages:

  https://github.com/avsm/opam-camlp4-analysis/wiki

 I don't think anyone has systematically gone through these yet, but I 
 think that it is important, before any concrete proposal is made by this 
 working group, to make clear which of these extensions we intend to 
 support and how we intend to support them.


2. New syntaxes needed for ppx:

 There seems to be general agreement that, for ppx to replace camlp4 for 
its
 most common uses, at least the following three kinds of syntax are needed:

 a) A "template" syntax along the lines of (:longid expr). This syntax 
    could be used as an expression, a pattern, a structure item, etc.
    For example Sedlex could be:
       (:sedlex
          match buf with
          | number -> ..
          | letter, Star ('A'..'Z' | 'a'..'z' | digit) -> ..
       )
 b) An "attribute" syntax along the lines of (@ expr). This syntax allows 
    you to attach expressions to other expressions, patterns, etc. Unlike 
    the template syntax, the type-checker can silently ignore any of these 
    that don't get translated. For example Bisect could be:

      let f x =
        match List.map foo [x; a x; b x] with
        | [y1; y2; y3] -> tata
        | _ -> (@ Bisect.visit) assert false

      (@ Bisect.ignore)
      let unused = ()
    
    It has also been suggested that there might need to be different syntax 
    for "post-fix" and "pre-fix". Gabriel suggested that whether an 
    attribute in a particular syntactic position is pre-fix or post-fix be 
    decided on a case by case basis.

 c) A quotation syntax like {x{ .. }x} (where x is any operator symbol) 
    that could be used for quoting non-OCaml syntax. For example sedlex 
    with a more compact notation for regular expressions:

      (:sedlex
         match lexbuf with
         | {{ xml_letter+ }} -> ...
         | {{ "with" }} -> ...
         | ...
      )

 There has also been some agreement, and no strong objection, to including 
 some abbreviated forms of the above syntaxes. Some of the suggested forms 
 include:

 a) Template + quotation: 
     {:id x{ str }x}  ==  (:id {x{ str }x})

 b) Template + let: 
      let:id x = .. in ...  ==  (:id let x = .. in ... )

 c) Template + match:
      match:id exp with ..  ==  (:id match exp with .. )

 d) Type-conv style attribute:
      type t = ... with foo, bar( expr ) == type t = ... (@foo) (@bar expr)

 e) Anonymous template:
      (# expr)  ==  (:(*no id*) expr)


3. Anti-quotations

 There has been some discussion about how to support anti-quotations:

 - Fabrice suggested using a standardised format for anti-quotations, but 
   some people were against that because they use "$" in their camlp4 
   quotation extensions.

   I suggested that if we provided functions which took a predicate 
   function and then parsed an OCaml phrase up until the next *unnested* 
   location that made the predicate true, then we could support general 
   anti-quotations for ppx.

 - Hongbo suggested that AST lifting was necessary for supporting 
   anti-quotations, citing this paper:

     http://dl.acm.org/citation.cfm?id=1291211

   I suggested that it isn't necessarily needed, and that if people wanted 
   it then it could be provided using a type-conv style extension or 
   run-time types.


4. On the use of "quotations"

 There has also been some discussion about when it is a good idea to use a 
 camlp4-style quasi-quotation:

 - Alain suggested that they should not be used for extensions that are 
   "mostly valid OCaml code". He pointed out that doing so causes you to 
   lose all editor and tool support.

   Hongbo disagreed saying that in Fan extensions like sedlex would be 
   implement as quasi-quotation and that editor support was fine.

   After this there seems to have been some agreement that it would be 
   better to implement such extensions as "templates" (see section 2 of 
   this post) rather than quasi-quotations.

 - Alain then went further, suggesting that quotations were not even 
   suitable for encoding foreign languages in OCaml.

   Gabriel disagreed, saying that for domain-specific foreign languages 
   (e.g. SQL) quotations allow you to have a domain expert maintain the 
   foreign code even if they didn't know OCaml.

   Other people also said that they liked using quotations for foreign 
   syntax.


5. Alternatives to ppx

 There have been some proposals for alternatives and variations to using 
 ppx for extensions:

 a) Hongbo suggests that his Fan project is a better alternative to camlp4 
    than ppx:

      https://github.com/bobzhang/Fan

 b) Xavier Clerc suggested that attributes might be declared and typed, as 
    in Java. So before an attribute could be used:

      (@ MyAnnot {a=1, b="two"})

    "MyAnnot" would have to be declared with fields "a" (of type "int") and 
    "b" (of type "string"). He points out that this may protect the user 
    from some typos and other obvious errors.

    Alain suggested that this would be a much more complicated system, and 
    might be too restrictive for some uses of attributes.

 c) Sebastien Mondet suggested that run-time types or dyntype might be 
    sufficient without ppx for many extensions.

    Markus Mottl pointed out that there are runtime performance 
    implications for using those solutions.

 d) Jeremy suggested that rather than implementing extensions as AST 
    transformers that operate over the whole AST they might be implemented 
    as transformers only for the part of the AST that they were to operate 
    on. So an extension used like this:

      (:perform
          x <-- m;
          y <-- n;
          return (x y))

    would be implemented as a function with type:

      val perform : Parsetree.expression -> Parsetree.expression

    He suggests that this may help with scoping, safety and 
    compositionality.

    Alain pointed out that some legitimate uses of ppx don't work nicely 
    with the constraint that they can operate only on a marked fragment. He 
    also pointed out that handling extensions as those extensions are found 
    within the source forces a top-down expansion order, which is not 
    necessarily desirable.

 e) I suggested an extension to Jeremy's proposal. This involves giving the 
    expansion functions in their own kind of file (".mlq" - compiled to 
    ".cmq"), referring to them using a namespace mechanism, and then having 
    the compiler itself perform the expansion of the extensions.

    There are more details in my blog post:

      http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html

    Since such a solution would take a while to implement, and since moving 
    an extension from ppx to it would be trivial, I proposed using ppx for 
    the short/medium term.

    I suggested that such a mechanism might improving tooling and make it 
    easier for average users to use extensions.

    Both Gabriel and Alain suggested that the use of namespaces might be 
    unnecessary and too heavyweight. Alain also questioned the need for 
    special ".mlq" files.


There are probably other parts of the discussion that I've forgotten. I'm 
sure someone will fill-in any important details I've missed.


From hongboz at seas.upenn.edu  Wed Feb  6 18:48:38 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Wed, 6 Feb 2013 13:48:38 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
Message-ID: <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>

Summarize of my suggestions:
   I wrote 3 blogs(http://hongboz.wordpress.com/) explaining  why Parsetree
is not an ideal candidate for meta-programming.
   I express my worries if ppx is widely used
   http://lists.ocaml.org/pipermail/wg-camlp4/2013-January/000140.html

   Some arguments why Fan is a better candidate than ppx
   1. Fan is much much faster than P4 (10~20 times)
   2. Fan does not require any compiler change, easy to distribute, on the
contrary the pervasive change to compiler is close to kill P4, Fan or any
other advanced external tools, unlike P4, it will
not inhibit OCaml's compiler's progress.
   3. It's easy to build in Fan, Fan can recognize its syntax on its own,
without external tool's help
   4. It's easy to port P4's code base to Fan, it only takes me 2 hours to
port Alain's ulex to Fan(I also make it available on the toplevel, this
feature is not available in sedlex or ulex)
   5. Global Ast Rewriter is available but discouraged
   6. Local Ast Rewriter is provided(deriving and type_conv conflicts will
never happen in Fan)
       {:ocaml| type u = A of int |}
       {:derive| (sexp,json) |}
   7. Fan's notation is uniform
       only {:| |} is introduced, I  am a bit headache when seeing so many
notations
   8. Fan provides first class parser lexer(or in-line parser/lexer) as a
library
   9. Last but not least, Compatibility is important
       If we are un-satisfied with a tool, the right approach is to find a
way to repair it, building something from scratch and discard the old tool
may not be wise.

On Wed, Feb 6, 2013 at 1:11 PM, Leo White <lpw25 at cam.ac.uk> wrote:

> Maybe a single post
>> summarizing the main proposals and points of contention?
>>
>
> I will attempt a summary of the parts of the discussion that I remember.
> In no particular order the following has been discussed:
>
>
> 1. Current uses of camlp4
>
> There were many examples of current uses of camlp4 given. Gabriel put a
> summary of them on a wiki:
>
>  https://github.com/gasche/**ocaml-syntax-extension-**
> discussion/wiki/Use-Cases<https://github.com/gasche/ocaml-syntax-extension-discussion/wiki/Use-Cases>
>
> Anil also posted a list of all the extensions used by OPAM packages:
>
>  https://github.com/avsm/opam-**camlp4-analysis/wiki<https://github.com/avsm/opam-camlp4-analysis/wiki>
>
> I don't think anyone has systematically gone through these yet, but I
> think that it is important, before any concrete proposal is made by this
> working group, to make clear which of these extensions we intend to support
> and how we intend to support them.
>
>
> 2. New syntaxes needed for ppx:
>
> There seems to be general agreement that, for ppx to replace camlp4 for its
> most common uses, at least the following three kinds of syntax are needed:
>
> a) A "template" syntax along the lines of (:longid expr). This syntax
>  could be used as an expression, a pattern, a structure item, etc.
>    For example Sedlex could be:
>       (:sedlex
>          match buf with
>          | number -> ..
>          | letter, Star ('A'..'Z' | 'a'..'z' | digit) -> ..
>       )
> b) An "attribute" syntax along the lines of (@ expr). This syntax allows
>  you to attach expressions to other expressions, patterns, etc. Unlike
>  the template syntax, the type-checker can silently ignore any of these
>  that don't get translated. For example Bisect could be:
>
>      let f x =
>        match List.map foo [x; a x; b x] with
>        | [y1; y2; y3] -> tata
>        | _ -> (@ Bisect.visit) assert false
>
>      (@ Bisect.ignore)
>      let unused = ()
>       It has also been suggested that there might need to be different
> syntax    for "post-fix" and "pre-fix". Gabriel suggested that whether an
>  attribute in a particular syntactic position is pre-fix or post-fix be
>  decided on a case by case basis.
>
> c) A quotation syntax like {x{ .. }x} (where x is any operator symbol)
>  that could be used for quoting non-OCaml syntax. For example sedlex
>  with a more compact notation for regular expressions:
>
>      (:sedlex
>         match lexbuf with
>         | {{ xml_letter+ }} -> ...
>         | {{ "with" }} -> ...
>         | ...
>      )
>
> There has also been some agreement, and no strong objection, to including
> some abbreviated forms of the above syntaxes. Some of the suggested forms
> include:
>
> a) Template + quotation:     {:id x{ str }x}  ==  (:id {x{ str }x})
>
> b) Template + let:      let:id x = .. in ...  ==  (:id let x = .. in ... )
>
> c) Template + match:
>      match:id exp with ..  ==  (:id match exp with .. )
>
> d) Type-conv style attribute:
>      type t = ... with foo, bar( expr ) == type t = ... (@foo) (@bar expr)
>
> e) Anonymous template:
>      (# expr)  ==  (:(*no id*) expr)
>
>
> 3. Anti-quotations
>
> There has been some discussion about how to support anti-quotations:
>
> - Fabrice suggested using a standardised format for anti-quotations, but
> some people were against that because they use "$" in their camlp4
> quotation extensions.
>
>   I suggested that if we provided functions which took a predicate
> function and then parsed an OCaml phrase up until the next *unnested*
> location that made the predicate true, then we could support general
> anti-quotations for ppx.
>
> - Hongbo suggested that AST lifting was necessary for supporting
> anti-quotations, citing this paper:
>
>     http://dl.acm.org/citation.**cfm?id=1291211<http://dl.acm.org/citation.cfm?id=1291211>
>
>   I suggested that it isn't necessarily needed, and that if people wanted
>   it then it could be provided using a type-conv style extension or
> run-time types.
>
>
> 4. On the use of "quotations"
>
> There has also been some discussion about when it is a good idea to use a
> camlp4-style quasi-quotation:
>
> - Alain suggested that they should not be used for extensions that are
> "mostly valid OCaml code". He pointed out that doing so causes you to
> lose all editor and tool support.
>
>   Hongbo disagreed saying that in Fan extensions like sedlex would be
> implement as quasi-quotation and that editor support was fine.
>
>   After this there seems to have been some agreement that it would be
> better to implement such extensions as "templates" (see section 2 of   this
> post) rather than quasi-quotations.
>
> - Alain then went further, suggesting that quotations were not even
> suitable for encoding foreign languages in OCaml.
>
>   Gabriel disagreed, saying that for domain-specific foreign languages
> (e.g. SQL) quotations allow you to have a domain expert maintain the
> foreign code even if they didn't know OCaml.
>
>   Other people also said that they liked using quotations for foreign
> syntax.
>
>
> 5. Alternatives to ppx
>
> There have been some proposals for alternatives and variations to using
> ppx for extensions:
>
> a) Hongbo suggests that his Fan project is a better alternative to camlp4
>    than ppx:
>
>      https://github.com/bobzhang/**Fan <https://github.com/bobzhang/Fan>
>
> b) Xavier Clerc suggested that attributes might be declared and typed, as
>    in Java. So before an attribute could be used:
>
>      (@ MyAnnot {a=1, b="two"})
>
>    "MyAnnot" would have to be declared with fields "a" (of type "int") and
>    "b" (of type "string"). He points out that this may protect the user
>  from some typos and other obvious errors.
>
>    Alain suggested that this would be a much more complicated system, and
>    might be too restrictive for some uses of attributes.
>
> c) Sebastien Mondet suggested that run-time types or dyntype might be
>  sufficient without ppx for many extensions.
>
>    Markus Mottl pointed out that there are runtime performance
>  implications for using those solutions.
>
> d) Jeremy suggested that rather than implementing extensions as AST
>  transformers that operate over the whole AST they might be implemented
>  as transformers only for the part of the AST that they were to operate
>  on. So an extension used like this:
>
>      (:perform
>          x <-- m;
>          y <-- n;
>          return (x y))
>
>    would be implemented as a function with type:
>
>      val perform : Parsetree.expression -> Parsetree.expression
>
>    He suggests that this may help with scoping, safety and
>  compositionality.
>
>    Alain pointed out that some legitimate uses of ppx don't work nicely
>  with the constraint that they can operate only on a marked fragment. He
>  also pointed out that handling extensions as those extensions are found
>  within the source forces a top-down expansion order, which is not
>  necessarily desirable.
>
> e) I suggested an extension to Jeremy's proposal. This involves giving the
>    expansion functions in their own kind of file (".mlq" - compiled to
>  ".cmq"), referring to them using a namespace mechanism, and then having
>  the compiler itself perform the expansion of the extensions.
>
>    There are more details in my blog post:
>
>      http://www.lpw25.net/2013/02/**05/camlp4-alternative-part-2.**html<http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html>
>
>    Since such a solution would take a while to implement, and since moving
>    an extension from ppx to it would be trivial, I proposed using ppx for
>  the short/medium term.
>
>    I suggested that such a mechanism might improving tooling and make it
>  easier for average users to use extensions.
>
>    Both Gabriel and Alain suggested that the use of namespaces might be
>  unnecessary and too heavyweight. Alain also questioned the need for
>  special ".mlq" files.
>
>
> There are probably other parts of the discussion that I've forgotten. I'm
> sure someone will fill-in any important details I've missed.
>
>
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130206/9f54a764/attachment-0001.html>

From alain.frisch at lexifi.com  Thu Feb  7 10:09:29 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Feb 2013 11:09:29 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
Message-ID: <51137D59.7050308@lexifi.com>

On 02/06/2013 07:48 PM, Hongbo Zhang wrote:
>     Some arguments why Fan is a better candidate than ppx
>     1. Fan is much much faster than P4 (10~20 times)

This is great, in particular because it illustrates a vastly simplified 
bootstrapping procedure of Fan compared to Camlp4.  But this does not 
bring much to the comparison with ppx.

"-ppx" on its own is even faster to build, since there is nothing to 
build (it is just a command-line flag, in the same way as "-pp" on which 
Fan relies, I guess).

>     2. Fan does not require any compiler change, easy to distribute, on
> the contrary the pervasive change to compiler is close to kill P4, Fan
> or any other advanced external tools

ppx is already part of the development version and required minimal 
changes.  We are also discussing the addition of a few syntactic 
constructs which will only impact the definition of Parsetree and the 
official parser.  This cannot really be considered as a "pervasive 
change" to the compiler.

Can you elaborate on why you think this would kill Camlp4 or Fan?  I 
know from experience that Camlp4 is quite tedious to update when the 
concrete syntax of OCaml changes, but I'm sure someone will manage to 
update Camlp4/Fan definition of OCaml's AST and the associate parsers.

-ppx is compatible with pre-processors implemented with -pp 
(Camlp4/Fan), as long as those pre-processors can understand the new 
syntactic constructs and pass them back to OCaml.

 > unlike P4, it will
 > not inhibit OCaml's compiler's progress.

Your point above illustrates that it is not that simple: a simple 
addition to the OCaml syntax, which would normally require to adapt only
parser.mly, parsetree.mli, ast_mapper.ml/mli and a few other modules in 
the compilers, also requires to port the same changes to Fan's 
definition of the OCaml AST and to its parsers.

>     3. It's easy to build in Fan

Again, this seems more like a comparison between Fan and Camlp4 than 
between Fan and the ppx approach.

 > Fan can recognize its syntax on its
 > own, without external tool's help

How does this argument apply to the comparison with the ppx approach?


>     4. It's easy to port P4's code base to Fan, it only takes me 2 hours
> to port Alain's ulex to Fan

It did not take that much longer to port ulex from Camlp4 to -ppx, and 
as an extra added bonus, it really gave me the feeling that I could 
finally *breathe* and understand exactly what I'm writing. Frankly, I'm 
more comfortable writing:

   E.let_ Recursive states
     (E.sequence
        (appfun "Sedlexing.start" [eid lexbuf])
        (E.match_ (appfun (state_fun 0) [eid lexbuf])
           (cases @ [P.any (), error])
        )
     )

than:

   <:expr< fun lexbuf ->
     let rec $list:Array.to_list states$ in
     do { Ulexing.start lexbuf;
          match __ulex_state_0 lexbuf with
          [ $list:Array.to_list cases$ | _ -> raise Ulexing.Error ] } >>

which requires me to learn two new "sub-languages" (the revised syntax 
and the notion of quotation / antiquotation).  Imagine that the "rec" 
flag above should be set only according to some condition to be checked; 
I know directly how to write that in regular OCaml but I would need to 
dig into Camlp4 documentation (or not) to see how to introduce an 
"anti-quotation on the rec flag".

Is the code for the Fan version of ulex/sedlex available somewehere?


 > (I also make it available on the toplevel,
 > this feature is not available in sedlex or ulex)

sedlex works fine in the toplevel:

$ ocaml -ppx "ocamlfind sedlex/sedlex.exe"
         OCaml version 4.01.0+dev10-2012-10-16

# #use "topfind";;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
...
# #require "sedlex";;
/home/afrisch/.opam/4.01.0dev+trunk/lib/sedlex: added to search path
/home/afrisch/.opam/4.01.0dev+trunk/lib/sedlex/sedlexing.cma: loaded
# let rec token buf =
   let ('a'..'z'|'A'..'Z') as letter = SEDLEX.regexp in
   let '0'..'9' as digit = SEDLEX.regexp in
   match SEDLEX buf with
   | Plus letter -> Printf.printf "Word %s\n" (Sedlexing.Latin1.lexeme 
buf); token buf
   | Plus digit -> Printf.printf "Number %s\n" (Sedlexing.Latin1.lexeme 
buf); token buf
   | _ -> failwith "Error"
               ;;
...
val token : Sedlexing.lexbuf -> 'a = <fun>
#


>     5. Global Ast Rewriter is available but discouraged
>     6. Local Ast Rewriter is provided(deriving and type_conv conflicts
> will never happen in Fan)
>         {:ocaml| type u = A of int |}
>         {:derive| (sexp,json) |}

Can you describe in more detail your position concerning the following 
points?

   - How do you deal with cases where the "expander" for such a local 
annotation needs to access the context of the AST fragment on which it 
applies, or where it needs to inject code non-locally?  For instance, 
several ulex/sedlex lexers specified in the same file will share code 
"partition function" (put at the beginning of the compilation unit in 
this case).

  - How would you support "ignorable" attributes, e.g. information 
targeted to specific tools like bisect or a variant ocamldoc based on 
structured comments?

  - How would you support a simple macro system?  For instance, I can 
imagine to use -ppx to do something like:

    let(:macro) if_debug x =
      if !debug_mode then (print_endline "DEBUG:"; x)

    let debug_mode = ref false

    ....

    if_debug (print_endline "XXX")

    What would be the Fan equivalent of it?

  - Imagine that two type-conv-like extensions need to be applied on the 
same type declaration, and detect attributes put on type expressions in it:

     type foo =
           {
             quantity: float (@xml ~digits:2) (@bin single);
             code: string (@xml ~cdata) (@bin base64);
           }
          (@xml) (@bin)

  (here we have two annotations "xml" and "bin" on the type declaration 
"foo", understood by two independent tools which generate marshaling 
code based the declaration, and interpret annotations on inner type 
expressions to customize the format)

  How do you write that in Fan?  My understanding is that one the 
expanders will be applied first and it will need to parse the type 
declaration itself; but what will it do with attributes intended to be 
used by the other extension?

  - Can you confirm that the content .... of {:foo| .... |} is passed as 
an unparsed string to the expander "foo"?  If this is the case, what is 
your position concerning support from editor?  Should they treat .... 
like OCaml code (e.g. applying lexing rules for coloring and grammar 
rules for indentation)?  If so, this syntax will not work well with 
fragments of code in a foreign syntax, and could potentially lead to 
broken editor behavior.  If not, you loose all support from your editor 
as soon as your are in the scope of an expander.  Or maybe do you 
envision a much ambitious proposal where the editor would somehow need 
to run the expander "on the fly" (I don't believe this is possible at a 
reasonable cost).  Another question: how is the end marker |} detected? 
  Can you write e.g.:

    {:html|
      <p>I <em>really</em> like <b>Fan</b> syntax, and especially
      its terminator |}
    |}

>     7. Fan's notation is uniform
>         only {:| |} is introduced, I  am a bit headache when seeing so
> many notations

I claim that this single notation corresponds to three different 
concepts which deserve to be understood separately:

   - Extension marker around a parsed fragment, to be interpreted by an 
expander (otherwise the type-checker fails).

   - Attributes attached on AST fragments, to be (optionally) 
interpreted by tools like Bisect, by expanders, or which can trigger 
themselves local rewritings (in that case, one might want a specific 
syntax to ensure they won't be silently ignored by the type-checker).

   - Quotations: a way to write fragment of code in a foreign syntax, by 
escaping from OCaml lexical conventions on string literals.  (I believe 
this is rather orthogonal to -ppx and might be useful for regular 
libraries, but I accept the idea of a combined notation: extension 
marker + quotation.)

>     8. Fan provides first class parser lexer(or in-line parser/lexer) as
> a library

I claim that most interesting uses of camlp4 extensions around can be 
implemented in a way which does not require any extra lexing/parsing 
technology in addition to what's included in the core compiler today 
(based on ocamllex/ocamlyacc).  (The only exceptions seem to be these 
extensions which need to parse foreign syntax, and I find it good that 
they can rely on an arbitrary parsing technology.)






Alain

From info at gerd-stolpmann.de  Thu Feb  7 13:16:14 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Thu, 07 Feb 2013 14:16:14 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <51137D59.7050308@lexifi.com> (from alain.frisch@lexifi.com on
 Thu Feb  7 11:09:29 2013)
Message-ID: <1360242974.18230.7@samsung>

Am 07.02.2013 11:09:29 schrieb(en) Alain Frisch:
>>     4. It's easy to port P4's code base to Fan, it only takes me 2  
>> hours
>> to port Alain's ulex to Fan
> 
> It did not take that much longer to port ulex from Camlp4 to -ppx,  
> and as an extra added bonus, it really gave me the feeling that I  
> could finally *breathe* and understand exactly what I'm writing.  
> Frankly, I'm more comfortable writing:
> 
>   E.let_ Recursive states
>     (E.sequence
>        (appfun "Sedlexing.start" [eid lexbuf])
>        (E.match_ (appfun (state_fun 0) [eid lexbuf])
>           (cases @ [P.any (), error])
>        )
>     )
> 
> than:
> 
>   <:expr< fun lexbuf ->
>     let rec $list:Array.to_list states$ in
>     do { Ulexing.start lexbuf;
>          match __ulex_state_0 lexbuf with
>          [ $list:Array.to_list cases$ | _ -> raise Ulexing.Error ]  
> } >>
> 
> which requires me to learn two new "sub-languages" (the revised  
> syntax and the notion of quotation / antiquotation).

Frankly, this is a quite subjective experience. For me (and many  
developers who are not familiar with parsetrees) there is not much  
difference doing either. Of course, the revised syntax is an extra  
hurdle.

Currently, there is no documentation about parsetrees, and I would need  
to guess how they are built up. But if there was some documentation  
plus some examples it would probably be fully acceptable.

>  Imagine that the "rec" flag above should be set only according to  
> some condition to be checked; I know directly how to write that in  
> regular OCaml but I would need to dig into Camlp4 documentation (or  
> not) to see how to introduce an "anti-quotation on the rec flag".

My guess here is that this is not directly possible, and you need to  
program two independent cases (if rec_flag then <:expr< ...>> else  
<:expr< ...>>). This is the price for an extra abstraction, but you  
also get something back: if, for some reason, the parsetree changes and  
let rec gets a variant of its own, you don't need to change the program.

"let rec" might be a bad example, because such a change is not  
expected, but generally we _will_ run into the problem that changes of  
the parsetree type break ppx processors. (Well, to some degree we can  
avoid this by having wrapper functions, i.e. don't use E.let_ directly,  
but a function mk_let, as then many changes can be done in a way that  
doesn't affect compatibility.)

Gerd
-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From hongboz at seas.upenn.edu  Thu Feb  7 14:56:22 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 7 Feb 2013 09:56:22 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <51137D59.7050308@lexifi.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
 <51137D59.7050308@lexifi.com>
Message-ID: <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>

On Thu, Feb 7, 2013 at 5:09 AM, Alain Frisch <alain.frisch at lexifi.com>
wrote:
>
>
> "-ppx" on its own is even faster to build, since there is nothing to
build (it is just a command-line flag, in the same way as "-pp" on which
Fan relies, I guess).

Not always, as I pointed out, as long as you combine several global Ast
Rewriter, I am  optimistic that Fan has a great chance to outperform
ppx.(currently with respect to the compiling performance, Fan is on par
with ocamlc.opt directly, slightly slower)
>
>
>
>>     2. Fan does not require any compiler change, easy to distribute, on
>> the contrary the pervasive change to compiler is close to kill P4, Fan
>> or any other advanced external tools
>
>
> ppx is already part of the development version and required minimal
changes.  We are also discussing the addition of a few syntactic constructs
which will only impact the definition of Parsetree and the official parser.
 This cannot really be considered as a "pervasive change" to the compiler.
>
> Can you elaborate on why you think this would kill Camlp4 or Fan?  I know
from experience that Camlp4 is quite tedious to update when the concrete
syntax of OCaml changes, but I'm sure someone will manage to update
Camlp4/Fan definition of OCaml's AST and the associate parsers.
>
> -ppx is compatible with pre-processors implemented with -pp (Camlp4/Fan),
as long as those pre-processors can understand the new syntactic constructs
and pass them back to OCaml.
>
Well, things are always possible, but just too difficult in some cases,
remember that (Camlp4/Camlp5/Fan) preprocess the intermediate Ast, if we
clutter Parsetree too much, like adding some attributes node per syntax
category and ignored by the compiler later, which may require all other
tools to mix Intermediate Ast with Parsetree, it's always possible, just
too hard. I am perfectly fine with ppx so far, and I am happy to see bisect
switch to ppx, because global Ast Rewriter happen to be very fit there, but
 if we try to make everything possible in ppx, there's a large chance that
it will result in a ugly design in the compiler.
>
>
> > unlike P4, it will
> > not inhibit OCaml's compiler's progress.
>
> Your point above illustrates that it is not that simple: a simple
addition to the OCaml syntax, which would normally require to adapt only
> parser.mly, parsetree.mli, ast_mapper.ml/mli and a few other modules in
the compilers, also requires to port the same changes to Fan's definition
of the OCaml AST and to its parsers.
> ]

I think the amount of work is similar, the only difference is that we
maintain the change ast2pt.ml(dump intermediate ast into parsetree), it's
just a piece of cake, and we don't need to maintain ast_mapper, since it is
generated automatically in Fan. For the fan ast, we have tools
   {|derive(Map2
      Fold2 OIter MetaExpr MetaPatt Map Fold Print OPrint OEq
      GenLoc  Strip ) |}
for FanAst, suppose in one day you have those tools for parsetree, the
maintenance will
be a nightmare.

>>     4. It's easy to port P4's code base to Fan, it only takes me 2 hours
>> to port Alain's ulex to Fan
>
>
> It did not take that much longer to port ulex from Camlp4 to -ppx, and as
an extra added bonus, it really gave me the feeling that I could finally
*breathe* and understand exactly what I'm writing. Frankly, I'm more
comfortable writing:
>
>   E.let_ Recursive states
>     (E.sequence
>        (appfun "Sedlexing.start" [eid lexbuf])
>        (E.match_ (appfun (state_fun 0) [eid lexbuf])
>           (cases @ [P.any (), error])
>        )
>     )
>
> than:
>
>   <:expr< fun lexbuf ->
>     let rec $list:Array.to_list states$ in
>     do { Ulexing.start lexbuf;
>          match __ulex_state_0 lexbuf with
>          [ $list:Array.to_list cases$ | _ -> raise Ulexing.Error ] } >>
>
> which requires me to learn two new "sub-languages" (the revised syntax
and the notion of quotation / antiquotation).  Imagine that the "rec" flag
above should be set only according to some condition to be checked; I know
directly how to write that in regular OCaml but I would need to dig into
Camlp4 documentation (or not) to see how to introduce an "anti-quotation on
the rec flag".

Here, this happens to hit the sweet spot of quosi-quotation, first, I agree
that the revised syntax should be adapted to original syntax, and that's
part of my on-going work.
Let me explain a bit why quosi-quotation is superb here:
1. It quickly goes into my muscle memory, because I write ocaml everyday
(not parsetree), it's just my *intuition* that the Ast should be
constructed that way, and I don't need to remember those alien function
names, to be honest, I don't know what's the module E here. If I want to
make a piece of code into data, I just need to quote them, add "{:expr||}"
surrounding them, that's all. How would that happen in your "E" module?
2. The E module seems to be a bit magic here, but Fan's quosiquotation
works very nice with Emacs or any decent IDE, just like slime for lisp, I
type one key in my Emacs, it just expand the code explicitly(I attached the
result), but it's never going to happen with your "E" module, since it
requires *explicit multiple staging*.
3. For the parsetree, if you want to do syntactic grep over bigarray, you
will get into much trouble:
   ({pexp_desc=Pexp_ident
                    {txt= Ldot (Ldot (Lident "Bigarray", array),
("get"|"set" as gs)) ;_};_}
   This does not solve the problem at all, since it can not discriminate
"a.{b,c}" from "Bigarray.get a b c " in Fan, you only need to do say
   "`Bigarray (a,b,c)"
   There are so many syntax desugaring in the parsetree that I don't know
where to stop.

>>     5. Global Ast Rewriter is available but discouraged
>>     6. Local Ast Rewriter is provided(deriving and type_conv conflicts
>> will never happen in Fan)
>>         {:ocaml| type u = A of int |}
>>         {:derive| (sexp,json) |}
>
>
> Can you describe in more detail your position concerning the following
points?
>
If it can be implemented by ppx, it can be straightforwardly translated
into Fan, since ppx is simply a tiny proper subset of Fan(the part of
global Ast Rewriter). There are so many great ideas proposed here that I
would shamelessly steal into Fan even without bothering any change to the
compiler. Fan provides first class parser/lexer(or in-line parser lexer),
which is good, and there are people who appreciate it(
https://sympa.inria.fr/sympa/arc/caml-list/2013-02/msg00020.html), john
harrop even claims that "Parsers written using Camlp4 are nicer than with
any other tool I have ever used", but users are not locked in specific
parsing technology, it's perfectly fine if you want to use either menhir or
ocamlyacc.


--
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130207/67c154b5/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: tmp.ml
Type: application/octet-stream
Size: 3179 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130207/67c154b5/attachment.obj>

From yminsky at janestreet.com  Thu Feb  7 15:48:46 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 7 Feb 2013 10:48:46 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
Message-ID: <CACLX4jQg2Lsre3DGyDvEFA1=dpPYoy_Gt-DrtkmeZ0UvLN75GQ@mail.gmail.com>

Thanks Leo!  This is very helpful.  Maybe we should throw this up on a
wiki page somewhere, and keep it up to date as proposals show up.

A few notes of my own below.

On Wed, Feb 6, 2013 at 1:11 PM, Leo White <lpw25 at cam.ac.uk> wrote:
> c) Sebastien Mondet suggested that run-time types or dyntype might be
> sufficient without ppx for many extensions.
>
> Markus Mottl pointed out that there are runtime performance
> implications for using those solutions.

I strongly agree with Markus on this.  Run-time types are lovely, but
we really need something more efficient for the vast majority of our
camlp4 needs.  Using a comparison function constructed with run-time
types, for example, would be a disaster performance wise.  We've done
experiments internally, and the performance hit is absolutely
crushing.

> d) Jeremy suggested that rather than implementing extensions as AST
> transformers that operate over the whole AST they might be implemented    as
> transformers only for the part of the AST that they were to operate    on.
> So an extension used like this:
>
>      (:perform
>          x <-- m;
>          y <-- n;
>          return (x y))
>
>    would be implemented as a function with type:
>
>      val perform : Parsetree.expression -> Parsetree.expression
>
>    He suggests that this may help with scoping, safety and
> compositionality.
>
>    Alain pointed out that some legitimate uses of ppx don't work nicely
> with the constraint that they can operate only on a marked fragment. He
> also pointed out that handling extensions as those extensions are found
> within the source forces a top-down expansion order, which is not
> necessarily desirable.

I wonder if this is a place where we can have it both ways: have an
underlying ppx mechanism that is a whole-AST transformation; and
expose libraries that support more disciplined, scoped
transformations.  We could strongly encourage the latter, but still
allow the former when necessary.

> e) I suggested an extension to Jeremy's proposal. This involves giving the
> expansion functions in their own kind of file (".mlq" - compiled to
> ".cmq"), referring to them using a namespace mechanism, and then having
> the compiler itself perform the expansion of the extensions.
>
>    There are more details in my blog post:
>
>      http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html
>
>    Since such a solution would take a while to implement, and since moving
> an extension from ppx to it would be trivial, I proposed using ppx for
> the short/medium term.
>
>    I suggested that such a mechanism might improving tooling and make it
> easier for average users to use extensions.
>
>    Both Gabriel and Alain suggested that the use of namespaces might be
> unnecessary and too heavyweight. Alain also questioned the need for
> special ".mlq" files.

I do like the idea of eventually getting to a name-spaced solution.
In our world, there are really two cases: one, where we really just
want to extend the language, and we're happy to specify which language
we're using fairly broadly at the build-system level.  For such
things, namespaces do not seem helpful.

The other case is where you want to invoke a particular,
special-purpose syntax extension for just one file.  There, having
something that would allow the specification of the extension in the
file, ideally with some integration with namespaces, seems lovely.
That said, I think it's a less important use-case in the current
world.

I wonder, does anyone on the list of have much experience with
Scheme's approach to macros?  There's been a lot of work there,
covering everything from hygeine to integration with module systems.
It would be great to leverage off of that experience.

y

From alain.frisch at lexifi.com  Thu Feb  7 16:37:26 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Feb 2013 17:37:26 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
 <51137D59.7050308@lexifi.com>
 <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>
Message-ID: <5113D846.3080703@lexifi.com>

On 2/7/2013 3:56 PM, Hongbo Zhang wrote:
> Not always, as I pointed out, as long as you combine several global Ast
> Rewriter, I am  optimistic that Fan has a great chance to outperform
> ppx.

Oh sorry, I thought you were referring to the compilation of Fan itself.

> Well, things are always possible, but just too difficult in some cases,
> remember that (Camlp4/Camlp5/Fan) preprocess the intermediate Ast, if we
> clutter Parsetree too much, like adding some attributes node per syntax
> category and ignored by the compiler later, which may require all other
> tools to mix Intermediate Ast with Parsetree, it's always possible, just
> too hard.

I don't follow. We are talking, basically, about adding simple 
constructions to the AST, like:

   Pexp_annotation of expression * expression
   Pexp_extension of string * expression

and you were suggesting that this would almost kill Camlp4/Fan. Why?

> I am perfectly fine with ppx so far, and I am happy to see
> bisect switch to ppx, because global Ast Rewriter happen to be very fit
> there, but  if we try to make everything possible in ppx, there's a
> large chance that it will result in a ugly design in the compiler.

Again, we are talking about adding a few constructs to the AST.  The 
only real "consumer" of the AST in the compiler is the type-checker, and 
its behavior is pretty clear for the new nodes:  attributes are ignored, 
extensions raise a type error.  Where is the "ugly design"?

> Let me explain a bit why quosi-quotation is superb here:
> 1. It quickly goes into my muscle memory, because I write ocaml everyday
> (not parsetree)

So do I and thus I'm more familiar with constructors of a standard sum 
types (wrapped into simple functions) than something which requires a 
new syntax.

>, it's just my *intuition* that the Ast should be
> constructed that way, and I don't need to remember those alien function
> names, to be honest, I don't know what's the module E here. If I want to
> make a piece of code into data, I just need to quote them, add
> "{:expr||}" surrounding them, that's all. How would that happen in your
> "E" module?

I don't see where "lifting ASTs" is required in order to implement all 
the interesting tools we are discussing here (except Fan itself).

> 2. The E module seems to be a bit magic here

E is defined in Ast_mapper:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/trunk/parsing/ast_mapper.mli?view=markup

For instance, let_ is defined very cleverly as:

let mk ?(loc = Location.none) x = {pexp_desc = x; pexp_loc = loc}
...
let let_ ?loc a b c = mk ?loc (Pexp_let (a, b, c))

There is absolutely no magic.


> 3. For the parsetree, if you want to do syntactic grep over bigarray,
> you will get into much trouble:
>     ({pexp_desc=Pexp_ident
>                      {txt= Ldot (Ldot (Lident "Bigarray", array),
> ("get"|"set" as gs)) ;_};_}
>     This does not solve the problem at all, since it can not
> discriminate "a.{b,c}" from "Bigarray.get a b c " in Fan, you only need
> to do say
>     "`Bigarray (a,b,c)"
>     There are so many syntax desugaring in the parsetree that I don't
> know where to stop.

This is a valid point, and I believe there would not be any strong 
opposition to move some desugaring logic from parser.mly into the 
typechecker, i.e. make Parsetree look more like a parse tree than an AST.

That said, I've no idea what

  `Bigarray (a,b,c)

means.


>  > Can you describe in more detail your position concerning the
> following points?
>  >
> If it can be implemented by ppx, it can be straightforwardly translated
> into Fan, since ppx is simply a tiny proper subset of Fan(the part of
> global Ast Rewriter).

Will you introduce in Fan the notion of attributes attached to every 
possible category and represented explicitly in the (Fan) AST?  I 
thought you only had the intention to extend the syntax of OCaml with a 
single construct {:xxx| ... |}  with  .... being left unparsed.  I don't 
see how you can simulate "ignorable attributes" with that. Can you 
elaborate?

> Fan provides first class parser/lexer(or in-line parser
> lexer), which is good, and there are people who appreciate
> it(https://sympa.inria.fr/sympa/arc/caml-list/2013-02/msg00020.html),

I'm fine with Camlp4/Fan as a "parsing technology", and I've used it 
quite a lot (e.g. the parser for CDuce was implemented in Camlp4).  But 
this is largely independent of the use of Camlp4 to write "syntax 
extensions".  I believe that most interesting uses of Camlp4 to write 
syntax extensions today don't require any parsing technology at all, 
because they are not about really extending the syntax per so, but 
rather about providing convenient tools to OCaml developpers, and this 
does not require to play with the syntax.


Alain

From gabriel.scherer at gmail.com  Thu Feb  7 16:49:18 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Thu, 7 Feb 2013 17:49:18 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CACLX4jQg2Lsre3DGyDvEFA1=dpPYoy_Gt-DrtkmeZ0UvLN75GQ@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CACLX4jQg2Lsre3DGyDvEFA1=dpPYoy_Gt-DrtkmeZ0UvLN75GQ@mail.gmail.com>
Message-ID: <CAPFanBGR-r+6T1_x1SPpOSBw1qottsyVVKEz4MeV9VK+b6RUsw@mail.gmail.com>

>> c) Sebastien Mondet suggested that run-time types or dyntype might be
>> sufficient without ppx for many extensions.
>>
>> Markus Mottl pointed out that there are runtime performance
>> implications for using those solutions.
>
> I strongly agree with Markus on this.  Run-time types are lovely, but
> we really need something more efficient for the vast majority of our
> camlp4 needs.  Using a comparison function constructed with run-time
> types, for example, would be a disaster performance wise.  We've done
> experiments internally, and the performance hit is absolutely
> crushing.

Two remarks on this.

First, it is unclear that runtime types (or any form of internalized
type-driven value generation) will scale to higher-kinded settings
(generating a "Functor" instance out of a parametrized datatype), so
there is also an argument of expressivity. In the current state of the
OCaml type system, "a ty" is only robustly defined for closed types or
type schemes (as opposed to parametrized types as type operators, that
is anything of kind different from '*'), and while I don't exclude
impressive workarounds from Alain or other, I wouldn't trust the
dyntype approach to work really well on type operators.

Second, Pierre Chambart and Gr?goire Henry are working on a different
take on type-directed code injection that is more general than just
inferred dynamic type representations, and could make much of that
performance overhead you're mentioning go away, at least on paper
(whether the actually generated terms will be actually optimized as
you would hope is another question in which I'm sure they are also
interested). The idea is that instead of having a type-directed
generation of a ('a ty) and then a function ('a ty -> 'a printer), you
could directly generate ('a printer) in a type-directed way. This
generalization allows to express type-directed behavior that are not
defined on all types (eg. comparison rejected statically rather than
at runtime on function types), and could potentially make the
performance issue simpler. Note that in theory clever partial
evaluation could work on the previous dyntype approach (but I think
that's beyond hope for now).

On Thu, Feb 7, 2013 at 4:48 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Thanks Leo!  This is very helpful.  Maybe we should throw this up on a
> wiki page somewhere, and keep it up to date as proposals show up.
>
> A few notes of my own below.
>
> On Wed, Feb 6, 2013 at 1:11 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>> c) Sebastien Mondet suggested that run-time types or dyntype might be
>> sufficient without ppx for many extensions.
>>
>> Markus Mottl pointed out that there are runtime performance
>> implications for using those solutions.
>
> I strongly agree with Markus on this.  Run-time types are lovely, but
> we really need something more efficient for the vast majority of our
> camlp4 needs.  Using a comparison function constructed with run-time
> types, for example, would be a disaster performance wise.  We've done
> experiments internally, and the performance hit is absolutely
> crushing.
>
>> d) Jeremy suggested that rather than implementing extensions as AST
>> transformers that operate over the whole AST they might be implemented    as
>> transformers only for the part of the AST that they were to operate    on.
>> So an extension used like this:
>>
>>      (:perform
>>          x <-- m;
>>          y <-- n;
>>          return (x y))
>>
>>    would be implemented as a function with type:
>>
>>      val perform : Parsetree.expression -> Parsetree.expression
>>
>>    He suggests that this may help with scoping, safety and
>> compositionality.
>>
>>    Alain pointed out that some legitimate uses of ppx don't work nicely
>> with the constraint that they can operate only on a marked fragment. He
>> also pointed out that handling extensions as those extensions are found
>> within the source forces a top-down expansion order, which is not
>> necessarily desirable.
>
> I wonder if this is a place where we can have it both ways: have an
> underlying ppx mechanism that is a whole-AST transformation; and
> expose libraries that support more disciplined, scoped
> transformations.  We could strongly encourage the latter, but still
> allow the former when necessary.
>
>> e) I suggested an extension to Jeremy's proposal. This involves giving the
>> expansion functions in their own kind of file (".mlq" - compiled to
>> ".cmq"), referring to them using a namespace mechanism, and then having
>> the compiler itself perform the expansion of the extensions.
>>
>>    There are more details in my blog post:
>>
>>      http://www.lpw25.net/2013/02/05/camlp4-alternative-part-2.html
>>
>>    Since such a solution would take a while to implement, and since moving
>> an extension from ppx to it would be trivial, I proposed using ppx for
>> the short/medium term.
>>
>>    I suggested that such a mechanism might improving tooling and make it
>> easier for average users to use extensions.
>>
>>    Both Gabriel and Alain suggested that the use of namespaces might be
>> unnecessary and too heavyweight. Alain also questioned the need for
>> special ".mlq" files.
>
> I do like the idea of eventually getting to a name-spaced solution.
> In our world, there are really two cases: one, where we really just
> want to extend the language, and we're happy to specify which language
> we're using fairly broadly at the build-system level.  For such
> things, namespaces do not seem helpful.
>
> The other case is where you want to invoke a particular,
> special-purpose syntax extension for just one file.  There, having
> something that would allow the specification of the extension in the
> file, ideally with some integration with namespaces, seems lovely.
> That said, I think it's a less important use-case in the current
> world.
>
> I wonder, does anyone on the list of have much experience with
> Scheme's approach to macros?  There's been a lot of work there,
> covering everything from hygeine to integration with module systems.
> It would be great to leverage off of that experience.
>
> y
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Thu Feb  7 16:52:49 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 07 Feb 2013 17:52:49 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <1360242974.18230.7@samsung>
References: <1360242974.18230.7@samsung>
Message-ID: <5113DBE1.8000808@lexifi.com>

On 2/7/2013 2:16 PM, Gerd Stolpmann wrote:
> Currently, there is no documentation about parsetrees, and I would need
> to guess how they are built up. But if there was some documentation plus
> some examples it would probably be fully acceptable.

See the discussion with X. Clerc on this list.  It has been suggested to 
add a compiler option to dump the parse tree into "Parsetree" syntax 
(Pexp_... constructors).

> "let rec" might be a bad example, because such a change is not expected,
> but generally we _will_ run into the problem that changes of the
> parsetree type break ppx processors. (Well, to some degree we can avoid
> this by having wrapper functions, i.e. don't use E.let_ directly, but a
> function mk_let, as then many changes can be done in a way that doesn't
> affect compatibility.)

E.let_ is already a wrapper around the constructor:

let mk ?(loc = Location.none) x = {pexp_desc = x; pexp_loc = loc}
...
let let_ ?loc a b c = mk ?loc (Pexp_let (a, b, c))

If the Parsetree is extended, there are different ways to organize 
ourselves to avoid breaking existing -ppx rewriters (at least for AST 
fragments "builders", not "patterns"): new functions, optional 
arguments, a copy of the ast_mapper module to support older versions of 
the Parsetree (with an implicit mapping).  But it also make sense to 
think about ways to make the definition of Parsetree itself more robust 
to future changes.  For instance, using records instead of tuples is 
much more future-proof:  when deconstructing a node, one can choose to 
use "open record patterns" (to explicitly ignore future fields which 
could be added) or not (to be forced to adapt the code if more fields 
are added);  and wrapper functions can use optional arguments for new 
fields.


Alain

From hongboz at seas.upenn.edu  Thu Feb  7 19:50:53 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 7 Feb 2013 14:50:53 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <5113D846.3080703@lexifi.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
 <51137D59.7050308@lexifi.com>
 <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>
 <5113D846.3080703@lexifi.com>
Message-ID: <CANcqPu6HjyvpRSG5AOiYEPnLYjeJwT2iTL6gV_MtO45L_UUDtA@mail.gmail.com>

On Thu, Feb 7, 2013 at 11:37 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 2/7/2013 3:56 PM, Hongbo Zhang wrote:
>
>>
>> I don't follow. We are talking, basically, about adding simple
> constructions to the AST, like:
>
>   Pexp_annotation of expression * expression
>   Pexp_extension of string * expression
>
> and you were suggesting that this would almost kill Camlp4/Fan. Why?
>
> The problem is that I am a bit unclear how to encode them in the
meta-level, since the introduced constructs will not be consumed by the
type checker, they are provided for the convenience of ppx, but does not
exist in real world.  I think camlp5 and Coq maintainers will also
appreciate that we are a bit conservative in the compiler part.

>
> E is defined in Ast_mapper:
>
> http://caml.inria.fr/cgi-bin/**viewvc.cgi/ocaml/trunk/**
> parsing/ast_mapper.mli?view=**markup<http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/trunk/parsing/ast_mapper.mli?view=markup>
>
> For instance, let_ is defined very cleverly as:
>
> let mk ?(loc = Location.none) x = {pexp_desc = x; pexp_loc = loc}
> ...
> let let_ ?loc a b c = mk ?loc (Pexp_let (a, b, c))
>
> There is absolutely no magic.
>
> First, I guess most people will seldom write ppx, and they have to
remember all those function names for once use a year. Quosi-quotation is
so intuitive that you don't need remember anything.

Second, as I said, quosi-quotation works so nice with IDE or Emacs, since
you can expand code any time you want, just one key binding, the expanded
code just show up in my emacs buffer, the experience is exactly the same as
slime in lisp, it's impossible to expand the code using arbitrary functions.

Third, this way to construct code is very limited, think about how you
encode the ast, "{:expr| {:expr| a + b|} |}"


> This is a valid point, and I believe there would not be any strong
> opposition to move some desugaring logic from parser.mly into the
> typechecker, i.e. make Parsetree look more like a parse tree than an AST.
>
> That said, I've no idea what
>
>  `Bigarray (a,b,c)
>
> means.

In Fan, the transformation between concrete syntax and abstract syntax is
bijective(at least the design goal), so there is no ambiguity here, but for
parsetree, it's hard to draw a line here, if you prevent all the syntax
desguaring, that might introduces too much unnecessary complexity for the
type checker

>
>
>
> Will you introduce in Fan the notion of attributes attached to every
> possible category and represented explicitly in the (Fan) AST?  I thought
> you only had the intention to extend the syntax of OCaml with a single
> construct {:xxx| ... |}  with  .... being left unparsed.  I don't see how
> you can simulate "ignorable attributes" with that. Can you elaborate?
>
> I am pretty open-minded here, actually I thought it for a while, I am more
inclined to do this in the parsing stage by providing some plugins without
cluttering the ast too much.

>
>
> Alain
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130207/1fc6fd85/attachment-0001.html>

From bobzhang1988 at gmail.com  Thu Feb  7 20:17:13 2013
From: bobzhang1988 at gmail.com (Hongbo Zhang)
Date: Thu, 07 Feb 2013 15:17:13 -0500
Subject: [wg-camlp4] [Caml-list] Working Group: the future of syntax
 extensions in OCaml, after camlp4
In-Reply-To: <51077DEC.5060109@frisch.fr>
References: <1359407533.10634.8@samsung> <51077DEC.5060109@frisch.fr>
Message-ID: <51140BC9.1060300@gmail.com>

On 1/29/13 2:44 AM, Alain Frisch wrote:
>
> Let me throw a crazy idea: maybe we could merge the grammar for 
> patterns and expressions, and let the type checker reject bad patterns 
> and bad expressions from this more admissible class. This would give 
> plenty of space for extensions.
>
This is not a crazy idea, it's a beautiful idea, In Fan, we make expr 
and patt symmetric, and defined a new type
expr_patt which is a subtype of both expr and patt(thanks to polymorphic 
variants), it seems that the  Ast lifting only need expr_patt, so the 
part [meta_expr] and [meta_patt] can be shared, which gives much more 
precise type information than the normal sum types, it's so beautiful, XD
>
>
>>>
>>
>>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From thomas at ocamlpro.com  Thu Feb  7 20:39:39 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Thu, 7 Feb 2013 21:39:39 +0100
Subject: [wg-camlp4] benchmarks
Message-ID: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>

Hi all,

In my opinion as a *user* of camlp4, the main pitfall that I can see (and which has not yet been addressed) is that it is really slowing down the compilation process. To improve that, the usual methods are:
1. to use native syntax extensions
2. to statically link the syntax extensions into one preprocessor binary

Currently, 1. is very broken  (natdynlink doesn't work on all platforms and most of the syntax packages do not install their native libraries anyway) and 2. is not very flexible because of lack of tooling, and so very rarely used.

So, if we decide to switch to a new preprocessing tool, I guess it's important to get these hings right:
* it should be easy enough for external tools to statically build pre-processors.
* the new preprocessor should be benchmarked on realistic examples to see how much time we gain vs. camlp4. A good example might be mirage which is using only pa_lwt and cstruct (or xen-api which is using only ocaml-rpc, or core but that maybe too much syntax in one go).

Best,
Thomas
PS: I'm not speaking about the bootstraping time of camlp4, which is indeed very painful, but which doesn't really affect the end-user once the compiler is installed.

From info at gerd-stolpmann.de  Thu Feb  7 21:22:51 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Thu, 07 Feb 2013 22:22:51 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com> (from
 thomas@ocamlpro.com on Thu Feb  7 21:39:39 2013)
Message-ID: <1360272171.18230.10@samsung>

Am 07.02.2013 21:39:39 schrieb(en) Thomas Gazagnaire:
> Hi all,
> 
> In my opinion as a *user* of camlp4, the main pitfall that I can see  
> (and which has not yet been addressed) is that it is really slowing  
> down the compilation process. To improve that, the usual methods are:
> 1. to use native syntax extensions
> 2. to statically link the syntax extensions into one preprocessor  
> binary

Well, Alain started with the suggestion to run all preprocessors as  
separate binaries. Of course, if you have many preprocessors or many  
files to preprocess, this will become slow. Under the most common  
assumption, though, namely that only a few files need preprocessing at  
all, this is no problem, and certainly the most flexible option.

Regarding dynloading. First, it's not only that native dynloading does  
not work on all platforms. Worse, not even bytecode dynloading works  
everywhere when it comes to loading external C libraries (which may be  
required here and there). Because of this, we should design without  
dynloading in mind, and at most consider this as an accelarator that is  
available on certain platforms only.

In my opinion, there should be ppx drivers (= something that turns a  
preprocessor into a program suited for -ppx). The simple default driver  
just pipes the parsetree through the preprocessors, and these are  
running as subprocesses. But it should also be possible to link a  
custom ppx driver for the not-so-frequent cases that the preprocessors  
are needed often. And finally, there could also be a ppx driver that  
dynloads.

I guess the details are not so complicated to figure out (e.g. define a  
module type a ppx preprocessor must satisfy, and have some utilities to  
"make this a program", "make this a dynloadable extension", and "bind  
several ppx processors together").

> Currently, 1. is very broken  (natdynlink doesn't work on all  
> platforms and most of the syntax packages do not install their native  
> libraries anyway) and 2. is not very flexible because of lack of  
> tooling, and so very rarely used.
> 
> So, if we decide to switch to a new preprocessing tool, I guess it's  
> important to get these hings right:
> * it should be easy enough for external tools to statically build  
> pre-processors.
> * the new preprocessor should be benchmarked on realistic examples to  
> see how much time we gain vs. camlp4. A good example might be mirage  
> which is using only pa_lwt and cstruct (or xen-api which is using  
> only ocaml-rpc, or core but that maybe too much syntax in one go).

Fully agreed to both points.

Gerd

> 
> Best,
> Thomas
> PS: I'm not speaking about the bootstraping time of camlp4, which is  
> indeed very painful, but which doesn't really affect the end-user  
> once the compiler is installed.
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From bobzhang1988 at gmail.com  Thu Feb  7 21:29:43 2013
From: bobzhang1988 at gmail.com (Hongbo Zhang)
Date: Thu, 07 Feb 2013 16:29:43 -0500
Subject: [wg-camlp4] benchmarks
In-Reply-To: <1360272171.18230.10@samsung>
References: <1360272171.18230.10@samsung>
Message-ID: <51141CC7.60201@gmail.com>

On 2/7/13 4:22 PM, Gerd Stolpmann wrote:
> Am 07.02.2013 21:39:39 schrieb(en) Thomas Gazagnaire:
>> Hi all,
>>
>> In my opinion as a *user* of camlp4, the main pitfall that I can see 
>> (and which has not yet been addressed) is that it is really slowing 
>> down the compilation process. To improve that, the usual methods are:
>> 1. to use native syntax extensions
>> 2. to statically link the syntax extensions into one preprocessor binary
>
Fan encourages static linking to native code, that's to say "linking all 
your plugins as much as possible", unlike p4 the linking does not have 
any side effects, it registers the features it could provide,  each file 
itself tells what features it want to use.
> Well, Alain started with the suggestion to run all preprocessors as 
> separate binaries. Of course, if you have many preprocessors or many 
> files to preprocess, this will become slow. Under the most common 
> assumption, though, namely that only a few files need preprocessing at 
> all, this is no problem, and certainly the most flexible option.
>
> Regarding dynloading. First, it's not only that native dynloading does 
> not work on all platforms. Worse, not even bytecode dynloading works 
> everywhere when it comes to loading external C libraries (which may be 
> required here and there). Because of this, we should design without 
> dynloading in mind, and at most consider this as an accelarator that 
> is available on certain platforms only.
>
> In my opinion, there should be ppx drivers (= something that turns a 
> preprocessor into a program suited for -ppx). The simple default 
> driver just pipes the parsetree through the preprocessors, and these 
> are running as subprocesses. But it should also be possible to link a 
> custom ppx driver for the not-so-frequent cases that the preprocessors 
> are needed often. And finally, there could also be a ppx driver that 
> dynloads.
>
> I guess the details are not so complicated to figure out (e.g. define 
> a module type a ppx preprocessor must satisfy, and have some utilities 
> to "make this a program", "make this a dynloadable extension", and 
> "bind several ppx processors together").
>
>> Currently, 1. is very broken  (natdynlink doesn't work on all 
>> platforms and most of the syntax packages do not install their native 
>> libraries anyway) and 2. is not very flexible because of lack of 
>> tooling, and so very rarely used.
>>
>> So, if we decide to switch to a new preprocessing tool, I guess it's 
>> important to get these hings right:
>> * it should be easy enough for external tools to statically build 
>> pre-processors.
>> * the new preprocessor should be benchmarked on realistic examples to 
>> see how much time we gain vs. camlp4. A good example might be mirage 
>> which is using only pa_lwt and cstruct (or xen-api which is using 
>> only ocaml-rpc, or core but that maybe too much syntax in one go).
>
> Fully agreed to both points.
>
> Gerd
>
>>
>> Best,
>> Thomas
>> PS: I'm not speaking about the bootstraping time of camlp4, which is 
>> indeed very painful, but which doesn't really affect the end-user 
>> once the compiler is installed.
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>>
>>
>
>
>


From yminsky at janestreet.com  Fri Feb  8 01:18:23 2013
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 7 Feb 2013 20:18:23 -0500
Subject: [wg-camlp4] benchmarks
In-Reply-To: <1360272171.18230.10@samsung>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <1360272171.18230.10@samsung>
Message-ID: <CACLX4jQE-=8Kk8bjfncLFNrwv+UCi2X_KCOeyJrUJoze7O8FmQ@mail.gmail.com>

On Thu, Feb 7, 2013 at 4:22 PM, Gerd Stolpmann <info at gerd-stolpmann.de> wrote:
> Am 07.02.2013 21:39:39 schrieb(en) Thomas Gazagnaire:
>
>> Hi all,
>>
>> In my opinion as a *user* of camlp4, the main pitfall that I can see (and
>> which has not yet been addressed) is that it is really slowing down the
>> compilation process. To improve that, the usual methods are:
>> 1. to use native syntax extensions
>> 2. to statically link the syntax extensions into one preprocessor binary
>
>
> Well, Alain started with the suggestion to run all preprocessors as separate
> binaries. Of course, if you have many preprocessors or many files to
> preprocess, this will become slow. Under the most common assumption, though,
> namely that only a few files need preprocessing at all, this is no problem,
> and certainly the most flexible option.

I'm not sure this should be the basic assumption.  At Jane Street,
essentially all of our files are processed by camlp4.  Extensions like
sexplib and camlp4 are at their best when used fairly pervasively.

That said, I could easily imagine that we would build a single, fast
binary that combined all of our transformations into one, if that
turns out to be a bottleneck.

> Regarding dynloading. First, it's not only that native dynloading does not
> work on all platforms. Worse, not even bytecode dynloading works everywhere
> when it comes to loading external C libraries (which may be required here
> and there). Because of this, we should design without dynloading in mind,
> and at most consider this as an accelarator that is available on certain
> platforms only.
>
> In my opinion, there should be ppx drivers (= something that turns a
> preprocessor into a program suited for -ppx). The simple default driver just
> pipes the parsetree through the preprocessors, and these are running as
> subprocesses. But it should also be possible to link a custom ppx driver for
> the not-so-frequent cases that the preprocessors are needed often. And
> finally, there could also be a ppx driver that dynloads.
>
> I guess the details are not so complicated to figure out (e.g. define a
> module type a ppx preprocessor must satisfy, and have some utilities to
> "make this a program", "make this a dynloadable extension", and "bind
> several ppx processors together").
>
>
>> Currently, 1. is very broken  (natdynlink doesn't work on all platforms
>> and most of the syntax packages do not install their native libraries
>> anyway) and 2. is not very flexible because of lack of tooling, and so very
>> rarely used.
>>
>> So, if we decide to switch to a new preprocessing tool, I guess it's
>> important to get these hings right:
>> * it should be easy enough for external tools to statically build
>> pre-processors.
>> * the new preprocessor should be benchmarked on realistic examples to see
>> how much time we gain vs. camlp4. A good example might be mirage which is
>> using only pa_lwt and cstruct (or xen-api which is using only ocaml-rpc, or
>> core but that maybe too much syntax in one go).
>
>
> Fully agreed to both points.
>
> Gerd
>
>
>>
>> Best,
>> Thomas
>> PS: I'm not speaking about the bootstraping time of camlp4, which is
>> indeed very painful, but which doesn't really affect the end-user once the
>> compiler is installed.
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>>
>>
>
>
>
> --
> ------------------------------------------------------------
> Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
> Creator of GODI and camlcity.org.
> Contact details:        http://www.camlcity.org/contact.html
> Company homepage:       http://www.gerd-stolpmann.de
> ------------------------------------------------------------
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From alain.frisch at lexifi.com  Fri Feb  8 06:13:20 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 08 Feb 2013 07:13:20 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
Message-ID: <51149780.1010302@lexifi.com>

On 2/7/2013 9:39 PM, Thomas Gazagnaire wrote:
> In my opinion as a *user* of camlp4, the main pitfall that I can see
> (and which has not yet been addressed) is that it is really slowing
> down the compilation process.
 >
> So, if we decide to switch to a new preprocessing tool, I guess it's important to get these hings right:
> * it should be easy enough for external tools to statically build pre-processors.
> * the new preprocessor should be benchmarked on realistic examples to see how much time we gain vs. camlp4. A good example might be mirage which is using only pa_lwt and cstruct (or xen-api which is using only ocaml-rpc, or core but that maybe too much syntax in one go).

It is certainly a good idea to do some benchmarks with the -ppx, I'll 
try to find some time to do so.

*If* performance is not satisfactory,  one should then identify the 
respective contributions of:

  1. Marshaling / demarshaling AST on the process boundaries.
  2. Spawning new processes.
  3. Traversing the AST with the ast_mapper class (overhead of method 
dispatch) and rebuilding a new AST in memory.

I doubt 3 would be a problem even with a lot of ppx rewriters, 
especially because they can be native code programs on platforms which 
support ocamlopt (even if native dynlink is not supported). *If* 1 or 2 
become a bottleneck,  one should indeed consider ways to avoid them.

The current version of ast_mapper:

http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/trunk/parsing/ast_mapper.mli?view=markup

provides a very simple "registration" API:

=========================================================================
val register_function: (string -> (string list -> mapper) -> unit) ref

val register: string -> (string list -> #mapper) -> unit

     (** Apply the [register_function].  The default behavior is to run
         the mapper immediately, taking arguments from the process
         command line.  This is to support a scenario where a mapper is
         linked as a stand-alone executable.

         It is possible to overwrite the [register_function] to define
         "-ppx drivers", which combine several mappers in a single
         process.  Typically, a driver starts by defining
         [register_function] to a custom implementation, then lets ppx
         rewriters (linked statically or dynamically) register
         themselves, and then run all or some of them.  It is also
         possible to have -ppx drivers apply rewriters to only specific
         parts of an AST.  *)
=========================================================================

The main program of a typical ppx tool would look like:


let mapper _args =
    object
       inherit Ast_mapper.mapper
       method! expr = ...
    end

let () = Ast_mapper.register "foo" mapper


When linked as a stand-alone program, this produces something which can 
be readily used as a -ppx rewriter.  But it is also possible to create 
"ppx drivers" which link code as above statically or dynamically (and 
then decide to run it or not).  It would even be possible to provide a 
hook in the compiler so as to make it possible (through compiler-libs) 
to link statically custom versions of ocamldep.opt / ocamlc.opt / 
ocamlopt.opt with statically linked "ppx rewriters" (avoiding any 
marshaling of the AST or any extra process).  I can imagine that for 
huge code base, this could be considered.


Alain

From alain.frisch at lexifi.com  Fri Feb  8 06:15:44 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Fri, 08 Feb 2013 07:15:44 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <51149780.1010302@lexifi.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com>
Message-ID: <51149810.7020502@lexifi.com>

On 2/8/2013 7:13 AM, Alain Frisch wrote:
>   1. Marshaling / demarshaling AST on the process boundaries.
>   2. Spawning new processes.
>   3. Traversing the AST with the ast_mapper class (overhead of method
> dispatch) and rebuilding a new AST in memory.

I forgot:

4. Passing marshaled AST through temporary files.


This is the most portable solution, and the only available with the 
standard library, but one could certainly do better under certain platforms.

-- Alain

From alain.frisch at lexifi.com  Mon Feb 11 10:06:48 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 11 Feb 2013 11:06:48 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <51149780.1010302@lexifi.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com>
Message-ID: <5118C2B8.4070807@lexifi.com>

On 02/08/2013 07:13 AM, Alain Frisch wrote:
> It is certainly a good idea to do some benchmarks with the -ppx, I'll
> try to find some time to do so.

Here we go.

I've done some timings for compiling typing/typecore.ml from the OCaml 
distribution with ocamlopt.opt, applying the sedlex AST mapper several 
times.

0.43s  ocamlopt.opt, no ppx
0.73s  ocamlopt.opt, 10 -ppx sedlex rewriters
0.98s  ocamlopt.opt, 20 -ppx sedlex rewriters
1.70s  ocamlopt.opt, 40 -ppx sedlex rewriters
0.54s  ocamlopt.opt, sedlex dynlinked by ppx_driver and run 10 times
0.58s  ocamlopt.opt, sedlex dynlinked by ppx_driver and run 20 times
0.68s  ocamlopt.opt, sedlex dynlinked by ppx_driver and run 40 times
0.84s  ocamlopt.opt, sedlex dynlinked by ppx_driver and run 80 times

0.57s  ocamlopt.opt, sedlex dynlinked by ppx_driver and run 80 times, 
with OCAMLRUNPARAM=s=32M (for ppx_driver only, not ocamlopt.opt itself)
0.45s  ocamlopt.opt, sedlex dynlinked by ppx_driver and run 80 times, 
with OCAMLRUNPARAM=s=32M for both ppx_driver and ocamlopt.opt itself

(Timings are user time, averaged over 5 runs, on a Linux 64-bit system. 
  Variance is quite high, though, so this should be taken with a grain 
of salt.)

Note: ppx_driver dynlinks sedlex.cmxs only once and runs it N times.
For big values of N, this gives a performance profile similar to static 
linking.

Intepretation:

- Running AST rewriters as independent processes adds about 7% of 
compilation time with ocamlopt.opt
- If we run a single process without marshaling the AST between 
rewriters, the marginal cost goes below 1% per rewriter.  (This is, 
basically, the cost of iterating over the AST with objects, matching 
over each expression to find extension "markers", and rebuilding a deep 
copy of the AST.)
- This can be reduced a lot with proper configuration of the GC (down to 
about 0.3% of compilation time with ocamlopt.opt, with the same GC config).
- It would be interesting to do some timings when dynlinking a lot of 
different .cmxs plugins in ppx_drivers.

(If we link the rewriters statically with a custom version of the 
compiler itself, assuming a new hook in the compiler allows to plug AST 
rewriter, we would only pay the marginal cost < 1%.)

For a code base like Jane Street's where many "extensions" have to be 
used everywhere, I suspect that the "independent" ppx processes might 
become an issue (or maybe not, if compared to camlp4), but the following 
solutions would work:

  - Statically linking a "big rewriter" called with -ppx.
  - Statically linking a version of ocamlopt.opt + all rewriters.
  - Dynamically linking all rewriters with a single ppx driver (to be 
confirmed, there would be a small overhead for the dynamic linking 
itself in addition to the 0.3% marginal cost above).




Alain

From alain.frisch at lexifi.com  Mon Feb 11 10:28:05 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 11 Feb 2013 11:28:05 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <CANcqPu6HjyvpRSG5AOiYEPnLYjeJwT2iTL6gV_MtO45L_UUDtA@mail.gmail.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
 <51137D59.7050308@lexifi.com>
 <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>
 <5113D846.3080703@lexifi.com>
 <CANcqPu6HjyvpRSG5AOiYEPnLYjeJwT2iTL6gV_MtO45L_UUDtA@mail.gmail.com>
Message-ID: <5118C7B5.8010309@lexifi.com>

On 02/07/2013 08:50 PM, Hongbo Zhang wrote:
> On Thu, Feb 7, 2013 at 11:37 AM, Alain Frisch <alain.frisch at lexifi.com
> <mailto:alain.frisch at lexifi.com>> wrote:
>     I don't follow. We are talking, basically, about adding simple
>     constructions to the AST, like:
>
>        Pexp_annotation of expression * expression
>        Pexp_extension of string * expression
>
>     and you were suggesting that this would almost kill Camlp4/Fan. Why?
>
> The problem is that I am a bit unclear how to encode them in the
> meta-level, since the introduced constructs will not be consumed by the
> type checker, they are provided for the convenience of ppx, but does not
> exist in real world.  I think camlp5 and Coq maintainers will also
> appreciate that we are a bit conservative in the compiler part.

Again, I'm lost.  Why is that difficult to support the suggested 
extensions to the grammar of OCaml in camlp4/camlp4/fan?  The fact that 
attributes are ignored (or propagated) by the type-checker does not 
change anything: Pexp_annotation is just like a binary operator from a 
syntactic point of view.  And what has Coq to do with it?

> First, I guess most people will seldom write ppx, and they have to
> remember all those function names for once use a year. Quosi-quotation
> is so intuitive that you don't need remember anything.

Yes, to write (robust) code generators or transformers, you need to know 
about the OCaml AST.  I suspect most people who have written Camlp4 
extensions are somehow familiar with the OCaml parse tree.  And we 
should make the Parsetree more accessible:

  - Clean up some of its rough edges (or introduce a variant of 
Parsetree which looks more like a parse tree than an AST; I'm not 
completely decided on that point yet).

  - Provide a tool / compiler command-line option to dump a fragment of 
parsed source code in "Parsetree" syntax (as discussed with X. Clerc on 
this list).



> Second, as I said, quosi-quotation works so nice with IDE or Emacs,
> since you can expand code any time you want, just one key binding, the
> expanded code just show up in my emacs buffer

Could you clarify how this would work?  My understanding of quotations 
in Fan is still that they should be completely ignored by editors, 
because you can put arbitrary syntax in them, so it doesn't make sense 
to apply OCaml "rules" (coloring, indentation, folding, etc) to them.


> Third, this way to construct code is very limited, think about how you
> encode the ast, "{:expr| {:expr| a + b|} |}"

It's a good example of something I've never wanted to do and which is 
not required to implement any of the "extensions" I'd be interested to use.



Regards,

Alain

From anil at recoil.org  Mon Feb 11 10:31:15 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 11 Feb 2013 10:31:15 +0000
Subject: [wg-camlp4] benchmarks
In-Reply-To: <5118C2B8.4070807@lexifi.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
Message-ID: <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>

On 11 Feb 2013, at 10:06, Alain Frisch <alain.frisch at lexifi.com> wrote:
> 
> For a code base like Jane Street's where many "extensions" have to be used everywhere, I suspect that the "independent" ppx processes might become an issue (or maybe not, if compared to camlp4), but the following solutions would work:
> 
> - Statically linking a "big rewriter" called with -ppx.

This worked well in the case of Mirage; in the monolithic repository, we link together all the camlp4 extensions into a single big one, and invoke that across all files.

It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).

There's also the advantage in camlp4 that this checks that syntax extensions do not conflict. This is less of an issue with ppx, thankfully.

-anil

From gabriel.scherer at gmail.com  Mon Feb 11 10:45:57 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 11 Feb 2013 11:45:57 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
Message-ID: <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>

On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).

That's of course rather orthogonal to the present discussion, but have
you been in contact with Gerd to see if some caching solution would be
possible? Intuitively it feels like ocamlfind could easily maintain a
cache in /var/run/blah and only clean it on install/remove commands.

(An external process invocation would still make some overhead so in
you're case you'd still have to go all the way, but that could improve
the threshold at which such ~hacks become interesting.)

On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On 11 Feb 2013, at 10:06, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>
>> For a code base like Jane Street's where many "extensions" have to be used everywhere, I suspect that the "independent" ppx processes might become an issue (or maybe not, if compared to camlp4), but the following solutions would work:
>>
>> - Statically linking a "big rewriter" called with -ppx.
>
> This worked well in the case of Mirage; in the monolithic repository, we link together all the camlp4 extensions into a single big one, and invoke that across all files.
>
> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).
>
> There's also the advantage in camlp4 that this checks that syntax extensions do not conflict. This is less of an issue with ppx, thankfully.
>
> -anil
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From gabriel.scherer at gmail.com  Mon Feb 11 10:49:13 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 11 Feb 2013 11:49:13 +0100
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <5118C7B5.8010309@lexifi.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
 <51137D59.7050308@lexifi.com>
 <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>
 <5113D846.3080703@lexifi.com>
 <CANcqPu6HjyvpRSG5AOiYEPnLYjeJwT2iTL6gV_MtO45L_UUDtA@mail.gmail.com>
 <5118C7B5.8010309@lexifi.com>
Message-ID: <CAPFanBEwXbjhkViVi-NW9pmH_5hW9+vqz7zZY-2r3WP2B+39KQ@mail.gmail.com>

On Mon, Feb 11, 2013 at 11:28 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>  - Clean up some of its rough edges (or introduce a variant of Parsetree
> which looks more like a parse tree than an AST; I'm not completely decided
> on that point yet).

Independently of whether we use a separate AST format for syntax
extensions to work on, I have concluded from the -bin-annot work that
we want the surface information to be maintained until the typetree if
possible in a non-invasive way (which enables the promise of doing
typedtree-level manipulation in a way that can be explained back to
the user in terms of her code), so I'm interested in the "keep more
concrete syntax details"-kind of changes bubbling up to the parsetree
and typedtree.

On Mon, Feb 11, 2013 at 11:28 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
> On 02/07/2013 08:50 PM, Hongbo Zhang wrote:
>>
>> On Thu, Feb 7, 2013 at 11:37 AM, Alain Frisch <alain.frisch at lexifi.com
>> <mailto:alain.frisch at lexifi.com>> wrote:
>>     I don't follow. We are talking, basically, about adding simple
>>     constructions to the AST, like:
>>
>>        Pexp_annotation of expression * expression
>>        Pexp_extension of string * expression
>>
>>     and you were suggesting that this would almost kill Camlp4/Fan. Why?
>>
>> The problem is that I am a bit unclear how to encode them in the
>> meta-level, since the introduced constructs will not be consumed by the
>> type checker, they are provided for the convenience of ppx, but does not
>> exist in real world.  I think camlp5 and Coq maintainers will also
>> appreciate that we are a bit conservative in the compiler part.
>
>
> Again, I'm lost.  Why is that difficult to support the suggested extensions
> to the grammar of OCaml in camlp4/camlp4/fan?  The fact that attributes are
> ignored (or propagated) by the type-checker does not change anything:
> Pexp_annotation is just like a binary operator from a syntactic point of
> view.  And what has Coq to do with it?
>
>
>> First, I guess most people will seldom write ppx, and they have to
>> remember all those function names for once use a year. Quosi-quotation
>> is so intuitive that you don't need remember anything.
>
>
> Yes, to write (robust) code generators or transformers, you need to know
> about the OCaml AST.  I suspect most people who have written Camlp4
> extensions are somehow familiar with the OCaml parse tree.  And we should
> make the Parsetree more accessible:
>
>  - Clean up some of its rough edges (or introduce a variant of Parsetree
> which looks more like a parse tree than an AST; I'm not completely decided
> on that point yet).
>
>  - Provide a tool / compiler command-line option to dump a fragment of
> parsed source code in "Parsetree" syntax (as discussed with X. Clerc on this
> list).
>
>
>
>
>> Second, as I said, quosi-quotation works so nice with IDE or Emacs,
>> since you can expand code any time you want, just one key binding, the
>> expanded code just show up in my emacs buffer
>
>
> Could you clarify how this would work?  My understanding of quotations in
> Fan is still that they should be completely ignored by editors, because you
> can put arbitrary syntax in them, so it doesn't make sense to apply OCaml
> "rules" (coloring, indentation, folding, etc) to them.
>
>
>
>> Third, this way to construct code is very limited, think about how you
>> encode the ast, "{:expr| {:expr| a + b|} |}"
>
>
> It's a good example of something I've never wanted to do and which is not
> required to implement any of the "extensions" I'd be interested to use.
>
>
>
> Regards,
>
>
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From anil at recoil.org  Mon Feb 11 10:56:52 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 11 Feb 2013 10:56:52 +0000
Subject: [wg-camlp4] benchmarks
In-Reply-To: <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
Message-ID: <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>

On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).
> 
> That's of course rather orthogonal to the present discussion, but have
> you been in contact with Gerd to see if some caching solution would be
> possible? Intuitively it feels like ocamlfind could easily maintain a
> cache in /var/run/blah and only clean it on install/remove commands.
> 
> (An external process invocation would still make some overhead so in
> you're case you'd still have to go all the way, but that could improve
> the threshold at which such ~hacks become interesting.)

I don't think it's necessary to put this in ocamlfind, which does the job
it's designed to do very well. Just fix your build systems to run ocamlfind
at configure time, save the results, and apply them to the compiler flags
during the build phase.

-anil


From gabriel.scherer at gmail.com  Mon Feb 11 12:20:47 2013
From: gabriel.scherer at gmail.com (Gabriel Scherer)
Date: Mon, 11 Feb 2013 13:20:47 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
Message-ID: <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>

On the other hand, build systems come and go (and ./configure is like
the most horrible part to add logic to in most cases), while ocamlfind
has proved a reliable tool as a basis for any OCaml ecosystem so far.
If I can shelve some logic there without making the tool more complex
or less elegant I think that would be better for everyone.

On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
>
>> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).
>>
>> That's of course rather orthogonal to the present discussion, but have
>> you been in contact with Gerd to see if some caching solution would be
>> possible? Intuitively it feels like ocamlfind could easily maintain a
>> cache in /var/run/blah and only clean it on install/remove commands.
>>
>> (An external process invocation would still make some overhead so in
>> you're case you'd still have to go all the way, but that could improve
>> the threshold at which such ~hacks become interesting.)
>
> I don't think it's necessary to put this in ocamlfind, which does the job
> it's designed to do very well. Just fix your build systems to run ocamlfind
> at configure time, save the results, and apply them to the compiler flags
> during the build phase.
>
> -anil
>

From hongboz at seas.upenn.edu  Mon Feb 11 13:41:23 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 11 Feb 2013 08:41:23 -0500
Subject: [wg-camlp4] Time for a summary?
In-Reply-To: <5118C7B5.8010309@lexifi.com>
References: <CACLX4jQVFgC1DCXxgCz1VorOkYXQuQsudBYWZ4XTw+QZJY5b-A@mail.gmail.com>
 <20130205150603.GV13082@three-tuns.net>
 <CACLX4jQaRxRd6DS2VJB_S6ndVLymmKgoDFJHO-GWjco4fzvv3A@mail.gmail.com>
 <Prayer.1.3.5.1302061811120.12086@hermes-1.csi.cam.ac.uk>
 <CANcqPu7QQDAwL3tTMOSbW2q5jhjtYpFF4SntH_NF336o9cOdLA@mail.gmail.com>
 <51137D59.7050308@lexifi.com>
 <CANcqPu7eG0v16GXkzz0kaQ66KLGT-sVGRTpYeVt9bHmr+eSUoA@mail.gmail.com>
 <5113D846.3080703@lexifi.com>
 <CANcqPu6HjyvpRSG5AOiYEPnLYjeJwT2iTL6gV_MtO45L_UUDtA@mail.gmail.com>
 <5118C7B5.8010309@lexifi.com>
Message-ID: <CANcqPu4+SW26QKB+dk0F+sOV8XGPhkxPyPBbxVZfBTY0cFyRvQ@mail.gmail.com>

On Mon, Feb 11, 2013 at 5:28 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

> On 02/07/2013 08:50 PM, Hongbo Zhang wrote:
>
>>
>> Again, I'm lost.  Why is that difficult to support the suggested
> extensions to the grammar of OCaml in camlp4/camlp4/fan?  The fact that
> attributes are ignored (or propagated) by the type-checker does not change
> anything: Pexp_annotation is just like a binary operator from a syntactic
> point of view.  And what has Coq to do with it?
>
> The grammar parser (the same as stream parser) relies on quasi-quotation.
Though I do not know how camlp5 implemented it, but I think they have a
similar implementation. (coq depends on p5)

>
>  First, I guess most people will seldom write ppx, and they have to
>> remember all those function names for once use a year. Quosi-quotation
>> is so intuitive that you don't need remember anything.
>>
>
> Yes, to write (robust) code generators or transformers, you need to know
> about the OCaml AST.  I suspect most people who have written Camlp4
> extensions are somehow familiar with the OCaml parse tree.  And we should
> make the Parsetree more accessible:
>
>  - Clean up some of its rough edges (or introduce a variant of Parsetree
> which looks more like a parse tree than an AST; I'm not completely decided
> on that point yet).
>
>  - Provide a tool / compiler command-line option to dump a fragment of
> parsed source code in "Parsetree" syntax (as discussed with X. Clerc on
> this list).
>
> This is a hack, it may help you to write, but does not help you to read
the code.

>
>
>
>  Second, as I said, quosi-quotation works so nice with IDE or Emacs,
>> since you can expand code any time you want, just one key binding, the
>> expanded code just show up in my emacs buffer
>>
>
> Could you clarify how this would work?  My understanding of quotations in
> Fan is still that they should be completely ignored by editors, because you
> can put arbitrary syntax in them, so it doesn't make sense to apply OCaml
> "rules" (coloring, indentation, folding, etc) to them.

Suppose you embed arbitrary functions to construct the ast,

"E.let_ (E.appfun_ ...)"
If you select the region, the IDE does not know how to expand this region
to view the expanded code.

For quosi-quotaiton, instead
"let a = fun b -> c"
The ide knows how to expanded this part of code to visualize its AST.

>
>
>
>  Third, this way to construct code is very limited, think about how you
>> encode the ast, "{:expr| {:expr| a + b|} |}"
>>
>
> It's a good example of something I've never wanted to do and which is not
> required to implement any of the "extensions" I'd be interested to use.
>
> Sometimes the fact people never think about to do something is due to the
current tool they use does not provide such ability. Nested quotation is a
 common idiom for meta programming

>
>
> Regards,
>
> Alain
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130211/8aa5404a/attachment.html>

From hongboz at seas.upenn.edu  Mon Feb 11 14:07:35 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 11 Feb 2013 09:07:35 -0500
Subject: [wg-camlp4] benchmarks
In-Reply-To: <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
 <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
Message-ID: <CANcqPu79E86_oG9z=SEk7RuKn_DOd=MO7PEXkDR_ykAF8TTz6g@mail.gmail.com>

Some statistics about Fan.

Fan has a mirror directory cold which shares the same structure as src,
it's the expanded code of src for distribution

For the user time
ocamlbuild cold/FanDriver.native
user 0m28.494s
ocamlbuild src/FanDriver.native
user 0m30.680s
For the system time
the cold directory takes
sys 0m3.843s
while the src directory takes
sys 0m4.657s


On Mon, Feb 11, 2013 at 7:20 AM, Gabriel Scherer
<gabriel.scherer at gmail.com>wrote:

> On the other hand, build systems come and go (and ./configure is like
> the most horrible part to add logic to in most cases), while ocamlfind
> has proved a reliable tool as a basis for any OCaml ecosystem so far.
> If I can shelve some logic there without making the tool more complex
> or less elegant I think that would be better for everyone.
>
> On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com>
> wrote:
> >
> >> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> >>> It should work just fine with ppx, and has the advantage of reducing
> the number of ocamlfind calls per-file (which is a considerable overhead on
> large projects, since it has to scan the META directories on every
> invocation).
> >>
> >> That's of course rather orthogonal to the present discussion, but have
> >> you been in contact with Gerd to see if some caching solution would be
> >> possible? Intuitively it feels like ocamlfind could easily maintain a
> >> cache in /var/run/blah and only clean it on install/remove commands.
> >>
> >> (An external process invocation would still make some overhead so in
> >> you're case you'd still have to go all the way, but that could improve
> >> the threshold at which such ~hacks become interesting.)
> >
> > I don't think it's necessary to put this in ocamlfind, which does the job
> > it's designed to do very well. Just fix your build systems to run
> ocamlfind
> > at configure time, save the results, and apply them to the compiler flags
> > during the build phase.
> >
> > -anil
> >
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130211/98d0cf0a/attachment.html>

From anil at recoil.org  Mon Feb 11 14:30:35 2013
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 11 Feb 2013 14:30:35 +0000
Subject: [wg-camlp4] benchmarks
In-Reply-To: <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
 <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
Message-ID: <DEF6D517-15E2-4C72-94B3-09DC4E3D6CE6@recoil.org>

Fix the underlying problem.  There are several build system efforts ongoing
at the moment from various folk at JSC/Citrix/other, and we need to tackle
that problem head-on.

There'll be a wg-build mailing list next month, after some preparatory work
has been done by the people involved.  It's fairly off-topic for this list,
so I'll defer further discussion until then.

-anil

On 11 Feb 2013, at 12:20, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:

> On the other hand, build systems come and go (and ./configure is like
> the most horrible part to add logic to in most cases), while ocamlfind
> has proved a reliable tool as a basis for any OCaml ecosystem so far.
> If I can shelve some logic there without making the tool more complex
> or less elegant I think that would be better for everyone.
> 
> On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
>> 
>>> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).
>>> 
>>> That's of course rather orthogonal to the present discussion, but have
>>> you been in contact with Gerd to see if some caching solution would be
>>> possible? Intuitively it feels like ocamlfind could easily maintain a
>>> cache in /var/run/blah and only clean it on install/remove commands.
>>> 
>>> (An external process invocation would still make some overhead so in
>>> you're case you'd still have to go all the way, but that could improve
>>> the threshold at which such ~hacks become interesting.)
>> 
>> I don't think it's necessary to put this in ocamlfind, which does the job
>> it's designed to do very well. Just fix your build systems to run ocamlfind
>> at configure time, save the results, and apply them to the compiler flags
>> during the build phase.
>> 
>> -anil
>> 
> 


From alain.frisch at lexifi.com  Mon Feb 11 14:45:52 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 11 Feb 2013 15:45:52 +0100
Subject: [wg-camlp4] Pending issues
Message-ID: <51190420.5080305@lexifi.com>

Dear all,

I think we have made good progress in discussing extensions to the OCaml 
grammar with generic extension points (which can be used as anchors for 
-ppx rewriters), and how existing "camlp4 extensions" could be 
re-implemented based on them.

Here is a list of questions on which I'd like to hear the opinion of 
participants.

0. Scope of extensions covered by ppx + extension points

Do people see useful camlp4 extensions which couldn't be covered in a 
satisfactory way with the ppx + extension points approach?  The only 
such cases I've seen mentioned on this list are pervasive changes to the 
syntax, where the goal is precisely to customized the concrete syntax.


1. Nature of extension points

There seems to be a consensus that we should distinguish between 
"ignorable" attributes and extension markers, to be expanded by 
rewriters (the type-checker fails on them).  Concretely, this amounts to 
extending the OCaml Parsetree with cases like:

  | Ptyp_attribute of core_type * attribute
  | Ptyp_extension of extension

  | Ppat_attribute of pattern * attribute
  | Ppat_extension of extension

  | Pmod_attribute of module_expr * attribute
  | Pmod_extension of extension

  ...

Leo suggests to take:

type attribute = expression
and extension = longident * expression option

I'm now convinced that it's a good idea to make the "extension name" 
explicit (and not encoded in the expression itself), if only to allow 
nice error messages when the type-checker fails on such a node.  I'm 
wondering if we shouldn't be more symmetric and do the same for 
attributes. Opinions?  Also, I'm not sure that the expression should be 
optional (if the idea is that the extension marker "expands" its 
content, without touching its context "too much", we need a non-trivial 
content).  One can always have a syntax which support "empty argument" 
represented as the "()" expression internally.


2. Concrete syntax for extension points

Proposals are welcome.  We must choose an unambiguous syntax, which 
allows to add an attribute on a structure item, an expression, etc.
Do we want both prefix and suffix syntaxes for attributes on all 
syntactic categories?  Do we want a special (lighter) syntax to attach 
attributes on specific constructions?


3. Quotations

The more I think about it, the more I believe this concept is orthogonal 
to "extensions".  Leo disagrees and would like to have a combined syntax 
for the case where the argument of an extension is a quotation.  What do 
other people think?  (For me, a quotation is only a way to introduce a 
string literal without "suffering" from the lexical conventions of OCaml.)

For the concrete syntax of quotations, it was suggested to use a form 
where the closing delimiter would be defined by the opening one.  This 
makes it possible to "quote" an arbitrary string without having to 
define a way to escape a potential occurrence of the closing delimiter 
(just pick a different one).   Example:  {xxx{blablabla}xxx}

Do people familiar with implementation of editor modes believe it will 
be easy to support such syntax in emacs or vim modes?


4. What to do with attributes in the type-checker

Attributes are designed in a way which make it trivial for the 
type-checker to ignore them, which is a good property.  It is not much 
more difficult to keep in the Typedtree so that they appear in 
.cmt/.cmti files.  This could support interesting tools, like an 
"ocamldoc-like" tool based on those files (instead of having to rarse 
the source file again).  What do people think about it?  Of course, this 
does not need to be implemented right away.

A related question is related to the current work on runtime types. 
Attributes on type declarations could be kept in the runtime 
representation of the declarations, allowing libraries to interpret them 
as they want.  (LexiFi's version of OCaml has been extended with 
attributes on type declarations precisely to do that.)  Having 
attributes defined as general expressions, however, means that those 
libraries would need to link with compiler-libs, or at least be compiled 
against some of its .cmi, in order to be able to analyze the Parsetree. 
  I don't see it is as a big problem, and it would also be possible to 
restrict which expressions are reflected in runtime types (e.g. to 
structured constants).  Comments are welcome!


5. Fork Parsetree or clean it up?

Hongbo has proposed that we introduce a different representation of the 
Parsetree on which -ppx rewriters would be applied.  Concretely, we 
could fork parsetree.mli into parsetree.mli/ast.mli, clean up parsetree 
(see below) and adapt parser.mly accordingly, and then implement a 
translation pass from Parsetree to Ast before running the type-checker 
on Ast.  The alternative is to clean up Parsetree directly and adapt the 
type-checker to these changes.  This avoids an extra intermediate 
language and the mapping, but this could add a little bit of extra 
complexity to the type-checker (and it might be more difficult to 
convince core developers).  What do people think?

Changes (to be discussed):

  - Avoid some desugaring currently done in the parsetree (interval 
patterns, let open M in... = M.(...) ).
  - Avoid some weird encodings (Pexp_when, mandatory Ptyp_poly at some 
places, etc).
  - Make the Parsetree more future proof and self-documented by using 
records instead of tuples, sum types instead of booleans, etc.
  - Remove prefixes on constructors/labels (although I've got some 
negative feedback from other core developers on this point).



Alain

From hongboz at seas.upenn.edu  Mon Feb 11 14:51:22 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 11 Feb 2013 09:51:22 -0500
Subject: [wg-camlp4] Pending issues
In-Reply-To: <51190420.5080305@lexifi.com>
References: <51190420.5080305@lexifi.com>
Message-ID: <CANcqPu5yEYov6Muk6sgpAX_3UyDMygsJzV5xXSYCnR1amaE_FA@mail.gmail.com>

On Mon, Feb 11, 2013 at 9:45 AM, Alain Frisch <alain.frisch at lexifi.com>wrote:

>
> 5. Fork Parsetree or clean it up?
>
> Hongbo has proposed that we introduce a different representation of the
> Parsetree on which -ppx rewriters would be applied.  Concretely, we could
> fork parsetree.mli into parsetree.mli/ast.mli, clean up parsetree (see
> below) and adapt parser.mly accordingly, and then implement a translation
> pass from Parsetree to Ast before running the type-checker on Ast.  The
> alternative is to clean up Parsetree directly and adapt the type-checker to
> these changes.  This avoids an extra intermediate language and the mapping,
> but this could add a little bit of extra complexity to the type-checker
> (and it might be more difficult to convince core developers).  What do
> people think?
>
> Hi Alain, This is great , and you have more freedom to clean up the Ast,
for example, remove the unnecessary prefix names without breaking other
existing software.

> Alain
> ______________________________**_________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/**listinfo/wg-camlp4<http://lists.ocaml.org/listinfo/wg-camlp4>
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130211/7fb30611/attachment.html>

From hongboz at seas.upenn.edu  Mon Feb 11 15:30:26 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Mon, 11 Feb 2013 10:30:26 -0500
Subject: [wg-camlp4] Pending issues
In-Reply-To: <CANcqPu5yEYov6Muk6sgpAX_3UyDMygsJzV5xXSYCnR1amaE_FA@mail.gmail.com>
References: <51190420.5080305@lexifi.com>
 <CANcqPu5yEYov6Muk6sgpAX_3UyDMygsJzV5xXSYCnR1amaE_FA@mail.gmail.com>
Message-ID: <CANcqPu6qD7YW-FmjDaQ6Ri+ALuXJrgxU9KaZPOT2HGU=0jJRbQ@mail.gmail.com>

If you clean up the ast, it could be great to make pattern and
expression symmetric for the intersection part.

For example, in Fan the intersection type is something like
--------------------------------------
  type ep =
     [= `Nil of loc
     | `Id  of (loc * ident) (* i *)
     | `App of (loc * ep * ep) (* e e *)
     | `Vrn of (loc * string)       (* `s *)
     | `Com of (loc * ep * ep)
     | `Sem of (loc * ep * ep) (* e; e *)
     | `Tup of (loc * ep)
     | `Record of (loc * rec_bind)
     | ant  | literal ]
     and rec_bind =
     [= `Nil of loc
     | `RecBind of (loc * ident * ep)
     | `Sem of (loc * rec_bind * rec_bind)
     | `Any of loc
     | ant];
--------------------------------------------------------
We benefit a lot from the subtyping  relation here (ep:>expr, ep :> patt)
On Mon, Feb 11, 2013 at 9:51 AM, Hongbo Zhang <hongboz at seas.upenn.edu> wrote:
>
>
>
> On Mon, Feb 11, 2013 at 9:45 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>>
>>
>> 5. Fork Parsetree or clean it up?
>>
>> Hongbo has proposed that we introduce a different representation of the Parsetree on which -ppx rewriters would be applied.  Concretely, we could fork parsetree.mli into parsetree.mli/ast.mli, clean up parsetree (see below) and adapt parser.mly accordingly, and then implement a translation pass from Parsetree to Ast before running the type-checker on Ast.  The alternative is to clean up Parsetree directly and adapt the type-checker to these changes.  This avoids an extra intermediate language and the mapping, but this could add a little bit of extra complexity to the type-checker (and it might be more difficult to convince core developers).  What do people think?
>>
> Hi Alain, This is great , and you have more freedom to clean up the Ast, for example, remove the unnecessary prefix names without breaking other existing software.
>>
>> Alain
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>
>
>
>
> --
> -- Regards, Hongbo




--
-- Regards, Hongbo

From info at gerd-stolpmann.de  Mon Feb 11 15:44:06 2013
From: info at gerd-stolpmann.de (Gerd Stolpmann)
Date: Mon, 11 Feb 2013 16:44:06 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 (from gabriel.scherer@gmail.com on Mon Feb 11 11:45:57 2013)
Message-ID: <1360597446.2379.2@samsung>

Am 11.02.2013 11:45:57 schrieb(en) Gabriel Scherer:
> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org>  
> wrote:
> > It should work just fine with ppx, and has the advantage of  
> reducing the number of ocamlfind calls per-file (which is a  
> considerable overhead on large projects, since it has to scan the  
> META directories on every invocation).
> 
> That's of course rather orthogonal to the present discussion, but have
> you been in contact with Gerd to see if some caching solution would be
> possible? Intuitively it feels like ocamlfind could easily maintain a
> cache in /var/run/blah and only clean it on install/remove commands.

As a system engineer I think this is overkill. ocamlfind only loads the  
META files actually needed (it does not "scan"), and loading a file  
already in the page cache is a matter of microseconds. Even when you  
have 100 packages this should be hardly noticeable. Such a cache can  
even make things worse, because loading once a large cache can be more  
costly than a few META files (simply because of the data volume).

What is probably more a problem when you have many packages: This  
generates many -I paths, and the compiler has to search for modules. I  
don't know how this is implemented, but if it is the naive way, this is  
an O(n*m) algorithm (n=number of -I directories, m=number of modules to  
look up).

Gerd


> (An external process invocation would still make some overhead so in
> you're case you'd still have to go all the way, but that could improve
> the threshold at which such ~hacks become interesting.)
> 
> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org>  
> wrote:
> > On 11 Feb 2013, at 10:06, Alain Frisch <alain.frisch at lexifi.com>  
> wrote:
> >>
> >> For a code base like Jane Street's where many "extensions" have to  
> be used everywhere, I suspect that the "independent" ppx processes  
> might become an issue (or maybe not, if compared to camlp4), but the  
> following solutions would work:
> >>
> >> - Statically linking a "big rewriter" called with -ppx.
> >
> > This worked well in the case of Mirage; in the monolithic  
> repository, we link together all the camlp4 extensions into a single  
> big one, and invoke that across all files.
> >
> > It should work just fine with ppx, and has the advantage of  
> reducing the number of ocamlfind calls per-file (which is a  
> considerable overhead on large projects, since it has to scan the  
> META directories on every invocation).
> >
> > There's also the advantage in camlp4 that this checks that syntax  
> extensions do not conflict. This is less of an issue with ppx,  
> thankfully.
> >
> > -anil
> > _______________________________________________
> > wg-camlp4 mailing list
> > wg-camlp4 at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 



-- 
------------------------------------------------------------
Gerd Stolpmann, Darmstadt, Germany    gerd at gerd-stolpmann.de
Creator of GODI and camlcity.org.
Contact details:        http://www.camlcity.org/contact.html
Company homepage:       http://www.gerd-stolpmann.de
------------------------------------------------------------

From edwin+ml-ocaml at etorok.net  Mon Feb 11 16:01:10 2013
From: edwin+ml-ocaml at etorok.net (=?ISO-8859-1?Q?T=F6r=F6k_Edwin?=)
Date: Mon, 11 Feb 2013 18:01:10 +0200
Subject: [wg-camlp4] benchmarks
In-Reply-To: <1360597446.2379.2@samsung>
References: <1360597446.2379.2@samsung>
Message-ID: <511915C6.4010509@etorok.net>

On 02/11/2013 05:44 PM, Gerd Stolpmann wrote:
> Am 11.02.2013 11:45:57 schrieb(en) Gabriel Scherer:
>> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> > It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META
>> directories on every invocation).
>>
>> That's of course rather orthogonal to the present discussion, but have
>> you been in contact with Gerd to see if some caching solution would be
>> possible? Intuitively it feels like ocamlfind could easily maintain a
>> cache in /var/run/blah and only clean it on install/remove commands.
> 
> As a system engineer I think this is overkill. ocamlfind only loads the META files actually needed (it does not "scan"), and loading a file already in the page cache is a matter of microseconds. Even
> when you have 100 packages this should be hardly noticeable. Such a cache can even make things worse, because loading once a large cache can be more costly than a few META files (simply because of the
> data volume).
> 
> What is probably more a problem when you have many packages: This generates many -I paths, and the compiler has to search for modules. I don't know how this is implemented, but if it is the naive way,
> this is an O(n*m) algorithm (n=number of -I directories, m=number of modules to look up).

Is there a reason that ocamlbuild has to spawn the compiler for each file?
Couldn't it use compiler-libs to perform the compilation directly, and re-use some of the cached information (location of modules, parsed interfaces for example)?

Also I've noticed some suboptimal behaviours with oasis+ocamlbuild+ocamlfind, would that new wg-build list be appropriate to discuss such issues (and find solutions)?
Or should I just file bugreports for the individual tools?

For example:
 - ocamlfind returning -I paths in different order (with different -tag), which caused ocamlbuild to think that the "build command" has changed, and thus rebuild files it shouldn't
 - oasis sometimes adds more -I than necessary (if two libraries share a directory)
 - oasis sometimes adds too few -I (causing interface mismatch errors between my src/ and test/ for example)
 - even when there's nothing to rebuild it takes 1-2s to say that


Best regards,
--Edwin

> 
> Gerd
> 
> 
>> (An external process invocation would still make some overhead so in
>> you're case you'd still have to go all the way, but that could improve
>> the threshold at which such ~hacks become interesting.)
>>
>> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> > On 11 Feb 2013, at 10:06, Alain Frisch <alain.frisch at lexifi.com> wrote:
>> >>
>> >> For a code base like Jane Street's where many "extensions" have to be used everywhere, I suspect that the "independent" ppx processes might become an issue (or maybe not, if compared to camlp4),
>> but the following solutions would work:
>> >>
>> >> - Statically linking a "big rewriter" called with -ppx.
>> >
>> > This worked well in the case of Mirage; in the monolithic repository, we link together all the camlp4 extensions into a single big one, and invoke that across all files.
>> >
>> > It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META
>> directories on every invocation).
>> >
>> > There's also the advantage in camlp4 that this checks that syntax extensions do not conflict. This is less of an issue with ppx, thankfully.
>> >
>> > -anil
>> > _______________________________________________
>> > wg-camlp4 mailing list
>> > wg-camlp4 at lists.ocaml.org
>> > http://lists.ocaml.org/listinfo/wg-camlp4
>>
>>
> 
> 
> 


From david.waern at gmail.com  Mon Feb 11 23:45:35 2013
From: david.waern at gmail.com (David Waern)
Date: Tue, 12 Feb 2013 00:45:35 +0100
Subject: [wg-camlp4] Pending issues
In-Reply-To: <51190420.5080305@lexifi.com>
References: <51190420.5080305@lexifi.com>
Message-ID: <CAN8ZjBGJpMZNiMccs6rCR-8PvzZezO_KzedqyV-yqMoEM_rDYA@mail.gmail.com>

2013/2/11 Alain Frisch <alain.frisch at lexifi.com>:
> 5. Fork Parsetree or clean it up?
>
> Hongbo has proposed that we introduce a different representation of the
> Parsetree on which -ppx rewriters would be applied.  Concretely, we could
> fork parsetree.mli into parsetree.mli/ast.mli, clean up parsetree (see
> below) and adapt parser.mly accordingly, and then implement a translation
> pass from Parsetree to Ast before running the type-checker on Ast.  The
> alternative is to clean up Parsetree directly and adapt the type-checker to
> these changes.  This avoids an extra intermediate language and the mapping,
> but this could add a little bit of extra complexity to the type-checker (and
> it might be more difficult to convince core developers).  What do people
> think?

I'm not a core developer, but I vote for cleaning up Parsetree rather
than forking it. Advantages:

  - one single (clean) type
  - the typechecker can produce error messages closer to what the user wrote

The Haskell compiler (GHC) does typechecking on the non-desugared
version of the syntax for exactly the second reason, and the
developers seem to have been quite happy with that decision.

Another note: in the Haskell land there are multiple different syntax
tree types floating around:

   - the aforementioned front end type
   - another one used in Template Haskell
   - a third type (in the "haskell-src-exts" library) that is designed
to be as clean and easy to use as possible

Most stand-alone tools are implemented using the third type since it's
by far the easiest one to use. I have heard many people (including GHC
core developers) whishing they would have just one clean type.

David

From romain.bardou at inria.fr  Tue Feb 12 11:42:39 2013
From: romain.bardou at inria.fr (Romain Bardou)
Date: Tue, 12 Feb 2013 12:42:39 +0100
Subject: [wg-camlp4] Pending issues
In-Reply-To: <51190420.5080305@lexifi.com>
References: <51190420.5080305@lexifi.com>
Message-ID: <511A2AAF.6010107@inria.fr>

Hello,

> 3. Quotations
>
> The more I think about it, the more I believe this concept is orthogonal
> to "extensions". Leo disagrees and would like to have a combined syntax
> for the case where the argument of an extension is a quotation. What do
> other people think? (For me, a quotation is only a way to introduce a
> string literal without "suffering" from the lexical conventions of OCaml.)
>
> For the concrete syntax of quotations, it was suggested to use a form
> where the closing delimiter would be defined by the opening one. This
> makes it possible to "quote" an arbitrary string without having to
> define a way to escape a potential occurrence of the closing delimiter
> (just pick a different one). Example: {xxx{blablabla}xxx}
>
> Do people familiar with implementation of editor modes believe it will
> be easy to support such syntax in emacs or vim modes?

I agree it is orthogonal and about the "string literal" aspect, *if* you 
do not want antiquotations.

Melt has a rather complex variation on quotations. There is an emacs 
mode and a vim mode. I think the emacs mode handles quotations. I don't 
know if the vim mode does. But the emacs mode can be very slow on big files.

However without antiquotations I think it should not be too hard, 
because it can be written as a regexp (using a group to repeat the "xxx").

I didn't follow the list close enough to know whether the consensus is 
to have antiquotations or not?

Cheers,

-- 
Romain Bardou

From thomas at ocamlpro.com  Tue Feb 12 11:54:21 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 12 Feb 2013 12:54:21 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <5118C2B8.4070807@lexifi.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
Message-ID: <BFBA82C7-FF2D-4E99-9DA8-E96734B76813@ocamlpro.com>

> - Running AST rewriters as independent processes adds about 7% of compilation time with ocamlopt.opt
> - If we run a single process without marshaling the AST between rewriters, the marginal cost goes below 1% per rewriter.  (This is, basically, the cost of iterating over the AST with objects, matching over each expression to find extension "markers", and rebuilding a deep copy of the AST.)
> - This can be reduced a lot with proper configuration of the GC (down to about 0.3% of compilation time with ocamlopt.opt, with the same GC config).
> - It would be interesting to do some timings when dynlinking a lot of different .cmxs plugins in ppx_drivers.

Thanks for the detailed explanation. This sounds like very good results and strong arguments to replace the complex camlp4 beast by something lighter.

I quite like the idea of having AST rewriter hooks in compiler libs to create easy-to-use compiler variations.

--
Thomas


> (If we link the rewriters statically with a custom version of the compiler itself, assuming a new hook in the compiler allows to plug AST rewriter, we would only pay the marginal cost < 1%.)
> 
> For a code base like Jane Street's where many "extensions" have to be used everywhere, I suspect that the "independent" ppx processes might become an issue (or maybe not, if compared to camlp4), but the following solutions would work:
> 
> - Statically linking a "big rewriter" called with -ppx.
> - Statically linking a version of ocamlopt.opt + all rewriters.
> - Dynamically linking all rewriters with a single ppx driver (to be confirmed, there would be a small overhead for the dynamic linking itself in addition to the 0.3% marginal cost above).
> 
> 
> 
> 
> Alain
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From thomas at ocamlpro.com  Tue Feb 12 11:57:29 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 12 Feb 2013 12:57:29 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <CANcqPu79E86_oG9z=SEk7RuKn_DOd=MO7PEXkDR_ykAF8TTz6g@mail.gmail.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
 <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
 <CANcqPu79E86_oG9z=SEk7RuKn_DOd=MO7PEXkDR_ykAF8TTz6g@mail.gmail.com>
Message-ID: <585C2A34-2B1C-4970-B985-727438280335@ocamlpro.com>

Hi Hongbo,

> For the user time
> ocamlbuild cold/FanDriver.native
> user	0m28.494s
> ocamlbuild src/FanDriver.native
> user	0m30.680s
> For the system time
> the cold directory takes
> sys	0m3.843s
> while the src directory takes
> sys	0m4.657s

I'm not sure to understand what you are measuring exactly here (ie. I don't know what magic your myocamlbuild.ml is doing) and how to interpret the results. Could you please elaborate a bit more ?

Cheers,
Thomas

> 
> 
> On Mon, Feb 11, 2013 at 7:20 AM, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
> On the other hand, build systems come and go (and ./configure is like
> the most horrible part to add logic to in most cases), while ocamlfind
> has proved a reliable tool as a basis for any OCaml ecosystem so far.
> If I can shelve some logic there without making the tool more complex
> or less elegant I think that would be better for everyone.
> 
> On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
> >
> >> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >>> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).
> >>
> >> That's of course rather orthogonal to the present discussion, but have
> >> you been in contact with Gerd to see if some caching solution would be
> >> possible? Intuitively it feels like ocamlfind could easily maintain a
> >> cache in /var/run/blah and only clean it on install/remove commands.
> >>
> >> (An external process invocation would still make some overhead so in
> >> you're case you'd still have to go all the way, but that could improve
> >> the threshold at which such ~hacks become interesting.)
> >
> > I don't think it's necessary to put this in ocamlfind, which does the job
> > it's designed to do very well. Just fix your build systems to run ocamlfind
> > at configure time, save the results, and apply them to the compiler flags
> > during the build phase.
> >
> > -anil
> >
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
> 
> 
> 
> -- 
> -- Regards, Hongbo
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4


From hongboz at seas.upenn.edu  Tue Feb 12 13:21:58 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 12 Feb 2013 08:21:58 -0500
Subject: [wg-camlp4] benchmarks
In-Reply-To: <BFBA82C7-FF2D-4E99-9DA8-E96734B76813@ocamlpro.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <BFBA82C7-FF2D-4E99-9DA8-E96734B76813@ocamlpro.com>
Message-ID: <CANcqPu5zxsXT-C4P_zVGahN+KiEJCH-c=23qA28Dt89kSxUZkA@mail.gmail.com>

On Tue, Feb 12, 2013 at 6:54 AM, Thomas Gazagnaire <thomas at ocamlpro.com> wrote:
>> - Running AST rewriters as independent processes adds about 7% of compilation time with ocamlopt.opt
>> - If we run a single process without marshaling the AST between rewriters, the marginal cost goes below 1% per rewriter.  (This is, basically, the cost of iterating over the AST with objects, matching over each expression to find extension "markers", and rebuilding a deep copy of the AST.)
>> - This can be reduced a lot with proper configuration of the GC (down to about 0.3% of compilation time with ocamlopt.opt, with the same GC config).
>> - It would be interesting to do some timings when dynlinking a lot of different .cmxs plugins in ppx_drivers.
>
> Thanks for the detailed explanation. This sounds like very good results and strong arguments to replace the complex camlp4 beast by something lighter.
Hi, Thomas, my micro-benchmark(in the previous email) shows fan be as
fast as ast rewriter
>
> I quite like the idea of having AST rewriter hooks in compiler libs to create easy-to-use compiler variations.
>
> --
> Thomas
>
>
>> (If we link the rewriters statically with a custom version of the compiler itself, assuming a new hook in the compiler allows to plug AST rewriter, we would only pay the marginal cost < 1%.)
>>
>> For a code base like Jane Street's where many "extensions" have to be used everywhere, I suspect that the "independent" ppx processes might become an issue (or maybe not, if compared to camlp4), but the following solutions would work:
>>
>> - Statically linking a "big rewriter" called with -ppx.
>> - Statically linking a version of ocamlopt.opt + all rewriters.
>> - Dynamically linking all rewriters with a single ppx driver (to be confirmed, there would be a small overhead for the dynamic linking itself in addition to the 0.3% marginal cost above).
>>
>>
>>
>>
>> Alain
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4



-- 
-- Regards, Hongbo

From hongboz at seas.upenn.edu  Tue Feb 12 13:44:38 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 12 Feb 2013 08:44:38 -0500
Subject: [wg-camlp4] benchmarks
In-Reply-To: <585C2A34-2B1C-4970-B985-727438280335@ocamlpro.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
 <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
 <CANcqPu79E86_oG9z=SEk7RuKn_DOd=MO7PEXkDR_ykAF8TTz6g@mail.gmail.com>
 <585C2A34-2B1C-4970-B985-727438280335@ocamlpro.com>
Message-ID: <CANcqPu4wHE+PPLb5wfK=UM1_R2aLX2gzUE+f48JwCOdHXfMHJQ@mail.gmail.com>

On Tue, Feb 12, 2013 at 6:57 AM, Thomas Gazagnaire <thomas at ocamlpro.com>
wrote:
> Hi Hongbo,
>
>> For the user time
>> ocamlbuild cold/FanDriver.native
>> user  0m28.494s
>> ocamlbuild src/FanDriver.native
>> user  0m30.680s
>> For the system time
>> the cold directory takes
>> sys   0m3.843s
>> while the src directory takes
>> sys   0m4.657s
>
> I'm not sure to understand what you are measuring exactly here (ie. I
don't know what magic your myocamlbuild.ml is doing) and how to interpret
the results. Could you please elaborate a bit more ?

For each file subdir/a.ml in src directory, there is a corresponding file
subdir/a.ml in the cold directory, they have *the same Parsetree*, the only
difference is that file in src should be preprocessed, while the file in
cold is vanilla ocaml code that can be compiled without preprocessing.

So here
ocamlbuild src/FanDriver.native
and
ocamlbuild cold/FanDriver.native
does exactly the samething except for each file, when
compiling src/a.mo, it will compile as
ocamlc.opt -c -pp fan src/a.ml
while when compiing cold/a.ml, it works as normal
ocamlc.opt -c cold/a.ml

For our non-trivial code base, our output shows that when compiling with
preprocessing by Fan, its performance is 30s compared with 28s without
preprocessing, this means with good engineering effort, even preprocessing
as powerful as camlp4(Fan provide more features than camlp4) should bring
not too much overhead, I did some experiment before, my feeling is that
typechecking is the bottleneck in most cases.

The extra effort for Fan compared with compiling directly is a dumping
process which dumps FanAst into Parsetree, since our output is already good
enough in practice, I did not tune the GC for better performance.

>
> Cheers,
> Thomas
>
>>
>>
>> On Mon, Feb 11, 2013 at 7:20 AM, Gabriel Scherer <
gabriel.scherer at gmail.com> wrote:
>> On the other hand, build systems come and go (and ./configure is like
>> the most horrible part to add logic to in most cases), while ocamlfind
>> has proved a reliable tool as a basis for any OCaml ecosystem so far.
>> If I can shelve some logic there without making the tool more complex
>> or less elegant I think that would be better for everyone.
>>
>> On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org>
wrote:
>> > On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com>
wrote:
>> >
>> >> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org>
wrote:
>> >>> It should work just fine with ppx, and has the advantage of reducing
the number of ocamlfind calls per-file (which is a considerable overhead on
large projects, since it has to scan the META directories on every
invocation).
>> >>
>> >> That's of course rather orthogonal to the present discussion, but have
>> >> you been in contact with Gerd to see if some caching solution would be
>> >> possible? Intuitively it feels like ocamlfind could easily maintain a
>> >> cache in /var/run/blah and only clean it on install/remove commands.
>> >>
>> >> (An external process invocation would still make some overhead so in
>> >> you're case you'd still have to go all the way, but that could improve
>> >> the threshold at which such ~hacks become interesting.)
>> >
>> > I don't think it's necessary to put this in ocamlfind, which does the
job
>> > it's designed to do very well. Just fix your build systems to run
ocamlfind
>> > at configure time, save the results, and apply them to the compiler
flags
>> > during the build phase.
>> >
>> > -anil
>> >
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>>
>>
>>
>> --
>> -- Regards, Hongbo
>> _______________________________________________
>> wg-camlp4 mailing list
>> wg-camlp4 at lists.ocaml.org
>> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130212/f4b4f8d0/attachment.html>

From thomas at ocamlpro.com  Tue Feb 12 14:02:02 2013
From: thomas at ocamlpro.com (Thomas Gazagnaire)
Date: Tue, 12 Feb 2013 15:02:02 +0100
Subject: [wg-camlp4] benchmarks
In-Reply-To: <CANcqPu4wHE+PPLb5wfK=UM1_R2aLX2gzUE+f48JwCOdHXfMHJQ@mail.gmail.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
 <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
 <CANcqPu79E86_oG9z=SEk7RuKn_DOd=MO7PEXkDR_ykAF8TTz6g@mail.gmail.com>
 <585C2A34-2B1C-4970-B985-727438280335@ocamlpro.com>
 <CANcqPu4wHE+PPLb5wfK=UM1_R2aLX2gzUE+f48JwCOdHXfMHJQ@mail.gmail.com>
Message-ID: <2DB281F2-8A2B-4D20-B758-6EBCB4C34BD7@ocamlpro.com>

> For each file subdir/a.ml in src directory, there is a corresponding file subdir/a.ml in the cold directory, they have the same Parsetree, the only difference is that file in src should be preprocessed, while the file in cold is vanilla ocaml code that can be compiled without preprocessing.
> 
> So here 
> ocamlbuild src/FanDriver.native 
> and
> ocamlbuild cold/FanDriver.native
> does exactly the samething except for each file, when 
> compiling src/a.mo, it will compile as
> ocamlc.opt -c -pp fan src/a.ml 
> while when compiing cold/a.ml, it works as normal
> ocamlc.opt -c cold/a.ml

I still don't understand. Alain clearly showed my the overhead of ppx compared to bare-bone ocaml compilers using dynamic and static strategies. I understand where are the bottleneck and I'm confident that this will not be a concerned regarding compilation speed. Here I don't understand what you are measuring exactly . So what magic is hidden in your '-pp fan' ? Does it look for some predefined path to dynamically load macros, or is it a self-contained statically-linked compiler ? In the later case, how does it work in practice when people start assembling different pieces of syntax extensions (as it is already the case with camlp4) ?

 Honestly, I don't have a strong opinion on which final syntax/solution this group will pick up (ppx, fan or other with hopefully a light syntax proposal) , I just need concrete arguments to motivate me enough to dig into my old camlp4 code and port it to the new selected tool. Also, I think it's important to understand upfront the impact of this change on how we are building OCaml programs: should we change all of our compilation tools if we want decent compilation performance ? For instance, I think that the way people tend to use camlp4 and ocamlfind is very suboptimal in term of compilation speed, and I think this comes from a design issue in the first place. Let's not do that again please.

--
Thomas
 
> 
> For our non-trivial code base, our output shows that when compiling with preprocessing by Fan, its performance is 30s compared with 28s without preprocessing, this means with good engineering effort, even preprocessing as powerful as camlp4(Fan provide more features than camlp4) should bring not too much overhead, I did some experiment before, my feeling is that typechecking is the bottleneck in most cases.
> 
> The extra effort for Fan compared with compiling directly is a dumping process which dumps FanAst into Parsetree, since our output is already good enough in practice, I did not tune the GC for better performance.
> 
> >
> > Cheers,
> > Thomas
> >
> >>
> >>
> >> On Mon, Feb 11, 2013 at 7:20 AM, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
> >> On the other hand, build systems come and go (and ./configure is like
> >> the most horrible part to add logic to in most cases), while ocamlfind
> >> has proved a reliable tool as a basis for any OCaml ecosystem so far.
> >> If I can shelve some logic there without making the tool more complex
> >> or less elegant I think that would be better for everyone.
> >>
> >> On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >> > On 11 Feb 2013, at 10:45, Gabriel Scherer <gabriel.scherer at gmail.com> wrote:
> >> >
> >> >> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >> >>> It should work just fine with ppx, and has the advantage of reducing the number of ocamlfind calls per-file (which is a considerable overhead on large projects, since it has to scan the META directories on every invocation).
> >> >>
> >> >> That's of course rather orthogonal to the present discussion, but have
> >> >> you been in contact with Gerd to see if some caching solution would be
> >> >> possible? Intuitively it feels like ocamlfind could easily maintain a
> >> >> cache in /var/run/blah and only clean it on install/remove commands.
> >> >>
> >> >> (An external process invocation would still make some overhead so in
> >> >> you're case you'd still have to go all the way, but that could improve
> >> >> the threshold at which such ~hacks become interesting.)
> >> >
> >> > I don't think it's necessary to put this in ocamlfind, which does the job
> >> > it's designed to do very well. Just fix your build systems to run ocamlfind
> >> > at configure time, save the results, and apply them to the compiler flags
> >> > during the build phase.
> >> >
> >> > -anil
> >> >
> >> _______________________________________________
> >> wg-camlp4 mailing list
> >> wg-camlp4 at lists.ocaml.org
> >> http://lists.ocaml.org/listinfo/wg-camlp4
> >>
> >>
> >>
> >> --
> >> -- Regards, Hongbo
> >> _______________________________________________
> >> wg-camlp4 mailing list
> >> wg-camlp4 at lists.ocaml.org
> >> http://lists.ocaml.org/listinfo/wg-camlp4
> >
> 
> 
> 
> -- 
> -- Regards, Hongbo


From hez at 0ok.org  Tue Feb 12 14:08:34 2013
From: hez at 0ok.org (Hezekiah M. Carty)
Date: Tue, 12 Feb 2013 09:08:34 -0500
Subject: [wg-camlp4] Pending issues
In-Reply-To: <51190420.5080305@lexifi.com>
References: <51190420.5080305@lexifi.com>
Message-ID: <CAMfPyLDQTa1KaV4QkGxZsxiaauQMFqmSZWPwWHRVraC3VJKZAw@mail.gmail.com>

On Mon, Feb 11, 2013 at 9:45 AM, Alain Frisch <alain.frisch at lexifi.com> wrote:
>
> 3. Quotations
>
> The more I think about it, the more I believe this concept is orthogonal to
> "extensions".  Leo disagrees and would like to have a combined syntax for
> the case where the argument of an extension is a quotation.  What do other
> people think?  (For me, a quotation is only a way to introduce a string
> literal without "suffering" from the lexical conventions of OCaml.)
>
> For the concrete syntax of quotations, it was suggested to use a form where
> the closing delimiter would be defined by the opening one.  This makes it
> possible to "quote" an arbitrary string without having to define a way to
> escape a potential occurrence of the closing delimiter (just pick a
> different one).   Example:  {xxx{blablabla}xxx}
>
> Do people familiar with implementation of editor modes believe it will be
> easy to support such syntax in emacs or vim modes?
>

Perl's custom quotes are similar and vim handles them well.  For
example, q/foo/ and q{foo} are both highlighted properly and would be
roughly equivalent to {{"foo"}}.

Hez

From hongboz at seas.upenn.edu  Tue Feb 12 14:18:02 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Tue, 12 Feb 2013 09:18:02 -0500
Subject: [wg-camlp4] benchmarks
In-Reply-To: <2DB281F2-8A2B-4D20-B758-6EBCB4C34BD7@ocamlpro.com>
References: <E51AEB20-0079-4D94-B75E-7BEDA84CFCC1@ocamlpro.com>
 <51149780.1010302@lexifi.com> <5118C2B8.4070807@lexifi.com>
 <293E5CF1-A147-49A1-8854-F428F28FFA1E@recoil.org>
 <CAPFanBGmFWg4JL17Qs5BiC9B30pu9CrGXc8eHA-QHN-f+RnNoQ@mail.gmail.com>
 <6E9F4686-250B-4C25-8149-A952543B3BE7@recoil.org>
 <CAPFanBGnTvCy1MvAP2nsFF3Kv+=RrFOXDjmyOqabJ9cUvVEb_w@mail.gmail.com>
 <CANcqPu79E86_oG9z=SEk7RuKn_DOd=MO7PEXkDR_ykAF8TTz6g@mail.gmail.com>
 <585C2A34-2B1C-4970-B985-727438280335@ocamlpro.com>
 <CANcqPu4wHE+PPLb5wfK=UM1_R2aLX2gzUE+f48JwCOdHXfMHJQ@mail.gmail.com>
 <2DB281F2-8A2B-4D20-B758-6EBCB4C34BD7@ocamlpro.com>
Message-ID: <CANcqPu4Z_Q5FD3_DKAVMR+MgU4NVeby9SJFk4f7WELUCfdLyJA@mail.gmail.com>

On Tue, Feb 12, 2013 at 9:02 AM, Thomas Gazagnaire <thomas at ocamlpro.com>wrote:

>
>
> I still don't understand. Alain clearly showed my the overhead of ppx
> compared to bare-bone ocaml compilers using dynamic and static strategies.
> I understand where are the bottleneck and I'm confident that this will not
> be a concerned regarding compilation speed. Here I don't understand what
> you are measuring exactly . So what magic is hidden in your '-pp fan' ?
> Does it look for some predefined path to dynamically load macros, or is it
> a self-contained statically-linked compiler ? In the later case, how does
> it work in practice when people start assembling different pieces of syntax
> extensions (as it is already the case with camlp4) ?
>
It's a statically-linked compiler. I am concerned about performance as much
as you, since I have to bootstrap Fan itself everytime I add new features.
Unlike Camlp4, Fan's design encourages static linking or dynamic linking as
much as you can. When you have different pieces of extensions, the static
linking or dynamic linking *only registe*r what features it provides, here
the order does not matter, and it does not have any side effect otherwise,
the file in src/a.ml specifies which syntax extension it wants to pick
for example in src/a.ml
---------------------------------
#load_syntax ["normal"];;
#filter ["serialize"];;
blabla ...
---------------------------------
itself states what syntax or ast rewriter it needs, so here you only need
to supply '-pp fan', it could figure out how to parse and transform the Ast
by itself as long as those features needed are registered.



>  Honestly, I don't have a strong opinion on which final syntax/solution
> this group will pick up (ppx, fan or other with hopefully a light syntax
> proposal) , I just need concrete arguments to motivate me enough to dig
> into my old camlp4 code and port it to the new selected tool. Also, I think
> it's important to understand upfront the impact of this change on how we
> are building OCaml programs: should we change all of our compilation tools
> if we want decent compilation performance ? For instance, I think that the
> way people tend to use camlp4 and ocamlfind is very suboptimal in term of
> compilation speed, and I think this comes from a design issue in the first
> place. Let's not do that again please.
>
> --
> Thomas
>
> >
> > For our non-trivial code base, our output shows that when compiling with
> preprocessing by Fan, its performance is 30s compared with 28s without
> preprocessing, this means with good engineering effort, even preprocessing
> as powerful as camlp4(Fan provide more features than camlp4) should bring
> not too much overhead, I did some experiment before, my feeling is that
> typechecking is the bottleneck in most cases.
> >
> > The extra effort for Fan compared with compiling directly is a dumping
> process which dumps FanAst into Parsetree, since our output is already good
> enough in practice, I did not tune the GC for better performance.
> >
> > >
> > > Cheers,
> > > Thomas
> > >
> > >>
> > >>
> > >> On Mon, Feb 11, 2013 at 7:20 AM, Gabriel Scherer <
> gabriel.scherer at gmail.com> wrote:
> > >> On the other hand, build systems come and go (and ./configure is like
> > >> the most horrible part to add logic to in most cases), while ocamlfind
> > >> has proved a reliable tool as a basis for any OCaml ecosystem so far.
> > >> If I can shelve some logic there without making the tool more complex
> > >> or less elegant I think that would be better for everyone.
> > >>
> > >> On Mon, Feb 11, 2013 at 11:56 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > >> > On 11 Feb 2013, at 10:45, Gabriel Scherer <
> gabriel.scherer at gmail.com> wrote:
> > >> >
> > >> >> On Mon, Feb 11, 2013 at 11:31 AM, Anil Madhavapeddy <
> anil at recoil.org> wrote:
> > >> >>> It should work just fine with ppx, and has the advantage of
> reducing the number of ocamlfind calls per-file (which is a considerable
> overhead on large projects, since it has to scan the META directories on
> every invocation).
> > >> >>
> > >> >> That's of course rather orthogonal to the present discussion, but
> have
> > >> >> you been in contact with Gerd to see if some caching solution
> would be
> > >> >> possible? Intuitively it feels like ocamlfind could easily
> maintain a
> > >> >> cache in /var/run/blah and only clean it on install/remove
> commands.
> > >> >>
> > >> >> (An external process invocation would still make some overhead so
> in
> > >> >> you're case you'd still have to go all the way, but that could
> improve
> > >> >> the threshold at which such ~hacks become interesting.)
> > >> >
> > >> > I don't think it's necessary to put this in ocamlfind, which does
> the job
> > >> > it's designed to do very well. Just fix your build systems to run
> ocamlfind
> > >> > at configure time, save the results, and apply them to the compiler
> flags
> > >> > during the build phase.
> > >> >
> > >> > -anil
> > >> >
> > >> _______________________________________________
> > >> wg-camlp4 mailing list
> > >> wg-camlp4 at lists.ocaml.org
> > >> http://lists.ocaml.org/listinfo/wg-camlp4
> > >>
> > >>
> > >>
> > >> --
> > >> -- Regards, Hongbo
> > >> _______________________________________________
> > >> wg-camlp4 mailing list
> > >> wg-camlp4 at lists.ocaml.org
> > >> http://lists.ocaml.org/listinfo/wg-camlp4
> > >
> >
> >
> >
> > --
> > -- Regards, Hongbo
>
>


-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130212/6ec7fea0/attachment.html>

From pierre.chambart at ocamlpro.com  Tue Feb 12 20:12:26 2013
From: pierre.chambart at ocamlpro.com (Pierre Chambart)
Date: Tue, 12 Feb 2013 21:12:26 +0100
Subject: [wg-camlp4] Pending issues
In-Reply-To: <51190420.5080305@lexifi.com>
References: <51190420.5080305@lexifi.com>
Message-ID: <20130212211226.31edad00@ocamlpro.com>

Le Mon, 11 Feb 2013 15:45:52 +0100,
Alain Frisch <alain.frisch at lexifi.com> a ?crit :

> 4. What to do with attributes in the type-checker
> 
> ...
> 
> A related question is related to the current work on runtime types. 
> Attributes on type declarations could be kept in the runtime 
> representation of the declarations, allowing libraries to interpret
> them as they want.  (LexiFi's version of OCaml has been extended with 
> attributes on type declarations precisely to do that.)  Having 
> attributes defined as general expressions, however, means that those 
> libraries would need to link with compiler-libs, or at least be
> compiled against some of its .cmi, in order to be able to analyze the
> Parsetree. I don't see it is as a big problem, and it would also be
> possible to restrict which expressions are reflected in runtime types
> (e.g. to structured constants).  Comments are welcome!

I think it is usualy a bad idea to need to link against compiler-libs.
Doing so almost certainly prevent you from being able to compile
against different version of the compiler. This ast should be
fixed once and be provided in the stdlib. I would also prefer to
restrict that kind of annotation to a small subset of the expression
language avoiding as much as possible duplication. This would simplify
the code using those annotations. Maybe only list, Variant, record and
string literals/identifiers would be sufficient. Maybe also let in ?

-- 
Pierre
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130212/1ad4150f/attachment.sig>

From lpw25 at cam.ac.uk  Wed Feb 13 12:06:12 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 13 Feb 2013 12:06:12 +0000
Subject: [wg-camlp4] Pending issues
In-Reply-To: <20130212211226.31edad00@ocamlpro.com>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
Message-ID: <Prayer.1.3.5.1302131206120.25997@hermes-1.csi.cam.ac.uk>

>> A related question is related to the current work on runtime types. 
>> Attributes on type declarations could be kept in the runtime 
>> representation of the declarations, allowing libraries to interpret
>> them as they want.  (LexiFi's version of OCaml has been extended with 
>> attributes on type declarations precisely to do that.)  Having 
>> attributes defined as general expressions, however, means that those 
>> libraries would need to link with compiler-libs, or at least be
>> compiled against some of its .cmi, in order to be able to analyze the
>> Parsetree. I don't see it is as a big problem, and it would also be
>> possible to restrict which expressions are reflected in runtime types
>> (e.g. to structured constants).  Comments are welcome!
>
>I think it is usualy a bad idea to need to link against compiler-libs.
>Doing so almost certainly prevent you from being able to compile
>against different version of the compiler. This ast should be
>fixed once and be provided in the stdlib. I would also prefer to
>restrict that kind of annotation to a small subset of the expression
>language avoiding as much as possible duplication. This would simplify
>the code using those annotations. Maybe only list, Variant, record and
>string literals/identifiers would be sufficient. Maybe also let in ?

I agree that we should avoid making people link against compiler-libs where 
possible. However, I think that having a fixed AST and only supporting a 
subset is too restrictive.

An alternative would be to provide a standard library module that could be 
used to handle simple ASTs, but still support using Parsetree directly for 
more complicated AST handling.

For example the "Ast" module might provide functions like:

getIdent: Ast.expression -> string option

which would return a string of an identifier if the expression was a simple 
identifier.

This way we don't restrict changes to Parsetree, or the possible 
expressions within an attribute, but we do allow people to get basic 
information out of an expression without linking against compiler-libs.



From pierre.chambart at ocamlpro.com  Wed Feb 13 12:15:41 2013
From: pierre.chambart at ocamlpro.com (Pierre Chambart)
Date: Wed, 13 Feb 2013 13:15:41 +0100
Subject: [wg-camlp4] Pending issues
In-Reply-To: <Prayer.1.3.5.1302131206120.25997@hermes-1.csi.cam.ac.uk>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
 <Prayer.1.3.5.1302131206120.25997@hermes-1.csi.cam.ac.uk>
Message-ID: <20130213131541.4e88a9a5@ocamlpro.com>

Le 13 Feb 2013 12:06:12 +0000,
Leo White <lpw25 at cam.ac.uk> a ?crit :

> >> A related question is related to the current work on runtime
> >> types. Attributes on type declarations could be kept in the
> >> runtime representation of the declarations, allowing libraries to
> >> interpret them as they want.  (LexiFi's version of OCaml has been
> >> extended with attributes on type declarations precisely to do
> >> that.)  Having attributes defined as general expressions, however,
> >> means that those libraries would need to link with compiler-libs,
> >> or at least be compiled against some of its .cmi, in order to be
> >> able to analyze the Parsetree. I don't see it is as a big problem,
> >> and it would also be possible to restrict which expressions are
> >> reflected in runtime types (e.g. to structured constants).
> >> Comments are welcome!
> >
> >I think it is usualy a bad idea to need to link against
> >compiler-libs. Doing so almost certainly prevent you from being able
> >to compile against different version of the compiler. This ast
> >should be fixed once and be provided in the stdlib. I would also
> >prefer to restrict that kind of annotation to a small subset of the
> >expression language avoiding as much as possible duplication. This
> >would simplify the code using those annotations. Maybe only list,
> >Variant, record and string literals/identifiers would be sufficient.
> >Maybe also let in ?
> 
> I agree that we should avoid making people link against compiler-libs
> where possible. However, I think that having a fixed AST and only
> supporting a subset is too restrictive.
> 
> An alternative would be to provide a standard library module that
> could be used to handle simple ASTs, but still support using
> Parsetree directly for more complicated AST handling.
> 
> For example the "Ast" module might provide functions like:
> 
> getIdent: Ast.expression -> string option
> 
> which would return a string of an identifier if the expression was a
> simple identifier.
> 
> This way we don't restrict changes to Parsetree, or the possible 
> expressions within an attribute, but we do allow people to get basic 
> information out of an expression without linking against
> compiler-libs.

I understand the need for accessing annotation at runtime, but why
whould anyone reasonnable want something else than simple declarative
informations, for which a simple substet is enouth. And restricting
as much as possible this make the usage far easier: this kind of value
won't be manipulated by 'experts' writing syntax extensions, but by
classical users. Moreover, if the ast you are manipulating is the full
ocaml one, it will be impossible to write exhaustive pattern matching
without breaking at each new ocaml release.

-- 
Pierre
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130213/e70ed3d6/attachment.sig>

From alain.frisch at lexifi.com  Wed Feb 13 13:12:52 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Wed, 13 Feb 2013 14:12:52 +0100
Subject: [wg-camlp4] Pending issues
In-Reply-To: <20130212211226.31edad00@ocamlpro.com>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
Message-ID: <511B9154.3030608@lexifi.com>

On 2/12/2013 9:12 PM, Pierre Chambart wrote:
> I would also prefer to
> restrict that kind of annotation to a small subset of the expression
> language avoiding as much as possible duplication.

Just to be clear, do you propose to restrict attributes in general, or 
only those which will be reflected in runtime types?   There are several 
cases where one really wants to be able to use general expressions as 
attributes, such as the example given by Yaron:

          type t =
            { a : int with default(2), sexp_drop_if(fun x -> x = 2);
            } with sexp

One could imagine restricting attributes to structured constants, and 
one would have to write the expression as a string literal to be parsed 
explicitly by the ppx rewriter.  Two arguments against doing so:

   - You loose editor support (admittedly, attributes are likely to be 
short enough that we don't care).

   - You need to be more careful about the order in which ppx rewriters 
are applied. Imagine a variant of the example above:

    type t =
      { a : int with default(2), sexp_drop_if("fun x -> x = DEFAULT");
      } with sexp

  where DEFAULT is to be expanded by another ppx rewriter.  Then you 
need to ensure that the macro expander is run after "sexp", not before. 
  And one could build other examples where one really needs the macro 
expander to apply to the attribute's content before it is processed 
(which works only if the attribute content is parsed).


Alain

From lpw25 at cam.ac.uk  Wed Feb 13 13:47:27 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 13 Feb 2013 13:47:27 +0000
Subject: [wg-camlp4] Pending issues
In-Reply-To: <20130213131541.4e88a9a5@ocamlpro.com>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
 <Prayer.1.3.5.1302131206120.25997@hermes-1.csi.cam.ac.uk>
 <20130213131541.4e88a9a5@ocamlpro.com>
Message-ID: <Prayer.1.3.5.1302131347271.7788@hermes-1.csi.cam.ac.uk>

>I understand the need for accessing annotation at runtime, but why
>whould anyone reasonnable want something else than simple declarative
>informations, for which a simple substet is enouth.

People will want them for statically handled attributes. You could restrict 
the kind that was passed to the run-time but that inconsistency will 
probably annoy people.

> And restricting
>as much as possible this make the usage far easier: this kind of value
>won't be manipulated by 'experts' writing syntax extensions, but by
>classical users. 

For the kind of information most classical users would want to get from an 
attribute, simple functions like "Ast.getIdent" and "Ast.getIntConst" are 
even easier to use than a reduced AST.

>Moreover, if the ast you are manipulating is the full
>ocaml one, it will be impossible to write exhaustive pattern matching
>without breaking at each new ocaml release.

When fetching data from an attribute you probably don't want exhaustive 
pattern matching. If you expect people to attach a number or a string to a 
type then all you want is to check if the attribute is a number or a 
string, and if it isn't then ignore it or raise an exception. You are 
unlikely to want to perform a different action for each possible kind of 
expression.

The exception to this would be if you wanted to handle general expressions 
within an attribute, but in that case you probably want to handle all 
expressions not a restricted subset.


From xavier.clerc at inria.fr  Wed Feb 13 15:22:51 2013
From: xavier.clerc at inria.fr (Xavier Clerc)
Date: Wed, 13 Feb 2013 16:22:51 +0100 (CET)
Subject: [wg-camlp4] Pending issues
In-Reply-To: <511B9154.3030608@lexifi.com>
Message-ID: <321459169.166662.1360768971402.JavaMail.root@inria.fr>

----- Mail original -----
> On 2/12/2013 9:12 PM, Pierre Chambart wrote:
> > I would also prefer to
> > restrict that kind of annotation to a small subset of the
> > expression
> > language avoiding as much as possible duplication.
> 
> Just to be clear, do you propose to restrict attributes in general,
> or
> only those which will be reflected in runtime types?   There are
> several
> cases where one really wants to be able to use general expressions as
> attributes, such as the example given by Yaron:
> 
>           type t =
>             { a : int with default(2), sexp_drop_if(fun x -> x = 2);
>             } with sexp

I am probably missing something here...

Are you discussing the ability to store some attribute
for runtime retrieval? In this case, how do you intent
to store the function? I mean, you cannot marshal it
as a closure, and at the very same time its usefulness
at runtime seems to be based on the ability to actually
execute it?


Regards,

Xavier Clerc

From pierre.chambart at ocamlpro.com  Wed Feb 13 16:03:54 2013
From: pierre.chambart at ocamlpro.com (Pierre Chambart)
Date: Wed, 13 Feb 2013 17:03:54 +0100
Subject: [wg-camlp4] Pending issues
In-Reply-To: <511B9154.3030608@lexifi.com>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
 <511B9154.3030608@lexifi.com>
Message-ID: <20130213170354.00a3622a@ocamlpro.com>

Le Wed, 13 Feb 2013 14:12:52 +0100,
Alain Frisch <alain.frisch at lexifi.com> a ?crit :

> On 2/12/2013 9:12 PM, Pierre Chambart wrote:
> > I would also prefer to
> > restrict that kind of annotation to a small subset of the expression
> > language avoiding as much as possible duplication.
> 
> Just to be clear, do you propose to restrict attributes in general,
> or only those which will be reflected in runtime types?

Only those available at runtime. Other attributes could of course need
to contain classical OCaml, so there is a need for the full syntax.
And when writting syntax extensions, you will already be exposed to the
full OCaml syntax.

What I was thinking of whas that a ppx rewriter could get whatever
expression as attributes, but what remains after applying all rewriters
must be included in a subset that could map to a type like (maybe a bit
too restricitve)

type expr =
  | List of expr list
  | Sum of string * expr
  | Cst of string

without a rewriter this could be written as

type t =
  { a : int with Min 1, Max 5 }

finishing as List [ Sum ("Min","1"); Sum ("Max","5") ]

If something really generic could be needed a case like this is
possible:

  | Dyn of 'a ty * 'a -> expr

It could be generated by a ppx or taken from a variable like:

let var_name = int_of_string (Sys.argv.(1))
type t =
  { a : int with Default var_name }

generating Sum ("Default", Dyn (Int,var_name))

-- 
Pierre
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130213/9ecc142a/attachment.sig>

From lpw25 at cam.ac.uk  Wed Feb 13 17:56:36 2013
From: lpw25 at cam.ac.uk (Leo White)
Date: 13 Feb 2013 17:56:36 +0000
Subject: [wg-camlp4] Pending issues
In-Reply-To: <20130213170354.00a3622a@ocamlpro.com>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
 <511B9154.3030608@lexifi.com>
 <20130213170354.00a3622a@ocamlpro.com>
Message-ID: <Prayer.1.3.5.1302131756360.20604@hermes-1.csi.cam.ac.uk>

>What I was thinking of whas that a ppx rewriter could get whatever
>expression as attributes, but what remains after applying all rewriters
>must be included in a subset that could map to a type like (maybe a bit
>too restricitve)
>
>type expr =
>  | List of expr list
>  | Sum of string * expr
>  | Cst of string
>

This interface can be provided by:

------
  (* Ast.mli *)

  type expr

  type simple_expr = 
  | List of expr list
  | Sum of string * simple_expr
  | Cst of string

  val simplify_expr: expr -> simple_expr

------
  (* Ast.ml *)

  type expr = Parsetree.expression

  type simple_expr =
  | List of expr list
  | Sum of string * simple_expr
  | Cst of string

  let simplify_expr expr = ...

------
  (* Parsetree.mli *)

  type expression = ...

  val of_ast_expr: Ast.expr -> expression

------
  (* Parsetree.ml *)

  type expression = ...

  external of_ast_expr: Ast.expr -> expression = "%identity"

------

This would allow users to use the fixed simple interface, or the full 
parsetree interface.


From wojciech.meyer at gmail.com  Thu Feb 14 11:48:26 2013
From: wojciech.meyer at gmail.com (Wojciech Meyer)
Date: Thu, 14 Feb 2013 11:48:26 +0000
Subject: [wg-camlp4] Pending issues
In-Reply-To: <Prayer.1.3.5.1302131756360.20604@hermes-1.csi.cam.ac.uk>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
 <511B9154.3030608@lexifi.com>
 <20130213170354.00a3622a@ocamlpro.com>
 <Prayer.1.3.5.1302131756360.20604@hermes-1.csi.cam.ac.uk>
Message-ID: <CAOg1smCbQdEFn9ge=+rOy5niFV_PT-xByGJgDi6qROL8ju4Ptg@mail.gmail.com>

Another way of providing these simple asts would be to treat any
flavor of variants uniformly and then in the end transform it back to
what was expected (only if it's needed).

(I don't know if that what wasn't originally proposed by Pierre).

So regardless if it's a polymorphic variant, GADT, or plain data type,
we would have one AST - the common denominator and what matters of
these is usually the tag name and general signature. Once we have that
we will match from that simple AST our type driven plugin that will
generate JSON, XML, visitors. etc The idea is to have something that
is good enough and reflects general structure to get rid of
complicated parse tree or/and quotations on the LHS and/or factor out
the common pattern matchers using some meta object.

We could go even further and generate all the bolier plate pattern
matchers via visitor pattern by default, of course it needs to be
thought - but the idea is to not look at types at all - now it turns
to be it's already a meta-meta programming.

On Wed, Feb 13, 2013 at 5:56 PM, Leo White <lpw25 at cam.ac.uk> wrote:
>> What I was thinking of whas that a ppx rewriter could get whatever
>> expression as attributes, but what remains after applying all rewriters
>> must be included in a subset that could map to a type like (maybe a bit
>> too restricitve)
>>
>> type expr =
>>  | List of expr list
>>  | Sum of string * expr
>>  | Cst of string
>>
>
> This interface can be provided by:
>
> ------
>  (* Ast.mli *)
>
>  type expr
>
>  type simple_expr =  | List of expr list
>  | Sum of string * simple_expr
>  | Cst of string
>
>  val simplify_expr: expr -> simple_expr
>
> ------
>  (* Ast.ml *)
>
>  type expr = Parsetree.expression
>
>  type simple_expr =
>  | List of expr list
>  | Sum of string * simple_expr
>  | Cst of string
>
>  let simplify_expr expr = ...
>
> ------
>  (* Parsetree.mli *)
>
>  type expression = ...
>
>  val of_ast_expr: Ast.expr -> expression
>
> ------
>  (* Parsetree.ml *)
>
>  type expression = ...
>
>  external of_ast_expr: Ast.expr -> expression = "%identity"
>
> ------
>
> This would allow users to use the fixed simple interface, or the full
> parsetree interface.
>
>
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4

From hongboz at seas.upenn.edu  Thu Feb 14 13:50:27 2013
From: hongboz at seas.upenn.edu (Hongbo Zhang)
Date: Thu, 14 Feb 2013 08:50:27 -0500
Subject: [wg-camlp4] Pending issues
In-Reply-To: <CAOg1smCbQdEFn9ge=+rOy5niFV_PT-xByGJgDi6qROL8ju4Ptg@mail.gmail.com>
References: <51190420.5080305@lexifi.com>
 <20130212211226.31edad00@ocamlpro.com>
 <511B9154.3030608@lexifi.com>
 <20130213170354.00a3622a@ocamlpro.com>
 <Prayer.1.3.5.1302131756360.20604@hermes-1.csi.cam.ac.uk>
 <CAOg1smCbQdEFn9ge=+rOy5niFV_PT-xByGJgDi6qROL8ju4Ptg@mail.gmail.com>
Message-ID: <CANcqPu4LeQaebtnm2V4iunGajVSgpigLkUa29cq4bw8UK6DQ6w@mail.gmail.com>

On Thu, Feb 14, 2013 at 6:48 AM, Wojciech Meyer <wojciech.meyer at gmail.com>wrote:

> Another way of providing these simple asts would be to treat any
> flavor of variants uniformly and then in the end transform it back to
> what was expected (only if it's needed).
>
> (I don't know if that what wasn't originally proposed by Pierre).
>
> So regardless if it's a polymorphic variant, GADT, or plain data type,
> we would have one AST - the common denominator and what matters of
> these is usually the tag name and general signature. Once we have that
> we will match from that simple AST our type driven plugin that will
> generate JSON, XML, visitors. etc The idea is to have something that
> is good enough and reflects general structure to get rid of
> complicated parse tree or/and quotations on the LHS and/or factor out
> the common pattern matchers using some meta object.
>
> We could go even further and generate all the bolier plate pattern
> matchers via visitor pattern by default, of course it needs to be
> thought - but the idea is to not look at types at all - now it turns
> to be it's already a meta-meta programming.
>
> That's how ast works in Fan, constructor names are not associated with
type at
all.
So, suppose you have a function
sem_of_list, it works for all syntax categories, in Camlp4 you need to
write sem_of_list_ctyp, sem_of_list_expr,.....

Second, no dependency, in Fan, you can write tons of libraries for Fan
without depending on Fan, since Fan adopts polymorphic variants, you don't
have to fix its type in the first place. There is a nice application here:
reflection or runtime types generated by Fan. For each compilation unit,
for example, a.ml, Fan can inject a value in the module A, called
repr_of_a, which stores the ast as a runtime value(there is a subtle
difference here, it's a runtime value), which means you can program it in
vanilla ocaml without marshalling or demarshalling

Third, subtyping, you can pick a subset of the ast you want to process,
while reuse most of existing Fan's utilities. The contract is detected at
compile time.




> On Wed, Feb 13, 2013 at 5:56 PM, Leo White <lpw25 at cam.ac.uk> wrote:
> >> What I was thinking of whas that a ppx rewriter could get whatever
> >> expression as attributes, but what remains after applying all rewriters
> >> must be included in a subset that could map to a type like (maybe a bit
> >> too restricitve)
> >>
> >> type expr =
> >>  | List of expr list
> >>  | Sum of string * expr
> >>  | Cst of string
> >>
> >
> > This interface can be provided by:
> >
> > ------
> >  (* Ast.mli *)
> >
> >  type expr
> >
> >  type simple_expr =  | List of expr list
> >  | Sum of string * simple_expr
> >  | Cst of string
> >
> >  val simplify_expr: expr -> simple_expr
> >
> > ------
> >  (* Ast.ml *)
> >
> >  type expr = Parsetree.expression
> >
> >  type simple_expr =
> >  | List of expr list
> >  | Sum of string * simple_expr
> >  | Cst of string
> >
> >  let simplify_expr expr = ...
> >
> > ------
> >  (* Parsetree.mli *)
> >
> >  type expression = ...
> >
> >  val of_ast_expr: Ast.expr -> expression
> >
> > ------
> >  (* Parsetree.ml *)
> >
> >  type expression = ...
> >
> >  external of_ast_expr: Ast.expr -> expression = "%identity"
> >
> > ------
> >
> > This would allow users to use the fixed simple interface, or the full
> > parsetree interface.
> >
> >
> > _______________________________________________
> > wg-camlp4 mailing list
> > wg-camlp4 at lists.ocaml.org
> > http://lists.ocaml.org/listinfo/wg-camlp4
> _______________________________________________
> wg-camlp4 mailing list
> wg-camlp4 at lists.ocaml.org
> http://lists.ocaml.org/listinfo/wg-camlp4
>



-- 
-- Regards, Hongbo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/wg-camlp4/attachments/20130214/29ea98d2/attachment.html>

From tews at os.inf.tu-dresden.de  Fri Feb 22 12:32:09 2013
From: tews at os.inf.tu-dresden.de (Hendrik Tews)
Date: Fri, 22 Feb 2013 13:32:09 +0100
Subject: [wg-camlp4] My no-use of camlp4 syntax extensions for Otags
Message-ID: <20775.25929.388649.943057@blau.inf.tu-dresden.de>

Hi,

I just noticed the wg-camlp4 initiative, here is my no-use of
camlp4 syntax extensions.

I use camlp4 for otags, the OCaml tag generator for emacs and vi.
I don't use any syntax extensions, I only use the parsing engine
and the ability to access the abstract syntax tree. After
generating the TAGS, the syntax tree is thrown away.

For generating TAGS one needs exact location information on the
identifiers in the abstract syntax tree. This has always been a
problem with camlp4, see the various open bug reports on this
topic. It would be good, if, together with -ppx, suitable
functions would be provided for getting the location info right
for those syntax tree nodes that get added/modified in -ppx
preprocessors. 

Another point that was always problematic with camlp4 was
documentation. I believe that the attitude present in
http://caml.inria.fr/pub/ml-archives/caml-list/2007/04/65b9d8de785307fe310d1179cea0729c.fr.html
and in
http://mirror.ocamlcore.org/caml.inria.fr/pub/ml-archives/caml-list/2007/05/9c2dd8a116e04931c0ba88337c7ced69.en.html
was largely responsible for the failure of the new camlp4. 
I would therefore strongly suggest to provide complete
documentation for the ast that preprocessors must process with
the _beta_ release of the next version.


One could think, that otags could work perfectly as a -ppx
preprocessor. There are, however, some issues:

- The otags ast preprocessor would produce no output, because no
  compilation should be happen when generating TAGS.

- For simplicity I would need to pass some state from one
  preprocessor invocation to the next. 

  For Emacs TAGS this would just be the open file descriptor of
  the TAGS file.

  vi TAGS should be sorted, so for vi I would need to pass the
  set of accumulated TAGS. Only the last preprocessor would
  write them to the file.

- For simplicity otags permits tagging whole projects or
  directory trees at once, where different files need possibly be
  preprocessed with different syntax extensions. Therefore I
  would need a version of the -ppx flag that applies to one file
  or a flag that clears the list of accumulated ppx'es.

For these reasons, it would probably be simpler, if otags has its
own driver that invokes the parser and the preprocessors as
needed. For this it would be nice, if the compilerlibs could
provide a function parse_with_ppx, or everything that is needed
for writing it. parse_with_ppx takes a filename and a list of
preprocessor names, parses the file, runs all preprocessors and
returns the ast.

Bye,

Hendrik

From alain.frisch at lexifi.com  Mon Feb 25 09:30:20 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Mon, 25 Feb 2013 10:30:20 +0100
Subject: [wg-camlp4] My no-use of camlp4 syntax extensions for Otags
In-Reply-To: <20775.25929.388649.943057@blau.inf.tu-dresden.de>
References: <20775.25929.388649.943057@blau.inf.tu-dresden.de>
Message-ID: <512B2F2C.9090308@lexifi.com>

On 02/22/2013 01:32 PM, Hendrik Tews wrote:
> For generating TAGS one needs exact location information on the
> identifiers in the abstract syntax tree. This has always been a
> problem with camlp4, see the various open bug reports on this
> topic. It would be good, if, together with -ppx, suitable
> functions would be provided for getting the location info right
> for those syntax tree nodes that get added/modified in -ppx
> preprocessors.

Defining the notion of the "right location" for syntax tree nodes which 
are added is not easy.  For instance, which location should we use for 
nodes obtained after macro expansion?  The location of the macro 
definition, or the location of the "call site"?  Similarly, which 
location should we use for code generated from type definitions?  The 
location of the type definition?


> Another point that was always problematic with camlp4 was
> documentation.

Point taken.  The nice thing is that we will mostly have to document the 
parse tree and the calling convention for ppx, which is rather simple. 
The amount of information to be aware of will be much smaller than with 
Camlp4.


> For these reasons, it would probably be simpler, if otags has its
> own driver that invokes the parser and the preprocessors as
> needed. For this it would be nice, if the compilerlibs could
> provide a function parse_with_ppx, or everything that is needed
> for writing it. parse_with_ppx takes a filename and a list of
> preprocessor names, parses the file, runs all preprocessors and
> returns the ast.

This is already the case, you can do something like:

   let inputfile = Pparse.preprocess sourcefile in
   let ast =
    Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number
   in
   ...
   Pparse.remove_preprocessed inputfile


The -pp and -ppx preprocessors are taken from Clflags 
(Clflags.preprocessor, Clflags.ppx).

Maybe we should encapsulate the code above as a single function (with 
proper support for errors, i.e. removing the temporary file produced by 
the -pp preprocessor in case of error).


Alain


From tews at os.inf.tu-dresden.de  Mon Feb 25 10:13:54 2013
From: tews at os.inf.tu-dresden.de (Hendrik Tews)
Date: Mon, 25 Feb 2013 11:13:54 +0100
Subject: [wg-camlp4] My no-use of camlp4 syntax extensions for Otags
In-Reply-To: <512B2F2C.9090308@lexifi.com>
References: <20775.25929.388649.943057@blau.inf.tu-dresden.de>
 <512B2F2C.9090308@lexifi.com>
Message-ID: <20779.14690.944605.283053@blau.inf.tu-dresden.de>

Alain Frisch writes:
   Date: Mon, 25 Feb 2013 10:30:20 +0100
   Subject: Re: [wg-camlp4] My no-use of camlp4 syntax extensions for Otags
   
   On 02/22/2013 01:32 PM, Hendrik Tews wrote:
   > For generating TAGS one needs exact location information on the
   > identifiers in the abstract syntax tree. 
   
   Defining the notion of the "right location" for syntax tree nodes which 
   are added is not easy.  For instance, which location should we use for 
   nodes obtained after macro expansion?  The location of the macro 
   definition, or the location of the "call site"?  Similarly, which 
   location should we use for code generated from type definitions?  The 
   location of the type definition?

It is not only about the synthesized or added ast nodes. Camlp4
suffers from the problem that sometimes location info for ast
nodes that follow a camlp4 macro are wrong (eg. bug #5127). I
hope that with -ppx we get for free, that location info of nodes
that are not touched stays correct.

Regarding synthesized nodes, my suggestion would be to have a
clear definition of an undefined location, which should be the
default for synthesized ast nodes. There should also be a clear
definition of synthesized location info, for the case where the
author of the preprocessor decides to provide some better
location info. 

For instance, from otags point of view, the identifiers for
printers and xml parsers that are generated for a type definition
should have the location of that type definition. But only the
identifiers, the generated function bodies can have the undefined
location. For otags I need to distinguish the locations for these
generated functions from those that really appear in the code.
This is because TAGS files contain small fragments from the
sources to make the TAGS file more robust when line numbers
change. For TAGS entries of synthesized functions and values it
is probably better to not copy any part of the source into the
TAGS file.


   > Another point that was always problematic with camlp4 was
   > documentation.
   
   Point taken.  

Thanks a lot! If you choose a form where user contribution is
easy (eg a wiki) I'll probably contribute, similarly to the
camlp4 wiki.

   > For this it would be nice, if the compilerlibs could
   > provide a function parse_with_ppx
   
   This is already the case, you can do something like:
   
Great!

   Maybe we should encapsulate the code above as a single function (with 
   proper support for errors, i.e. removing the temporary file produced by 
   the -pp preprocessor in case of error).
   
I would prefer something that automatically deals with temporary
files but raises errors as exceptions together with a function
that converts these exceptions into proper error messages. 

There are people who run otags automatically on whole directory
trees to index all files in there. For them, files with parse
errors should be simply skipped without even producing an error
message.


Bye,

Hendrik

From alain.frisch at lexifi.com  Thu Feb 28 21:04:07 2013
From: alain.frisch at lexifi.com (Alain Frisch)
Date: Thu, 28 Feb 2013 22:04:07 +0100
Subject: [wg-camlp4] A new branch to experiment with extension points
Message-ID: <512FC647.6050900@lexifi.com>

Dear all,

Since there seemed to be a consensus about extending the OCaml grammar 
with attributes and extension nodes in various syntactic categories, 
I've started an experimental branch on the OCaml SVN to try some syntax.
The branch is called extension_points ( 
http://caml.inria.fr/cgi-bin/viewvc.cgi/ocaml/branches/extension_points/ ).

Currently, the following are supported:

  - Extension node as a structure item:

       &(foo expr)

  - Extension node as an expression:

       (&foo expr)

  - Extension node as a type expression:

       (&foo expr)

  - Attribute on a structure item, postfix notation:

       .... :: foo expr

  - Attribute on a type expression, postfix notation:

       .... (/foo expr)

In all cases, foo denotes a lowercase unprefixed identifier (LIDENT) and 
expr is an optional expression (it can be omitted).

(The parser has more commented-out syntax for attributes on expressions 
with prefix and postfix notation, and attributes on type expression with 
prefix notation.)


Alain

