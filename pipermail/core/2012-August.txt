From ocaml-core at googlegroups.com  Fri Aug  3 03:47:51 2012
From: ocaml-core at googlegroups.com (ocaml-core at googlegroups.com)
Date: Fri, 03 Aug 2012 02:47:51 +0000
Subject: Moderator's spam report for ocaml-core@googlegroups.com
Message-ID: <0016e65c7c28db87a404c6538dad@google.com>


This message is being sent to you because you are a moderator of the group ocaml-core.

The following suspicious messages were sent to your group, but are being held in your moderation queue because they are classified as likely spam messages.

If you take no action, all the messages below will be discarded automatically as spam.

However, if you see any messages that are not spam below, you may approve them individually by going to:

http://groups.google.com/group/ocaml-core/pendmsg

Please do not mark this notification as spam; this is a service for group moderators. If you do not wish to receive these notifications in the future, you may change your preferences by going to:

http://groups.google.com/group/ocaml-core/manage_post


------- 1 of 1  -------
Subject: greetings from very far
>From: "Ted"  <ted at softsoftwareapps.com>
Date: Jul 31 10:42PM -0400

what precisely time did you tell hook up?


Approve: http://groups.google.com/group/ocaml-core/pendmsg?view=full&pending_id=4193238326765171892


For more information about this message, please visit:
https://support.google.com/groups/bin/answer.py?hl=en&answer=47792



From ninjew at gmail.com  Sat Aug 11 04:05:29 2012
From: ninjew at gmail.com (David Ziman)
Date: Fri, 10 Aug 2012 20:05:29 -0700 (PDT)
Subject: installation mess
In-Reply-To: <CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com>
 <CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
Message-ID: <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>

I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a 
dependency for type-conv. Is there an ETA on this fix?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120810/f26c356e/attachment.html>

From seanmcl at gmail.com  Mon Aug 13 18:04:51 2012
From: seanmcl at gmail.com (Sean McLaughlin)
Date: Mon, 13 Aug 2012 13:04:51 -0400
Subject: Lock_file on OSX
Message-ID: <CAO4dZbehnXY_cp1KiULn+u8FnQdrFcYKPcq+hQ8dCvnMz42B+g@mail.gmail.com>

It appears Lock_file does not work on OSX.

# Lock_file.create "/tmp/a";;
- : bool = false

The problem is in the call to

Unix.lockf fd ~mode:Unix.F_TLOCK ~len:Int64.zero;

which always raises an exception.

Exception:
Unix.Unix_error (Core.Std.Unix.EACCES, "lockf",
 "((fd 6) (mode F_TEST) (len 0))").

Unfortunately, this renders the very useful Core_service_command unusable
on OSX.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120813/5499ecb8/attachment.html>

From markus.mottl at gmail.com  Wed Aug 15 17:24:39 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Wed, 15 Aug 2012 12:24:39 -0400
Subject: Bitbucket teams
Message-ID: <CAP_800p=9sN6A+jv782EeMUzXuvc9RX7CtkHcORv-k8MfFeN3Q@mail.gmail.com>


Hi,

not sure you've already considered this, but Bitbucket also supports teams:

  http://blog.bitbucket.org/2012/05/30/bitbucket-teams/

Maybe ocaml-core could also be organized that way, i.e. converted to a
team account?

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From yminsky at janestreet.com  Wed Aug 15 18:45:02 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 15 Aug 2012 13:45:02 -0400
Subject: Bitbucket teams
In-Reply-To: <CAP_800p=9sN6A+jv782EeMUzXuvc9RX7CtkHcORv-k8MfFeN3Q@mail.gmail.com>
References: <CAP_800p=9sN6A+jv782EeMUzXuvc9RX7CtkHcORv-k8MfFeN3Q@mail.gmail.com>
Message-ID: <CACLX4jT7_b9Qqvt6OCUNq1s7aBQyaPO5RzU+OYqW1+TpAvt1uQ@mail.gmail.com>


Yeah, I've considered this.  I have another project that I did this
way, and it worked well.  We should probably switch, though I think
it's not pressing right now.

y

On Wed, Aug 15, 2012 at 12:24 PM, Markus Mottl <markus.mottl at gmail.com> wrote:
> Hi,
>
> not sure you've already considered this, but Bitbucket also supports teams:
>
>   http://blog.bitbucket.org/2012/05/30/bitbucket-teams/
>
> Maybe ocaml-core could also be organized that way, i.e. converted to a
> team account?
>
> Regards,
> Markus
>
> --
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From anil at recoil.org  Fri Aug 17 02:46:15 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 16 Aug 2012 18:46:15 -0700
Subject: Lwt/Async abstraction for HTTP library
Message-ID: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>


I've been working on a release of a cooperative threading HTTP library, and have been using the opportunity to experiment with parameterising it over Lwt/Async.  I had a few (basic) Async questions as a result.

The code is at:
https://github.com/avsm/ocaml-cohttp/tree/v2-interface
(requires Lwt-current to build at the moment)

The basic IO interface that takes care of low-level parsing is very straightforward to implement in Async and Lwt:
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async_raw.ml
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt_raw.ml

The higher-level client HTTP interface is where Lwt and Async diverge, and so have different implementations. The Async version exposes the body as a Pipe which can be lazily consumed or passed to a proxy. This means that pipelined requests must be careful to wait until previous requests have fully consumed their respective bodies before using that particular channel.  In Lwt, this can be modelled with Lwt_stream.t that maps over the requests and responses.

In Async, I ran into a few basic questions while building the equivalent Lwt support.

- Only one Scheduler.go is supported (unlike Lwt_main, which can run multiple times in a program), which makes multiple Async tests hard to compose in oUnit.  Do you have a custom oUnit that can isolate  multiple Async test-cases, or should I write a forking one that does this?

- What's the best way to get a human-readable error?  I have this in the oUnit right now, which is very clunky:

  let _ =  Async_core.Scheduler.within' (fun () ->
    Monitor.try_with make_net_req >>=
    function
    |Error exn -> 
      (* TODO: how to dump out top-level errors in a nicer way? *)
       Printf.fprintf stderr "err %s.\n%!" (Exn.backtrace ()); return ()
    |Ok _ -> return ()
  ) in Async_unix.Scheduler.go ()

- Async_streams are deprecated, and I should use Pipes instead. I need to be able to run a background task that will close the I/O channel whenever the Pipe is completed to close the underlying fd.  I obtain a Deferred via Pipe.closed, but how should this run in the background?  Should I just ignore the return, or register it with the Scheduler?

In general, are there any toy network programs written using Async that I could crib good style from?

cheers,
Anil

From anil at recoil.org  Fri Aug 17 02:59:41 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 16 Aug 2012 18:59:41 -0700
Subject: Fwd: Lwt/Async abstraction for HTTP library
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
Message-ID: <BBF79EDB-E5E2-457C-ADC5-59A25BD1AAFB@recoil.org>


I also thought this might be quite useful for our (rapidly approaching) ICFP tutorial.  We could spend some time after the basics on showing how both Lwt/Async can be used to implement a simple web service or a crawler.  The Github API bindings are working pretty well, so would let us demonstrate Yojson as well.

-a

Begin forwarded message:

> From: Anil Madhavapeddy <anil at recoil.org>
> Subject: Lwt/Async abstraction for HTTP library
> Date: 16 August 2012 18:46:15 PDT
> To: "ocaml-core at googlegroups.com" <ocaml-core at googlegroups.com>
> Reply-To: ocaml-core at googlegroups.com
> 
> I've been working on a release of a cooperative threading HTTP library, and have been using the opportunity to experiment with parameterising it over Lwt/Async.  I had a few (basic) Async questions as a result.
> 
> The code is at:
> https://github.com/avsm/ocaml-cohttp/tree/v2-interface
> (requires Lwt-current to build at the moment)
> 
> The basic IO interface that takes care of low-level parsing is very straightforward to implement in Async and Lwt:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async_raw.ml
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt_raw.ml
> 
> The higher-level client HTTP interface is where Lwt and Async diverge, and so have different implementations. The Async version exposes the body as a Pipe which can be lazily consumed or passed to a proxy. This means that pipelined requests must be careful to wait until previous requests have fully consumed their respective bodies before using that particular channel.  In Lwt, this can be modelled with Lwt_stream.t that maps over the requests and responses.
> 
> In Async, I ran into a few basic questions while building the equivalent Lwt support.
> 
> - Only one Scheduler.go is supported (unlike Lwt_main, which can run multiple times in a program), which makes multiple Async tests hard to compose in oUnit.  Do you have a custom oUnit that can isolate  multiple Async test-cases, or should I write a forking one that does this?
> 
> - What's the best way to get a human-readable error?  I have this in the oUnit right now, which is very clunky:
> 
>  let _ =  Async_core.Scheduler.within' (fun () ->
>    Monitor.try_with make_net_req >>=
>    function
>    |Error exn -> 
>      (* TODO: how to dump out top-level errors in a nicer way? *)
>       Printf.fprintf stderr "err %s.\n%!" (Exn.backtrace ()); return ()
>    |Ok _ -> return ()
>  ) in Async_unix.Scheduler.go ()
> 
> - Async_streams are deprecated, and I should use Pipes instead. I need to be able to run a background task that will close the I/O channel whenever the Pipe is completed to close the underlying fd.  I obtain a Deferred via Pipe.closed, but how should this run in the background?  Should I just ignore the return, or register it with the Scheduler?
> 
> In general, are there any toy network programs written using Async that I could crib good style from?
> 
> cheers,
> Anil



From anil at recoil.org  Fri Aug 17 18:22:44 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 17 Aug 2012 10:22:44 -0700
Subject: installation mess
In-Reply-To: <CAOCAUGPOrgUWuxN8Oz2rSiY7eT6HmEn7LHyQqwrZHHpssyiwBw@mail.gmail.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com> <CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com> <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com> <CAOCAUGPOrgUWuxN8Oz2rSiY7eT6HmEn7LHyQqwrZHHpssyiwBw@mail.gmail.com>
Message-ID: <4E09736E-F2A8-4DE6-BED8-888795A38C52@recoil.org>


This isn't a big deal if you install the released version of core.  I use
OPAM for this day-to-day now.  Grab the latest OPAM from:

http://github.com/OCamlPro/opam (I just use HEAD)

$ opam init
$ opam install oasis core
$ eval `opam config -env` 

The last step will import the environment variables for the OPAM-installed
ocamlfind.  You then have a working OASIS-0.3 and Core, from which you can
regenerate the files in the dev repositories.

I believe Thomas is working on the last patchset for a feature addition
before OPAM can be declared beta, but I find it useful already.

-anil

On 17 Aug 2012, at 01:45, Sylvain Le Gall <sylvain at le-gall.net> wrote:

> Hello,
> 
> 2012/8/11 David Ziman <ninjew at gmail.com>:
>> I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a
>> dependency for type-conv. Is there an ETA on this fix?
> 
> <With my OASIS upstream author hat>
> 
> I start to be a little bit concerned of this situation. I think I
> should get rid of type-conv dependency. I would have preferred to keep
> ocaml-data-notation depends on type-conv but it makes things more
> complicated than needed (although, this only happens in the the dev
> version of ocaml-core).
> 
> Can type-conv people help me to migrate away from type-conv ? (ok
> this look like a weird request, but I think it will help everyone).
> 
> Regards
> Sylvain
> 



From sylvain at le-gall.net  Fri Aug 17 09:45:25 2012
From: sylvain at le-gall.net (Sylvain Le Gall)
Date: Fri, 17 Aug 2012 10:45:25 +0200
Subject: installation mess
In-Reply-To: <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com>
	<CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
	<a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
Message-ID: <CAOCAUGPOrgUWuxN8Oz2rSiY7eT6HmEn7LHyQqwrZHHpssyiwBw@mail.gmail.com>


Hello,

2012/8/11 David Ziman <ninjew at gmail.com>:
> I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a
> dependency for type-conv. Is there an ETA on this fix?

<With my OASIS upstream author hat>

I start to be a little bit concerned of this situation. I think I
should get rid of type-conv dependency. I would have preferred to keep
ocaml-data-notation depends on type-conv but it makes things more
complicated than needed (although, this only happens in the the dev
version of ocaml-core).

 Can type-conv people help me to migrate away from type-conv ? (ok
this look like a weird request, but I think it will help everyone).

Regards
Sylvain


From seanmcl at gmail.com  Fri Aug 17 20:57:48 2012
From: seanmcl at gmail.com (Sean McLaughlin)
Date: Fri, 17 Aug 2012 15:57:48 -0400
Subject: ocaml-core-submissions questions
Message-ID: <CAO4dZbctcsuqXw-fajTSfGWGO60nQ3yjFwibwvR-SwkD8X-7Zw@mail.gmail.com>

Hi,

I need to make a change to core to support some features on OSX.

1) Is cloning the ocaml-core-submissions queue is the way forward in
contributing to core?

If yes,

2) Why is yminsky/ocaml-core-submissions unrelated to
mmottl/ocaml-core-submissions?

Thanks,

Sean

/usr/local/src/ocaml-core-submissions-mmottl
$ hg fetch https://bitbucket.org/mmottl/ocaml-core-submissions
pulling from https://bitbucket.org/mmottl/ocaml-core-submissions
searching for changes
no changes found

/usr/local/src/ocaml-core-submissions-mmottl
$ hg fetch https://bitbucket.org/yminsky/ocaml-core-submissions
pulling from https://bitbucket.org/yminsky/ocaml-core-submissions
searching for changes
abort: repository is unrelated
EXIT STATUS 255
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120817/7abc6df5/attachment.html>

From markus.mottl at gmail.com  Fri Aug 17 21:22:52 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Fri, 17 Aug 2012 16:22:52 -0400
Subject: ocaml-core-submissions questions
In-Reply-To: <CAO4dZbctcsuqXw-fajTSfGWGO60nQ3yjFwibwvR-SwkD8X-7Zw@mail.gmail.com>
References: <CAO4dZbctcsuqXw-fajTSfGWGO60nQ3yjFwibwvR-SwkD8X-7Zw@mail.gmail.com>
Message-ID: <CAP_800pLPiut0q4-TgaLO9jDuRRiyqfRUzYfdhHFsYARGqYywQ@mail.gmail.com>


On Fri, Aug 17, 2012 at 3:57 PM, Sean McLaughlin <seanmcl at gmail.com> wrote:
> Hi,
>
> I need to make a change to core to support some features on OSX.
>
> 1) Is cloning the ocaml-core-submissions queue is the way forward in
> contributing to core?

Basically, yes.  But it requires a certain procedure with Bitbucket.
Here is some documentation:

  http://ches.nausicaamedia.com/articles/technogeekery/using-mercurial-queues-and-bitbucket-org

> 2) Why is yminsky/ocaml-core-submissions unrelated to
> mmottl/ocaml-core-submissions?

You have to make sure to relate the right repositories.  With patch
queues there are really two of those: the "normal" repository for the
source tree and the patch queue repository in .hg/patches.  Most
Mercurial commands take a "--mq" flag to make sure that you are
performing some operation on the queue repository, not the "normal"
one.  You can also "cd" into the patch queue repository and then treat
it like a normal one (without "--mq").

My local source tree configuration in .hg/hgrc (default path) always
points to the original yminsky/ocaml-core-submissions repository at
Bitbucket.  But my patch queue repository configuration in
.hg/patches/.hg/hgrc points to my patch queue at Bitbucket.  That way
I can make sure to stay up-to-date wrt. the source tree, but my
patches will be pushed to my patch queue repository.  I can then send
pull requests via the web interface to Ron.

There is a slight initial learning curve with Bitbucket patch queues.
But once everything is set up correctly, it's really easy to use.

Cheers,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From yminsky at janestreet.com  Fri Aug 17 21:40:56 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 17 Aug 2012 16:40:56 -0400
Subject: installation mess
In-Reply-To: <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com>
	<CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
	<a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
Message-ID: <CACLX4jTXMxMnG8FQMKeqzaZ22avFYNi71kYHSL=q6SNERuYW7A@mail.gmail.com>


I'm actually confused by the question.  Oasis is indeed a dependency
for the dev version of type-conv.  If you grab a tarball and install,
there's no dependency, but the dev version requires it.  Why is this a
problem, i.e., why not just install Oasis?

There is the circularity issue that Sylvain mentions.  But I dealt
with that by: installing type-conv from the tarball; building and
installing oasis; and then building and installing the dev-version of
type-conv and the rest of core.  It's slightly awkward, but not
terrible.

y

On Fri, Aug 10, 2012 at 11:05 PM, David Ziman <ninjew at gmail.com> wrote:
> I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a
> dependency for type-conv. Is there an ETA on this fix?


From yminsky at janestreet.com  Sun Aug 19 19:54:25 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 19 Aug 2012 14:54:25 -0400
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
Message-ID: <CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>


On Thu, Aug 16, 2012 at 9:46 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I've been working on a release of a cooperative threading HTTP library, and have been using the opportunity to experiment with parameterising it over Lwt/Async.  I had a few (basic) Async questions as a result.
>
> The code is at:
> https://github.com/avsm/ocaml-cohttp/tree/v2-interface
> (requires Lwt-current to build at the moment)
>
> The basic IO interface that takes care of low-level parsing is very straightforward to implement in Async and Lwt:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async_raw.ml
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt_raw.ml
>
> The higher-level client HTTP interface is where Lwt and Async diverge, and so have different implementations. The Async version exposes the body as a Pipe which can be lazily consumed or passed to a proxy. This means that pipelined requests must be careful to wait until previous requests have fully consumed their respective bodies before using that particular channel.  In Lwt, this can be modelled with Lwt_stream.t that maps over the requests and responses.
>
> In Async, I ran into a few basic questions while building the equivalent Lwt support.
>
> - Only one Scheduler.go is supported (unlike Lwt_main, which can run multiple times in a program), which makes multiple Async tests hard to compose in oUnit.  Do you have a custom oUnit that can isolate  multiple Async test-cases, or should I write a forking one that does this?
>
> - What's the best way to get a human-readable error?  I have this in the oUnit right now, which is very clunky:
>
>   let _ =  Async_core.Scheduler.within' (fun () ->
>     Monitor.try_with make_net_req >>=
>     function
>     |Error exn ->
>       (* TODO: how to dump out top-level errors in a nicer way? *)
>        Printf.fprintf stderr "err %s.\n%!" (Exn.backtrace ()); return ()
>     |Ok _ -> return ()
>   ) in Async_unix.Scheduler.go ()

One quick observation: this code would be a little cleaner if you
opened Async.Std.  Then you'd write:

   open Core.Std
   open Async.Std

   let _ =  within' (fun () ->
     try_with make_net_req
     >>= function
     | Error exn ->
       (* TODO: how to dump out top-level errors in a nicer way? *)
        fprintf stderr "err %s.\n%!" (Exn.backtrace ());
        return ()
     | Ok _ -> return ()
   )
   in
   Scheduler.go ()

Further, I don't think the [within'] call is doing you any good, since
you're not using it to set the block group, the monitor or the
priority.  So you should be able to just drop that.

Stephen, do you have a view as to how to do the error handling here
properly?

As a side note, we have a new release that should be out in a bit over
a week (it's totally done internally, but Yury, who is responsible for
the external releases, last week and the next.)  I think there are
some material changes there that should improve some of the error
presentation.

>
> - Async_streams are deprecated, and I should use Pipes instead. I
>   need to be able to run a background task that will close the I/O
>   channel whenever the Pipe is completed to close the underlying fd.
>   I obtain a Deferred via Pipe.closed, but how should this run in
>   the background?  Should I just ignore the return, or register it
>   with the Scheduler?

Sorry, I'm not quite able to decode the question.  Do you have a code
snippet you could share?

> In general, are there any toy network programs written using Async
> that I could crib good style from?

That's an excellent question.  We do have some examples that are
presently not included in our external tree.  I'll see if we can fix
that.

y


From yminsky at janestreet.com  Tue Aug 21 04:03:47 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 20 Aug 2012 23:03:47 -0400
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <20120821021103.GR24660@dark.recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
	<CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
	<20120821021103.GR24660@dark.recoil.org>
Message-ID: <CACLX4jQQhYjdwg=zDK=v432BKukTe2eDfya2-n4+5yHkePDbNA@mail.gmail.com>


On Mon, Aug 20, 2012 at 10:11 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On Sun, Aug 19, 2012 at 02:54:25PM -0400, Yaron Minsky wrote:
>> One quick observation: this code would be a little cleaner if you
>> opened Async.Std.  Then you'd write:
>>
>>    open Core.Std
>>    open Async.Std
>>
>
> Ah, I missed the Async package's existence and went straight for
> Async_unix.  I've now updated the dependency to use Async directly and all
> the interfaces are much simpler.
>
>>    let _ =  within' (fun () ->
>>      try_with make_net_req
>>      >>= function
>>      | Error exn ->
>>        (* TODO: how to dump out top-level errors in a nicer way? *)
>>         fprintf stderr "err %s.\n%!" (Exn.backtrace ());
>>         return ()
>>      | Ok _ -> return ()
>>    )
>>    in
>>    Scheduler.go ()
>>
>> Further, I don't think the [within'] call is doing you any good, since
>> you're not using it to set the block group, the monitor or the
>> priority.  So you should be able to just drop that.
>
> This was actually related to me experimenting with what all those options
> do (particularly the custom monitor).  I'll wait for your new update when
> Yury's back and see what the interface looks like.   Do you normally just
> read the s-expr encoded in Error.t, or do you have something fancier (the
> former is good enough for me in practise).

We usually just dump the s-expr that you get from the Error.t.

>> > - Async_streams are deprecated, and I should use Pipes instead. I
>> >   need to be able to run a background task that will close the I/O
>> >   channel whenever the Pipe is completed to close the underlying fd.
>> >   I obtain a Deferred via Pipe.closed, but how should this run in
>> >   the background?  Should I just ignore the return, or register it
>> >   with the Scheduler?
>>
>> Sorry, I'm not quite able to decode the question.  Do you have a code
>> snippet you could share?
>
> Yeah, in:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async.ml
>
> let pipe_of_body read_fn ic =
>   let rd, wr = Pipe.create () in
>   (* Consume from the input channel and write to the new pipe *)
>   let rec write () =
>     read_fn ic >>= function
>     |Transfer.Done ->
>       Pipe.close wr; return ()
>     |Transfer.Final_chunk c -> begin
>       Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>=
>         function
>         |`Closed -> return ()
>         |`Ok _ -> Pipe.close wr; return ()
>     end
>     |Transfer.Chunk c -> begin
>       Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>=
>         function
>         |`Closed -> return ()
>         |`Ok _ -> write ()
>     end
>   in
>   (* TODO: how to run write () as a background task? *)
>   let _ = write () in
>   rd
>
> This function is called to convert a HTTP body into a Pipe pair, such that
> the client can lazily consume the (potentially very large) HTTP body, or
> pass it onto a proxy process.  There is a write() function that reads from
> the HTTP body and potentially blocks on the I/O or pushback from the pipe.
> We immediately return the reader pipe as a return value from the function.
>
> So my question is what to do with:
>
>   (* TODO: how to run write () as a background task? *)
>   let _ = write () in
>   rd

The narrow answer to this one is: [write ()] is automatically run as a
background task, no registration required.  You'd normally write this:

   whenever (write ());
   rd

where `whenever` is actually a function that just ignores a [unit
Deferred.t].  We decided that `whenever` was a bit of a confusing name
for this, and we changed it to:

  don't_wait_for (write ());
  rd

in the latest release, which will come out next week.  But the effect
is just the same as:

  ignore (write () : unit Deferred.t);
  rd

> Does write() need to be registered with something to be a "proper"
> background task for accounting purposes, or to run a cleanup function if
> the Reader pipe terminates early?

I need to look at your example in more detail to understand how the
early termination you're talking about works.  I'll try to get to that
in the next day or so.

> The equivalent code in Lwt is here and looks like:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt.ml
>
> let stream_of_body read_fn ic =
>   let fin = ref false in
>   Lwt_stream.from (fun () ->
>     match !fin with
>     |true -> return None
>     |false -> begin
>       match_lwt read_fn ic with
>       |Transfer.Done ->
>         return None
>       |Transfer.Final_chunk c ->
>         fin := true;
>         return (Some c);
>       |Transfer.Chunk c ->
>         return (Some c)
>     end
>   )
>
> The Lwt_stream that is returned has an Lwt.on_terminate handler for when
> the consumer hits EOF (e.g. to close the socket), and I think (but am a
> little blurry here) cancels the other end with an Lwt.Canceled exception
> if the other side stops early.
>
>> > In general, are there any toy network programs written using Async
>> > that I could crib good style from?
>>
>> That's an excellent question.  We do have some examples that are
>> presently not included in our external tree.  I'll see if we can fix
>> that.
>
> That would be great!
>
> --
> Anil Madhavapeddy                                 http://anil.recoil.org


From anil at recoil.org  Tue Aug 21 03:11:03 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 21 Aug 2012 03:11:03 +0100
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
 <CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
Message-ID: <20120821021103.GR24660@dark.recoil.org>


On Sun, Aug 19, 2012 at 02:54:25PM -0400, Yaron Minsky wrote:
> One quick observation: this code would be a little cleaner if you
> opened Async.Std.  Then you'd write:
> 
>    open Core.Std
>    open Async.Std
> 

Ah, I missed the Async package's existence and went straight for
Async_unix.  I've now updated the dependency to use Async directly and all
the interfaces are much simpler.

>    let _ =  within' (fun () ->
>      try_with make_net_req
>      >>= function
>      | Error exn ->
>        (* TODO: how to dump out top-level errors in a nicer way? *)
>         fprintf stderr "err %s.\n%!" (Exn.backtrace ());
>         return ()
>      | Ok _ -> return ()
>    )
>    in
>    Scheduler.go ()
> 
> Further, I don't think the [within'] call is doing you any good, since
> you're not using it to set the block group, the monitor or the
> priority.  So you should be able to just drop that.

This was actually related to me experimenting with what all those options
do (particularly the custom monitor).  I'll wait for your new update when
Yury's back and see what the interface looks like.   Do you normally just
read the s-expr encoded in Error.t, or do you have something fancier (the
former is good enough for me in practise).

> > - Async_streams are deprecated, and I should use Pipes instead. I
> >   need to be able to run a background task that will close the I/O
> >   channel whenever the Pipe is completed to close the underlying fd.
> >   I obtain a Deferred via Pipe.closed, but how should this run in
> >   the background?  Should I just ignore the return, or register it
> >   with the Scheduler?
> 
> Sorry, I'm not quite able to decode the question.  Do you have a code
> snippet you could share?

Yeah, in:
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async.ml

let pipe_of_body read_fn ic =
  let rd, wr = Pipe.create () in
  (* Consume from the input channel and write to the new pipe *)
  let rec write () =
    read_fn ic >>= function
    |Transfer.Done ->
      Pipe.close wr; return ()
    |Transfer.Final_chunk c -> begin
      Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>= 
        function
        |`Closed -> return ()
        |`Ok _ -> Pipe.close wr; return ()
    end
    |Transfer.Chunk c -> begin
      Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>=
        function
        |`Closed -> return ()
        |`Ok _ -> write () 
    end
  in
  (* TODO: how to run write () as a background task? *)
  let _ = write () in
  rd

This function is called to convert a HTTP body into a Pipe pair, such that
the client can lazily consume the (potentially very large) HTTP body, or
pass it onto a proxy process.  There is a write() function that reads from
the HTTP body and potentially blocks on the I/O or pushback from the pipe.
We immediately return the reader pipe as a return value from the function.

So my question is what to do with:

  (* TODO: how to run write () as a background task? *)
  let _ = write () in
  rd

Does write() need to be registered with something to be a "proper"
background task for accounting purposes, or to run a cleanup function if
the Reader pipe terminates early?

The equivalent code in Lwt is here and looks like:
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt.ml

let stream_of_body read_fn ic =
  let fin = ref false in
  Lwt_stream.from (fun () ->
    match !fin with
    |true -> return None
    |false -> begin
      match_lwt read_fn ic with
      |Transfer.Done -> 
        return None
      |Transfer.Final_chunk c ->
        fin := true;
        return (Some c);
      |Transfer.Chunk c ->
        return (Some c)
    end
  )

The Lwt_stream that is returned has an Lwt.on_terminate handler for when
the consumer hits EOF (e.g. to close the socket), and I think (but am a
little blurry here) cancels the other end with an Lwt.Canceled exception
if the other side stops early.

> > In general, are there any toy network programs written using Async
> > that I could crib good style from?
> 
> That's an excellent question.  We do have some examples that are
> presently not included in our external tree.  I'll see if we can fix
> that.

That would be great!

-- 
Anil Madhavapeddy                                 http://anil.recoil.org


From jeremie at dimino.org  Tue Aug 21 10:55:48 2012
From: jeremie at dimino.org (=?UTF-8?B?SsOpcsOpbWll?= Dimino)
Date: Tue, 21 Aug 2012 11:55:48 +0200
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <20120821021103.GR24660@dark.recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
	<CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
	<20120821021103.GR24660@dark.recoil.org>
Message-ID: <20120821115548.7ccdc157@caladan.esterel-technologies.com>


Le Tue, 21 Aug 2012 03:11:03 +0100,
Anil Madhavapeddy <anil at recoil.org> a ?crit :

> The Lwt_stream that is returned has an Lwt.on_terminate handler for
> when the consumer hits EOF (e.g. to close the socket), and I think
> (but am a little blurry here) cancels the other end with an
> Lwt.Canceled exception if the other side stops early.

Actually no, cancelling an operation on a Lwt stream does not cancel
its "from" function. Allowing cancels in streams may lead to
unexpected behaviors.

J?r?mie


From dhouse at janestreet.com  Thu Aug 23 09:01:52 2012
From: dhouse at janestreet.com (David House)
Date: Thu, 23 Aug 2012 09:01:52 +0100
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <20120821021103.GR24660@dark.recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
	<CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
	<20120821021103.GR24660@dark.recoil.org>
Message-ID: <CAK=fH+iho4Nzuvbi63yKc9nJRzyUakB9tPGHFkAmUg5N4pZf0A@mail.gmail.com>


On Tue, Aug 21, 2012 at 3:11 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> So my question is what to do with:
>
>   (* TODO: how to run write () as a background task? *)
>   let _ = write () in
>   rd
>
> Does write() need to be registered with something to be a "proper"
> background task for accounting purposes, or to run a cleanup function if
> the Reader pipe terminates early?

As Yaron points out, it is more idiomatic to say [whenever (write
())], or in the newer version of async, [don't_wait_for (write ())].
For example, the stuff below "TODO" in Client.read_response might be
written:

if close then don't_wait_for (
  Pipe.closed body_rd
  >>= fun () ->
  Reader.close ic
  >>= fun () ->
  Writer.close oc)

There is no need to register background processes with the scheduler.
Your code is already correct in the case of early termination by the
consumer: one of the [Pipe.write_when_ready] calls will terminate with
`Closed, and your loop will exit.

P.s. I see in your code that you open Deferred. Why is this? All of
the infix operators, plus [return] and a few others, are already in
the scope of Async.Std, so there is no need to go opening anything
else.

Also, two more stylistic points:

1. If the code on the right-hand side of a bind does not return a
deferred, it is common to use >>| instead of >>=, and then delete all
the "return"s on the right-hand side. E.g. in read_response.

2. All code between two binds is guaranteed to execute atomically,
without being interleaved with any other code. This is a very nice
feature of async, and really simplifies thinking about concurrent
code. Because of this, it is idiomatic to put all of your binds
flush-left, so that they stick out visually. (This is not quite
universal in our code base, but is certainly to be encouraged.) You
can see that in my snippet above.


From francois.berenger.working at gmail.com  Tue Aug 28 02:55:25 2012
From: francois.berenger.working at gmail.com (Francois Berenger)
Date: Mon, 27 Aug 2012 18:55:25 -0700 (PDT)
Subject: picture of the day
Message-ID: <206e1352-758b-424b-9c76-b0c903f857e8@googlegroups.com>

Hello,

Maybe the functionality to generate this will be in odb.ml soon.

Regards,
F.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120827/3e450d00/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: core_deps.png
Type: image/png
Size: 154987 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120827/3e450d00/attachment.png>

From yminsky at janestreet.com  Tue Aug 28 03:32:45 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 27 Aug 2012 22:32:45 -0400
Subject: picture of the day
In-Reply-To: <206e1352-758b-424b-9c76-b0c903f857e8@googlegroups.com>
References: <206e1352-758b-424b-9c76-b0c903f857e8@googlegroups.com>
Message-ID: <CACLX4jRCbnUD74UTRnydvpeFkXo7R-bUOi=w7ZeLnjfO-MGBug@mail.gmail.com>


Very pretty!

On Mon, Aug 27, 2012 at 9:55 PM, Francois Berenger
<francois.berenger.working at gmail.com> wrote:
> Hello,
>
> Maybe the functionality to generate this will be in odb.ml soon.
>
> Regards,
> F.
>


From brankovv at gmail.com  Fri Aug 31 16:48:17 2012
From: brankovv at gmail.com (Vladimir Brankov)
Date: Fri, 31 Aug 2012 08:48:17 -0700 (PDT)
Subject: Compose function operator
Message-ID: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>

As far as I can tell, the only way to compose functions is Fn.compose.  Why 
not having an operator as well?  It's easier to say:

    f1 |- f2 |- f3

than

    compose (compose f1 f2) f3

Also, I see that Batteries has some other interesting function composition 
operators.  I don't have any use for it now, but we may want to think about 
it.

http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/18205b87/attachment.html>

From seanmcl at gmail.com  Fri Aug 31 17:13:45 2012
From: seanmcl at gmail.com (Sean McLaughlin)
Date: Fri, 31 Aug 2012 12:13:45 -0400
Subject: Compose function operator
In-Reply-To: <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com> <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
Message-ID: <CAO4dZbdSdmNtEFX1TMXQsRND-1otet12vXO+XZ3K2u1LEVo+Tw@mail.gmail.com>

>
> Finally, there is a significant cost for any new infix operator. If
> that thing is not used all the time, it is very obscure and makes code
> quite opaque.
>

Function composition seems fundamental, and has built-in operators in SML
and Haskell.  I don't see a great reason why we don't have one in ocaml.
I personally think composition in Haskell can make code more clear (and
beautiful, if we're using aesthetics as some kind of metric as above.)

One major problem with composition in SML (also ocaml), is that the value
restriction prevents useful composition of pure functions.

$ sml
Standard ML of New Jersey v110.74 [built: Tue Jan 31 16:23:10 2012]
- fun id x = x
val id = fn : 'a -> 'a
- id o id;
stdIn:3.1-3.8 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val it = fn : ?.X1 -> ?.X1

Thus it's not nearly as useful as in Haskell.  You could imagine always
wrapping compositions in a big lambda

- fn x => (id o id o id o id) x;
val it = fn : 'a -> 'a

but this pretty much defeats the purpose if you have |!
fun x -> x |! id |! id |! id |! id

 On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <brankovv at gmail.com>
> wrote:
> > As far as I can tell, the only way to compose functions is Fn.compose.
>  Why
> > not having an operator as well?  It's easier to say:
> >
> >     f1 |- f2 |- f3
> >
> > than
> >
> >     compose (compose f1 f2) f3
> >
> > Also, I see that Batteries has some other interesting function
> composition
> > operators.  I don't have any use for it now, but we may want to think
> about
> > it.
> >
> >
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/e4a48792/attachment.html>

From brankovv at gmail.com  Fri Aug 31 21:00:39 2012
From: brankovv at gmail.com (Vladimir Brankov)
Date: Fri, 31 Aug 2012 13:00:39 -0700 (PDT)
Subject: Compose function operator
In-Reply-To: <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
 <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
Message-ID: <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>

Composition would not hurt in this case:

    let name = to_string |- lowercase

as opposed to

    let name t = to_string t |! lowercase

IMHO both are slightly clearer than:

    let name t = lowercase (to_string t)

This is a small example, imagine if we have a few stacked functions.

On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>
> There is already (|!) which almost does what you want, but in a more 
> logical order. 
>
> I say "almost" since it does not allow you to build up a partially 
> applied function. But I for one very much dislike Fn.compose in those 
> scenarios. I think it's generally much clearer to write out the 
> lambda, since then one is forced to give a name to the variable. E.g. 
> which is clearer? 
>
>   List.map events ~f:(Fn.compose to_string fst) 
>   List.map events ~f:(fun (kind, _time) -> to_string kind) 
>
> The latter code is much more annotated and, to me, clearer as a result. 
>
> I know that sometimes writing names is pretty unnecessary, because 
> it's already clear what the output of a function will be. And in that 
> case, adding names can just clutter the code and decrease the 
> information density, making it harder to read. But one can just use 
> (|!), which as I said makes things appear in a more logical order. 
>
> Finally, there is a significant cost for any new infix operator. If 
> that thing is not used all the time, it is very obscure and makes code 
> quite opaque. 
>
> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com<javascript:>> 
> wrote: 
> > As far as I can tell, the only way to compose functions is Fn.compose. 
>  Why 
> > not having an operator as well?  It's easier to say: 
> > 
> >     f1 |- f2 |- f3 
> > 
> > than 
> > 
> >     compose (compose f1 f2) f3 
> > 
> > Also, I see that Batteries has some other interesting function 
> composition 
> > operators.  I don't have any use for it now, but we may want to think 
> about 
> > it. 
> > 
> > 
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html 
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/4b0eece6/attachment.html>

From brankovv at gmail.com  Fri Aug 31 21:20:54 2012
From: brankovv at gmail.com (Vladimir Brankov)
Date: Fri, 31 Aug 2012 13:20:54 -0700 (PDT)
Subject: Compose function operator
In-Reply-To: <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
 <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
 <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
 <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
Message-ID: <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>

What about this case:

    List.iter l ~f:(fun t -> to_string t |! lowercase)

as opposed to

    List.iter l ~f:(lowercase |- to_string)

I suppose you would argue that the first one is preferred.  That raises a 
question - who decides whether a feature gets included or rejected?  I 
suppose that none of us can claim to know what the majority of the users 
would or wouldn't want.  What's the procedure for new features?

On Friday, August 31, 2012 4:04:17 PM UTC-4, David House wrote:
>
> Don't you mean: 
>
>   let name = lowercase |- to_string 
>
> Functional composition is normally written such that the function on 
> the right is applied first. 
>
> This strikes me as less clear than your example with |!, because of 
> the weird ordering. 
>
> But even without the ordering constraint, if |- were as clear or only 
> a little clearer than |!, we should still not include it, because |! 
> already exists (and is more general), and because of that cost of 
> every new infix operator that I mentioned before. 
>
> On 31 August 2012 21:00, Vladimir Brankov <bran... at gmail.com <javascript:>> 
> wrote: 
> > Composition would not hurt in this case: 
> > 
> >     let name = to_string |- lowercase 
> > 
> > as opposed to 
> > 
> >     let name t = to_string t |! lowercase 
> > 
> > IMHO both are slightly clearer than: 
> > 
> >     let name t = lowercase (to_string t) 
> > 
> > This is a small example, imagine if we have a few stacked functions. 
> > 
> > On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote: 
> >> 
> >> There is already (|!) which almost does what you want, but in a more 
> >> logical order. 
> >> 
> >> I say "almost" since it does not allow you to build up a partially 
> >> applied function. But I for one very much dislike Fn.compose in those 
> >> scenarios. I think it's generally much clearer to write out the 
> >> lambda, since then one is forced to give a name to the variable. E.g. 
> >> which is clearer? 
> >> 
> >>   List.map events ~f:(Fn.compose to_string fst) 
> >>   List.map events ~f:(fun (kind, _time) -> to_string kind) 
> >> 
> >> The latter code is much more annotated and, to me, clearer as a result. 
> >> 
> >> I know that sometimes writing names is pretty unnecessary, because 
> >> it's already clear what the output of a function will be. And in that 
> >> case, adding names can just clutter the code and decrease the 
> >> information density, making it harder to read. But one can just use 
> >> (|!), which as I said makes things appear in a more logical order. 
> >> 
> >> Finally, there is a significant cost for any new infix operator. If 
> >> that thing is not used all the time, it is very obscure and makes code 
> >> quite opaque. 
> >> 
> >> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com> 
> >> wrote: 
> >> > As far as I can tell, the only way to compose functions is 
> Fn.compose. 
> >> > Why 
> >> > not having an operator as well?  It's easier to say: 
> >> > 
> >> >     f1 |- f2 |- f3 
> >> > 
> >> > than 
> >> > 
> >> >     compose (compose f1 f2) f3 
> >> > 
> >> > Also, I see that Batteries has some other interesting function 
> >> > composition 
> >> > operators.  I don't have any use for it now, but we may want to think 
> >> > about 
> >> > it. 
> >> > 
> >> > 
> >> > 
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html 
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/8d4c3a34/attachment.html>

From anil at recoil.org  Fri Aug 31 22:51:59 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 31 Aug 2012 14:51:59 -0700
Subject: Core on a Mac
In-Reply-To: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com>
References: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com>
Message-ID: <027F8960-82EA-432D-884E-4E900389088F@recoil.org>


On 31 Aug 2012, at 14:48, David House <dmhouse at gmail.com> wrote:

> I'm interested in getting core working on my Mac. Has anyone tried
> this, and how well does it work?


- Install Homebrew from http://github.com/mxcl/homebrew
- $ brew install ocaml
- $ brew tap mirage/ocaml      # hook in custom ocaml packages
- $ brew install opam --HEAD   # get the very latest OPAM
- $ opam install core async
- $ eval `opam config -env`    # import the right PATH

Some of these steps will disappear in a bit (e.g. the tap is only
required until a more stable OPAM appears, which will hopefully be
before ICFP in a couple of weeks).

Note that Homebrew just updated to ocaml-4.00.0, so hopefully Core
works with it too.

-anil


From anil at recoil.org  Fri Aug 31 23:18:32 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 31 Aug 2012 15:18:32 -0700
Subject: Core on a Mac
In-Reply-To: <CAMu2m2LezwGjxo9v6ZV2JPdN58L6oPeRWno7K_5OA2e88pPpjQ@mail.gmail.com>
References: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com> <027F8960-82EA-432D-884E-4E900389088F@recoil.org> <CAMu2m2LezwGjxo9v6ZV2JPdN58L6oPeRWno7K_5OA2e88pPpjQ@mail.gmail.com>
Message-ID: <96D17667-DE37-4116-85FB-583F61D1B7C7@recoil.org>

The Homebrew OCaml includes 10.8-specific fixes [1] too, which cause sporadic crashes otherwise with exception backtraces in particular.  And once OPAM is bootstrapped, it supports multiple local development environments via `opam switch`.  This is assuming its solver isn't going off and upgrading everything, which Thomas has mostly fixed now :)

[1] http://caml.inria.fr/mantis/view.php?id=5700

-a

On 31 Aug 2012, at 15:14, Ashish Agarwal <agarwal1975 at gmail.com> wrote:

> I install core from the release tarball on my OS X 10.7.4 Mac without problems. It's on top of a base installation of ocaml, findlib, etc. from godi.
> 
> On Fri, Aug 31, 2012 at 5:51 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On 31 Aug 2012, at 14:48, David House <dmhouse at gmail.com> wrote:
> 
> > I'm interested in getting core working on my Mac. Has anyone tried
> > this, and how well does it work?
> 
> 
> - Install Homebrew from http://github.com/mxcl/homebrew
> - $ brew install ocaml
> - $ brew tap mirage/ocaml      # hook in custom ocaml packages
> - $ brew install opam --HEAD   # get the very latest OPAM
> - $ opam install core async
> - $ eval `opam config -env`    # import the right PATH
> 
> Some of these steps will disappear in a bit (e.g. the tap is only
> required until a more stable OPAM appears, which will hopefully be
> before ICFP in a couple of weeks).
> 
> Note that Homebrew just updated to ocaml-4.00.0, so hopefully Core
> works with it too.
> 
> -anil
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/b8b167cf/attachment.html>

From dhouse at janestreet.com  Fri Aug 31 17:01:10 2012
From: dhouse at janestreet.com (David House)
Date: Fri, 31 Aug 2012 17:01:10 +0100
Subject: Compose function operator
In-Reply-To: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
Message-ID: <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>


There is already (|!) which almost does what you want, but in a more
logical order.

I say "almost" since it does not allow you to build up a partially
applied function. But I for one very much dislike Fn.compose in those
scenarios. I think it's generally much clearer to write out the
lambda, since then one is forced to give a name to the variable. E.g.
which is clearer?

  List.map events ~f:(Fn.compose to_string fst)
  List.map events ~f:(fun (kind, _time) -> to_string kind)

The latter code is much more annotated and, to me, clearer as a result.

I know that sometimes writing names is pretty unnecessary, because
it's already clear what the output of a function will be. And in that
case, adding names can just clutter the code and decrease the
information density, making it harder to read. But one can just use
(|!), which as I said makes things appear in a more logical order.

Finally, there is a significant cost for any new infix operator. If
that thing is not used all the time, it is very obscure and makes code
quite opaque.

On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <brankovv at gmail.com> wrote:
> As far as I can tell, the only way to compose functions is Fn.compose.  Why
> not having an operator as well?  It's easier to say:
>
>     f1 |- f2 |- f3
>
> than
>
>     compose (compose f1 f2) f3
>
> Also, I see that Batteries has some other interesting function composition
> operators.  I don't have any use for it now, but we may want to think about
> it.
>
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From thelema314 at gmail.com  Fri Aug 31 22:36:05 2012
From: thelema314 at gmail.com (Edgar Friendly)
Date: Fri, 31 Aug 2012 17:36:05 -0400
Subject: Compose function operator
In-Reply-To: <CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com> <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com> <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com> <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com> <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com> <CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
Message-ID: <50412E45.9010407@gmail.com>


On 08/31/2012 05:11 PM, David House wrote:
> (As an aside, |! has this problem to a
> lesser extent, because it visually looks like a unix command-line
> pipe. This provides a helpful mnemonic, so remembering is much
> easier.)

To me, |! looks quite similar to ||.  I'm quite happy with the F# and 
batteries |> operator which visually looks like an arrow funneling data 
to the right.

E.


From yminsky at janestreet.com  Fri Aug 31 22:42:13 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 31 Aug 2012 17:42:13 -0400
Subject: Compose function operator
In-Reply-To: <50412E45.9010407@gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
	<CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
	<50412E45.9010407@gmail.com>
Message-ID: <CACLX4jRByKHHZC=APCWorVpkV_rgpUNUO+Gh4YQCJgdsEFsK7w@mail.gmail.com>


Yeah, if we'd realized earlier, I would have liked to use |>.  I've
toyed with the idea of adding it as an alias, but switching all of our
internal code would be a lot of painful, pointless churn.

y

On Fri, Aug 31, 2012 at 5:36 PM, Edgar Friendly <thelema314 at gmail.com> wrote:
> On 08/31/2012 05:11 PM, David House wrote:
>>
>> (As an aside, |! has this problem to a
>> lesser extent, because it visually looks like a unix command-line
>> pipe. This provides a helpful mnemonic, so remembering is much
>> easier.)
>
>
> To me, |! looks quite similar to ||.  I'm quite happy with the F# and
> batteries |> operator which visually looks like an arrow funneling data to
> the right.
>
> E.


From yminsky at janestreet.com  Fri Aug 31 22:44:28 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 31 Aug 2012 17:44:28 -0400
Subject: Compose function operator
In-Reply-To: <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
Message-ID: <CACLX4jTU=Og-fnDpgAEzEFv1pPh3TKFhKJajLncxs=2DRwzZSg@mail.gmail.com>


We've talked about this one a lot internally over the years, and have
settled on not adding a compose operator.  Our experience has been
that code using the compose operator tends to be harder to read, and
House's point about the cognitive load of infix operators is well
taken.

y

On Fri, Aug 31, 2012 at 4:20 PM, Vladimir Brankov <brankovv at gmail.com> wrote:
> What about this case:
>
>     List.iter l ~f:(fun t -> to_string t |! lowercase)
>
> as opposed to
>
>     List.iter l ~f:(lowercase |- to_string)
>
> I suppose you would argue that the first one is preferred.  That raises a
> question - who decides whether a feature gets included or rejected?  I
> suppose that none of us can claim to know what the majority of the users
> would or wouldn't want.  What's the procedure for new features?
>
> On Friday, August 31, 2012 4:04:17 PM UTC-4, David House wrote:
>>
>> Don't you mean:
>>
>>   let name = lowercase |- to_string
>>
>> Functional composition is normally written such that the function on
>> the right is applied first.
>>
>> This strikes me as less clear than your example with |!, because of
>> the weird ordering.
>>
>> But even without the ordering constraint, if |- were as clear or only
>> a little clearer than |!, we should still not include it, because |!
>> already exists (and is more general), and because of that cost of
>> every new infix operator that I mentioned before.
>>
>> On 31 August 2012 21:00, Vladimir Brankov <bran... at gmail.com> wrote:
>> > Composition would not hurt in this case:
>> >
>> >     let name = to_string |- lowercase
>> >
>> > as opposed to
>> >
>> >     let name t = to_string t |! lowercase
>> >
>> > IMHO both are slightly clearer than:
>> >
>> >     let name t = lowercase (to_string t)
>> >
>> > This is a small example, imagine if we have a few stacked functions.
>> >
>> > On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>> >>
>> >> There is already (|!) which almost does what you want, but in a more
>> >> logical order.
>> >>
>> >> I say "almost" since it does not allow you to build up a partially
>> >> applied function. But I for one very much dislike Fn.compose in those
>> >> scenarios. I think it's generally much clearer to write out the
>> >> lambda, since then one is forced to give a name to the variable. E.g.
>> >> which is clearer?
>> >>
>> >>   List.map events ~f:(Fn.compose to_string fst)
>> >>   List.map events ~f:(fun (kind, _time) -> to_string kind)
>> >>
>> >> The latter code is much more annotated and, to me, clearer as a result.
>> >>
>> >> I know that sometimes writing names is pretty unnecessary, because
>> >> it's already clear what the output of a function will be. And in that
>> >> case, adding names can just clutter the code and decrease the
>> >> information density, making it harder to read. But one can just use
>> >> (|!), which as I said makes things appear in a more logical order.
>> >>
>> >> Finally, there is a significant cost for any new infix operator. If
>> >> that thing is not used all the time, it is very obscure and makes code
>> >> quite opaque.
>> >>
>> >> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com>
>> >> wrote:
>> >> > As far as I can tell, the only way to compose functions is
>> >> > Fn.compose.
>> >> > Why
>> >> > not having an operator as well?  It's easier to say:
>> >> >
>> >> >     f1 |- f2 |- f3
>> >> >
>> >> > than
>> >> >
>> >> >     compose (compose f1 f2) f3
>> >> >
>> >> > Also, I see that Batteries has some other interesting function
>> >> > composition
>> >> > operators.  I don't have any use for it now, but we may want to think
>> >> > about
>> >> > it.
>> >> >
>> >> >
>> >> >
>> >> > http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From agarwal1975 at gmail.com  Fri Aug 31 23:14:05 2012
From: agarwal1975 at gmail.com (Ashish Agarwal)
Date: Fri, 31 Aug 2012 18:14:05 -0400
Subject: Core on a Mac
In-Reply-To: <027F8960-82EA-432D-884E-4E900389088F@recoil.org>
References: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com>
 <027F8960-82EA-432D-884E-4E900389088F@recoil.org>
Message-ID: <CAMu2m2LezwGjxo9v6ZV2JPdN58L6oPeRWno7K_5OA2e88pPpjQ@mail.gmail.com>

I install core from the release tarball on my OS X 10.7.4 Mac without
problems. It's on top of a base installation of ocaml, findlib, etc. from
godi.

On Fri, Aug 31, 2012 at 5:51 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> On 31 Aug 2012, at 14:48, David House <dmhouse at gmail.com> wrote:
>
> > I'm interested in getting core working on my Mac. Has anyone tried
> > this, and how well does it work?
>
>
> - Install Homebrew from http://github.com/mxcl/homebrew
> - $ brew install ocaml
> - $ brew tap mirage/ocaml      # hook in custom ocaml packages
> - $ brew install opam --HEAD   # get the very latest OPAM
> - $ opam install core async
> - $ eval `opam config -env`    # import the right PATH
>
> Some of these steps will disappear in a bit (e.g. the tap is only
> required until a more stable OPAM appears, which will hopefully be
> before ICFP in a couple of weeks).
>
> Note that Homebrew just updated to ocaml-4.00.0, so hopefully Core
> works with it too.
>
> -anil
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/dd09e25f/attachment.html>

From dmhouse at gmail.com  Fri Aug 31 21:04:16 2012
From: dmhouse at gmail.com (David House)
Date: Fri, 31 Aug 2012 21:04:16 +0100
Subject: Compose function operator
In-Reply-To: <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
Message-ID: <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>


Don't you mean:

  let name = lowercase |- to_string

Functional composition is normally written such that the function on
the right is applied first.

This strikes me as less clear than your example with |!, because of
the weird ordering.

But even without the ordering constraint, if |- were as clear or only
a little clearer than |!, we should still not include it, because |!
already exists (and is more general), and because of that cost of
every new infix operator that I mentioned before.

On 31 August 2012 21:00, Vladimir Brankov <brankovv at gmail.com> wrote:
> Composition would not hurt in this case:
>
>     let name = to_string |- lowercase
>
> as opposed to
>
>     let name t = to_string t |! lowercase
>
> IMHO both are slightly clearer than:
>
>     let name t = lowercase (to_string t)
>
> This is a small example, imagine if we have a few stacked functions.
>
> On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>>
>> There is already (|!) which almost does what you want, but in a more
>> logical order.
>>
>> I say "almost" since it does not allow you to build up a partially
>> applied function. But I for one very much dislike Fn.compose in those
>> scenarios. I think it's generally much clearer to write out the
>> lambda, since then one is forced to give a name to the variable. E.g.
>> which is clearer?
>>
>>   List.map events ~f:(Fn.compose to_string fst)
>>   List.map events ~f:(fun (kind, _time) -> to_string kind)
>>
>> The latter code is much more annotated and, to me, clearer as a result.
>>
>> I know that sometimes writing names is pretty unnecessary, because
>> it's already clear what the output of a function will be. And in that
>> case, adding names can just clutter the code and decrease the
>> information density, making it harder to read. But one can just use
>> (|!), which as I said makes things appear in a more logical order.
>>
>> Finally, there is a significant cost for any new infix operator. If
>> that thing is not used all the time, it is very obscure and makes code
>> quite opaque.
>>
>> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com>
>> wrote:
>> > As far as I can tell, the only way to compose functions is Fn.compose.
>> > Why
>> > not having an operator as well?  It's easier to say:
>> >
>> >     f1 |- f2 |- f3
>> >
>> > than
>> >
>> >     compose (compose f1 f2) f3
>> >
>> > Also, I see that Batteries has some other interesting function
>> > composition
>> > operators.  I don't have any use for it now, but we may want to think
>> > about
>> > it.
>> >
>> >
>> > http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From dmhouse at gmail.com  Fri Aug 31 22:11:51 2012
From: dmhouse at gmail.com (David House)
Date: Fri, 31 Aug 2012 22:11:51 +0100
Subject: Compose function operator
In-Reply-To: <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
Message-ID: <CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>


Yes, the first is preferred. You've called the variable [t], which
immediately tells me what kind of a list we're iterating over. In the
second example, I have to think about the type of to_string in order
to infer this.

Plus, the order is still weird, and the new infix operator is very
opaque. Everyone has to commit to memory what this new arbitrary
sequence of characters means. (As an aside, |! has this problem to a
lesser extent, because it visually looks like a unix command-line
pipe. This provides a helpful mnemonic, so remembering is much
easier.)

On 31 August 2012 21:20, Vladimir Brankov <brankovv at gmail.com> wrote:
> What about this case:
>
>     List.iter l ~f:(fun t -> to_string t |! lowercase)
>
> as opposed to
>
>     List.iter l ~f:(lowercase |- to_string)
>
> I suppose you would argue that the first one is preferred.  That raises a
> question - who decides whether a feature gets included or rejected?  I
> suppose that none of us can claim to know what the majority of the users
> would or wouldn't want.  What's the procedure for new features?
>
> On Friday, August 31, 2012 4:04:17 PM UTC-4, David House wrote:
>>
>> Don't you mean:
>>
>>   let name = lowercase |- to_string
>>
>> Functional composition is normally written such that the function on
>> the right is applied first.
>>
>> This strikes me as less clear than your example with |!, because of
>> the weird ordering.
>>
>> But even without the ordering constraint, if |- were as clear or only
>> a little clearer than |!, we should still not include it, because |!
>> already exists (and is more general), and because of that cost of
>> every new infix operator that I mentioned before.
>>
>> On 31 August 2012 21:00, Vladimir Brankov <bran... at gmail.com> wrote:
>> > Composition would not hurt in this case:
>> >
>> >     let name = to_string |- lowercase
>> >
>> > as opposed to
>> >
>> >     let name t = to_string t |! lowercase
>> >
>> > IMHO both are slightly clearer than:
>> >
>> >     let name t = lowercase (to_string t)
>> >
>> > This is a small example, imagine if we have a few stacked functions.
>> >
>> > On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>> >>
>> >> There is already (|!) which almost does what you want, but in a more
>> >> logical order.
>> >>
>> >> I say "almost" since it does not allow you to build up a partially
>> >> applied function. But I for one very much dislike Fn.compose in those
>> >> scenarios. I think it's generally much clearer to write out the
>> >> lambda, since then one is forced to give a name to the variable. E.g.
>> >> which is clearer?
>> >>
>> >>   List.map events ~f:(Fn.compose to_string fst)
>> >>   List.map events ~f:(fun (kind, _time) -> to_string kind)
>> >>
>> >> The latter code is much more annotated and, to me, clearer as a result.
>> >>
>> >> I know that sometimes writing names is pretty unnecessary, because
>> >> it's already clear what the output of a function will be. And in that
>> >> case, adding names can just clutter the code and decrease the
>> >> information density, making it harder to read. But one can just use
>> >> (|!), which as I said makes things appear in a more logical order.
>> >>
>> >> Finally, there is a significant cost for any new infix operator. If
>> >> that thing is not used all the time, it is very obscure and makes code
>> >> quite opaque.
>> >>
>> >> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com>
>> >> wrote:
>> >> > As far as I can tell, the only way to compose functions is
>> >> > Fn.compose.
>> >> > Why
>> >> > not having an operator as well?  It's easier to say:
>> >> >
>> >> >     f1 |- f2 |- f3
>> >> >
>> >> > than
>> >> >
>> >> >     compose (compose f1 f2) f3
>> >> >
>> >> > Also, I see that Batteries has some other interesting function
>> >> > composition
>> >> > operators.  I don't have any use for it now, but we may want to think
>> >> > about
>> >> > it.
>> >> >
>> >> >
>> >> >
>> >> > http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From dmhouse at gmail.com  Fri Aug 31 22:44:17 2012
From: dmhouse at gmail.com (David House)
Date: Fri, 31 Aug 2012 22:44:17 +0100
Subject: Compose function operator
In-Reply-To: <50412E45.9010407@gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
	<CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
	<50412E45.9010407@gmail.com>
Message-ID: <CADy1Mau+x7CsYix9ij7LLJkbpE+KQL89m82aMzHO-uH67qkz3g@mail.gmail.com>


Yeah, I've also thought that. |> does seem like a slightly better choice.


On 31 August 2012 22:36, Edgar Friendly <thelema314 at gmail.com> wrote:
> On 08/31/2012 05:11 PM, David House wrote:
>>
>> (As an aside, |! has this problem to a
>> lesser extent, because it visually looks like a unix command-line
>> pipe. This provides a helpful mnemonic, so remembering is much
>> easier.)
>
>
> To me, |! looks quite similar to ||.  I'm quite happy with the F# and
> batteries |> operator which visually looks like an arrow funneling data to
> the right.
>
> E.


From ocaml-core at googlegroups.com  Fri Aug  3 03:47:51 2012
From: ocaml-core at googlegroups.com (ocaml-core at googlegroups.com)
Date: Fri, 03 Aug 2012 02:47:51 +0000
Subject: Moderator's spam report for ocaml-core@googlegroups.com
Message-ID: <0016e65c7c28db87a404c6538dad@google.com>


This message is being sent to you because you are a moderator of the group ocaml-core.

The following suspicious messages were sent to your group, but are being held in your moderation queue because they are classified as likely spam messages.

If you take no action, all the messages below will be discarded automatically as spam.

However, if you see any messages that are not spam below, you may approve them individually by going to:

http://groups.google.com/group/ocaml-core/pendmsg

Please do not mark this notification as spam; this is a service for group moderators. If you do not wish to receive these notifications in the future, you may change your preferences by going to:

http://groups.google.com/group/ocaml-core/manage_post


------- 1 of 1  -------
Subject: greetings from very far
>From: "Ted"  <ted at softsoftwareapps.com>
Date: Jul 31 10:42PM -0400

what precisely time did you tell hook up?


Approve: http://groups.google.com/group/ocaml-core/pendmsg?view=full&pending_id=4193238326765171892


For more information about this message, please visit:
https://support.google.com/groups/bin/answer.py?hl=en&answer=47792



From ninjew at gmail.com  Sat Aug 11 04:05:29 2012
From: ninjew at gmail.com (David Ziman)
Date: Fri, 10 Aug 2012 20:05:29 -0700 (PDT)
Subject: installation mess
In-Reply-To: <CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com>
 <CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
Message-ID: <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>

I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a 
dependency for type-conv. Is there an ETA on this fix?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120810/f26c356e/attachment-0001.html>

From seanmcl at gmail.com  Mon Aug 13 18:04:51 2012
From: seanmcl at gmail.com (Sean McLaughlin)
Date: Mon, 13 Aug 2012 13:04:51 -0400
Subject: Lock_file on OSX
Message-ID: <CAO4dZbehnXY_cp1KiULn+u8FnQdrFcYKPcq+hQ8dCvnMz42B+g@mail.gmail.com>

It appears Lock_file does not work on OSX.

# Lock_file.create "/tmp/a";;
- : bool = false

The problem is in the call to

Unix.lockf fd ~mode:Unix.F_TLOCK ~len:Int64.zero;

which always raises an exception.

Exception:
Unix.Unix_error (Core.Std.Unix.EACCES, "lockf",
 "((fd 6) (mode F_TEST) (len 0))").

Unfortunately, this renders the very useful Core_service_command unusable
on OSX.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120813/5499ecb8/attachment-0001.html>

From markus.mottl at gmail.com  Wed Aug 15 17:24:39 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Wed, 15 Aug 2012 12:24:39 -0400
Subject: Bitbucket teams
Message-ID: <CAP_800p=9sN6A+jv782EeMUzXuvc9RX7CtkHcORv-k8MfFeN3Q@mail.gmail.com>


Hi,

not sure you've already considered this, but Bitbucket also supports teams:

  http://blog.bitbucket.org/2012/05/30/bitbucket-teams/

Maybe ocaml-core could also be organized that way, i.e. converted to a
team account?

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From yminsky at janestreet.com  Wed Aug 15 18:45:02 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 15 Aug 2012 13:45:02 -0400
Subject: Bitbucket teams
In-Reply-To: <CAP_800p=9sN6A+jv782EeMUzXuvc9RX7CtkHcORv-k8MfFeN3Q@mail.gmail.com>
References: <CAP_800p=9sN6A+jv782EeMUzXuvc9RX7CtkHcORv-k8MfFeN3Q@mail.gmail.com>
Message-ID: <CACLX4jT7_b9Qqvt6OCUNq1s7aBQyaPO5RzU+OYqW1+TpAvt1uQ@mail.gmail.com>


Yeah, I've considered this.  I have another project that I did this
way, and it worked well.  We should probably switch, though I think
it's not pressing right now.

y

On Wed, Aug 15, 2012 at 12:24 PM, Markus Mottl <markus.mottl at gmail.com> wrote:
> Hi,
>
> not sure you've already considered this, but Bitbucket also supports teams:
>
>   http://blog.bitbucket.org/2012/05/30/bitbucket-teams/
>
> Maybe ocaml-core could also be organized that way, i.e. converted to a
> team account?
>
> Regards,
> Markus
>
> --
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From anil at recoil.org  Fri Aug 17 02:46:15 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 16 Aug 2012 18:46:15 -0700
Subject: Lwt/Async abstraction for HTTP library
Message-ID: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>


I've been working on a release of a cooperative threading HTTP library, and have been using the opportunity to experiment with parameterising it over Lwt/Async.  I had a few (basic) Async questions as a result.

The code is at:
https://github.com/avsm/ocaml-cohttp/tree/v2-interface
(requires Lwt-current to build at the moment)

The basic IO interface that takes care of low-level parsing is very straightforward to implement in Async and Lwt:
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async_raw.ml
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt_raw.ml

The higher-level client HTTP interface is where Lwt and Async diverge, and so have different implementations. The Async version exposes the body as a Pipe which can be lazily consumed or passed to a proxy. This means that pipelined requests must be careful to wait until previous requests have fully consumed their respective bodies before using that particular channel.  In Lwt, this can be modelled with Lwt_stream.t that maps over the requests and responses.

In Async, I ran into a few basic questions while building the equivalent Lwt support.

- Only one Scheduler.go is supported (unlike Lwt_main, which can run multiple times in a program), which makes multiple Async tests hard to compose in oUnit.  Do you have a custom oUnit that can isolate  multiple Async test-cases, or should I write a forking one that does this?

- What's the best way to get a human-readable error?  I have this in the oUnit right now, which is very clunky:

  let _ =  Async_core.Scheduler.within' (fun () ->
    Monitor.try_with make_net_req >>=
    function
    |Error exn -> 
      (* TODO: how to dump out top-level errors in a nicer way? *)
       Printf.fprintf stderr "err %s.\n%!" (Exn.backtrace ()); return ()
    |Ok _ -> return ()
  ) in Async_unix.Scheduler.go ()

- Async_streams are deprecated, and I should use Pipes instead. I need to be able to run a background task that will close the I/O channel whenever the Pipe is completed to close the underlying fd.  I obtain a Deferred via Pipe.closed, but how should this run in the background?  Should I just ignore the return, or register it with the Scheduler?

In general, are there any toy network programs written using Async that I could crib good style from?

cheers,
Anil

From anil at recoil.org  Fri Aug 17 02:59:41 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 16 Aug 2012 18:59:41 -0700
Subject: Fwd: Lwt/Async abstraction for HTTP library
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
Message-ID: <BBF79EDB-E5E2-457C-ADC5-59A25BD1AAFB@recoil.org>


I also thought this might be quite useful for our (rapidly approaching) ICFP tutorial.  We could spend some time after the basics on showing how both Lwt/Async can be used to implement a simple web service or a crawler.  The Github API bindings are working pretty well, so would let us demonstrate Yojson as well.

-a

Begin forwarded message:

> From: Anil Madhavapeddy <anil at recoil.org>
> Subject: Lwt/Async abstraction for HTTP library
> Date: 16 August 2012 18:46:15 PDT
> To: "ocaml-core at googlegroups.com" <ocaml-core at googlegroups.com>
> Reply-To: ocaml-core at googlegroups.com
> 
> I've been working on a release of a cooperative threading HTTP library, and have been using the opportunity to experiment with parameterising it over Lwt/Async.  I had a few (basic) Async questions as a result.
> 
> The code is at:
> https://github.com/avsm/ocaml-cohttp/tree/v2-interface
> (requires Lwt-current to build at the moment)
> 
> The basic IO interface that takes care of low-level parsing is very straightforward to implement in Async and Lwt:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async_raw.ml
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt_raw.ml
> 
> The higher-level client HTTP interface is where Lwt and Async diverge, and so have different implementations. The Async version exposes the body as a Pipe which can be lazily consumed or passed to a proxy. This means that pipelined requests must be careful to wait until previous requests have fully consumed their respective bodies before using that particular channel.  In Lwt, this can be modelled with Lwt_stream.t that maps over the requests and responses.
> 
> In Async, I ran into a few basic questions while building the equivalent Lwt support.
> 
> - Only one Scheduler.go is supported (unlike Lwt_main, which can run multiple times in a program), which makes multiple Async tests hard to compose in oUnit.  Do you have a custom oUnit that can isolate  multiple Async test-cases, or should I write a forking one that does this?
> 
> - What's the best way to get a human-readable error?  I have this in the oUnit right now, which is very clunky:
> 
>  let _ =  Async_core.Scheduler.within' (fun () ->
>    Monitor.try_with make_net_req >>=
>    function
>    |Error exn -> 
>      (* TODO: how to dump out top-level errors in a nicer way? *)
>       Printf.fprintf stderr "err %s.\n%!" (Exn.backtrace ()); return ()
>    |Ok _ -> return ()
>  ) in Async_unix.Scheduler.go ()
> 
> - Async_streams are deprecated, and I should use Pipes instead. I need to be able to run a background task that will close the I/O channel whenever the Pipe is completed to close the underlying fd.  I obtain a Deferred via Pipe.closed, but how should this run in the background?  Should I just ignore the return, or register it with the Scheduler?
> 
> In general, are there any toy network programs written using Async that I could crib good style from?
> 
> cheers,
> Anil



From anil at recoil.org  Fri Aug 17 18:22:44 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 17 Aug 2012 10:22:44 -0700
Subject: installation mess
In-Reply-To: <CAOCAUGPOrgUWuxN8Oz2rSiY7eT6HmEn7LHyQqwrZHHpssyiwBw@mail.gmail.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com> <CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com> <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com> <CAOCAUGPOrgUWuxN8Oz2rSiY7eT6HmEn7LHyQqwrZHHpssyiwBw@mail.gmail.com>
Message-ID: <4E09736E-F2A8-4DE6-BED8-888795A38C52@recoil.org>


This isn't a big deal if you install the released version of core.  I use
OPAM for this day-to-day now.  Grab the latest OPAM from:

http://github.com/OCamlPro/opam (I just use HEAD)

$ opam init
$ opam install oasis core
$ eval `opam config -env` 

The last step will import the environment variables for the OPAM-installed
ocamlfind.  You then have a working OASIS-0.3 and Core, from which you can
regenerate the files in the dev repositories.

I believe Thomas is working on the last patchset for a feature addition
before OPAM can be declared beta, but I find it useful already.

-anil

On 17 Aug 2012, at 01:45, Sylvain Le Gall <sylvain at le-gall.net> wrote:

> Hello,
> 
> 2012/8/11 David Ziman <ninjew at gmail.com>:
>> I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a
>> dependency for type-conv. Is there an ETA on this fix?
> 
> <With my OASIS upstream author hat>
> 
> I start to be a little bit concerned of this situation. I think I
> should get rid of type-conv dependency. I would have preferred to keep
> ocaml-data-notation depends on type-conv but it makes things more
> complicated than needed (although, this only happens in the the dev
> version of ocaml-core).
> 
> Can type-conv people help me to migrate away from type-conv ? (ok
> this look like a weird request, but I think it will help everyone).
> 
> Regards
> Sylvain
> 



From sylvain at le-gall.net  Fri Aug 17 09:45:25 2012
From: sylvain at le-gall.net (Sylvain Le Gall)
Date: Fri, 17 Aug 2012 10:45:25 +0200
Subject: installation mess
In-Reply-To: <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com>
	<CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
	<a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
Message-ID: <CAOCAUGPOrgUWuxN8Oz2rSiY7eT6HmEn7LHyQqwrZHHpssyiwBw@mail.gmail.com>


Hello,

2012/8/11 David Ziman <ninjew at gmail.com>:
> I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a
> dependency for type-conv. Is there an ETA on this fix?

<With my OASIS upstream author hat>

I start to be a little bit concerned of this situation. I think I
should get rid of type-conv dependency. I would have preferred to keep
ocaml-data-notation depends on type-conv but it makes things more
complicated than needed (although, this only happens in the the dev
version of ocaml-core).

 Can type-conv people help me to migrate away from type-conv ? (ok
this look like a weird request, but I think it will help everyone).

Regards
Sylvain


From seanmcl at gmail.com  Fri Aug 17 20:57:48 2012
From: seanmcl at gmail.com (Sean McLaughlin)
Date: Fri, 17 Aug 2012 15:57:48 -0400
Subject: ocaml-core-submissions questions
Message-ID: <CAO4dZbctcsuqXw-fajTSfGWGO60nQ3yjFwibwvR-SwkD8X-7Zw@mail.gmail.com>

Hi,

I need to make a change to core to support some features on OSX.

1) Is cloning the ocaml-core-submissions queue is the way forward in
contributing to core?

If yes,

2) Why is yminsky/ocaml-core-submissions unrelated to
mmottl/ocaml-core-submissions?

Thanks,

Sean

/usr/local/src/ocaml-core-submissions-mmottl
$ hg fetch https://bitbucket.org/mmottl/ocaml-core-submissions
pulling from https://bitbucket.org/mmottl/ocaml-core-submissions
searching for changes
no changes found

/usr/local/src/ocaml-core-submissions-mmottl
$ hg fetch https://bitbucket.org/yminsky/ocaml-core-submissions
pulling from https://bitbucket.org/yminsky/ocaml-core-submissions
searching for changes
abort: repository is unrelated
EXIT STATUS 255
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120817/7abc6df5/attachment-0001.html>

From markus.mottl at gmail.com  Fri Aug 17 21:22:52 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Fri, 17 Aug 2012 16:22:52 -0400
Subject: ocaml-core-submissions questions
In-Reply-To: <CAO4dZbctcsuqXw-fajTSfGWGO60nQ3yjFwibwvR-SwkD8X-7Zw@mail.gmail.com>
References: <CAO4dZbctcsuqXw-fajTSfGWGO60nQ3yjFwibwvR-SwkD8X-7Zw@mail.gmail.com>
Message-ID: <CAP_800pLPiut0q4-TgaLO9jDuRRiyqfRUzYfdhHFsYARGqYywQ@mail.gmail.com>


On Fri, Aug 17, 2012 at 3:57 PM, Sean McLaughlin <seanmcl at gmail.com> wrote:
> Hi,
>
> I need to make a change to core to support some features on OSX.
>
> 1) Is cloning the ocaml-core-submissions queue is the way forward in
> contributing to core?

Basically, yes.  But it requires a certain procedure with Bitbucket.
Here is some documentation:

  http://ches.nausicaamedia.com/articles/technogeekery/using-mercurial-queues-and-bitbucket-org

> 2) Why is yminsky/ocaml-core-submissions unrelated to
> mmottl/ocaml-core-submissions?

You have to make sure to relate the right repositories.  With patch
queues there are really two of those: the "normal" repository for the
source tree and the patch queue repository in .hg/patches.  Most
Mercurial commands take a "--mq" flag to make sure that you are
performing some operation on the queue repository, not the "normal"
one.  You can also "cd" into the patch queue repository and then treat
it like a normal one (without "--mq").

My local source tree configuration in .hg/hgrc (default path) always
points to the original yminsky/ocaml-core-submissions repository at
Bitbucket.  But my patch queue repository configuration in
.hg/patches/.hg/hgrc points to my patch queue at Bitbucket.  That way
I can make sure to stay up-to-date wrt. the source tree, but my
patches will be pushed to my patch queue repository.  I can then send
pull requests via the web interface to Ron.

There is a slight initial learning curve with Bitbucket patch queues.
But once everything is set up correctly, it's really easy to use.

Cheers,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From yminsky at janestreet.com  Fri Aug 17 21:40:56 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 17 Aug 2012 16:40:56 -0400
Subject: installation mess
In-Reply-To: <a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
References: <CAMu2m2L=HZSutfPt2SArjTJKFBOzPaVU4G2REB-NELbQsw0ong@mail.gmail.com>
	<CACLX4jRqVSu8euuNEpf7Y_WahpHvt56OwvcAgUBxUVwTfuAVTA@mail.gmail.com>
	<a17c4d5f-6c85-4af5-b7e4-fe5400cf6b77@googlegroups.com>
Message-ID: <CACLX4jTXMxMnG8FQMKeqzaZ22avFYNi71kYHSL=q6SNERuYW7A@mail.gmail.com>


I'm actually confused by the question.  Oasis is indeed a dependency
for the dev version of type-conv.  If you grab a tarball and install,
there's no dependency, but the dev version requires it.  Why is this a
problem, i.e., why not just install Oasis?

There is the circularity issue that Sylvain mentions.  But I dealt
with that by: installing type-conv from the tarball; building and
installing oasis; and then building and installing the dev-version of
type-conv and the rest of core.  It's slightly awkward, but not
terrible.

y

On Fri, Aug 10, 2012 at 11:05 PM, David Ziman <ninjew at gmail.com> wrote:
> I pulled down changeset 139:8808e3a2571f . It appears that oasis is still a
> dependency for type-conv. Is there an ETA on this fix?


From yminsky at janestreet.com  Sun Aug 19 19:54:25 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 19 Aug 2012 14:54:25 -0400
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
Message-ID: <CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>


On Thu, Aug 16, 2012 at 9:46 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I've been working on a release of a cooperative threading HTTP library, and have been using the opportunity to experiment with parameterising it over Lwt/Async.  I had a few (basic) Async questions as a result.
>
> The code is at:
> https://github.com/avsm/ocaml-cohttp/tree/v2-interface
> (requires Lwt-current to build at the moment)
>
> The basic IO interface that takes care of low-level parsing is very straightforward to implement in Async and Lwt:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async_raw.ml
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt_raw.ml
>
> The higher-level client HTTP interface is where Lwt and Async diverge, and so have different implementations. The Async version exposes the body as a Pipe which can be lazily consumed or passed to a proxy. This means that pipelined requests must be careful to wait until previous requests have fully consumed their respective bodies before using that particular channel.  In Lwt, this can be modelled with Lwt_stream.t that maps over the requests and responses.
>
> In Async, I ran into a few basic questions while building the equivalent Lwt support.
>
> - Only one Scheduler.go is supported (unlike Lwt_main, which can run multiple times in a program), which makes multiple Async tests hard to compose in oUnit.  Do you have a custom oUnit that can isolate  multiple Async test-cases, or should I write a forking one that does this?
>
> - What's the best way to get a human-readable error?  I have this in the oUnit right now, which is very clunky:
>
>   let _ =  Async_core.Scheduler.within' (fun () ->
>     Monitor.try_with make_net_req >>=
>     function
>     |Error exn ->
>       (* TODO: how to dump out top-level errors in a nicer way? *)
>        Printf.fprintf stderr "err %s.\n%!" (Exn.backtrace ()); return ()
>     |Ok _ -> return ()
>   ) in Async_unix.Scheduler.go ()

One quick observation: this code would be a little cleaner if you
opened Async.Std.  Then you'd write:

   open Core.Std
   open Async.Std

   let _ =  within' (fun () ->
     try_with make_net_req
     >>= function
     | Error exn ->
       (* TODO: how to dump out top-level errors in a nicer way? *)
        fprintf stderr "err %s.\n%!" (Exn.backtrace ());
        return ()
     | Ok _ -> return ()
   )
   in
   Scheduler.go ()

Further, I don't think the [within'] call is doing you any good, since
you're not using it to set the block group, the monitor or the
priority.  So you should be able to just drop that.

Stephen, do you have a view as to how to do the error handling here
properly?

As a side note, we have a new release that should be out in a bit over
a week (it's totally done internally, but Yury, who is responsible for
the external releases, last week and the next.)  I think there are
some material changes there that should improve some of the error
presentation.

>
> - Async_streams are deprecated, and I should use Pipes instead. I
>   need to be able to run a background task that will close the I/O
>   channel whenever the Pipe is completed to close the underlying fd.
>   I obtain a Deferred via Pipe.closed, but how should this run in
>   the background?  Should I just ignore the return, or register it
>   with the Scheduler?

Sorry, I'm not quite able to decode the question.  Do you have a code
snippet you could share?

> In general, are there any toy network programs written using Async
> that I could crib good style from?

That's an excellent question.  We do have some examples that are
presently not included in our external tree.  I'll see if we can fix
that.

y


From yminsky at janestreet.com  Tue Aug 21 04:03:47 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 20 Aug 2012 23:03:47 -0400
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <20120821021103.GR24660@dark.recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
	<CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
	<20120821021103.GR24660@dark.recoil.org>
Message-ID: <CACLX4jQQhYjdwg=zDK=v432BKukTe2eDfya2-n4+5yHkePDbNA@mail.gmail.com>


On Mon, Aug 20, 2012 at 10:11 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On Sun, Aug 19, 2012 at 02:54:25PM -0400, Yaron Minsky wrote:
>> One quick observation: this code would be a little cleaner if you
>> opened Async.Std.  Then you'd write:
>>
>>    open Core.Std
>>    open Async.Std
>>
>
> Ah, I missed the Async package's existence and went straight for
> Async_unix.  I've now updated the dependency to use Async directly and all
> the interfaces are much simpler.
>
>>    let _ =  within' (fun () ->
>>      try_with make_net_req
>>      >>= function
>>      | Error exn ->
>>        (* TODO: how to dump out top-level errors in a nicer way? *)
>>         fprintf stderr "err %s.\n%!" (Exn.backtrace ());
>>         return ()
>>      | Ok _ -> return ()
>>    )
>>    in
>>    Scheduler.go ()
>>
>> Further, I don't think the [within'] call is doing you any good, since
>> you're not using it to set the block group, the monitor or the
>> priority.  So you should be able to just drop that.
>
> This was actually related to me experimenting with what all those options
> do (particularly the custom monitor).  I'll wait for your new update when
> Yury's back and see what the interface looks like.   Do you normally just
> read the s-expr encoded in Error.t, or do you have something fancier (the
> former is good enough for me in practise).

We usually just dump the s-expr that you get from the Error.t.

>> > - Async_streams are deprecated, and I should use Pipes instead. I
>> >   need to be able to run a background task that will close the I/O
>> >   channel whenever the Pipe is completed to close the underlying fd.
>> >   I obtain a Deferred via Pipe.closed, but how should this run in
>> >   the background?  Should I just ignore the return, or register it
>> >   with the Scheduler?
>>
>> Sorry, I'm not quite able to decode the question.  Do you have a code
>> snippet you could share?
>
> Yeah, in:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async.ml
>
> let pipe_of_body read_fn ic =
>   let rd, wr = Pipe.create () in
>   (* Consume from the input channel and write to the new pipe *)
>   let rec write () =
>     read_fn ic >>= function
>     |Transfer.Done ->
>       Pipe.close wr; return ()
>     |Transfer.Final_chunk c -> begin
>       Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>=
>         function
>         |`Closed -> return ()
>         |`Ok _ -> Pipe.close wr; return ()
>     end
>     |Transfer.Chunk c -> begin
>       Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>=
>         function
>         |`Closed -> return ()
>         |`Ok _ -> write ()
>     end
>   in
>   (* TODO: how to run write () as a background task? *)
>   let _ = write () in
>   rd
>
> This function is called to convert a HTTP body into a Pipe pair, such that
> the client can lazily consume the (potentially very large) HTTP body, or
> pass it onto a proxy process.  There is a write() function that reads from
> the HTTP body and potentially blocks on the I/O or pushback from the pipe.
> We immediately return the reader pipe as a return value from the function.
>
> So my question is what to do with:
>
>   (* TODO: how to run write () as a background task? *)
>   let _ = write () in
>   rd

The narrow answer to this one is: [write ()] is automatically run as a
background task, no registration required.  You'd normally write this:

   whenever (write ());
   rd

where `whenever` is actually a function that just ignores a [unit
Deferred.t].  We decided that `whenever` was a bit of a confusing name
for this, and we changed it to:

  don't_wait_for (write ());
  rd

in the latest release, which will come out next week.  But the effect
is just the same as:

  ignore (write () : unit Deferred.t);
  rd

> Does write() need to be registered with something to be a "proper"
> background task for accounting purposes, or to run a cleanup function if
> the Reader pipe terminates early?

I need to look at your example in more detail to understand how the
early termination you're talking about works.  I'll try to get to that
in the next day or so.

> The equivalent code in Lwt is here and looks like:
> https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt.ml
>
> let stream_of_body read_fn ic =
>   let fin = ref false in
>   Lwt_stream.from (fun () ->
>     match !fin with
>     |true -> return None
>     |false -> begin
>       match_lwt read_fn ic with
>       |Transfer.Done ->
>         return None
>       |Transfer.Final_chunk c ->
>         fin := true;
>         return (Some c);
>       |Transfer.Chunk c ->
>         return (Some c)
>     end
>   )
>
> The Lwt_stream that is returned has an Lwt.on_terminate handler for when
> the consumer hits EOF (e.g. to close the socket), and I think (but am a
> little blurry here) cancels the other end with an Lwt.Canceled exception
> if the other side stops early.
>
>> > In general, are there any toy network programs written using Async
>> > that I could crib good style from?
>>
>> That's an excellent question.  We do have some examples that are
>> presently not included in our external tree.  I'll see if we can fix
>> that.
>
> That would be great!
>
> --
> Anil Madhavapeddy                                 http://anil.recoil.org


From anil at recoil.org  Tue Aug 21 03:11:03 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 21 Aug 2012 03:11:03 +0100
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
 <CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
Message-ID: <20120821021103.GR24660@dark.recoil.org>


On Sun, Aug 19, 2012 at 02:54:25PM -0400, Yaron Minsky wrote:
> One quick observation: this code would be a little cleaner if you
> opened Async.Std.  Then you'd write:
> 
>    open Core.Std
>    open Async.Std
> 

Ah, I missed the Async package's existence and went straight for
Async_unix.  I've now updated the dependency to use Async directly and all
the interfaces are much simpler.

>    let _ =  within' (fun () ->
>      try_with make_net_req
>      >>= function
>      | Error exn ->
>        (* TODO: how to dump out top-level errors in a nicer way? *)
>         fprintf stderr "err %s.\n%!" (Exn.backtrace ());
>         return ()
>      | Ok _ -> return ()
>    )
>    in
>    Scheduler.go ()
> 
> Further, I don't think the [within'] call is doing you any good, since
> you're not using it to set the block group, the monitor or the
> priority.  So you should be able to just drop that.

This was actually related to me experimenting with what all those options
do (particularly the custom monitor).  I'll wait for your new update when
Yury's back and see what the interface looks like.   Do you normally just
read the s-expr encoded in Error.t, or do you have something fancier (the
former is good enough for me in practise).

> > - Async_streams are deprecated, and I should use Pipes instead. I
> >   need to be able to run a background task that will close the I/O
> >   channel whenever the Pipe is completed to close the underlying fd.
> >   I obtain a Deferred via Pipe.closed, but how should this run in
> >   the background?  Should I just ignore the return, or register it
> >   with the Scheduler?
> 
> Sorry, I'm not quite able to decode the question.  Do you have a code
> snippet you could share?

Yeah, in:
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/async/cohttp_async.ml

let pipe_of_body read_fn ic =
  let rd, wr = Pipe.create () in
  (* Consume from the input channel and write to the new pipe *)
  let rec write () =
    read_fn ic >>= function
    |Transfer.Done ->
      Pipe.close wr; return ()
    |Transfer.Final_chunk c -> begin
      Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>= 
        function
        |`Closed -> return ()
        |`Ok _ -> Pipe.close wr; return ()
    end
    |Transfer.Chunk c -> begin
      Pipe.with_write wr ~f:(fun wrfn -> wrfn c) >>=
        function
        |`Closed -> return ()
        |`Ok _ -> write () 
    end
  in
  (* TODO: how to run write () as a background task? *)
  let _ = write () in
  rd

This function is called to convert a HTTP body into a Pipe pair, such that
the client can lazily consume the (potentially very large) HTTP body, or
pass it onto a proxy process.  There is a write() function that reads from
the HTTP body and potentially blocks on the I/O or pushback from the pipe.
We immediately return the reader pipe as a return value from the function.

So my question is what to do with:

  (* TODO: how to run write () as a background task? *)
  let _ = write () in
  rd

Does write() need to be registered with something to be a "proper"
background task for accounting purposes, or to run a cleanup function if
the Reader pipe terminates early?

The equivalent code in Lwt is here and looks like:
https://github.com/avsm/ocaml-cohttp/blob/v2-interface/lwt/cohttp_lwt.ml

let stream_of_body read_fn ic =
  let fin = ref false in
  Lwt_stream.from (fun () ->
    match !fin with
    |true -> return None
    |false -> begin
      match_lwt read_fn ic with
      |Transfer.Done -> 
        return None
      |Transfer.Final_chunk c ->
        fin := true;
        return (Some c);
      |Transfer.Chunk c ->
        return (Some c)
    end
  )

The Lwt_stream that is returned has an Lwt.on_terminate handler for when
the consumer hits EOF (e.g. to close the socket), and I think (but am a
little blurry here) cancels the other end with an Lwt.Canceled exception
if the other side stops early.

> > In general, are there any toy network programs written using Async
> > that I could crib good style from?
> 
> That's an excellent question.  We do have some examples that are
> presently not included in our external tree.  I'll see if we can fix
> that.

That would be great!

-- 
Anil Madhavapeddy                                 http://anil.recoil.org


From jeremie at dimino.org  Tue Aug 21 10:55:48 2012
From: jeremie at dimino.org (=?UTF-8?B?SsOpcsOpbWll?= Dimino)
Date: Tue, 21 Aug 2012 11:55:48 +0200
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <20120821021103.GR24660@dark.recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
	<CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
	<20120821021103.GR24660@dark.recoil.org>
Message-ID: <20120821115548.7ccdc157@caladan.esterel-technologies.com>


Le Tue, 21 Aug 2012 03:11:03 +0100,
Anil Madhavapeddy <anil at recoil.org> a ?crit :

> The Lwt_stream that is returned has an Lwt.on_terminate handler for
> when the consumer hits EOF (e.g. to close the socket), and I think
> (but am a little blurry here) cancels the other end with an
> Lwt.Canceled exception if the other side stops early.

Actually no, cancelling an operation on a Lwt stream does not cancel
its "from" function. Allowing cancels in streams may lead to
unexpected behaviors.

J?r?mie


From dhouse at janestreet.com  Thu Aug 23 09:01:52 2012
From: dhouse at janestreet.com (David House)
Date: Thu, 23 Aug 2012 09:01:52 +0100
Subject: Lwt/Async abstraction for HTTP library
In-Reply-To: <20120821021103.GR24660@dark.recoil.org>
References: <C83A6D18-3331-4311-8874-AD50F5640E37@recoil.org>
	<CACLX4jS3Vw0boWAk-a+0DG7ALy4qxMuMiW6DYJ=EhLTrdm8JQA@mail.gmail.com>
	<20120821021103.GR24660@dark.recoil.org>
Message-ID: <CAK=fH+iho4Nzuvbi63yKc9nJRzyUakB9tPGHFkAmUg5N4pZf0A@mail.gmail.com>


On Tue, Aug 21, 2012 at 3:11 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> So my question is what to do with:
>
>   (* TODO: how to run write () as a background task? *)
>   let _ = write () in
>   rd
>
> Does write() need to be registered with something to be a "proper"
> background task for accounting purposes, or to run a cleanup function if
> the Reader pipe terminates early?

As Yaron points out, it is more idiomatic to say [whenever (write
())], or in the newer version of async, [don't_wait_for (write ())].
For example, the stuff below "TODO" in Client.read_response might be
written:

if close then don't_wait_for (
  Pipe.closed body_rd
  >>= fun () ->
  Reader.close ic
  >>= fun () ->
  Writer.close oc)

There is no need to register background processes with the scheduler.
Your code is already correct in the case of early termination by the
consumer: one of the [Pipe.write_when_ready] calls will terminate with
`Closed, and your loop will exit.

P.s. I see in your code that you open Deferred. Why is this? All of
the infix operators, plus [return] and a few others, are already in
the scope of Async.Std, so there is no need to go opening anything
else.

Also, two more stylistic points:

1. If the code on the right-hand side of a bind does not return a
deferred, it is common to use >>| instead of >>=, and then delete all
the "return"s on the right-hand side. E.g. in read_response.

2. All code between two binds is guaranteed to execute atomically,
without being interleaved with any other code. This is a very nice
feature of async, and really simplifies thinking about concurrent
code. Because of this, it is idiomatic to put all of your binds
flush-left, so that they stick out visually. (This is not quite
universal in our code base, but is certainly to be encouraged.) You
can see that in my snippet above.


From francois.berenger.working at gmail.com  Tue Aug 28 02:55:25 2012
From: francois.berenger.working at gmail.com (Francois Berenger)
Date: Mon, 27 Aug 2012 18:55:25 -0700 (PDT)
Subject: picture of the day
Message-ID: <206e1352-758b-424b-9c76-b0c903f857e8@googlegroups.com>

Hello,

Maybe the functionality to generate this will be in odb.ml soon.

Regards,
F.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120827/3e450d00/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: core_deps.png
Type: image/png
Size: 154987 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120827/3e450d00/attachment-0001.png>

From yminsky at janestreet.com  Tue Aug 28 03:32:45 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Mon, 27 Aug 2012 22:32:45 -0400
Subject: picture of the day
In-Reply-To: <206e1352-758b-424b-9c76-b0c903f857e8@googlegroups.com>
References: <206e1352-758b-424b-9c76-b0c903f857e8@googlegroups.com>
Message-ID: <CACLX4jRCbnUD74UTRnydvpeFkXo7R-bUOi=w7ZeLnjfO-MGBug@mail.gmail.com>


Very pretty!

On Mon, Aug 27, 2012 at 9:55 PM, Francois Berenger
<francois.berenger.working at gmail.com> wrote:
> Hello,
>
> Maybe the functionality to generate this will be in odb.ml soon.
>
> Regards,
> F.
>


From brankovv at gmail.com  Fri Aug 31 16:48:17 2012
From: brankovv at gmail.com (Vladimir Brankov)
Date: Fri, 31 Aug 2012 08:48:17 -0700 (PDT)
Subject: Compose function operator
Message-ID: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>

As far as I can tell, the only way to compose functions is Fn.compose.  Why 
not having an operator as well?  It's easier to say:

    f1 |- f2 |- f3

than

    compose (compose f1 f2) f3

Also, I see that Batteries has some other interesting function composition 
operators.  I don't have any use for it now, but we may want to think about 
it.

http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/18205b87/attachment-0001.html>

From seanmcl at gmail.com  Fri Aug 31 17:13:45 2012
From: seanmcl at gmail.com (Sean McLaughlin)
Date: Fri, 31 Aug 2012 12:13:45 -0400
Subject: Compose function operator
In-Reply-To: <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com> <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
Message-ID: <CAO4dZbdSdmNtEFX1TMXQsRND-1otet12vXO+XZ3K2u1LEVo+Tw@mail.gmail.com>

>
> Finally, there is a significant cost for any new infix operator. If
> that thing is not used all the time, it is very obscure and makes code
> quite opaque.
>

Function composition seems fundamental, and has built-in operators in SML
and Haskell.  I don't see a great reason why we don't have one in ocaml.
I personally think composition in Haskell can make code more clear (and
beautiful, if we're using aesthetics as some kind of metric as above.)

One major problem with composition in SML (also ocaml), is that the value
restriction prevents useful composition of pure functions.

$ sml
Standard ML of New Jersey v110.74 [built: Tue Jan 31 16:23:10 2012]
- fun id x = x
val id = fn : 'a -> 'a
- id o id;
stdIn:3.1-3.8 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val it = fn : ?.X1 -> ?.X1

Thus it's not nearly as useful as in Haskell.  You could imagine always
wrapping compositions in a big lambda

- fn x => (id o id o id o id) x;
val it = fn : 'a -> 'a

but this pretty much defeats the purpose if you have |!
fun x -> x |! id |! id |! id |! id

 On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <brankovv at gmail.com>
> wrote:
> > As far as I can tell, the only way to compose functions is Fn.compose.
>  Why
> > not having an operator as well?  It's easier to say:
> >
> >     f1 |- f2 |- f3
> >
> > than
> >
> >     compose (compose f1 f2) f3
> >
> > Also, I see that Batteries has some other interesting function
> composition
> > operators.  I don't have any use for it now, but we may want to think
> about
> > it.
> >
> >
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/e4a48792/attachment-0001.html>

From brankovv at gmail.com  Fri Aug 31 21:00:39 2012
From: brankovv at gmail.com (Vladimir Brankov)
Date: Fri, 31 Aug 2012 13:00:39 -0700 (PDT)
Subject: Compose function operator
In-Reply-To: <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
 <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
Message-ID: <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>

Composition would not hurt in this case:

    let name = to_string |- lowercase

as opposed to

    let name t = to_string t |! lowercase

IMHO both are slightly clearer than:

    let name t = lowercase (to_string t)

This is a small example, imagine if we have a few stacked functions.

On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>
> There is already (|!) which almost does what you want, but in a more 
> logical order. 
>
> I say "almost" since it does not allow you to build up a partially 
> applied function. But I for one very much dislike Fn.compose in those 
> scenarios. I think it's generally much clearer to write out the 
> lambda, since then one is forced to give a name to the variable. E.g. 
> which is clearer? 
>
>   List.map events ~f:(Fn.compose to_string fst) 
>   List.map events ~f:(fun (kind, _time) -> to_string kind) 
>
> The latter code is much more annotated and, to me, clearer as a result. 
>
> I know that sometimes writing names is pretty unnecessary, because 
> it's already clear what the output of a function will be. And in that 
> case, adding names can just clutter the code and decrease the 
> information density, making it harder to read. But one can just use 
> (|!), which as I said makes things appear in a more logical order. 
>
> Finally, there is a significant cost for any new infix operator. If 
> that thing is not used all the time, it is very obscure and makes code 
> quite opaque. 
>
> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com<javascript:>> 
> wrote: 
> > As far as I can tell, the only way to compose functions is Fn.compose. 
>  Why 
> > not having an operator as well?  It's easier to say: 
> > 
> >     f1 |- f2 |- f3 
> > 
> > than 
> > 
> >     compose (compose f1 f2) f3 
> > 
> > Also, I see that Batteries has some other interesting function 
> composition 
> > operators.  I don't have any use for it now, but we may want to think 
> about 
> > it. 
> > 
> > 
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html 
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/4b0eece6/attachment-0001.html>

From brankovv at gmail.com  Fri Aug 31 21:20:54 2012
From: brankovv at gmail.com (Vladimir Brankov)
Date: Fri, 31 Aug 2012 13:20:54 -0700 (PDT)
Subject: Compose function operator
In-Reply-To: <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
 <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
 <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
 <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
Message-ID: <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>

What about this case:

    List.iter l ~f:(fun t -> to_string t |! lowercase)

as opposed to

    List.iter l ~f:(lowercase |- to_string)

I suppose you would argue that the first one is preferred.  That raises a 
question - who decides whether a feature gets included or rejected?  I 
suppose that none of us can claim to know what the majority of the users 
would or wouldn't want.  What's the procedure for new features?

On Friday, August 31, 2012 4:04:17 PM UTC-4, David House wrote:
>
> Don't you mean: 
>
>   let name = lowercase |- to_string 
>
> Functional composition is normally written such that the function on 
> the right is applied first. 
>
> This strikes me as less clear than your example with |!, because of 
> the weird ordering. 
>
> But even without the ordering constraint, if |- were as clear or only 
> a little clearer than |!, we should still not include it, because |! 
> already exists (and is more general), and because of that cost of 
> every new infix operator that I mentioned before. 
>
> On 31 August 2012 21:00, Vladimir Brankov <bran... at gmail.com <javascript:>> 
> wrote: 
> > Composition would not hurt in this case: 
> > 
> >     let name = to_string |- lowercase 
> > 
> > as opposed to 
> > 
> >     let name t = to_string t |! lowercase 
> > 
> > IMHO both are slightly clearer than: 
> > 
> >     let name t = lowercase (to_string t) 
> > 
> > This is a small example, imagine if we have a few stacked functions. 
> > 
> > On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote: 
> >> 
> >> There is already (|!) which almost does what you want, but in a more 
> >> logical order. 
> >> 
> >> I say "almost" since it does not allow you to build up a partially 
> >> applied function. But I for one very much dislike Fn.compose in those 
> >> scenarios. I think it's generally much clearer to write out the 
> >> lambda, since then one is forced to give a name to the variable. E.g. 
> >> which is clearer? 
> >> 
> >>   List.map events ~f:(Fn.compose to_string fst) 
> >>   List.map events ~f:(fun (kind, _time) -> to_string kind) 
> >> 
> >> The latter code is much more annotated and, to me, clearer as a result. 
> >> 
> >> I know that sometimes writing names is pretty unnecessary, because 
> >> it's already clear what the output of a function will be. And in that 
> >> case, adding names can just clutter the code and decrease the 
> >> information density, making it harder to read. But one can just use 
> >> (|!), which as I said makes things appear in a more logical order. 
> >> 
> >> Finally, there is a significant cost for any new infix operator. If 
> >> that thing is not used all the time, it is very obscure and makes code 
> >> quite opaque. 
> >> 
> >> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com> 
> >> wrote: 
> >> > As far as I can tell, the only way to compose functions is 
> Fn.compose. 
> >> > Why 
> >> > not having an operator as well?  It's easier to say: 
> >> > 
> >> >     f1 |- f2 |- f3 
> >> > 
> >> > than 
> >> > 
> >> >     compose (compose f1 f2) f3 
> >> > 
> >> > Also, I see that Batteries has some other interesting function 
> >> > composition 
> >> > operators.  I don't have any use for it now, but we may want to think 
> >> > about 
> >> > it. 
> >> > 
> >> > 
> >> > 
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html 
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/8d4c3a34/attachment-0001.html>

From anil at recoil.org  Fri Aug 31 22:51:59 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 31 Aug 2012 14:51:59 -0700
Subject: Core on a Mac
In-Reply-To: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com>
References: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com>
Message-ID: <027F8960-82EA-432D-884E-4E900389088F@recoil.org>


On 31 Aug 2012, at 14:48, David House <dmhouse at gmail.com> wrote:

> I'm interested in getting core working on my Mac. Has anyone tried
> this, and how well does it work?


- Install Homebrew from http://github.com/mxcl/homebrew
- $ brew install ocaml
- $ brew tap mirage/ocaml      # hook in custom ocaml packages
- $ brew install opam --HEAD   # get the very latest OPAM
- $ opam install core async
- $ eval `opam config -env`    # import the right PATH

Some of these steps will disappear in a bit (e.g. the tap is only
required until a more stable OPAM appears, which will hopefully be
before ICFP in a couple of weeks).

Note that Homebrew just updated to ocaml-4.00.0, so hopefully Core
works with it too.

-anil


From anil at recoil.org  Fri Aug 31 23:18:32 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 31 Aug 2012 15:18:32 -0700
Subject: Core on a Mac
In-Reply-To: <CAMu2m2LezwGjxo9v6ZV2JPdN58L6oPeRWno7K_5OA2e88pPpjQ@mail.gmail.com>
References: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com> <027F8960-82EA-432D-884E-4E900389088F@recoil.org> <CAMu2m2LezwGjxo9v6ZV2JPdN58L6oPeRWno7K_5OA2e88pPpjQ@mail.gmail.com>
Message-ID: <96D17667-DE37-4116-85FB-583F61D1B7C7@recoil.org>

The Homebrew OCaml includes 10.8-specific fixes [1] too, which cause sporadic crashes otherwise with exception backtraces in particular.  And once OPAM is bootstrapped, it supports multiple local development environments via `opam switch`.  This is assuming its solver isn't going off and upgrading everything, which Thomas has mostly fixed now :)

[1] http://caml.inria.fr/mantis/view.php?id=5700

-a

On 31 Aug 2012, at 15:14, Ashish Agarwal <agarwal1975 at gmail.com> wrote:

> I install core from the release tarball on my OS X 10.7.4 Mac without problems. It's on top of a base installation of ocaml, findlib, etc. from godi.
> 
> On Fri, Aug 31, 2012 at 5:51 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On 31 Aug 2012, at 14:48, David House <dmhouse at gmail.com> wrote:
> 
> > I'm interested in getting core working on my Mac. Has anyone tried
> > this, and how well does it work?
> 
> 
> - Install Homebrew from http://github.com/mxcl/homebrew
> - $ brew install ocaml
> - $ brew tap mirage/ocaml      # hook in custom ocaml packages
> - $ brew install opam --HEAD   # get the very latest OPAM
> - $ opam install core async
> - $ eval `opam config -env`    # import the right PATH
> 
> Some of these steps will disappear in a bit (e.g. the tap is only
> required until a more stable OPAM appears, which will hopefully be
> before ICFP in a couple of weeks).
> 
> Note that Homebrew just updated to ocaml-4.00.0, so hopefully Core
> works with it too.
> 
> -anil
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/b8b167cf/attachment-0001.html>

From dhouse at janestreet.com  Fri Aug 31 17:01:10 2012
From: dhouse at janestreet.com (David House)
Date: Fri, 31 Aug 2012 17:01:10 +0100
Subject: Compose function operator
In-Reply-To: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
Message-ID: <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>


There is already (|!) which almost does what you want, but in a more
logical order.

I say "almost" since it does not allow you to build up a partially
applied function. But I for one very much dislike Fn.compose in those
scenarios. I think it's generally much clearer to write out the
lambda, since then one is forced to give a name to the variable. E.g.
which is clearer?

  List.map events ~f:(Fn.compose to_string fst)
  List.map events ~f:(fun (kind, _time) -> to_string kind)

The latter code is much more annotated and, to me, clearer as a result.

I know that sometimes writing names is pretty unnecessary, because
it's already clear what the output of a function will be. And in that
case, adding names can just clutter the code and decrease the
information density, making it harder to read. But one can just use
(|!), which as I said makes things appear in a more logical order.

Finally, there is a significant cost for any new infix operator. If
that thing is not used all the time, it is very obscure and makes code
quite opaque.

On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <brankovv at gmail.com> wrote:
> As far as I can tell, the only way to compose functions is Fn.compose.  Why
> not having an operator as well?  It's easier to say:
>
>     f1 |- f2 |- f3
>
> than
>
>     compose (compose f1 f2) f3
>
> Also, I see that Batteries has some other interesting function composition
> operators.  I don't have any use for it now, but we may want to think about
> it.
>
> http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From thelema314 at gmail.com  Fri Aug 31 22:36:05 2012
From: thelema314 at gmail.com (Edgar Friendly)
Date: Fri, 31 Aug 2012 17:36:05 -0400
Subject: Compose function operator
In-Reply-To: <CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com> <CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com> <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com> <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com> <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com> <CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
Message-ID: <50412E45.9010407@gmail.com>


On 08/31/2012 05:11 PM, David House wrote:
> (As an aside, |! has this problem to a
> lesser extent, because it visually looks like a unix command-line
> pipe. This provides a helpful mnemonic, so remembering is much
> easier.)

To me, |! looks quite similar to ||.  I'm quite happy with the F# and 
batteries |> operator which visually looks like an arrow funneling data 
to the right.

E.


From yminsky at janestreet.com  Fri Aug 31 22:42:13 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 31 Aug 2012 17:42:13 -0400
Subject: Compose function operator
In-Reply-To: <50412E45.9010407@gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
	<CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
	<50412E45.9010407@gmail.com>
Message-ID: <CACLX4jRByKHHZC=APCWorVpkV_rgpUNUO+Gh4YQCJgdsEFsK7w@mail.gmail.com>


Yeah, if we'd realized earlier, I would have liked to use |>.  I've
toyed with the idea of adding it as an alias, but switching all of our
internal code would be a lot of painful, pointless churn.

y

On Fri, Aug 31, 2012 at 5:36 PM, Edgar Friendly <thelema314 at gmail.com> wrote:
> On 08/31/2012 05:11 PM, David House wrote:
>>
>> (As an aside, |! has this problem to a
>> lesser extent, because it visually looks like a unix command-line
>> pipe. This provides a helpful mnemonic, so remembering is much
>> easier.)
>
>
> To me, |! looks quite similar to ||.  I'm quite happy with the F# and
> batteries |> operator which visually looks like an arrow funneling data to
> the right.
>
> E.


From yminsky at janestreet.com  Fri Aug 31 22:44:28 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 31 Aug 2012 17:44:28 -0400
Subject: Compose function operator
In-Reply-To: <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
Message-ID: <CACLX4jTU=Og-fnDpgAEzEFv1pPh3TKFhKJajLncxs=2DRwzZSg@mail.gmail.com>


We've talked about this one a lot internally over the years, and have
settled on not adding a compose operator.  Our experience has been
that code using the compose operator tends to be harder to read, and
House's point about the cognitive load of infix operators is well
taken.

y

On Fri, Aug 31, 2012 at 4:20 PM, Vladimir Brankov <brankovv at gmail.com> wrote:
> What about this case:
>
>     List.iter l ~f:(fun t -> to_string t |! lowercase)
>
> as opposed to
>
>     List.iter l ~f:(lowercase |- to_string)
>
> I suppose you would argue that the first one is preferred.  That raises a
> question - who decides whether a feature gets included or rejected?  I
> suppose that none of us can claim to know what the majority of the users
> would or wouldn't want.  What's the procedure for new features?
>
> On Friday, August 31, 2012 4:04:17 PM UTC-4, David House wrote:
>>
>> Don't you mean:
>>
>>   let name = lowercase |- to_string
>>
>> Functional composition is normally written such that the function on
>> the right is applied first.
>>
>> This strikes me as less clear than your example with |!, because of
>> the weird ordering.
>>
>> But even without the ordering constraint, if |- were as clear or only
>> a little clearer than |!, we should still not include it, because |!
>> already exists (and is more general), and because of that cost of
>> every new infix operator that I mentioned before.
>>
>> On 31 August 2012 21:00, Vladimir Brankov <bran... at gmail.com> wrote:
>> > Composition would not hurt in this case:
>> >
>> >     let name = to_string |- lowercase
>> >
>> > as opposed to
>> >
>> >     let name t = to_string t |! lowercase
>> >
>> > IMHO both are slightly clearer than:
>> >
>> >     let name t = lowercase (to_string t)
>> >
>> > This is a small example, imagine if we have a few stacked functions.
>> >
>> > On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>> >>
>> >> There is already (|!) which almost does what you want, but in a more
>> >> logical order.
>> >>
>> >> I say "almost" since it does not allow you to build up a partially
>> >> applied function. But I for one very much dislike Fn.compose in those
>> >> scenarios. I think it's generally much clearer to write out the
>> >> lambda, since then one is forced to give a name to the variable. E.g.
>> >> which is clearer?
>> >>
>> >>   List.map events ~f:(Fn.compose to_string fst)
>> >>   List.map events ~f:(fun (kind, _time) -> to_string kind)
>> >>
>> >> The latter code is much more annotated and, to me, clearer as a result.
>> >>
>> >> I know that sometimes writing names is pretty unnecessary, because
>> >> it's already clear what the output of a function will be. And in that
>> >> case, adding names can just clutter the code and decrease the
>> >> information density, making it harder to read. But one can just use
>> >> (|!), which as I said makes things appear in a more logical order.
>> >>
>> >> Finally, there is a significant cost for any new infix operator. If
>> >> that thing is not used all the time, it is very obscure and makes code
>> >> quite opaque.
>> >>
>> >> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com>
>> >> wrote:
>> >> > As far as I can tell, the only way to compose functions is
>> >> > Fn.compose.
>> >> > Why
>> >> > not having an operator as well?  It's easier to say:
>> >> >
>> >> >     f1 |- f2 |- f3
>> >> >
>> >> > than
>> >> >
>> >> >     compose (compose f1 f2) f3
>> >> >
>> >> > Also, I see that Batteries has some other interesting function
>> >> > composition
>> >> > operators.  I don't have any use for it now, but we may want to think
>> >> > about
>> >> > it.
>> >> >
>> >> >
>> >> >
>> >> > http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From agarwal1975 at gmail.com  Fri Aug 31 23:14:05 2012
From: agarwal1975 at gmail.com (Ashish Agarwal)
Date: Fri, 31 Aug 2012 18:14:05 -0400
Subject: Core on a Mac
In-Reply-To: <027F8960-82EA-432D-884E-4E900389088F@recoil.org>
References: <CADy1MavvzhL3+Q2WPV+4u1xcDmNcEUSCTvUMUu=A8SXPb96Nxg@mail.gmail.com>
 <027F8960-82EA-432D-884E-4E900389088F@recoil.org>
Message-ID: <CAMu2m2LezwGjxo9v6ZV2JPdN58L6oPeRWno7K_5OA2e88pPpjQ@mail.gmail.com>

I install core from the release tarball on my OS X 10.7.4 Mac without
problems. It's on top of a base installation of ocaml, findlib, etc. from
godi.

On Fri, Aug 31, 2012 at 5:51 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> On 31 Aug 2012, at 14:48, David House <dmhouse at gmail.com> wrote:
>
> > I'm interested in getting core working on my Mac. Has anyone tried
> > this, and how well does it work?
>
>
> - Install Homebrew from http://github.com/mxcl/homebrew
> - $ brew install ocaml
> - $ brew tap mirage/ocaml      # hook in custom ocaml packages
> - $ brew install opam --HEAD   # get the very latest OPAM
> - $ opam install core async
> - $ eval `opam config -env`    # import the right PATH
>
> Some of these steps will disappear in a bit (e.g. the tap is only
> required until a more stable OPAM appears, which will hopefully be
> before ICFP in a couple of weeks).
>
> Note that Homebrew just updated to ocaml-4.00.0, so hopefully Core
> works with it too.
>
> -anil
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20120831/dd09e25f/attachment-0001.html>

From dmhouse at gmail.com  Fri Aug 31 21:04:16 2012
From: dmhouse at gmail.com (David House)
Date: Fri, 31 Aug 2012 21:04:16 +0100
Subject: Compose function operator
In-Reply-To: <fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
Message-ID: <CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>


Don't you mean:

  let name = lowercase |- to_string

Functional composition is normally written such that the function on
the right is applied first.

This strikes me as less clear than your example with |!, because of
the weird ordering.

But even without the ordering constraint, if |- were as clear or only
a little clearer than |!, we should still not include it, because |!
already exists (and is more general), and because of that cost of
every new infix operator that I mentioned before.

On 31 August 2012 21:00, Vladimir Brankov <brankovv at gmail.com> wrote:
> Composition would not hurt in this case:
>
>     let name = to_string |- lowercase
>
> as opposed to
>
>     let name t = to_string t |! lowercase
>
> IMHO both are slightly clearer than:
>
>     let name t = lowercase (to_string t)
>
> This is a small example, imagine if we have a few stacked functions.
>
> On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>>
>> There is already (|!) which almost does what you want, but in a more
>> logical order.
>>
>> I say "almost" since it does not allow you to build up a partially
>> applied function. But I for one very much dislike Fn.compose in those
>> scenarios. I think it's generally much clearer to write out the
>> lambda, since then one is forced to give a name to the variable. E.g.
>> which is clearer?
>>
>>   List.map events ~f:(Fn.compose to_string fst)
>>   List.map events ~f:(fun (kind, _time) -> to_string kind)
>>
>> The latter code is much more annotated and, to me, clearer as a result.
>>
>> I know that sometimes writing names is pretty unnecessary, because
>> it's already clear what the output of a function will be. And in that
>> case, adding names can just clutter the code and decrease the
>> information density, making it harder to read. But one can just use
>> (|!), which as I said makes things appear in a more logical order.
>>
>> Finally, there is a significant cost for any new infix operator. If
>> that thing is not used all the time, it is very obscure and makes code
>> quite opaque.
>>
>> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com>
>> wrote:
>> > As far as I can tell, the only way to compose functions is Fn.compose.
>> > Why
>> > not having an operator as well?  It's easier to say:
>> >
>> >     f1 |- f2 |- f3
>> >
>> > than
>> >
>> >     compose (compose f1 f2) f3
>> >
>> > Also, I see that Batteries has some other interesting function
>> > composition
>> > operators.  I don't have any use for it now, but we may want to think
>> > about
>> > it.
>> >
>> >
>> > http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From dmhouse at gmail.com  Fri Aug 31 22:11:51 2012
From: dmhouse at gmail.com (David House)
Date: Fri, 31 Aug 2012 22:11:51 +0100
Subject: Compose function operator
In-Reply-To: <e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
Message-ID: <CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>


Yes, the first is preferred. You've called the variable [t], which
immediately tells me what kind of a list we're iterating over. In the
second example, I have to think about the type of to_string in order
to infer this.

Plus, the order is still weird, and the new infix operator is very
opaque. Everyone has to commit to memory what this new arbitrary
sequence of characters means. (As an aside, |! has this problem to a
lesser extent, because it visually looks like a unix command-line
pipe. This provides a helpful mnemonic, so remembering is much
easier.)

On 31 August 2012 21:20, Vladimir Brankov <brankovv at gmail.com> wrote:
> What about this case:
>
>     List.iter l ~f:(fun t -> to_string t |! lowercase)
>
> as opposed to
>
>     List.iter l ~f:(lowercase |- to_string)
>
> I suppose you would argue that the first one is preferred.  That raises a
> question - who decides whether a feature gets included or rejected?  I
> suppose that none of us can claim to know what the majority of the users
> would or wouldn't want.  What's the procedure for new features?
>
> On Friday, August 31, 2012 4:04:17 PM UTC-4, David House wrote:
>>
>> Don't you mean:
>>
>>   let name = lowercase |- to_string
>>
>> Functional composition is normally written such that the function on
>> the right is applied first.
>>
>> This strikes me as less clear than your example with |!, because of
>> the weird ordering.
>>
>> But even without the ordering constraint, if |- were as clear or only
>> a little clearer than |!, we should still not include it, because |!
>> already exists (and is more general), and because of that cost of
>> every new infix operator that I mentioned before.
>>
>> On 31 August 2012 21:00, Vladimir Brankov <bran... at gmail.com> wrote:
>> > Composition would not hurt in this case:
>> >
>> >     let name = to_string |- lowercase
>> >
>> > as opposed to
>> >
>> >     let name t = to_string t |! lowercase
>> >
>> > IMHO both are slightly clearer than:
>> >
>> >     let name t = lowercase (to_string t)
>> >
>> > This is a small example, imagine if we have a few stacked functions.
>> >
>> > On Friday, August 31, 2012 12:01:12 PM UTC-4, David House wrote:
>> >>
>> >> There is already (|!) which almost does what you want, but in a more
>> >> logical order.
>> >>
>> >> I say "almost" since it does not allow you to build up a partially
>> >> applied function. But I for one very much dislike Fn.compose in those
>> >> scenarios. I think it's generally much clearer to write out the
>> >> lambda, since then one is forced to give a name to the variable. E.g.
>> >> which is clearer?
>> >>
>> >>   List.map events ~f:(Fn.compose to_string fst)
>> >>   List.map events ~f:(fun (kind, _time) -> to_string kind)
>> >>
>> >> The latter code is much more annotated and, to me, clearer as a result.
>> >>
>> >> I know that sometimes writing names is pretty unnecessary, because
>> >> it's already clear what the output of a function will be. And in that
>> >> case, adding names can just clutter the code and decrease the
>> >> information density, making it harder to read. But one can just use
>> >> (|!), which as I said makes things appear in a more logical order.
>> >>
>> >> Finally, there is a significant cost for any new infix operator. If
>> >> that thing is not used all the time, it is very obscure and makes code
>> >> quite opaque.
>> >>
>> >> On Fri, Aug 31, 2012 at 4:48 PM, Vladimir Brankov <bran... at gmail.com>
>> >> wrote:
>> >> > As far as I can tell, the only way to compose functions is
>> >> > Fn.compose.
>> >> > Why
>> >> > not having an operator as well?  It's easier to say:
>> >> >
>> >> >     f1 |- f2 |- f3
>> >> >
>> >> > than
>> >> >
>> >> >     compose (compose f1 f2) f3
>> >> >
>> >> > Also, I see that Batteries has some other interesting function
>> >> > composition
>> >> > operators.  I don't have any use for it now, but we may want to think
>> >> > about
>> >> > it.
>> >> >
>> >> >
>> >> >
>> >> > http://batteries.forge.ocamlcore.org/doc.preview:batteries-beta1/html/api/Standard.html


From dmhouse at gmail.com  Fri Aug 31 22:44:17 2012
From: dmhouse at gmail.com (David House)
Date: Fri, 31 Aug 2012 22:44:17 +0100
Subject: Compose function operator
In-Reply-To: <50412E45.9010407@gmail.com>
References: <84233b57-4b25-4712-81eb-e30ec98d54cc@googlegroups.com>
	<CAK=fH+jzc59ccPkpkxrU+oG0_1qUsO_jiQ5rOZchn-Jr+VpN9w@mail.gmail.com>
	<fde573cc-4432-45a4-a408-7c41407b6248@googlegroups.com>
	<CADy1MasMTjjQXcn-oS27pDZS4T6ok0KCcQTCvnqozH6SSzATmw@mail.gmail.com>
	<e601804a-5f75-48e9-976e-dc7397de251b@googlegroups.com>
	<CADy1Masf1yQk-CD=FAh=-jSOcQfJN=2dVfemyWZGkuMMo275eQ@mail.gmail.com>
	<50412E45.9010407@gmail.com>
Message-ID: <CADy1Mau+x7CsYix9ij7LLJkbpE+KQL89m82aMzHO-uH67qkz3g@mail.gmail.com>


Yeah, I've also thought that. |> does seem like a slightly better choice.


On 31 August 2012 22:36, Edgar Friendly <thelema314 at gmail.com> wrote:
> On 08/31/2012 05:11 PM, David House wrote:
>>
>> (As an aside, |! has this problem to a
>> lesser extent, because it visually looks like a unix command-line
>> pipe. This provides a helpful mnemonic, so remembering is much
>> easier.)
>
>
> To me, |! looks quite similar to ||.  I'm quite happy with the F# and
> batteries |> operator which visually looks like an arrow funneling data to
> the right.
>
> E.


