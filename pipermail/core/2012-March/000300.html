<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> sexp_default
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:core%40lists.ocaml.org?Subject=Re%3A%20sexp_default&In-Reply-To=%3CCAOZm%2BP%3Ddr6HDGP1NER%2BDA-TRReiAZ-_a%2BtacC3c9XyxB_wmOTQ%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000299.html">
   <LINK REL="Next"  HREF="000302.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>sexp_default</H1>
    <B>Jim Clune</B> 
    <A HREF="mailto:core%40lists.ocaml.org?Subject=Re%3A%20sexp_default&In-Reply-To=%3CCAOZm%2BP%3Ddr6HDGP1NER%2BDA-TRReiAZ-_a%2BtacC3c9XyxB_wmOTQ%40mail.gmail.com%3E"
       TITLE="sexp_default">jim.clune at gmail.com
       </A><BR>
    <I>Sat Mar 31 20:16:52 BST 2012</I>
    <P><UL>
        <LI>Previous message: <A HREF="000299.html">sexp_default
</A></li>
        <LI>Next message: <A HREF="000302.html">sexp_default
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#300">[ date ]</a>
              <a href="thread.html#300">[ thread ]</a>
              <a href="subject.html#300">[ subject ]</a>
              <a href="author.html#300">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Perhaps I shouldn't have used the word &quot;semantics&quot;. Here is an example
of what I mean:

module A = struct
  type t = {
    guest : string;
    food : string sexp_default(&quot;steak&quot;)!;
  } with sexp
end

module B = struct
  type t = A.t = {
    guest : string;
    food : string sexp_default(&quot;fish&quot;);
  } with sexp
end

  let () =
    let original = { A.
      guest = &quot;Bob&quot;;
      food = &quot;steak&quot;;
    } in
    let x = B.t_of_sexp (A.sexp_of_t original) in
    printf &quot;%s ordered %s\n&quot; x.A.guest x.A.food

If I understand the proposal correctly, this will say that Bob ordered
fish even though he originally ordered steak. Obviously, one can write
custom sexp converters to get this behavior already. I'm just
questioning the desirability of having this be easy.

- Jim

On Sat, Mar 31, 2012 at 7:53 AM, Yaron Minsky &lt;<A HREF="http://lists.ocaml.org/listinfo/core">yminsky at janestreet.com</A>&gt; wrote:
&gt;<i> I think of this kind of multiple-view trick as pretty standard. &#160;We
</I>&gt;<i> use this internally quite a bit when we want to generate an alternate
</I>&gt;<i> view without creating a new type. &#160;We just create a new type-alias,
</I>&gt;<i> and attach the specialized converters to that type.
</I>&gt;<i>
</I>&gt;<i> I guess I'm just saying I'm in the &quot;feature, not bug&quot; camp. &#160;That
</I>&gt;<i> said, I'm not sure what you mean when you talk about &quot;silently
</I>&gt;<i> incompatible semantics&quot;. &#160;Can you create a toy example of the kind of
</I>&gt;<i> bug you're concerned about?
</I>&gt;<i>
</I>&gt;<i> y
</I>&gt;<i>
</I>&gt;<i> On Sat, Mar 31, 2012 at 5:31 AM, Jim Clune &lt;<A HREF="http://lists.ocaml.org/listinfo/core">jim.clune at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> Hi, Markus. Your proposal is interesting, but I'm a little concerned
</I>&gt;&gt;<i> about this part:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Using manifest types, developers can easily generate equivalent
</I>&gt;&gt;&gt;<i> instantiations of a record type with different conversion behavior.
</I>&gt;&gt;&gt;<i> E.g.:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &#160; &#160;type drop_foo_default = t = { foo : int sexp_default(foo)! } with sexp
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> This way different &quot;default views&quot; could be emitted for a given record.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> It is not clear to me whether this is best construed as a feature or a
</I>&gt;&gt;<i> bug. It seems to encourage people to make type-equivalences that have
</I>&gt;&gt;<i> sexp representations that can be generated by one type and parsed by
</I>&gt;&gt;<i> an &quot;equivalent&quot; type that has silently incompatible semantics. This,
</I>&gt;&gt;<i> combined with the fact that sexp representations do not embed the name
</I>&gt;&gt;<i> of the types or modules that generated them, looks to me to like a
</I>&gt;&gt;<i> recipe for bugs.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do you consider this facilitation of different &quot;default views&quot; to be
</I>&gt;&gt;<i> an important aspect of the proposal? Or is there a milder version of
</I>&gt;&gt;<i> the proposal that does not have this feature?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - Jim
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000299.html">sexp_default
</A></li>
	<LI>Next message: <A HREF="000302.html">sexp_default
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#300">[ date ]</a>
              <a href="thread.html#300">[ thread ]</a>
              <a href="subject.html#300">[ subject ]</a>
              <a href="author.html#300">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ocaml.org/listinfo/core">More information about the core
mailing list</a><br>
</body></html>
