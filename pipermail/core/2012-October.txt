From anil at recoil.org  Mon Oct  1 18:23:46 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 10:23:46 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
Message-ID: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>


Hi Yury,

I got a little lost in the new type_conv control flow (objects, why is it always objects!), but it looks like the bug is at:

  class vars_of = object
    inherit fold as super
    val vars = []
    method vars = vars
    method ident = function
    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
    | ident -> super#ident ident
  end
  let lids_of_patt patt =
    ((new vars_of)#patt patt)#vars

This extracts out all the identifiers in a pattern binding. In the case of dyntype, we generate output like:

let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
  <snip> in
   fun ?id_seed t =
     <snip>

I've simplified the Dyntype generation to be simply:

let value_of_t, value_of_foo =
   (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)

and it works fine now. The changeset is:
https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
and is present in dyntype-0.9.0.

Where would you like Core bugs such as this type_conv one to be reported?  The bitbucket issue tracker?

-anil

On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> Hi Anil,
> 
> I'll take a look at the dyntype extension to see how type_conv is broken, but the point of these assignments is to avoid ocaml 4's unused value warnings by from generated code. Apparently, type_conv thinks that values called "t", "ref", "t_of_value", and "value_of_t" have been generated by this extension.
> 
> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I've been porting some of our syntax extensions to the new type_conv (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of some extra bits that are generated:
> 
> For a simple:
> 
> # type t = int with value;;
> 
> This diff happens between the output of 108.00.02 and 108.07.00:
> 
> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> @@ -22,6 +22,12 @@
>            then Dyntype.Value.Rec ((("t", __id__), __x__))
>            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)), __x__))
> 
> +let _ = t
> +and _ = t
> +and _ = t
> +and _ = ref
> +and _ = value_of_t
> +
>  let (t_of_value : Dyntype.Value.t -> t) =
>    let module Deps =
>      struct
> @@ -73,4 +79,8 @@
>               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>      in t_of_value_aux { Deps.t = []; }
> 
> +let _ = t
> +and _ = t
> +and _ = t_of_value
> +
> 
> These are unbound, and so compilation breaks... what are they for?
> 
> -anil
> 



From anil at recoil.org  Mon Oct  1 18:49:25 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 10:49:25 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
Message-ID: <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>


Great!  The workaround was pretty straightforward, so I'll leave the simpler code generation in place.

Let me know when the bugfix is out, and we'll update OPAM.  Can your release system issue only a bumped version number for Core and Type_conv, instead of a complete set of new packages with new versions? This is a good test of the constraint system, as our constraints are probably way too specific (="108.07.00"). 

-a

On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> Hi Anil,
> 
> This was definitely a bug in type-conv. Valentin has a fix for this:
> 
> diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/pa_type_conv.ml
> --- a/base/type_conv/lib/pa_type_conv.ml
> +++ b/base/type_conv/lib/pa_type_conv.ml
> @@ -371,10 +371,11 @@
>        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc< '$var$ >>
>        | tp -> tp))#ctyp
>  
> -  class vars_of = object
> +  class vars_of = object (self)
>      inherit fold as super
>      val vars = []
>      method vars = vars
> +    method! ctyp _ = self
>      method ident = function
>      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>      | ident -> super#ident ident
> 
> I'd like to get a quick bugfix out the door that includes this and more portable use of mktemp in base/core/lib/discover.sh.
> 
> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> Hi Yury,
> 
> I got a little lost in the new type_conv control flow (objects, why is it always objects!), but it looks like the bug is at:
> 
>   class vars_of = object
>     inherit fold as super
>     val vars = []
>     method vars = vars
>     method ident = function
>     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>     | ident -> super#ident ident
>   end
>   let lids_of_patt patt =
>     ((new vars_of)#patt patt)#vars
> 
> This extracts out all the identifiers in a pattern binding. In the case of dyntype, we generate output like:
> 
> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>   <snip> in
>    fun ?id_seed t =
>      <snip>
> 
> I've simplified the Dyntype generation to be simply:
> 
> let value_of_t, value_of_foo =
>    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> 
> and it works fine now. The changeset is:
> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> and is present in dyntype-0.9.0.
> 
> Where would you like Core bugs such as this type_conv one to be reported?  The bitbucket issue tracker?
> 
> -anil
> 
> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> 
> > Hi Anil,
> >
> > I'll take a look at the dyntype extension to see how type_conv is broken, but the point of these assignments is to avoid ocaml 4's unused value warnings by from generated code. Apparently, type_conv thinks that values called "t", "ref", "t_of_value", and "value_of_t" have been generated by this extension.
> >
> > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > I've been porting some of our syntax extensions to the new type_conv (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of some extra bits that are generated:
> >
> > For a simple:
> >
> > # type t = int with value;;
> >
> > This diff happens between the output of 108.00.02 and 108.07.00:
> >
> > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > @@ -22,6 +22,12 @@
> >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)), __x__))
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t
> > +and _ = ref
> > +and _ = value_of_t
> > +
> >  let (t_of_value : Dyntype.Value.t -> t) =
> >    let module Deps =
> >      struct
> > @@ -73,4 +79,8 @@
> >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> >      in t_of_value_aux { Deps.t = []; }
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t_of_value
> > +
> >
> > These are unbound, and so compilation breaks... what are they for?
> >
> > -anil
> >
> 
> 



From anil at recoil.org  Mon Oct  1 19:36:02 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 11:36:02 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
Message-ID: <88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org>


On 1 Oct 2012, at 11:28, Markus Mottl <markus.mottl at gmail.com> wrote:

> Hi Yuri,
> 
> On Mon, Oct 1, 2012 at 1:37 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> This was definitely a bug in type-conv. Valentin has a fix for this:
> 
> It seems your latest version of type_conv has diverged already quite a
> lot from what's in the Core development tree or even patch queue.  I'm
> not sure what your release plans are for the future, but I find it
> rather hard to merge or even keep track of changes that happen in
> tarball releases but not in the development tree.  What are your
> future plans for the development process and release cycles?  I'd hope
> we'll see more activity in the development tree or at least patch
> queue.

I had a quick chat with Yaron about this at OUD.  It seems that the best
way to export changes from the JSC dev trees is via tarballs (that lose
history).  However, if we do not need patches to go *bidirectionally*, then
the Mercurial export infrastructure could be significantly simplified.

I propose something along these lines:

- JSC releases tarballs that are similar to the current ones, but with
  preX releases so we can see some changes before they're committed to
  the final release.

- These tarballs are committed by script against a Github repository of
  Core. This will lose renames if changes are made, but this can't be
  helped for now.

- Any patches or pull requests against the Github version are transformed
  into e-mail patches and sent to JSC for incorporation into a future
  version.  A Git merge will naturally resolve these.

It's not an ideal workflow as the external consumers lose all the version
history, but it would be a lot better than the current tarball/dev sync
issues.

An alternative, if JSC can keep the Bitbucket repo up-to-date more
frequently, is for us to setup a unidirectional Bitbucket->Github mirror.
In practical terms, there seems little advantage though, as the Bitbucket
repo also loses version history of changesets at present (I think).

Whatever happens, a Github repo would extremely useful to fit into other
project workflows such as http://github.com/xen-org/xen-api (where there
are autobuildbots that could work against forks and pre-release for
continuous build coverage tests).

-anil


From anil at recoil.org  Mon Oct  1 20:23:06 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 12:23:06 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAP_800rBTJW9wcbRYad87iFojk=KmSE+GCOSaZp8hWh_25rOsQ@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com> <88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org> <CAP_800rBTJW9wcbRYad87iFojk=KmSE+GCOSaZp8hWh_25rOsQ@mail.gmail.com>
Message-ID: <475013F1-3C0A-4BDC-A617-9AFF0E7E56D1@recoil.org>



On 1 Oct 2012, at 12:20, Markus Mottl <markus.mottl at gmail.com> wrote:

> On Mon, Oct 1, 2012 at 2:36 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> I had a quick chat with Yaron about this at OUD.  It seems that the best
>> way to export changes from the JSC dev trees is via tarballs (that lose
>> history).  However, if we do not need patches to go *bidirectionally*, then
>> the Mercurial export infrastructure could be significantly simplified.
> 
> I was under the (wrong?) impression that the bidirectional issues had
> been successfully resolved with the patch queue repository.  I can
> imagine that releasing the internal dev tree (Core part) via tarballs
> is less work for Jane Street than pushing changes to the external dev
> tree.  OTOH, it would be great if we could at least see changes in the
> patch queue, even if it's just one huge blob rather than more
> fine-grained patches.
> 
> For example, I don't even know which ones of my patches (if any) have
> made it into the internal tree.  If JS placed a patch into the queue
> such that it takes already existing, internally applied patches into
> account, external developers' lives would be much easier.  If you want
> to do things quickly without too much fine-grained control, you'd just
> have to apply the internally applied patches to the last release and
> create a new patch in the queue from the diff to the latest dev
> release.

I agree; if the patchqueue approach works, then it would be simpler than
tarball exports. The Github mirror could also be auto-synched as a read
only (perhaps rebased) tree from this.

-anil



From yury.sulsky at gmail.com  Mon Oct  1 18:37:24 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Mon, 1 Oct 2012 13:37:24 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
Message-ID: <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>

Hi Anil,

This was definitely a bug in type-conv. Valentin has a fix for this:

diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/
pa_type_conv.ml
--- a/base/type_conv/lib/pa_type_conv.ml
+++ b/base/type_conv/lib/pa_type_conv.ml
@@ -371,10 +371,11 @@
       | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
'$var$ >>
       | tp -> tp))#ctyp

-  class vars_of = object
+  class vars_of = object (self)
     inherit fold as super
     val vars = []
     method vars = vars
+    method! ctyp _ = self
     method ident = function
     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
     | ident -> super#ident ident

I'd like to get a quick bugfix out the door that includes this and more
portable use of mktemp in base/core/lib/discover.sh.

On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> Hi Yury,
>
> I got a little lost in the new type_conv control flow (objects, why is it
> always objects!), but it looks like the bug is at:
>
>   class vars_of = object
>     inherit fold as super
>     val vars = []
>     method vars = vars
>     method ident = function
>     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>     | ident -> super#ident ident
>   end
>   let lids_of_patt patt =
>     ((new vars_of)#patt patt)#vars
>
> This extracts out all the identifiers in a pattern binding. In the case of
> dyntype, we generate output like:
>
> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>   <snip> in
>    fun ?id_seed t =
>      <snip>
>
> I've simplified the Dyntype generation to be simply:
>
> let value_of_t, value_of_foo =
>    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>
> and it works fine now. The changeset is:
>
> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> and is present in dyntype-0.9.0.
>
> Where would you like Core bugs such as this type_conv one to be reported?
>  The bitbucket issue tracker?
>
> -anil
>
> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
> > Hi Anil,
> >
> > I'll take a look at the dyntype extension to see how type_conv is
> broken, but the point of these assignments is to avoid ocaml 4's unused
> value warnings by from generated code. Apparently, type_conv thinks that
> values called "t", "ref", "t_of_value", and "value_of_t" have been
> generated by this extension.
> >
> > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > I've been porting some of our syntax extensions to the new type_conv
> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
> some extra bits that are generated:
> >
> > For a simple:
> >
> > # type t = int with value;;
> >
> > This diff happens between the output of 108.00.02 and 108.07.00:
> >
> > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > @@ -22,6 +22,12 @@
> >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
> __x__))
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t
> > +and _ = ref
> > +and _ = value_of_t
> > +
> >  let (t_of_value : Dyntype.Value.t -> t) =
> >    let module Deps =
> >      struct
> > @@ -73,4 +79,8 @@
> >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> >      in t_of_value_aux { Deps.t = []; }
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t_of_value
> > +
> >
> > These are unbound, and so compilation breaks... what are they for?
> >
> > -anil
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121001/7d42b48a/attachment.html>

From markus.mottl at gmail.com  Mon Oct  1 19:28:08 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Mon, 1 Oct 2012 14:28:08 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
Message-ID: <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>


Hi Yuri,

On Mon, Oct 1, 2012 at 1:37 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> This was definitely a bug in type-conv. Valentin has a fix for this:

It seems your latest version of type_conv has diverged already quite a
lot from what's in the Core development tree or even patch queue.  I'm
not sure what your release plans are for the future, but I find it
rather hard to merge or even keep track of changes that happen in
tarball releases but not in the development tree.  What are your
future plans for the development process and release cycles?  I'd hope
we'll see more activity in the development tree or at least patch
queue.

Cheers,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From markus.mottl at gmail.com  Mon Oct  1 20:20:10 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Mon, 1 Oct 2012 15:20:10 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
	<88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org>
Message-ID: <CAP_800rBTJW9wcbRYad87iFojk=KmSE+GCOSaZp8hWh_25rOsQ@mail.gmail.com>


On Mon, Oct 1, 2012 at 2:36 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I had a quick chat with Yaron about this at OUD.  It seems that the best
> way to export changes from the JSC dev trees is via tarballs (that lose
> history).  However, if we do not need patches to go *bidirectionally*, then
> the Mercurial export infrastructure could be significantly simplified.

I was under the (wrong?) impression that the bidirectional issues had
been successfully resolved with the patch queue repository.  I can
imagine that releasing the internal dev tree (Core part) via tarballs
is less work for Jane Street than pushing changes to the external dev
tree.  OTOH, it would be great if we could at least see changes in the
patch queue, even if it's just one huge blob rather than more
fine-grained patches.

For example, I don't even know which ones of my patches (if any) have
made it into the internal tree.  If JS placed a patch into the queue
such that it takes already existing, internally applied patches into
account, external developers' lives would be much easier.  If you want
to do things quickly without too much fine-grained control, you'd just
have to apply the internally applied patches to the last release and
create a new patch in the queue from the diff to the latest dev
release.

> I propose something along these lines:
>
> - JSC releases tarballs that are similar to the current ones, but with
>   preX releases so we can see some changes before they're committed to
>   the final release.

This seems neatly addressed by the patch queue.  E.g. we might have
the policy that "Jane Street patches come first in the queue" so that
external developers have to fix their patches to stay compatible with
pre-releases rather than the other way round.

> - These tarballs are committed by script against a Github repository of
>   Core. This will lose renames if changes are made, but this can't be
>   helped for now.
>
> - Any patches or pull requests against the Github version are transformed
>   into e-mail patches and sent to JSC for incorporation into a future
>   version.  A Git merge will naturally resolve these.
>
> An alternative, if JSC can keep the Bitbucket repo up-to-date more
> frequently, is for us to setup a unidirectional Bitbucket->Github mirror.
> In practical terms, there seems little advantage though, as the Bitbucket
> repo also loses version history of changesets at present (I think).

This seems rather involved.  I think the fewer tools, scripts,
repositories, etc., we need to support the workflow, the better.

Has there ever been any attempt at JS to use the patch queue
repository to publish updates?  I don't see any problems with this
fairly simple approach, but your mileage may vary.

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From yury.sulsky at gmail.com  Mon Oct  1 21:57:02 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Mon, 1 Oct 2012 16:57:02 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
Message-ID: <CAEDxudxVT0OUHUpPRsDBcU9jABf5rYFR1zgD_VBfMc4ouGub-w@mail.gmail.com>

Hi Markus,

I think 108.08 will be the first version where the external tree is sync'd
to our internal one. We have tarballs for 108.07, but they include
portability fixes and changes for ocaml 4 compatibility that didn't make it
into our internal release. So rather than export that merge point, the
current plan is to wait until 108.08 and from then on maintain a patch
queue between releases.

On Mon, Oct 1, 2012 at 2:28 PM, Markus Mottl <markus.mottl at gmail.com> wrote:

> Hi Yuri,
>
> On Mon, Oct 1, 2012 at 1:37 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> > This was definitely a bug in type-conv. Valentin has a fix for this:
>
> It seems your latest version of type_conv has diverged already quite a
> lot from what's in the Core development tree or even patch queue.  I'm
> not sure what your release plans are for the future, but I find it
> rather hard to merge or even keep track of changes that happen in
> tarball releases but not in the development tree.  What are your
> future plans for the development process and release cycles?  I'd hope
> we'll see more activity in the development tree or at least patch
> queue.
>
> Cheers,
> Markus
>
> --
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121001/6dfa9ca2/attachment.html>

From yury.sulsky at gmail.com  Mon Oct  1 21:58:15 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Mon, 1 Oct 2012 16:58:15 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
Message-ID: <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>

Great, The tarballs are up here:
https://ocaml.janestreet.com/ocaml-core/108.07.01

Thanks!
Yury

On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> Great!  The workaround was pretty straightforward, so I'll leave the
> simpler code generation in place.
>
> Let me know when the bugfix is out, and we'll update OPAM.  Can your
> release system issue only a bumped version number for Core and Type_conv,
> instead of a complete set of new packages with new versions? This is a good
> test of the constraint system, as our constraints are probably way too
> specific (="108.07.00").
>
> -a
>
> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
> > Hi Anil,
> >
> > This was definitely a bug in type-conv. Valentin has a fix for this:
> >
> > diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/
> pa_type_conv.ml
> > --- a/base/type_conv/lib/pa_type_conv.ml
> > +++ b/base/type_conv/lib/pa_type_conv.ml
> > @@ -371,10 +371,11 @@
> >        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
> '$var$ >>
> >        | tp -> tp))#ctyp
> >
> > -  class vars_of = object
> > +  class vars_of = object (self)
> >      inherit fold as super
> >      val vars = []
> >      method vars = vars
> > +    method! ctyp _ = self
> >      method ident = function
> >      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >      | ident -> super#ident ident
> >
> > I'd like to get a quick bugfix out the door that includes this and more
> portable use of mktemp in base/core/lib/discover.sh.
> >
> > On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > Hi Yury,
> >
> > I got a little lost in the new type_conv control flow (objects, why is
> it always objects!), but it looks like the bug is at:
> >
> >   class vars_of = object
> >     inherit fold as super
> >     val vars = []
> >     method vars = vars
> >     method ident = function
> >     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >     | ident -> super#ident ident
> >   end
> >   let lids_of_patt patt =
> >     ((new vars_of)#patt patt)#vars
> >
> > This extracts out all the identifiers in a pattern binding. In the case
> of dyntype, we generate output like:
> >
> > let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
> >   <snip> in
> >    fun ?id_seed t =
> >      <snip>
> >
> > I've simplified the Dyntype generation to be simply:
> >
> > let value_of_t, value_of_foo =
> >    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> >
> > and it works fine now. The changeset is:
> >
> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> > and is present in dyntype-0.9.0.
> >
> > Where would you like Core bugs such as this type_conv one to be
> reported?  The bitbucket issue tracker?
> >
> > -anil
> >
> > On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >
> > > Hi Anil,
> > >
> > > I'll take a look at the dyntype extension to see how type_conv is
> broken, but the point of these assignments is to avoid ocaml 4's unused
> value warnings by from generated code. Apparently, type_conv thinks that
> values called "t", "ref", "t_of_value", and "value_of_t" have been
> generated by this extension.
> > >
> > > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > > I've been porting some of our syntax extensions to the new type_conv
> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
> some extra bits that are generated:
> > >
> > > For a simple:
> > >
> > > # type t = int with value;;
> > >
> > > This diff happens between the output of 108.00.02 and 108.07.00:
> > >
> > > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > > @@ -22,6 +22,12 @@
> > >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> > >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
> __x__))
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t
> > > +and _ = ref
> > > +and _ = value_of_t
> > > +
> > >  let (t_of_value : Dyntype.Value.t -> t) =
> > >    let module Deps =
> > >      struct
> > > @@ -73,4 +79,8 @@
> > >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> > >      in t_of_value_aux { Deps.t = []; }
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t_of_value
> > > +
> > >
> > > These are unbound, and so compilation breaks... what are they for?
> > >
> > > -anil
> > >
> >
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121001/d99ed71d/attachment.html>

From markus.mottl at gmail.com  Tue Oct  2 14:28:03 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Tue, 2 Oct 2012 09:28:03 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudxVT0OUHUpPRsDBcU9jABf5rYFR1zgD_VBfMc4ouGub-w@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
	<CAEDxudxVT0OUHUpPRsDBcU9jABf5rYFR1zgD_VBfMc4ouGub-w@mail.gmail.com>
Message-ID: <CAP_800oa2YeeNNDo9MzsGrrwEY8ow0=LrnFr6tLnZjbu=xDfiA@mail.gmail.com>


On Mon, Oct 1, 2012 at 4:57 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> I think 108.08 will be the first version where the external tree is sync'd
> to our internal one. We have tarballs for 108.07, but they include
> portability fixes and changes for ocaml 4 compatibility that didn't make it
> into our internal release. So rather than export that merge point, the
> current plan is to wait until 108.08 and from then on maintain a patch queue
> between releases.

Thanks, good to know that the development tree and patch queue are
still on the future release roadmap.

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From anil at recoil.org  Tue Oct  2 17:31:07 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 2 Oct 2012 09:31:07 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
Message-ID: <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>

This should be available on OPAM now too, if you do 'opam update'.

-anil

On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> Great, The tarballs are up here: https://ocaml.janestreet.com/ocaml-core/108.07.01
> 
> Thanks!
> Yury
> 
> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> Great!  The workaround was pretty straightforward, so I'll leave the simpler code generation in place.
> 
> Let me know when the bugfix is out, and we'll update OPAM.  Can your release system issue only a bumped version number for Core and Type_conv, instead of a complete set of new packages with new versions? This is a good test of the constraint system, as our constraints are probably way too specific (="108.07.00").
> 
> -a
> 
> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> 
> > Hi Anil,
> >
> > This was definitely a bug in type-conv. Valentin has a fix for this:
> >
> > diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/pa_type_conv.ml
> > --- a/base/type_conv/lib/pa_type_conv.ml
> > +++ b/base/type_conv/lib/pa_type_conv.ml
> > @@ -371,10 +371,11 @@
> >        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc< '$var$ >>
> >        | tp -> tp))#ctyp
> >
> > -  class vars_of = object
> > +  class vars_of = object (self)
> >      inherit fold as super
> >      val vars = []
> >      method vars = vars
> > +    method! ctyp _ = self
> >      method ident = function
> >      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >      | ident -> super#ident ident
> >
> > I'd like to get a quick bugfix out the door that includes this and more portable use of mktemp in base/core/lib/discover.sh.
> >
> > On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > Hi Yury,
> >
> > I got a little lost in the new type_conv control flow (objects, why is it always objects!), but it looks like the bug is at:
> >
> >   class vars_of = object
> >     inherit fold as super
> >     val vars = []
> >     method vars = vars
> >     method ident = function
> >     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >     | ident -> super#ident ident
> >   end
> >   let lids_of_patt patt =
> >     ((new vars_of)#patt patt)#vars
> >
> > This extracts out all the identifiers in a pattern binding. In the case of dyntype, we generate output like:
> >
> > let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
> >   <snip> in
> >    fun ?id_seed t =
> >      <snip>
> >
> > I've simplified the Dyntype generation to be simply:
> >
> > let value_of_t, value_of_foo =
> >    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> >
> > and it works fine now. The changeset is:
> > https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> > and is present in dyntype-0.9.0.
> >
> > Where would you like Core bugs such as this type_conv one to be reported?  The bitbucket issue tracker?
> >
> > -anil
> >
> > On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >
> > > Hi Anil,
> > >
> > > I'll take a look at the dyntype extension to see how type_conv is broken, but the point of these assignments is to avoid ocaml 4's unused value warnings by from generated code. Apparently, type_conv thinks that values called "t", "ref", "t_of_value", and "value_of_t" have been generated by this extension.
> > >
> > > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > > I've been porting some of our syntax extensions to the new type_conv (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of some extra bits that are generated:
> > >
> > > For a simple:
> > >
> > > # type t = int with value;;
> > >
> > > This diff happens between the output of 108.00.02 and 108.07.00:
> > >
> > > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > > @@ -22,6 +22,12 @@
> > >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> > >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)), __x__))
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t
> > > +and _ = ref
> > > +and _ = value_of_t
> > > +
> > >  let (t_of_value : Dyntype.Value.t -> t) =
> > >    let module Deps =
> > >      struct
> > > @@ -73,4 +79,8 @@
> > >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> > >      in t_of_value_aux { Deps.t = []; }
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t_of_value
> > > +
> > >
> > > These are unbound, and so compilation breaks... what are they for?
> > >
> > > -anil
> > >
> >
> >
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121002/084fa4a6/attachment.html>

From anil at recoil.org  Thu Oct  4 05:08:44 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Wed, 3 Oct 2012 21:08:44 -0700
Subject: scripting with ocaml and core
In-Reply-To: <20120924082606.133392d8@locris.home>
References: <CAO4dZbc2vtihEW8ViBU1KPT3SvK-Rh=UP5C4FErY_Ye00meG8Q@mail.gmail.com> <CACLX4jSSV13bY_J0pswjS=HQ24C+ZawNwEf7hj3dxaVQewgCbw@mail.gmail.com> <CAO4dZbfToja39pT0s1B+9fW=xZGrSNBdw0OS+v7U1Huy7J5FOQ@mail.gmail.com> <CACLX4jRHmrxbjqsO7sMge_2ATQ+sxdi4fnZCrut3n9j_rfOKOQ@mail.gmail.com> <A6CD9DEE-D02A-472F-94C0-E1CB6EBBB999@recoil.org> <20120924082606.133392d8@locris.home>
Message-ID: <87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>


On 23 Sep 2012, at 23:26, J?r?mie Dimino <jeremie at dimino.org> wrote:

> Le Sun, 23 Sep 2012 21:57:57 -0400,
> Anil Madhavapeddy <anil at recoil.org> a ?crit :
> 
>> Jeremie, have you ever tried utop as native code?
> 
> No, but it should work with the attached patch and the latest version
> of findlib.

Do you mean findlib-1.3.3?  I took a shot at getting this to work, and
ended up patching ocaml to install the toplevel cmx files, and findlib
to install findlib_top.cmxa, and then hit various linking errors. Just
wondering if you're using a patched compiler and ocamlfind with a native
toplevel, or if I'm missing something else before I look further.

-anil

From jeremie at dimino.org  Thu Oct  4 07:34:10 2012
From: jeremie at dimino.org (=?UTF-8?B?SsOpcsOpbWll?= Dimino)
Date: Thu, 4 Oct 2012 08:34:10 +0200
Subject: scripting with ocaml and core
In-Reply-To: <87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>
References: <CAO4dZbc2vtihEW8ViBU1KPT3SvK-Rh=UP5C4FErY_Ye00meG8Q@mail.gmail.com>
	<CACLX4jSSV13bY_J0pswjS=HQ24C+ZawNwEf7hj3dxaVQewgCbw@mail.gmail.com>
	<CAO4dZbfToja39pT0s1B+9fW=xZGrSNBdw0OS+v7U1Huy7J5FOQ@mail.gmail.com>
	<CACLX4jRHmrxbjqsO7sMge_2ATQ+sxdi4fnZCrut3n9j_rfOKOQ@mail.gmail.com>
	<A6CD9DEE-D02A-472F-94C0-E1CB6EBBB999@recoil.org>
	<20120924082606.133392d8@locris.home>
	<87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>
Message-ID: <20121004083410.6aefdf79@locris.home>


Le Wed, 3 Oct 2012 21:08:44 -0700,
Anil Madhavapeddy <anil at recoil.org> a ?crit :

> Do you mean findlib-1.3.3?  I took a shot at getting this to work, and
> ended up patching ocaml to install the toplevel cmx files, and findlib
> to install findlib_top.cmxa, and then hit various linking errors. Just
> wondering if you're using a patched compiler and ocamlfind with a
> native toplevel, or if I'm missing something else before I look
> further.

Yeah, actually it is a bit more complicated than what i thought (i did
not try it). I made it work but i had to install ocaml*.cmxa, replace
Topfoo by Opttopfoo in findlib and utop, and modify a bit META files.

-- 
J?r?mie


From jeremie at dimino.org  Thu Oct  4 16:42:04 2012
From: jeremie at dimino.org (=?UTF-8?B?SsOpcsOpbWll?= Dimino)
Date: Thu, 4 Oct 2012 17:42:04 +0200
Subject: scripting with ocaml and core
In-Reply-To: <20121004083410.6aefdf79@locris.home>
References: <CAO4dZbc2vtihEW8ViBU1KPT3SvK-Rh=UP5C4FErY_Ye00meG8Q@mail.gmail.com>
	<CACLX4jSSV13bY_J0pswjS=HQ24C+ZawNwEf7hj3dxaVQewgCbw@mail.gmail.com>
	<CAO4dZbfToja39pT0s1B+9fW=xZGrSNBdw0OS+v7U1Huy7J5FOQ@mail.gmail.com>
	<CACLX4jRHmrxbjqsO7sMge_2ATQ+sxdi4fnZCrut3n9j_rfOKOQ@mail.gmail.com>
	<A6CD9DEE-D02A-472F-94C0-E1CB6EBBB999@recoil.org>
	<20120924082606.133392d8@locris.home>
	<87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>
	<20121004083410.6aefdf79@locris.home>
Message-ID: <20121004174204.70ddc8f7@caladan.esterel-technologies.com>

Le Thu, 4 Oct 2012 08:34:10 +0200,
J?r?mie Dimino <jeremie at dimino.org> a ?crit :

> Yeah, actually it is a bit more complicated than what i thought (i did
> not try it). I made it work but i had to install ocaml*.cmxa, replace
> Topfoo by Opttopfoo in findlib and utop, and modify a bit META files.

I put in attachement the patches needed to build a native utop.

-- 
J?r?mie
-------------- next part --------------
A non-text attachment was scrubbed...
Name: findlib-1.3.3.diff
Type: text/x-patch
Size: 4426 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121004/7ebad83b/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ocaml-trunk.diff
Type: text/x-patch
Size: 8076 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121004/7ebad83b/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: utop-trunk.diff
Type: text/x-patch
Size: 24539 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121004/7ebad83b/attachment-0002.bin>

From anil at recoil.org  Fri Oct  5 01:45:40 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 4 Oct 2012 17:45:40 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <-2309447399847593243@unknownmsgid>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com> <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com> <-2309447399847593243@unknownmsgid>
Message-ID: <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>


That's correct; almost all non-Core packages are broken by the
type_conv interface change. I have some patches queued up for them,
but haven't had a chance to submit them upstream yet.  Some (such
as Dyntype) I've already fixed, but I haven't done OASIS yet.

For now, a decent workaround is to switch to a compiler alias to
install OASIS, and otherwise use the new type_conv in a separate
switch.

-anil

On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> It looks like ocaml-data-notation should be upgraded to work with a
> newer version of type_conv. If you're not using  oasis, can you just
> remove it?
> 
> Yury
> 
> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> 
>> I can't seem to get the new async to build, even in the latest opam.
>> By default it picks the older async, and when I pin to the latest
>> version, I get:
>> 
>> en $ opam upgrade async
>> No solution has been found:
>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>> async_core.108.07.01 <- async.108.07.01
>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>> 
>> Any thoughts on how to get this to work?
>> 
>> y
>> 
>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> This should be available on OPAM now too, if you do 'opam update'.
>>> 
>>> -anil
>>> 
>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>> 
>>> Great, The tarballs are up here:
>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>> 
>>> Thanks!
>>> Yury
>>> 
>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> 
>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>> simpler code generation in place.
>>>> 
>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>> release system issue only a bumped version number for Core and Type_conv,
>>>> instead of a complete set of new packages with new versions? This is a good
>>>> test of the constraint system, as our constraints are probably way too
>>>> specific (="108.07.00").
>>>> 
>>>> -a
>>>> 
>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>> 
>>>>> Hi Anil,
>>>>> 
>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>> 
>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>> @@ -371,10 +371,11 @@
>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>> '$var$ >>
>>>>>      | tp -> tp))#ctyp
>>>>> 
>>>>> -  class vars_of = object
>>>>> +  class vars_of = object (self)
>>>>>    inherit fold as super
>>>>>    val vars = []
>>>>>    method vars = vars
>>>>> +    method! ctyp _ = self
>>>>>    method ident = function
>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>    | ident -> super#ident ident
>>>>> 
>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>> 
>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>> wrote:
>>>>> Hi Yury,
>>>>> 
>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>> it always objects!), but it looks like the bug is at:
>>>>> 
>>>>> class vars_of = object
>>>>>   inherit fold as super
>>>>>   val vars = []
>>>>>   method vars = vars
>>>>>   method ident = function
>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>   | ident -> super#ident ident
>>>>> end
>>>>> let lids_of_patt patt =
>>>>>   ((new vars_of)#patt patt)#vars
>>>>> 
>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>> of dyntype, we generate output like:
>>>>> 
>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>> <snip> in
>>>>>  fun ?id_seed t =
>>>>>    <snip>
>>>>> 
>>>>> I've simplified the Dyntype generation to be simply:
>>>>> 
>>>>> let value_of_t, value_of_foo =
>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>> 
>>>>> and it works fine now. The changeset is:
>>>>> 
>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>> and is present in dyntype-0.9.0.
>>>>> 
>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>> reported?  The bitbucket issue tracker?
>>>>> 
>>>>> -anil
>>>>> 
>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>> 
>>>>>> Hi Anil,
>>>>>> 
>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>> by this extension.
>>>>>> 
>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>> wrote:
>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>> some extra bits that are generated:
>>>>>> 
>>>>>> For a simple:
>>>>>> 
>>>>>> # type t = int with value;;
>>>>>> 
>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>> 
>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>> @@ -22,6 +22,12 @@
>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>> __x__))
>>>>>> 
>>>>>> +let _ = t
>>>>>> +and _ = t
>>>>>> +and _ = t
>>>>>> +and _ = ref
>>>>>> +and _ = value_of_t
>>>>>> +
>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>  let module Deps =
>>>>>>    struct
>>>>>> @@ -73,4 +79,8 @@
>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>> 
>>>>>> +let _ = t
>>>>>> +and _ = t
>>>>>> +and _ = t_of_value
>>>>>> +
>>>>>> 
>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>> 
>>>>>> -anil
>>> 
>>> 
> 



From yminsky at janestreet.com  Fri Oct  5 01:34:35 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 4 Oct 2012 20:34:35 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
Message-ID: <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>


I can't seem to get the new async to build, even in the latest opam.
By default it picks the older async, and when I pin to the latest
version, I get:

en $ opam upgrade async
No solution has been found:
 - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
 + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
async_core.108.07.01 <- async.108.07.01
 + type_conv.108.00.02 <- ocaml-data-notation.0.0.9

Any thoughts on how to get this to work?

y

On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> This should be available on OPAM now too, if you do 'opam update'.
>
> -anil
>
> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
> Great, The tarballs are up here:
> https://ocaml.janestreet.com/ocaml-core/108.07.01
>
> Thanks!
> Yury
>
> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>
>> Great!  The workaround was pretty straightforward, so I'll leave the
>> simpler code generation in place.
>>
>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>> release system issue only a bumped version number for Core and Type_conv,
>> instead of a complete set of new packages with new versions? This is a good
>> test of the constraint system, as our constraints are probably way too
>> specific (="108.07.00").
>>
>> -a
>>
>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>
>> > Hi Anil,
>> >
>> > This was definitely a bug in type-conv. Valentin has a fix for this:
>> >
>> > diff --git a/base/type_conv/lib/pa_type_conv.ml
>> > b/base/type_conv/lib/pa_type_conv.ml
>> > --- a/base/type_conv/lib/pa_type_conv.ml
>> > +++ b/base/type_conv/lib/pa_type_conv.ml
>> > @@ -371,10 +371,11 @@
>> >        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>> > '$var$ >>
>> >        | tp -> tp))#ctyp
>> >
>> > -  class vars_of = object
>> > +  class vars_of = object (self)
>> >      inherit fold as super
>> >      val vars = []
>> >      method vars = vars
>> > +    method! ctyp _ = self
>> >      method ident = function
>> >      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >      | ident -> super#ident ident
>> >
>> > I'd like to get a quick bugfix out the door that includes this and more
>> > portable use of mktemp in base/core/lib/discover.sh.
>> >
>> > On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>> > wrote:
>> > Hi Yury,
>> >
>> > I got a little lost in the new type_conv control flow (objects, why is
>> > it always objects!), but it looks like the bug is at:
>> >
>> >   class vars_of = object
>> >     inherit fold as super
>> >     val vars = []
>> >     method vars = vars
>> >     method ident = function
>> >     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >     | ident -> super#ident ident
>> >   end
>> >   let lids_of_patt patt =
>> >     ((new vars_of)#patt patt)#vars
>> >
>> > This extracts out all the identifiers in a pattern binding. In the case
>> > of dyntype, we generate output like:
>> >
>> > let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>> >   <snip> in
>> >    fun ?id_seed t =
>> >      <snip>
>> >
>> > I've simplified the Dyntype generation to be simply:
>> >
>> > let value_of_t, value_of_foo =
>> >    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>> >
>> > and it works fine now. The changeset is:
>> >
>> > https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>> > and is present in dyntype-0.9.0.
>> >
>> > Where would you like Core bugs such as this type_conv one to be
>> > reported?  The bitbucket issue tracker?
>> >
>> > -anil
>> >
>> > On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >
>> > > Hi Anil,
>> > >
>> > > I'll take a look at the dyntype extension to see how type_conv is
>> > > broken, but the point of these assignments is to avoid ocaml 4's unused
>> > > value warnings by from generated code. Apparently, type_conv thinks that
>> > > values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>> > > by this extension.
>> > >
>> > > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>> > > wrote:
>> > > I've been porting some of our syntax extensions to the new type_conv
>> > > (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>> > > some extra bits that are generated:
>> > >
>> > > For a simple:
>> > >
>> > > # type t = int with value;;
>> > >
>> > > This diff happens between the output of 108.00.02 and 108.07.00:
>> > >
>> > > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>> > > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>> > > @@ -22,6 +22,12 @@
>> > >            then Dyntype.Value.Rec ((("t", __id__), __x__))
>> > >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>> > > __x__))
>> > >
>> > > +let _ = t
>> > > +and _ = t
>> > > +and _ = t
>> > > +and _ = ref
>> > > +and _ = value_of_t
>> > > +
>> > >  let (t_of_value : Dyntype.Value.t -> t) =
>> > >    let module Deps =
>> > >      struct
>> > > @@ -73,4 +79,8 @@
>> > >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>> > >      in t_of_value_aux { Deps.t = []; }
>> > >
>> > > +let _ = t
>> > > +and _ = t
>> > > +and _ = t_of_value
>> > > +
>> > >
>> > > These are unbound, and so compilation breaks... what are they for?
>> > >
>> > > -anil
>> > >
>> >
>> >
>>
>
>


From yury.sulsky at gmail.com  Fri Oct  5 01:40:32 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Thu, 4 Oct 2012 20:40:32 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
 <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
 <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
 <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
 <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
Message-ID: <-2309447399847593243@unknownmsgid>


It looks like ocaml-data-notation should be upgraded to work with a
newer version of type_conv. If you're not using  oasis, can you just
remove it?

Yury

On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:

> I can't seem to get the new async to build, even in the latest opam.
> By default it picks the older async, and when I pin to the latest
> version, I get:
>
> en $ opam upgrade async
> No solution has been found:
> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
> async_core.108.07.01 <- async.108.07.01
> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>
> Any thoughts on how to get this to work?
>
> y
>
> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> This should be available on OPAM now too, if you do 'opam update'.
>>
>> -anil
>>
>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>
>> Great, The tarballs are up here:
>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>
>> Thanks!
>> Yury
>>
>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>
>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>> simpler code generation in place.
>>>
>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>> release system issue only a bumped version number for Core and Type_conv,
>>> instead of a complete set of new packages with new versions? This is a good
>>> test of the constraint system, as our constraints are probably way too
>>> specific (="108.07.00").
>>>
>>> -a
>>>
>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>
>>>> Hi Anil,
>>>>
>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>
>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>> @@ -371,10 +371,11 @@
>>>>       | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>> '$var$ >>
>>>>       | tp -> tp))#ctyp
>>>>
>>>> -  class vars_of = object
>>>> +  class vars_of = object (self)
>>>>     inherit fold as super
>>>>     val vars = []
>>>>     method vars = vars
>>>> +    method! ctyp _ = self
>>>>     method ident = function
>>>>     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>     | ident -> super#ident ident
>>>>
>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>
>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>> wrote:
>>>> Hi Yury,
>>>>
>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>> it always objects!), but it looks like the bug is at:
>>>>
>>>>  class vars_of = object
>>>>    inherit fold as super
>>>>    val vars = []
>>>>    method vars = vars
>>>>    method ident = function
>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>    | ident -> super#ident ident
>>>>  end
>>>>  let lids_of_patt patt =
>>>>    ((new vars_of)#patt patt)#vars
>>>>
>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>> of dyntype, we generate output like:
>>>>
>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>  <snip> in
>>>>   fun ?id_seed t =
>>>>     <snip>
>>>>
>>>> I've simplified the Dyntype generation to be simply:
>>>>
>>>> let value_of_t, value_of_foo =
>>>>   (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>
>>>> and it works fine now. The changeset is:
>>>>
>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>> and is present in dyntype-0.9.0.
>>>>
>>>> Where would you like Core bugs such as this type_conv one to be
>>>> reported?  The bitbucket issue tracker?
>>>>
>>>> -anil
>>>>
>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>
>>>>> Hi Anil,
>>>>>
>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>> by this extension.
>>>>>
>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>> wrote:
>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>> some extra bits that are generated:
>>>>>
>>>>> For a simple:
>>>>>
>>>>> # type t = int with value;;
>>>>>
>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>
>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>> @@ -22,6 +22,12 @@
>>>>>           then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>           else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>> __x__))
>>>>>
>>>>> +let _ = t
>>>>> +and _ = t
>>>>> +and _ = t
>>>>> +and _ = ref
>>>>> +and _ = value_of_t
>>>>> +
>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>   let module Deps =
>>>>>     struct
>>>>> @@ -73,4 +79,8 @@
>>>>>              raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>     in t_of_value_aux { Deps.t = []; }
>>>>>
>>>>> +let _ = t
>>>>> +and _ = t
>>>>> +and _ = t_of_value
>>>>> +
>>>>>
>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>
>>>>> -anil
>>
>>


From anil at recoil.org  Fri Oct  5 05:55:34 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 4 Oct 2012 21:55:34 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CACLX4jSv+32CgumdNkFfd59t07fUD=uij4KC+O_+5O_ZXM7SWg@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com> <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com> <-2309447399847593243@unknownmsgid> <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org> <CACLX4jSv+32CgumdNkFfd59t07fUD=uij4KC+O_+5O_ZXM7SWg@mail.gmail.com>
Message-ID: <7EC3CEC7-1985-4205-8518-3D161D6F47C0@recoil.org>


Well, removing OASIS should remove the constraint that should cause Async
to upgrade again.  However, the actual constraint is on ODN and not OASIS,
so I wonder if this is a transitive dependency bug...

If you uninstall ocaml-data-notation, does Core upgrade to 107.00.01?

-anil

On 4 Oct 2012, at 20:11, Yaron Minsky <yminsky at janestreet.com> wrote:

> Is it surprising that uninstalling oasis causes a rebuild of Async and Core?
> 
> en $ opam remove oasis
> The following variables are set in your environment, you should better
> unset it if you want OPAM to work correctly.
> - CAML_LD_LIBRARY_PATH
> Do you want to continue ? [Y/n]
> The following actions will be performed:
> - remove oasis.0.3.0
> - recompile async_core.108.00.02
> - recompile async_unix.108.00.02
> - recompile cow.0.3.2
> - recompile core_extended.108.00.02
> - recompile core.108.00.02
> - recompile async_extra.108.00.02
> 0 to install | 6 to reinstall | 0 to upgrade | 0 to downgrade | 1 to remove
> Do you want to continue ? [Y/n]
> 
> On Thu, Oct 4, 2012 at 8:45 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> That's correct; almost all non-Core packages are broken by the
>> type_conv interface change. I have some patches queued up for them,
>> but haven't had a chance to submit them upstream yet.  Some (such
>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>> 
>> For now, a decent workaround is to switch to a compiler alias to
>> install OASIS, and otherwise use the new type_conv in a separate
>> switch.
>> 
>> -anil
>> 
>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> 
>>> It looks like ocaml-data-notation should be upgraded to work with a
>>> newer version of type_conv. If you're not using  oasis, can you just
>>> remove it?
>>> 
>>> Yury
>>> 
>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> 
>>>> I can't seem to get the new async to build, even in the latest opam.
>>>> By default it picks the older async, and when I pin to the latest
>>>> version, I get:
>>>> 
>>>> en $ opam upgrade async
>>>> No solution has been found:
>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>> async_core.108.07.01 <- async.108.07.01
>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>> 
>>>> Any thoughts on how to get this to work?
>>>> 
>>>> y
>>>> 
>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>> 
>>>>> -anil
>>>>> 
>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>> 
>>>>> Great, The tarballs are up here:
>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>> 
>>>>> Thanks!
>>>>> Yury
>>>>> 
>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>> 
>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>> simpler code generation in place.
>>>>>> 
>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>> specific (="108.07.00").
>>>>>> 
>>>>>> -a
>>>>>> 
>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>> 
>>>>>>> Hi Anil,
>>>>>>> 
>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>> 
>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>     | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>> '$var$ >>
>>>>>>>     | tp -> tp))#ctyp
>>>>>>> 
>>>>>>> -  class vars_of = object
>>>>>>> +  class vars_of = object (self)
>>>>>>>   inherit fold as super
>>>>>>>   val vars = []
>>>>>>>   method vars = vars
>>>>>>> +    method! ctyp _ = self
>>>>>>>   method ident = function
>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>   | ident -> super#ident ident
>>>>>>> 
>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>> 
>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> Hi Yury,
>>>>>>> 
>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>> 
>>>>>>> class vars_of = object
>>>>>>>  inherit fold as super
>>>>>>>  val vars = []
>>>>>>>  method vars = vars
>>>>>>>  method ident = function
>>>>>>>  | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>  | ident -> super#ident ident
>>>>>>> end
>>>>>>> let lids_of_patt patt =
>>>>>>>  ((new vars_of)#patt patt)#vars
>>>>>>> 
>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>> of dyntype, we generate output like:
>>>>>>> 
>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>> <snip> in
>>>>>>> fun ?id_seed t =
>>>>>>>   <snip>
>>>>>>> 
>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>> 
>>>>>>> let value_of_t, value_of_foo =
>>>>>>> (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>> 
>>>>>>> and it works fine now. The changeset is:
>>>>>>> 
>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>> and is present in dyntype-0.9.0.
>>>>>>> 
>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>> 
>>>>>>> -anil
>>>>>>> 
>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>> 
>>>>>>>> Hi Anil,
>>>>>>>> 
>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>> by this extension.
>>>>>>>> 
>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>> some extra bits that are generated:
>>>>>>>> 
>>>>>>>> For a simple:
>>>>>>>> 
>>>>>>>> # type t = int with value;;
>>>>>>>> 
>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>> 
>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>         then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>         else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>> __x__))
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = ref
>>>>>>>> +and _ = value_of_t
>>>>>>>> +
>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>> let module Deps =
>>>>>>>>   struct
>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>            raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>   in t_of_value_aux { Deps.t = []; }
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t_of_value
>>>>>>>> +
>>>>>>>> 
>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>> 
>>>>>>>> -anil
>>>>> 
>>>>> 
>>> 
>> 
> 



From yminsky at janestreet.com  Fri Oct  5 04:11:24 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 4 Oct 2012 23:11:24 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
Message-ID: <CACLX4jSv+32CgumdNkFfd59t07fUD=uij4KC+O_+5O_ZXM7SWg@mail.gmail.com>


Is it surprising that uninstalling oasis causes a rebuild of Async and Core?

en $ opam remove oasis
The following variables are set in your environment, you should better
unset it if you want OPAM to work correctly.
 - CAML_LD_LIBRARY_PATH
Do you want to continue ? [Y/n]
The following actions will be performed:
 - remove oasis.0.3.0
 - recompile async_core.108.00.02
 - recompile async_unix.108.00.02
 - recompile cow.0.3.2
 - recompile core_extended.108.00.02
 - recompile core.108.00.02
 - recompile async_extra.108.00.02
0 to install | 6 to reinstall | 0 to upgrade | 0 to downgrade | 1 to remove
Do you want to continue ? [Y/n]

On Thu, Oct 4, 2012 at 8:45 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> That's correct; almost all non-Core packages are broken by the
> type_conv interface change. I have some patches queued up for them,
> but haven't had a chance to submit them upstream yet.  Some (such
> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>
> For now, a decent workaround is to switch to a compiler alias to
> install OASIS, and otherwise use the new type_conv in a separate
> switch.
>
> -anil
>
> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
>> It looks like ocaml-data-notation should be upgraded to work with a
>> newer version of type_conv. If you're not using  oasis, can you just
>> remove it?
>>
>> Yury
>>
>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>
>>> I can't seem to get the new async to build, even in the latest opam.
>>> By default it picks the older async, and when I pin to the latest
>>> version, I get:
>>>
>>> en $ opam upgrade async
>>> No solution has been found:
>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>> async_core.108.07.01 <- async.108.07.01
>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>
>>> Any thoughts on how to get this to work?
>>>
>>> y
>>>
>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>
>>>> -anil
>>>>
>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>
>>>> Great, The tarballs are up here:
>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>
>>>> Thanks!
>>>> Yury
>>>>
>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>
>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>> simpler code generation in place.
>>>>>
>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>> test of the constraint system, as our constraints are probably way too
>>>>> specific (="108.07.00").
>>>>>
>>>>> -a
>>>>>
>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>
>>>>>> Hi Anil,
>>>>>>
>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>
>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>> @@ -371,10 +371,11 @@
>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>> '$var$ >>
>>>>>>      | tp -> tp))#ctyp
>>>>>>
>>>>>> -  class vars_of = object
>>>>>> +  class vars_of = object (self)
>>>>>>    inherit fold as super
>>>>>>    val vars = []
>>>>>>    method vars = vars
>>>>>> +    method! ctyp _ = self
>>>>>>    method ident = function
>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>    | ident -> super#ident ident
>>>>>>
>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>
>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>> wrote:
>>>>>> Hi Yury,
>>>>>>
>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>
>>>>>> class vars_of = object
>>>>>>   inherit fold as super
>>>>>>   val vars = []
>>>>>>   method vars = vars
>>>>>>   method ident = function
>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>   | ident -> super#ident ident
>>>>>> end
>>>>>> let lids_of_patt patt =
>>>>>>   ((new vars_of)#patt patt)#vars
>>>>>>
>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>> of dyntype, we generate output like:
>>>>>>
>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>> <snip> in
>>>>>>  fun ?id_seed t =
>>>>>>    <snip>
>>>>>>
>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>
>>>>>> let value_of_t, value_of_foo =
>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>
>>>>>> and it works fine now. The changeset is:
>>>>>>
>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>> and is present in dyntype-0.9.0.
>>>>>>
>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>> reported?  The bitbucket issue tracker?
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>>> Hi Anil,
>>>>>>>
>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>> by this extension.
>>>>>>>
>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>> some extra bits that are generated:
>>>>>>>
>>>>>>> For a simple:
>>>>>>>
>>>>>>> # type t = int with value;;
>>>>>>>
>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>
>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>> __x__))
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = ref
>>>>>>> +and _ = value_of_t
>>>>>>> +
>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>  let module Deps =
>>>>>>>    struct
>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t_of_value
>>>>>>> +
>>>>>>>
>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>
>>>>>>> -anil
>>>>
>>>>
>>
>


From yminsky at janestreet.com  Fri Oct  5 12:55:04 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 5 Oct 2012 07:55:04 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
	<CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
Message-ID: <CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>


By the way, no love on installing async 108.07.01 on opam.  Here's the
tail of the error:

. /Users/yminsky/.opam/4.00.0/bin/ocamldep.opt -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -modules
syntax/json/extension.ml > syntax/json/extension.ml.depends
. /Users/yminsky/.opam/4.00.0/bin/ocamlc.opt -c -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -I syntax/json -I syntax
-o syntax/json/json.cmo syntax/json/json.ml
. /Users/yminsky/.opam/4.00.0/bin/ocamlc.opt -c -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -I syntax/json -I syntax
-o syntax/json/extension.cmo syntax/json/extension.ml
. + /Users/yminsky/.opam/4.00.0/bin/ocamlc.opt -c -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -I syntax/json -I syntax
-o syntax/json/extension.cmo syntax/json/extension.ml
. File "syntax/json/extension.ml", line 371, characters 36-39:
. Error: This expression has type bool but an expression was expected of type
.          Camlp4.PreCast.Syntax.Ast.ctyp = Camlp4.PreCast.Ast.ctyp
. Command exited with code 2.
* make: *** [all] Error 10
  'opam upgrade' failed

Has anyone gotten this to succeed?  Also, how did json get implemented
here?  There's no json support in async as far as I know...

y

On Fri, Oct 5, 2012 at 4:54 AM, Sylvain Le Gall <sylvain at le-gall.net> wrote:
> If you send the patch for ODN, you''ll have a new upstream tarball by
> then end of the day.
>
> 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>> That's correct; almost all non-Core packages are broken by the
>> type_conv interface change. I have some patches queued up for them,
>> but haven't had a chance to submit them upstream yet.  Some (such
>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>>
>> For now, a decent workaround is to switch to a compiler alias to
>> install OASIS, and otherwise use the new type_conv in a separate
>> switch.
>>
>> -anil
>>
>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>
>>> It looks like ocaml-data-notation should be upgraded to work with a
>>> newer version of type_conv. If you're not using  oasis, can you just
>>> remove it?
>>>
>>> Yury
>>>
>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>
>>>> I can't seem to get the new async to build, even in the latest opam.
>>>> By default it picks the older async, and when I pin to the latest
>>>> version, I get:
>>>>
>>>> en $ opam upgrade async
>>>> No solution has been found:
>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>> async_core.108.07.01 <- async.108.07.01
>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>>
>>>> Any thoughts on how to get this to work?
>>>>
>>>> y
>>>>
>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>>
>>>>> -anil
>>>>>
>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>
>>>>> Great, The tarballs are up here:
>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>>
>>>>> Thanks!
>>>>> Yury
>>>>>
>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>>
>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>> simpler code generation in place.
>>>>>>
>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>> specific (="108.07.00").
>>>>>>
>>>>>> -a
>>>>>>
>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>>> Hi Anil,
>>>>>>>
>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>>
>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>> '$var$ >>
>>>>>>>      | tp -> tp))#ctyp
>>>>>>>
>>>>>>> -  class vars_of = object
>>>>>>> +  class vars_of = object (self)
>>>>>>>    inherit fold as super
>>>>>>>    val vars = []
>>>>>>>    method vars = vars
>>>>>>> +    method! ctyp _ = self
>>>>>>>    method ident = function
>>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>    | ident -> super#ident ident
>>>>>>>
>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>>
>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> Hi Yury,
>>>>>>>
>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>>
>>>>>>> class vars_of = object
>>>>>>>   inherit fold as super
>>>>>>>   val vars = []
>>>>>>>   method vars = vars
>>>>>>>   method ident = function
>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>   | ident -> super#ident ident
>>>>>>> end
>>>>>>> let lids_of_patt patt =
>>>>>>>   ((new vars_of)#patt patt)#vars
>>>>>>>
>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>> of dyntype, we generate output like:
>>>>>>>
>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>> <snip> in
>>>>>>>  fun ?id_seed t =
>>>>>>>    <snip>
>>>>>>>
>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>>
>>>>>>> let value_of_t, value_of_foo =
>>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>>
>>>>>>> and it works fine now. The changeset is:
>>>>>>>
>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>> and is present in dyntype-0.9.0.
>>>>>>>
>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>>
>>>>>>> -anil
>>>>>>>
>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>>
>>>>>>>> Hi Anil,
>>>>>>>>
>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>> by this extension.
>>>>>>>>
>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>> some extra bits that are generated:
>>>>>>>>
>>>>>>>> For a simple:
>>>>>>>>
>>>>>>>> # type t = int with value;;
>>>>>>>>
>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>>
>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>> __x__))
>>>>>>>>
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = ref
>>>>>>>> +and _ = value_of_t
>>>>>>>> +
>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>>  let module Deps =
>>>>>>>>    struct
>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>>>>
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t_of_value
>>>>>>>> +
>>>>>>>>
>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>>
>>>>>>>> -anil
>>>>>
>>>>>
>>>
>>


From sylvain at le-gall.net  Fri Oct  5 09:54:10 2012
From: sylvain at le-gall.net (Sylvain Le Gall)
Date: Fri, 5 Oct 2012 10:54:10 +0200
Subject: type_conv-108.07 breakage
In-Reply-To: <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
Message-ID: <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>


If you send the patch for ODN, you''ll have a new upstream tarball by
then end of the day.

2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
> That's correct; almost all non-Core packages are broken by the
> type_conv interface change. I have some patches queued up for them,
> but haven't had a chance to submit them upstream yet.  Some (such
> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>
> For now, a decent workaround is to switch to a compiler alias to
> install OASIS, and otherwise use the new type_conv in a separate
> switch.
>
> -anil
>
> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
>> It looks like ocaml-data-notation should be upgraded to work with a
>> newer version of type_conv. If you're not using  oasis, can you just
>> remove it?
>>
>> Yury
>>
>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>
>>> I can't seem to get the new async to build, even in the latest opam.
>>> By default it picks the older async, and when I pin to the latest
>>> version, I get:
>>>
>>> en $ opam upgrade async
>>> No solution has been found:
>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>> async_core.108.07.01 <- async.108.07.01
>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>
>>> Any thoughts on how to get this to work?
>>>
>>> y
>>>
>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>
>>>> -anil
>>>>
>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>
>>>> Great, The tarballs are up here:
>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>
>>>> Thanks!
>>>> Yury
>>>>
>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>
>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>> simpler code generation in place.
>>>>>
>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>> test of the constraint system, as our constraints are probably way too
>>>>> specific (="108.07.00").
>>>>>
>>>>> -a
>>>>>
>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>
>>>>>> Hi Anil,
>>>>>>
>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>
>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>> @@ -371,10 +371,11 @@
>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>> '$var$ >>
>>>>>>      | tp -> tp))#ctyp
>>>>>>
>>>>>> -  class vars_of = object
>>>>>> +  class vars_of = object (self)
>>>>>>    inherit fold as super
>>>>>>    val vars = []
>>>>>>    method vars = vars
>>>>>> +    method! ctyp _ = self
>>>>>>    method ident = function
>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>    | ident -> super#ident ident
>>>>>>
>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>
>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>> wrote:
>>>>>> Hi Yury,
>>>>>>
>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>
>>>>>> class vars_of = object
>>>>>>   inherit fold as super
>>>>>>   val vars = []
>>>>>>   method vars = vars
>>>>>>   method ident = function
>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>   | ident -> super#ident ident
>>>>>> end
>>>>>> let lids_of_patt patt =
>>>>>>   ((new vars_of)#patt patt)#vars
>>>>>>
>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>> of dyntype, we generate output like:
>>>>>>
>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>> <snip> in
>>>>>>  fun ?id_seed t =
>>>>>>    <snip>
>>>>>>
>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>
>>>>>> let value_of_t, value_of_foo =
>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>
>>>>>> and it works fine now. The changeset is:
>>>>>>
>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>> and is present in dyntype-0.9.0.
>>>>>>
>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>> reported?  The bitbucket issue tracker?
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>>> Hi Anil,
>>>>>>>
>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>> by this extension.
>>>>>>>
>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>> some extra bits that are generated:
>>>>>>>
>>>>>>> For a simple:
>>>>>>>
>>>>>>> # type t = int with value;;
>>>>>>>
>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>
>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>> __x__))
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = ref
>>>>>>> +and _ = value_of_t
>>>>>>> +
>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>  let module Deps =
>>>>>>>    struct
>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t_of_value
>>>>>>> +
>>>>>>>
>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>
>>>>>>> -anil
>>>>
>>>>
>>
>


From yminsky at janestreet.com  Fri Oct  5 19:03:13 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 5 Oct 2012 14:03:13 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <20121005161230.GF27858@dark.recoil.org>
References: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
	<CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
	<CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>
	<20121005161230.GF27858@dark.recoil.org>
Message-ID: <CACLX4jQ7Z87usvNOspDMnqs1sn2366q3Wdp_8eE7skkbNtLDSg@mail.gmail.com>


I do have COW installed.  That makes sense.  I'll try deleting it.

On Fri, Oct 5, 2012 at 12:12 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On Fri, Oct 05, 2012 at 07:55:04AM -0400, Yaron Minsky wrote:
>> By the way, no love on installing async 108.07.01 on opam.  Here's the
>> tail of the error:
>>
>> . File "syntax/json/extension.ml", line 371, characters 36-39:
>> . Error: This expression has type bool but an expression was expected of type
>> .          Camlp4.PreCast.Syntax.Ast.ctyp = Camlp4.PreCast.Ast.ctyp
>> . Command exited with code 2.
>> * make: *** [all] Error 10
>>   'opam upgrade' failed
>>
>> Has anyone gotten this to succeed?  Also, how did json get implemented
>> here?  There's no json support in async as far as I know...
>
> This looks like it's trying to install COW, and not Core.  I think that
> your pinning of type_conv might have confused things a little. I'll upload
> a new COW and send Sylvain the ODN patches shortly, but it would be good
> to understand why the package constraints aren't working as expected at
> present...
>
> Do you have COW installed also?
>
> -anil
>
>
>
>
>>
>> y
>>
>> On Fri, Oct 5, 2012 at 4:54 AM, Sylvain Le Gall <sylvain at le-gall.net> wrote:
>> > If you send the patch for ODN, you''ll have a new upstream tarball by
>> > then end of the day.
>> >
>> > 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>> >> That's correct; almost all non-Core packages are broken by the
>> >> type_conv interface change. I have some patches queued up for them,
>> >> but haven't had a chance to submit them upstream yet.  Some (such
>> >> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>> >>
>> >> For now, a decent workaround is to switch to a compiler alias to
>> >> install OASIS, and otherwise use the new type_conv in a separate
>> >> switch.
>> >>
>> >> -anil
>> >>
>> >> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>
>> >>> It looks like ocaml-data-notation should be upgraded to work with a
>> >>> newer version of type_conv. If you're not using  oasis, can you just
>> >>> remove it?
>> >>>
>> >>> Yury
>> >>>
>> >>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> >>>
>> >>>> I can't seem to get the new async to build, even in the latest opam.
>> >>>> By default it picks the older async, and when I pin to the latest
>> >>>> version, I get:
>> >>>>
>> >>>> en $ opam upgrade async
>> >>>> No solution has been found:
>> >>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>> >>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>> >>>> async_core.108.07.01 <- async.108.07.01
>> >>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>> >>>>
>> >>>> Any thoughts on how to get this to work?
>> >>>>
>> >>>> y
>> >>>>
>> >>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> >>>>> This should be available on OPAM now too, if you do 'opam update'.
>> >>>>>
>> >>>>> -anil
>> >>>>>
>> >>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>>>>
>> >>>>> Great, The tarballs are up here:
>> >>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>> >>>>>
>> >>>>> Thanks!
>> >>>>> Yury
>> >>>>>
>> >>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> >>>>>>
>> >>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>> >>>>>> simpler code generation in place.
>> >>>>>>
>> >>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>> >>>>>> release system issue only a bumped version number for Core and Type_conv,
>> >>>>>> instead of a complete set of new packages with new versions? This is a good
>> >>>>>> test of the constraint system, as our constraints are probably way too
>> >>>>>> specific (="108.07.00").
>> >>>>>>
>> >>>>>> -a
>> >>>>>>
>> >>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>>>>>
>> >>>>>>> Hi Anil,
>> >>>>>>>
>> >>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>> >>>>>>>
>> >>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> @@ -371,10 +371,11 @@
>> >>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>> >>>>>>> '$var$ >>
>> >>>>>>>      | tp -> tp))#ctyp
>> >>>>>>>
>> >>>>>>> -  class vars_of = object
>> >>>>>>> +  class vars_of = object (self)
>> >>>>>>>    inherit fold as super
>> >>>>>>>    val vars = []
>> >>>>>>>    method vars = vars
>> >>>>>>> +    method! ctyp _ = self
>> >>>>>>>    method ident = function
>> >>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >>>>>>>    | ident -> super#ident ident
>> >>>>>>>
>> >>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>> >>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>> >>>>>>>
>> >>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>> >>>>>>> wrote:
>> >>>>>>> Hi Yury,
>> >>>>>>>
>> >>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>> >>>>>>> it always objects!), but it looks like the bug is at:
>> >>>>>>>
>> >>>>>>> class vars_of = object
>> >>>>>>>   inherit fold as super
>> >>>>>>>   val vars = []
>> >>>>>>>   method vars = vars
>> >>>>>>>   method ident = function
>> >>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >>>>>>>   | ident -> super#ident ident
>> >>>>>>> end
>> >>>>>>> let lids_of_patt patt =
>> >>>>>>>   ((new vars_of)#patt patt)#vars
>> >>>>>>>
>> >>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>> >>>>>>> of dyntype, we generate output like:
>> >>>>>>>
>> >>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>> >>>>>>> <snip> in
>> >>>>>>>  fun ?id_seed t =
>> >>>>>>>    <snip>
>> >>>>>>>
>> >>>>>>> I've simplified the Dyntype generation to be simply:
>> >>>>>>>
>> >>>>>>> let value_of_t, value_of_foo =
>> >>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>> >>>>>>>
>> >>>>>>> and it works fine now. The changeset is:
>> >>>>>>>
>> >>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>> >>>>>>> and is present in dyntype-0.9.0.
>> >>>>>>>
>> >>>>>>> Where would you like Core bugs such as this type_conv one to be
>> >>>>>>> reported?  The bitbucket issue tracker?
>> >>>>>>>
>> >>>>>>> -anil
>> >>>>>>>
>> >>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>>>>>>
>> >>>>>>>> Hi Anil,
>> >>>>>>>>
>> >>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>> >>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>> >>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>> >>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>> >>>>>>>> by this extension.
>> >>>>>>>>
>> >>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>> >>>>>>>> wrote:
>> >>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>> >>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>> >>>>>>>> some extra bits that are generated:
>> >>>>>>>>
>> >>>>>>>> For a simple:
>> >>>>>>>>
>> >>>>>>>> # type t = int with value;;
>> >>>>>>>>
>> >>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>> >>>>>>>>
>> >>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>> >>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>> >>>>>>>> @@ -22,6 +22,12 @@
>> >>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>> >>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>> >>>>>>>> __x__))
>> >>>>>>>>
>> >>>>>>>> +let _ = t
>> >>>>>>>> +and _ = t
>> >>>>>>>> +and _ = t
>> >>>>>>>> +and _ = ref
>> >>>>>>>> +and _ = value_of_t
>> >>>>>>>> +
>> >>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>> >>>>>>>>  let module Deps =
>> >>>>>>>>    struct
>> >>>>>>>> @@ -73,4 +79,8 @@
>> >>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>> >>>>>>>>    in t_of_value_aux { Deps.t = []; }
>> >>>>>>>>
>> >>>>>>>> +let _ = t
>> >>>>>>>> +and _ = t
>> >>>>>>>> +and _ = t_of_value
>> >>>>>>>> +
>> >>>>>>>>
>> >>>>>>>> These are unbound, and so compilation breaks... what are they for?
>> >>>>>>>>
>> >>>>>>>> -anil
>> >>>>>
>> >>>>>
>> >>>
>> >>
>>
>
> --
> Anil Madhavapeddy                                 http://anil.recoil.org


From anil at recoil.org  Sat Oct  6 00:31:22 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 5 Oct 2012 16:31:22 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com> <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com> <-2309447399847593243@unknownmsgid> <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org> <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
Message-ID: <4BA6C80E-1971-4BFD-8500-664CA157A250@recoil.org>


Sylvain,

Patch put in a bug report at https://forge.ocamlcore.org/tracker/index.php?func=detail&aid=1226&group_id=148&atid=674

Would you consider moving ODN and the other OASIS dependencies to Github, since the main OASIS repo is also up there now?

Let me know when you cut a release and I'll update the OPAM constraints.

-anil

On 5 Oct 2012, at 01:54, Sylvain Le Gall <sylvain at le-gall.net> wrote:

> If you send the patch for ODN, you''ll have a new upstream tarball by
> then end of the day.
> 
> 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>> That's correct; almost all non-Core packages are broken by the
>> type_conv interface change. I have some patches queued up for them,
>> but haven't had a chance to submit them upstream yet.  Some (such
>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>> 
>> For now, a decent workaround is to switch to a compiler alias to
>> install OASIS, and otherwise use the new type_conv in a separate
>> switch.
>> 
>> -anil
>> 
>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> 
>>> It looks like ocaml-data-notation should be upgraded to work with a
>>> newer version of type_conv. If you're not using  oasis, can you just
>>> remove it?
>>> 
>>> Yury
>>> 
>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> 
>>>> I can't seem to get the new async to build, even in the latest opam.
>>>> By default it picks the older async, and when I pin to the latest
>>>> version, I get:
>>>> 
>>>> en $ opam upgrade async
>>>> No solution has been found:
>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>> async_core.108.07.01 <- async.108.07.01
>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>> 
>>>> Any thoughts on how to get this to work?
>>>> 
>>>> y
>>>> 
>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>> 
>>>>> -anil
>>>>> 
>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>> 
>>>>> Great, The tarballs are up here:
>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>> 
>>>>> Thanks!
>>>>> Yury
>>>>> 
>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>> 
>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>> simpler code generation in place.
>>>>>> 
>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>> specific (="108.07.00").
>>>>>> 
>>>>>> -a
>>>>>> 
>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>> 
>>>>>>> Hi Anil,
>>>>>>> 
>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>> 
>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>     | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>> '$var$ >>
>>>>>>>     | tp -> tp))#ctyp
>>>>>>> 
>>>>>>> -  class vars_of = object
>>>>>>> +  class vars_of = object (self)
>>>>>>>   inherit fold as super
>>>>>>>   val vars = []
>>>>>>>   method vars = vars
>>>>>>> +    method! ctyp _ = self
>>>>>>>   method ident = function
>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>   | ident -> super#ident ident
>>>>>>> 
>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>> 
>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> Hi Yury,
>>>>>>> 
>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>> 
>>>>>>> class vars_of = object
>>>>>>>  inherit fold as super
>>>>>>>  val vars = []
>>>>>>>  method vars = vars
>>>>>>>  method ident = function
>>>>>>>  | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>  | ident -> super#ident ident
>>>>>>> end
>>>>>>> let lids_of_patt patt =
>>>>>>>  ((new vars_of)#patt patt)#vars
>>>>>>> 
>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>> of dyntype, we generate output like:
>>>>>>> 
>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>> <snip> in
>>>>>>> fun ?id_seed t =
>>>>>>>   <snip>
>>>>>>> 
>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>> 
>>>>>>> let value_of_t, value_of_foo =
>>>>>>> (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>> 
>>>>>>> and it works fine now. The changeset is:
>>>>>>> 
>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>> and is present in dyntype-0.9.0.
>>>>>>> 
>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>> 
>>>>>>> -anil
>>>>>>> 
>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>> 
>>>>>>>> Hi Anil,
>>>>>>>> 
>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>> by this extension.
>>>>>>>> 
>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>> some extra bits that are generated:
>>>>>>>> 
>>>>>>>> For a simple:
>>>>>>>> 
>>>>>>>> # type t = int with value;;
>>>>>>>> 
>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>> 
>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>         then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>         else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>> __x__))
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = ref
>>>>>>>> +and _ = value_of_t
>>>>>>>> +
>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>> let module Deps =
>>>>>>>>   struct
>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>            raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>   in t_of_value_aux { Deps.t = []; }
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t_of_value
>>>>>>>> +
>>>>>>>> 
>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>> 
>>>>>>>> -anil
>>>>> 
>>>>> 
>>> 
>> 
> 



From anil at recoil.org  Fri Oct  5 17:12:30 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 5 Oct 2012 17:12:30 +0100
Subject: type_conv-108.07 breakage
In-Reply-To: <CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>
References: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
 <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
 <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
 <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
 <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
 <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
 <-2309447399847593243@unknownmsgid>
 <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
 <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
 <CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>
Message-ID: <20121005161230.GF27858@dark.recoil.org>


On Fri, Oct 05, 2012 at 07:55:04AM -0400, Yaron Minsky wrote:
> By the way, no love on installing async 108.07.01 on opam.  Here's the
> tail of the error:
> 
> . File "syntax/json/extension.ml", line 371, characters 36-39:
> . Error: This expression has type bool but an expression was expected of type
> .          Camlp4.PreCast.Syntax.Ast.ctyp = Camlp4.PreCast.Ast.ctyp
> . Command exited with code 2.
> * make: *** [all] Error 10
>   'opam upgrade' failed
> 
> Has anyone gotten this to succeed?  Also, how did json get implemented
> here?  There's no json support in async as far as I know...

This looks like it's trying to install COW, and not Core.  I think that
your pinning of type_conv might have confused things a little. I'll upload
a new COW and send Sylvain the ODN patches shortly, but it would be good
to understand why the package constraints aren't working as expected at
present...

Do you have COW installed also?

-anil




> 
> y
> 
> On Fri, Oct 5, 2012 at 4:54 AM, Sylvain Le Gall <sylvain at le-gall.net> wrote:
> > If you send the patch for ODN, you''ll have a new upstream tarball by
> > then end of the day.
> >
> > 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
> >> That's correct; almost all non-Core packages are broken by the
> >> type_conv interface change. I have some patches queued up for them,
> >> but haven't had a chance to submit them upstream yet.  Some (such
> >> as Dyntype) I've already fixed, but I haven't done OASIS yet.
> >>
> >> For now, a decent workaround is to switch to a compiler alias to
> >> install OASIS, and otherwise use the new type_conv in a separate
> >> switch.
> >>
> >> -anil
> >>
> >> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>
> >>> It looks like ocaml-data-notation should be upgraded to work with a
> >>> newer version of type_conv. If you're not using  oasis, can you just
> >>> remove it?
> >>>
> >>> Yury
> >>>
> >>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> >>>
> >>>> I can't seem to get the new async to build, even in the latest opam.
> >>>> By default it picks the older async, and when I pin to the latest
> >>>> version, I get:
> >>>>
> >>>> en $ opam upgrade async
> >>>> No solution has been found:
> >>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
> >>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
> >>>> async_core.108.07.01 <- async.108.07.01
> >>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
> >>>>
> >>>> Any thoughts on how to get this to work?
> >>>>
> >>>> y
> >>>>
> >>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >>>>> This should be available on OPAM now too, if you do 'opam update'.
> >>>>>
> >>>>> -anil
> >>>>>
> >>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>>>>
> >>>>> Great, The tarballs are up here:
> >>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
> >>>>>
> >>>>> Thanks!
> >>>>> Yury
> >>>>>
> >>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >>>>>>
> >>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
> >>>>>> simpler code generation in place.
> >>>>>>
> >>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
> >>>>>> release system issue only a bumped version number for Core and Type_conv,
> >>>>>> instead of a complete set of new packages with new versions? This is a good
> >>>>>> test of the constraint system, as our constraints are probably way too
> >>>>>> specific (="108.07.00").
> >>>>>>
> >>>>>> -a
> >>>>>>
> >>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>>>>>
> >>>>>>> Hi Anil,
> >>>>>>>
> >>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
> >>>>>>>
> >>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> b/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> @@ -371,10 +371,11 @@
> >>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
> >>>>>>> '$var$ >>
> >>>>>>>      | tp -> tp))#ctyp
> >>>>>>>
> >>>>>>> -  class vars_of = object
> >>>>>>> +  class vars_of = object (self)
> >>>>>>>    inherit fold as super
> >>>>>>>    val vars = []
> >>>>>>>    method vars = vars
> >>>>>>> +    method! ctyp _ = self
> >>>>>>>    method ident = function
> >>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >>>>>>>    | ident -> super#ident ident
> >>>>>>>
> >>>>>>> I'd like to get a quick bugfix out the door that includes this and more
> >>>>>>> portable use of mktemp in base/core/lib/discover.sh.
> >>>>>>>
> >>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
> >>>>>>> wrote:
> >>>>>>> Hi Yury,
> >>>>>>>
> >>>>>>> I got a little lost in the new type_conv control flow (objects, why is
> >>>>>>> it always objects!), but it looks like the bug is at:
> >>>>>>>
> >>>>>>> class vars_of = object
> >>>>>>>   inherit fold as super
> >>>>>>>   val vars = []
> >>>>>>>   method vars = vars
> >>>>>>>   method ident = function
> >>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >>>>>>>   | ident -> super#ident ident
> >>>>>>> end
> >>>>>>> let lids_of_patt patt =
> >>>>>>>   ((new vars_of)#patt patt)#vars
> >>>>>>>
> >>>>>>> This extracts out all the identifiers in a pattern binding. In the case
> >>>>>>> of dyntype, we generate output like:
> >>>>>>>
> >>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
> >>>>>>> <snip> in
> >>>>>>>  fun ?id_seed t =
> >>>>>>>    <snip>
> >>>>>>>
> >>>>>>> I've simplified the Dyntype generation to be simply:
> >>>>>>>
> >>>>>>> let value_of_t, value_of_foo =
> >>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> >>>>>>>
> >>>>>>> and it works fine now. The changeset is:
> >>>>>>>
> >>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> >>>>>>> and is present in dyntype-0.9.0.
> >>>>>>>
> >>>>>>> Where would you like Core bugs such as this type_conv one to be
> >>>>>>> reported?  The bitbucket issue tracker?
> >>>>>>>
> >>>>>>> -anil
> >>>>>>>
> >>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>>>>>>
> >>>>>>>> Hi Anil,
> >>>>>>>>
> >>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
> >>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
> >>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
> >>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
> >>>>>>>> by this extension.
> >>>>>>>>
> >>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
> >>>>>>>> wrote:
> >>>>>>>> I've been porting some of our syntax extensions to the new type_conv
> >>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
> >>>>>>>> some extra bits that are generated:
> >>>>>>>>
> >>>>>>>> For a simple:
> >>>>>>>>
> >>>>>>>> # type t = int with value;;
> >>>>>>>>
> >>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
> >>>>>>>>
> >>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> >>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> >>>>>>>> @@ -22,6 +22,12 @@
> >>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
> >>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
> >>>>>>>> __x__))
> >>>>>>>>
> >>>>>>>> +let _ = t
> >>>>>>>> +and _ = t
> >>>>>>>> +and _ = t
> >>>>>>>> +and _ = ref
> >>>>>>>> +and _ = value_of_t
> >>>>>>>> +
> >>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
> >>>>>>>>  let module Deps =
> >>>>>>>>    struct
> >>>>>>>> @@ -73,4 +79,8 @@
> >>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> >>>>>>>>    in t_of_value_aux { Deps.t = []; }
> >>>>>>>>
> >>>>>>>> +let _ = t
> >>>>>>>> +and _ = t
> >>>>>>>> +and _ = t_of_value
> >>>>>>>> +
> >>>>>>>>
> >>>>>>>> These are unbound, and so compilation breaks... what are they for?
> >>>>>>>>
> >>>>>>>> -anil
> >>>>>
> >>>>>
> >>>
> >>
> 

-- 
Anil Madhavapeddy                                 http://anil.recoil.org


From sylvain at le-gall.net  Sat Oct  6 09:17:09 2012
From: sylvain at le-gall.net (Sylvain Le Gall)
Date: Sat, 6 Oct 2012 10:17:09 +0200
Subject: type_conv-108.07 breakage
In-Reply-To: <4BA6C80E-1971-4BFD-8500-664CA157A250@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
	<CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
	<4BA6C80E-1971-4BFD-8500-664CA157A250@recoil.org>
Message-ID: <CAOCAUGMEWiYrDNGxnpwo7XoYeYy+ds688fVV0C5UJc=SjNjKrg@mail.gmail.com>


2012/10/6 Anil Madhavapeddy <anil at recoil.org>:
> Sylvain,
>
> Patch put in a bug report at https://forge.ocamlcore.org/tracker/index.php?func=detail&aid=1226&group_id=148&atid=674
>
> Would you consider moving ODN and the other OASIS dependencies to Github, since the main OASIS repo is also up there now?
>

Not yet, give me time to adapt. If there were a way to have a forge
plugin that create a link between github and forge.ocamlcore.org, I
would more easily consider it, but until then, I will keep 2nd level
project where they are.

> Let me know when you cut a release and I'll update the OPAM constraints.
>

Jobs done, but don't have access to 108.07.01, so I let you check that
it compiles fine...

> -anil
>
> On 5 Oct 2012, at 01:54, Sylvain Le Gall <sylvain at le-gall.net> wrote:
>
>> If you send the patch for ODN, you''ll have a new upstream tarball by
>> then end of the day.
>>
>> 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>>> That's correct; almost all non-Core packages are broken by the
>>> type_conv interface change. I have some patches queued up for them,
>>> but haven't had a chance to submit them upstream yet.  Some (such
>>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>>>
>>> For now, a decent workaround is to switch to a compiler alias to
>>> install OASIS, and otherwise use the new type_conv in a separate
>>> switch.
>>>
>>> -anil
>>>
>>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>
>>>> It looks like ocaml-data-notation should be upgraded to work with a
>>>> newer version of type_conv. If you're not using  oasis, can you just
>>>> remove it?
>>>>
>>>> Yury
>>>>
>>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>>
>>>>> I can't seem to get the new async to build, even in the latest opam.
>>>>> By default it picks the older async, and when I pin to the latest
>>>>> version, I get:
>>>>>
>>>>> en $ opam upgrade async
>>>>> No solution has been found:
>>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>>> async_core.108.07.01 <- async.108.07.01
>>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>>>
>>>>> Any thoughts on how to get this to work?
>>>>>
>>>>> y
>>>>>
>>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>> Great, The tarballs are up here:
>>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>>>
>>>>>> Thanks!
>>>>>> Yury
>>>>>>
>>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>>>
>>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>>> simpler code generation in place.
>>>>>>>
>>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>>> specific (="108.07.00").
>>>>>>>
>>>>>>> -a
>>>>>>>
>>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>>
>>>>>>>> Hi Anil,
>>>>>>>>
>>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>>>
>>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>>     | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>>> '$var$ >>
>>>>>>>>     | tp -> tp))#ctyp
>>>>>>>>
>>>>>>>> -  class vars_of = object
>>>>>>>> +  class vars_of = object (self)
>>>>>>>>   inherit fold as super
>>>>>>>>   val vars = []
>>>>>>>>   method vars = vars
>>>>>>>> +    method! ctyp _ = self
>>>>>>>>   method ident = function
>>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>>   | ident -> super#ident ident
>>>>>>>>
>>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>>>
>>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> Hi Yury,
>>>>>>>>
>>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>>>
>>>>>>>> class vars_of = object
>>>>>>>>  inherit fold as super
>>>>>>>>  val vars = []
>>>>>>>>  method vars = vars
>>>>>>>>  method ident = function
>>>>>>>>  | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>>  | ident -> super#ident ident
>>>>>>>> end
>>>>>>>> let lids_of_patt patt =
>>>>>>>>  ((new vars_of)#patt patt)#vars
>>>>>>>>
>>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>>> of dyntype, we generate output like:
>>>>>>>>
>>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>>> <snip> in
>>>>>>>> fun ?id_seed t =
>>>>>>>>   <snip>
>>>>>>>>
>>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>>>
>>>>>>>> let value_of_t, value_of_foo =
>>>>>>>> (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>>>
>>>>>>>> and it works fine now. The changeset is:
>>>>>>>>
>>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>>> and is present in dyntype-0.9.0.
>>>>>>>>
>>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>>>
>>>>>>>> -anil
>>>>>>>>
>>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>>>
>>>>>>>>> Hi Anil,
>>>>>>>>>
>>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>>> by this extension.
>>>>>>>>>
>>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>>> wrote:
>>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>>> some extra bits that are generated:
>>>>>>>>>
>>>>>>>>> For a simple:
>>>>>>>>>
>>>>>>>>> # type t = int with value;;
>>>>>>>>>
>>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>>>
>>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>>         then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>>         else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>>> __x__))
>>>>>>>>>
>>>>>>>>> +let _ = t
>>>>>>>>> +and _ = t
>>>>>>>>> +and _ = t
>>>>>>>>> +and _ = ref
>>>>>>>>> +and _ = value_of_t
>>>>>>>>> +
>>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>>> let module Deps =
>>>>>>>>>   struct
>>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>>            raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>>   in t_of_value_aux { Deps.t = []; }
>>>>>>>>>
>>>>>>>>> +let _ = t
>>>>>>>>> +and _ = t
>>>>>>>>> +and _ = t_of_value
>>>>>>>>> +
>>>>>>>>>
>>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>>>
>>>>>>>>> -anil
>>>>>>
>>>>>>
>>>>
>>>
>>
>


From yminsky at janestreet.com  Sun Oct  7 13:06:55 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 7 Oct 2012 08:06:55 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
Message-ID: <CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>


CC'ing Nathan, who is the primary author of Command.

We're in a bit of an awkward state with bitbucket right now, though it
will be fixed eventually.  That said, I'm not sure why that's
important to learning the command API: it's all available in the
tarball, after all, which you can get here:

   https://ocaml.janestreet.com/ocaml-core/108.07.01/

Also, the HTML documentation can be found here:

   https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html

Also, there's a module called Deprecated_command in Core_extended
(where the old Command lived) that has the old API on top of the new
implementation.

The new Command uses some pretty clever types to give a good
interface, and we should really publish some examples (which we have
internally).  Nathan, do you have some ideas as to what we can do to
improve the docs?

y


On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Hi, opam is installing 108.07.01 for me which seems to have a number
> of API changes to the previous release (108.00.01 I think?).  But the
> source on bitbucket seems to correspond to the older version.  Am I
> missing something obvious or will bitbucket be updated soon?  Or is
> there some kind of migration documentation available?  Specifically
> I'm trying to figure out the new Command API.
>
> Thanks,
> /M


From yminsky at janestreet.com  Sun Oct  7 13:23:15 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 7 Oct 2012 08:23:15 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
Message-ID: <CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>


I thought we'd killed that link.  Where's the bad documentation link you found?

y

On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Ah thanks, I couldn't find the docs earlier.  It looks like the
> Documentation link off the Jane St site points to something from 2009,
> thank you for the correct link.
>
> /M
>
> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> CC'ing Nathan, who is the primary author of Command.
>>
>> We're in a bit of an awkward state with bitbucket right now, though it
>> will be fixed eventually.  That said, I'm not sure why that's
>> important to learning the command API: it's all available in the
>> tarball, after all, which you can get here:
>>
>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>
>> Also, the HTML documentation can be found here:
>>
>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>
>> Also, there's a module called Deprecated_command in Core_extended
>> (where the old Command lived) that has the old API on top of the new
>> implementation.
>>
>> The new Command uses some pretty clever types to give a good
>> interface, and we should really publish some examples (which we have
>> internally).  Nathan, do you have some ideas as to what we can do to
>> improve the docs?
>>
>> y
>>
>>
>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>> of API changes to the previous release (108.00.01 I think?).  But the
>>> source on bitbucket seems to correspond to the older version.  Am I
>>> missing something obvious or will bitbucket be updated soon?  Or is
>>> there some kind of migration documentation available?  Specifically
>>> I'm trying to figure out the new Command API.
>>>
>>> Thanks,
>>> /M


From yminsky at janestreet.com  Sun Oct  7 13:36:32 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 7 Oct 2012 08:36:32 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
	<CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
	<CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>
Message-ID: <CACLX4jQU80SbtFXE6y1gZPRyBm9pGcrKsuXp5+vSOUYw18oPuw@mail.gmail.com>


Got it.  Will fix.

On Sun, Oct 7, 2012 at 8:25 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> https://ocaml.janestreet.com/
>
> The Documentation link on the top next to Code points to
> http://www.janestreet.com/ocaml/janestreet-ocamldocs/
>
> /M
>
> On Sun, Oct 7, 2012 at 2:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> I thought we'd killed that link.  Where's the bad documentation link you found?
>>
>> y
>>
>> On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Ah thanks, I couldn't find the docs earlier.  It looks like the
>>> Documentation link off the Jane St site points to something from 2009,
>>> thank you for the correct link.
>>>
>>> /M
>>>
>>> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>> CC'ing Nathan, who is the primary author of Command.
>>>>
>>>> We're in a bit of an awkward state with bitbucket right now, though it
>>>> will be fixed eventually.  That said, I'm not sure why that's
>>>> important to learning the command API: it's all available in the
>>>> tarball, after all, which you can get here:
>>>>
>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>>>
>>>> Also, the HTML documentation can be found here:
>>>>
>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>>>
>>>> Also, there's a module called Deprecated_command in Core_extended
>>>> (where the old Command lived) that has the old API on top of the new
>>>> implementation.
>>>>
>>>> The new Command uses some pretty clever types to give a good
>>>> interface, and we should really publish some examples (which we have
>>>> internally).  Nathan, do you have some ideas as to what we can do to
>>>> improve the docs?
>>>>
>>>> y
>>>>
>>>>
>>>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>>>> of API changes to the previous release (108.00.01 I think?).  But the
>>>>> source on bitbucket seems to correspond to the older version.  Am I
>>>>> missing something obvious or will bitbucket be updated soon?  Or is
>>>>> there some kind of migration documentation available?  Specifically
>>>>> I'm trying to figure out the new Command API.
>>>>>
>>>>> Thanks,
>>>>> /M


From mmatalka at gmail.com  Sun Oct  7 11:10:30 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 12:10:30 +0200
Subject: opam and bitbucket out of sync?
Message-ID: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>


Hi, opam is installing 108.07.01 for me which seems to have a number
of API changes to the previous release (108.00.01 I think?).  But the
source on bitbucket seems to correspond to the older version.  Am I
missing something obvious or will bitbucket be updated soon?  Or is
there some kind of migration documentation available?  Specifically
I'm trying to figure out the new Command API.

Thanks,
/M


From mmatalka at gmail.com  Sun Oct  7 13:20:03 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 14:20:03 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
Message-ID: <CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>


Ah thanks, I couldn't find the docs earlier.  It looks like the
Documentation link off the Jane St site points to something from 2009,
thank you for the correct link.

/M

On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> CC'ing Nathan, who is the primary author of Command.
>
> We're in a bit of an awkward state with bitbucket right now, though it
> will be fixed eventually.  That said, I'm not sure why that's
> important to learning the command API: it's all available in the
> tarball, after all, which you can get here:
>
>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>
> Also, the HTML documentation can be found here:
>
>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>
> Also, there's a module called Deprecated_command in Core_extended
> (where the old Command lived) that has the old API on top of the new
> implementation.
>
> The new Command uses some pretty clever types to give a good
> interface, and we should really publish some examples (which we have
> internally).  Nathan, do you have some ideas as to what we can do to
> improve the docs?
>
> y
>
>
> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Hi, opam is installing 108.07.01 for me which seems to have a number
>> of API changes to the previous release (108.00.01 I think?).  But the
>> source on bitbucket seems to correspond to the older version.  Am I
>> missing something obvious or will bitbucket be updated soon?  Or is
>> there some kind of migration documentation available?  Specifically
>> I'm trying to figure out the new Command API.
>>
>> Thanks,
>> /M


From mmatalka at gmail.com  Sun Oct  7 13:25:28 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 14:25:28 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
	<CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
Message-ID: <CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>


https://ocaml.janestreet.com/

The Documentation link on the top next to Code points to
http://www.janestreet.com/ocaml/janestreet-ocamldocs/

/M

On Sun, Oct 7, 2012 at 2:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> I thought we'd killed that link.  Where's the bad documentation link you found?
>
> y
>
> On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Ah thanks, I couldn't find the docs earlier.  It looks like the
>> Documentation link off the Jane St site points to something from 2009,
>> thank you for the correct link.
>>
>> /M
>>
>> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> CC'ing Nathan, who is the primary author of Command.
>>>
>>> We're in a bit of an awkward state with bitbucket right now, though it
>>> will be fixed eventually.  That said, I'm not sure why that's
>>> important to learning the command API: it's all available in the
>>> tarball, after all, which you can get here:
>>>
>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>>
>>> Also, the HTML documentation can be found here:
>>>
>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>>
>>> Also, there's a module called Deprecated_command in Core_extended
>>> (where the old Command lived) that has the old API on top of the new
>>> implementation.
>>>
>>> The new Command uses some pretty clever types to give a good
>>> interface, and we should really publish some examples (which we have
>>> internally).  Nathan, do you have some ideas as to what we can do to
>>> improve the docs?
>>>
>>> y
>>>
>>>
>>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>>> of API changes to the previous release (108.00.01 I think?).  But the
>>>> source on bitbucket seems to correspond to the older version.  Am I
>>>> missing something obvious or will bitbucket be updated soon?  Or is
>>>> there some kind of migration documentation available?  Specifically
>>>> I'm trying to figure out the new Command API.
>>>>
>>>> Thanks,
>>>> /M


From mmatalka at gmail.com  Sun Oct  7 13:40:16 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 14:40:16 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jQU80SbtFXE6y1gZPRyBm9pGcrKsuXp5+vSOUYw18oPuw@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
	<CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
	<CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>
	<CACLX4jQU80SbtFXE6y1gZPRyBm9pGcrKsuXp5+vSOUYw18oPuw@mail.gmail.com>
Message-ID: <CAKziXDUgX+yzhR__ABzK41Xk_q2-LaBiWcwoi-6ax0qKvLnAcw@mail.gmail.com>


Great, thanks the the quick response!

On Sun, Oct 7, 2012 at 2:36 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Got it.  Will fix.
>
> On Sun, Oct 7, 2012 at 8:25 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> https://ocaml.janestreet.com/
>>
>> The Documentation link on the top next to Code points to
>> http://www.janestreet.com/ocaml/janestreet-ocamldocs/
>>
>> /M
>>
>> On Sun, Oct 7, 2012 at 2:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> I thought we'd killed that link.  Where's the bad documentation link you found?
>>>
>>> y
>>>
>>> On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Ah thanks, I couldn't find the docs earlier.  It looks like the
>>>> Documentation link off the Jane St site points to something from 2009,
>>>> thank you for the correct link.
>>>>
>>>> /M
>>>>
>>>> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>>> CC'ing Nathan, who is the primary author of Command.
>>>>>
>>>>> We're in a bit of an awkward state with bitbucket right now, though it
>>>>> will be fixed eventually.  That said, I'm not sure why that's
>>>>> important to learning the command API: it's all available in the
>>>>> tarball, after all, which you can get here:
>>>>>
>>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>>>>
>>>>> Also, the HTML documentation can be found here:
>>>>>
>>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>>>>
>>>>> Also, there's a module called Deprecated_command in Core_extended
>>>>> (where the old Command lived) that has the old API on top of the new
>>>>> implementation.
>>>>>
>>>>> The new Command uses some pretty clever types to give a good
>>>>> interface, and we should really publish some examples (which we have
>>>>> internally).  Nathan, do you have some ideas as to what we can do to
>>>>> improve the docs?
>>>>>
>>>>> y
>>>>>
>>>>>
>>>>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>>>>> of API changes to the previous release (108.00.01 I think?).  But the
>>>>>> source on bitbucket seems to correspond to the older version.  Am I
>>>>>> missing something obvious or will bitbucket be updated soon?  Or is
>>>>>> there some kind of migration documentation available?  Specifically
>>>>>> I'm trying to figure out the new Command API.
>>>>>>
>>>>>> Thanks,
>>>>>> /M


From anil at recoil.org  Mon Oct  8 02:04:53 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Sun, 7 Oct 2012 18:04:53 -0700
Subject: Error: Unbound value OpamGlobals.os_string
In-Reply-To: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>
References: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>
Message-ID: <9E3D531E-5792-4335-919D-663F31178E4A@recoil.org>


This is fixed by:
https://github.com/OCamlPro/opam/pull/215

but you should be using the 0.7.5 release, as trunk is currently broken in other ways.

-anil

On 7 Oct 2012, at 18:01, Ralph Douglass <ralph at grayskies.net> wrote:

> I just did a git clone (git clone git://github.com/OCamlPro/opam.git), tried to build, and got this:
> 
> [1104.1] '/usr/bin/ocamlc.opt' '-g' '-annot' '-warn-error' 'A' '-c' '-o' '_obuild/1104/opamClient.cmo' '-I' './_obuild/opam-lib' '-I' '.' '-I' './_obuild/re' '-I' './src_ext' '-I' './_obuild/re_perl' '-I' './_obuild/extlib' '-I' './_obuild/cudf' '-I' '/usr/lib64/ocaml' '-I' './_obuild/graph' '-I' './_obuild/dose' '-I' './_obuild/re_glob' 'src/opamClient.ml'
> File "src/opamClient.ml", line 424, characters 16-37:
> Error: Unbound value OpamGlobals.os_string
> 
> I added 'let os_string = string_of_os;;' to src/opamGlobals.ml and was able to carry on.
> 
> Probably not important, but I'm running FC 17.
> 
> -- 
> Ralph



From ralph at grayskies.net  Mon Oct  8 02:01:00 2012
From: ralph at grayskies.net (Ralph Douglass)
Date: Sun, 7 Oct 2012 21:01:00 -0400
Subject: Error: Unbound value OpamGlobals.os_string
Message-ID: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>

I just did a git clone (git clone git://github.com/OCamlPro/opam.git),
tried to build, and got this:

[1104.1] '/usr/bin/ocamlc.opt' '-g' '-annot' '-warn-error' 'A' '-c' '-o'
'_obuild/1104/opamClient.cmo' '-I' './_obuild/opam-lib' '-I' '.' '-I'
'./_obuild/re' '-I' './src_ext' '-I' './_obuild/re_perl' '-I'
'./_obuild/extlib' '-I' './_obuild/cudf' '-I' '/usr/lib64/ocaml' '-I'
'./_obuild/graph' '-I' './_obuild/dose' '-I' './_obuild/re_glob'
'src/opamClient.ml'
File "src/opamClient.ml", line 424, characters 16-37:
Error: Unbound value OpamGlobals.os_string

I added 'let os_string = string_of_os;;' to src/opamGlobals.ml and was able
to carry on.

Probably not important, but I'm running FC 17.

-- 
Ralph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121007/8a6b0a7b/attachment.html>

From ralph at grayskies.net  Mon Oct  8 02:06:01 2012
From: ralph at grayskies.net (Ralph Douglass)
Date: Sun, 7 Oct 2012 21:06:01 -0400
Subject: Error: Unbound value OpamGlobals.os_string
In-Reply-To: <9E3D531E-5792-4335-919D-663F31178E4A@recoil.org>
References: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>
 <9E3D531E-5792-4335-919D-663F31178E4A@recoil.org>
Message-ID: <CAL7hpAkt-Hc7eY_j8PmFp_yS8TAhcFTT0E6LY7cNZ4TO-sJbrA@mail.gmail.com>

Ah got it.  Thanks!

On Sun, Oct 7, 2012 at 9:04 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> This is fixed by:
> https://github.com/OCamlPro/opam/pull/215
>
> but you should be using the 0.7.5 release, as trunk is currently broken in
> other ways.
>
> -anil
>
> On 7 Oct 2012, at 18:01, Ralph Douglass <ralph at grayskies.net> wrote:
>
> > I just did a git clone (git clone git://github.com/OCamlPro/opam.git),
> tried to build, and got this:
> >
> > [1104.1] '/usr/bin/ocamlc.opt' '-g' '-annot' '-warn-error' 'A' '-c' '-o'
> '_obuild/1104/opamClient.cmo' '-I' './_obuild/opam-lib' '-I' '.' '-I'
> './_obuild/re' '-I' './src_ext' '-I' './_obuild/re_perl' '-I'
> './_obuild/extlib' '-I' './_obuild/cudf' '-I' '/usr/lib64/ocaml' '-I'
> './_obuild/graph' '-I' './_obuild/dose' '-I' './_obuild/re_glob'
> 'src/opamClient.ml'
> > File "src/opamClient.ml", line 424, characters 16-37:
> > Error: Unbound value OpamGlobals.os_string
> >
> > I added 'let os_string = string_of_os;;' to src/opamGlobals.ml and was
> able to carry on.
> >
> > Probably not important, but I'm running FC 17.
> >
> > --
> > Ralph
>
>


-- 
Ralph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121007/c0777f01/attachment.html>

From nlinger at janestreet.com  Mon Oct  8 14:38:19 2012
From: nlinger at janestreet.com (Nathan Linger)
Date: Mon, 8 Oct 2012 09:38:19 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
Message-ID: <CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>


On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> CC'ing Nathan, who is the primary author of Command.
>
> The new Command uses some pretty clever types to give a good
> interface, and we should really publish some examples (which we have
> internally).  Nathan, do you have some ideas as to what we can do to
> improve the docs?

Malcolm, there is code showing how to use Command in

  core-108.07.01/examples/command/main.ml

There are several examples there.  I will clean up that module in the
future to be even more didatic.  Also, I'll add a reference to this
file in command.mli.


From anil at recoil.org  Tue Oct  9 06:04:16 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 8 Oct 2012 22:04:16 -0700
Subject: using Async from the toplevel
Message-ID: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>


I can use Lwt from the top-level (especially utop) very easily since the main function (Lwt_main.run) returns when the input thread has completed, and more commands can be typed in.

Scheduler.go () in Async never returns control the toplevel.  Is there a variant you all use to interactively play with Async threads?

-anil




From anil at recoil.org  Tue Oct  9 23:08:10 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 9 Oct 2012 15:08:10 -0700
Subject: Faster preprocessing
In-Reply-To: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>
References: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>
Message-ID: <90E08C02-80EA-4220-BC94-827A4FC2E171@recoil.org>


That -traverse trick is also really useful when using version-controlled
source trees!

FWIW, when I switched the Mirage build (which builds a complete OS environment)
from byte to native camlp4 [1], the build time dropped from 6.50min to 2.10min.
There was also a significant benefit from bundling all the extensions into a
single pa_mirage, which is also easier from the perspective of ensuring that all
extensions work together.

Have you considered building a Core syntax bundle which could be linked in
*instead* of the individual equivalents?  Until OASIS gets first-class syntax
extension support, this would make the instructions for modifying _tags easier
too.

-anil

[1] https://github.com/avsm/mirage/commit/7468a6129c56b89663615836f4a2314ad88538c9#lib/myocamlbuild.ml

On 9 Oct 2012, at 15:01, Markus Mottl <markus.mottl at gmail.com> wrote:

> This might be a good idea to add to the Core build process:
> https://mancoosi.org/~abate/two-simple-tips-speed-ocaml-compilation
> 
> Since probably most files depend on syntax extensions, using the
> native code preprocessor (camlp4o.opt) and .cmxs preprocessing modules
> could lead to a pretty noticeable speedup.  Adding support for this to
> Oasis should make this even more seamless.
> 
> Regards,
> Markus
> 
> -- 
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
> 



From yminsky at janestreet.com  Tue Oct  9 22:19:10 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 9 Oct 2012 17:19:10 -0400
Subject: using Async from the toplevel
In-Reply-To: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
Message-ID: <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>


Looping in Stephen.  I think there's no option now, but there could
be.  One issue now is that the scheduler never shuts down on its own
accord --- even when no jobs are left, it still sits there, waiting in
case, say, a C thread wants to jump into the runtime and do something.

To make this work, we probably need to fix both facts.

y

On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I can use Lwt from the top-level (especially utop) very easily since the main function (Lwt_main.run) returns when the input thread has completed, and more commands can be typed in.
>
> Scheduler.go () in Async never returns control the toplevel.  Is there a variant you all use to interactively play with Async threads?
>
> -anil
>
>


From yury.sulsky at gmail.com  Tue Oct  9 22:31:57 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Tue, 9 Oct 2012 17:31:57 -0400
Subject: using Async from the toplevel
In-Reply-To: <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
Message-ID: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>

This isn't as nice, but you can execute some commands by blocking on Async
in a separate thread:

# open Core.Std
# open Async.Std;;
# Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
- : Core.Std.Thread.t = <abstr>
# Thread_safe.block_on_async_exn (fun () ->
      Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;


On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:

> Looping in Stephen.  I think there's no option now, but there could
> be.  One issue now is that the scheduler never shuts down on its own
> accord --- even when no jobs are left, it still sits there, waiting in
> case, say, a C thread wants to jump into the runtime and do something.
>
> To make this work, we probably need to fix both facts.
>
> y
>
> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > I can use Lwt from the top-level (especially utop) very easily since the
> main function (Lwt_main.run) returns when the input thread has completed,
> and more commands can be typed in.
> >
> > Scheduler.go () in Async never returns control the toplevel.  Is there a
> variant you all use to interactively play with Async threads?
> >
> > -anil
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121009/87a7427f/attachment.html>

From sweeks at janestreet.com  Tue Oct  9 22:53:56 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Tue, 9 Oct 2012 17:53:56 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
Message-ID: <CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>


> This isn't as nice, but you can execute some commands by blocking on Async
> in a separate thread:
>
> # open Core.Std
> # open Async.Std;;
> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
> - : Core.Std.Thread.t = <abstr>
> # Thread_safe.block_on_async_exn (fun () ->
>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;

I know nothing about the toplevel, but it seems plausible to me that
one could hook something in that wrapped every expression [e] in:

  Thread_safe.block_on_async_exn (fun () -> e)


From markus.mottl at gmail.com  Tue Oct  9 23:01:40 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Tue, 9 Oct 2012 18:01:40 -0400
Subject: Faster preprocessing
Message-ID: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>


This might be a good idea to add to the Core build process:
https://mancoosi.org/~abate/two-simple-tips-speed-ocaml-compilation

Since probably most files depend on syntax extensions, using the
native code preprocessor (camlp4o.opt) and .cmxs preprocessing modules
could lead to a pretty noticeable speedup.  Adding support for this to
Oasis should make this even more seamless.

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From sweeks at janestreet.com  Wed Oct 10 00:25:27 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Tue, 9 Oct 2012 19:25:27 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
Message-ID: <CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>


With the OCaml toplevel and async scheduler running in different
threads, we need to guarantee that they don't interfere with each
other.  It is not necessary to stop the async scheduler; we just have
to prevent it from running while the toplevel is evaluating an input
expression.  This can be accomplished by having the toplevel hold the
async lock while it is evaluating an input expression, and is part of
what is done by wrapping the expression in [block_on_async_exn]:

  val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a

[block_on_async_exn] also waits until the deferred becomes determined,
which may or may not be desirable.  The only key point for correctness
is the locking.  So, all we really need is [run_in_async_exn], which
acquires the lock, but does not block:

  val run_in_async_exn : (unit -> 'a) -> 'a

If people want the ability to block the async scheduler from running,
we could easily add the following functions to [Async.Thread_safe]:

  val  pause_scheduler : unit -> unit
  val resume_scheduler : unit -> unit

Calling [pause_scheduler] would block until it can acquire the async
lock, at which point the scheduler would be prevented from running.
One can then do whatever one wants, without interference from async,
and then, when one is finished, call [resume_scheduler].

But, I've never heard a need for these at Jane Street; we've been able
to get by with [{block_on,run_in}_async_exn].


From yminsky at janestreet.com  Wed Oct 10 01:21:07 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 9 Oct 2012 20:21:07 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
	<CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
Message-ID: <CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>


On a related note, have you ever considered having the async scheduler
stop running when it runs out of jobs?  It has been argued that this
would make simple command-line apps simpler, since they would exit
automatically when the work was done.  I'm sure there are complexities
here...

y

On Tue, Oct 9, 2012 at 7:25 PM, Stephen Weeks <sweeks at janestreet.com> wrote:
> With the OCaml toplevel and async scheduler running in different
> threads, we need to guarantee that they don't interfere with each
> other.  It is not necessary to stop the async scheduler; we just have
> to prevent it from running while the toplevel is evaluating an input
> expression.  This can be accomplished by having the toplevel hold the
> async lock while it is evaluating an input expression, and is part of
> what is done by wrapping the expression in [block_on_async_exn]:
>
>   val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a
>
> [block_on_async_exn] also waits until the deferred becomes determined,
> which may or may not be desirable.  The only key point for correctness
> is the locking.  So, all we really need is [run_in_async_exn], which
> acquires the lock, but does not block:
>
>   val run_in_async_exn : (unit -> 'a) -> 'a
>
> If people want the ability to block the async scheduler from running,
> we could easily add the following functions to [Async.Thread_safe]:
>
>   val  pause_scheduler : unit -> unit
>   val resume_scheduler : unit -> unit
>
> Calling [pause_scheduler] would block until it can acquire the async
> lock, at which point the scheduler would be prevented from running.
> One can then do whatever one wants, without interference from async,
> and then, when one is finished, call [resume_scheduler].
>
> But, I've never heard a need for these at Jane Street; we've been able
> to get by with [{block_on,run_in}_async_exn].


From mmatalka at gmail.com  Tue Oct  9 22:40:15 2012
From: mmatalka at gmail.com (Malcolm)
Date: Tue, 9 Oct 2012 23:40:15 +0200
Subject: using Async from the toplevel
In-Reply-To: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org> <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com> <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
Message-ID: <A6DE786C-E82B-4DFF-9E0A-9B8726084761@gmail.com>


Once nice thing about the Lwt way is sometimes I have a program that is 80% sequential work and at a few key places I want to do concurrent things, which just likes like thing1 (); thing2 (); let res = Lwt.run (thing_that_returns_a_lwt_thread ()); thing3 ();  etc.  Having an interface similar to Lwt's here gets my vote.

/Malcolm

On Oct 9, 2012, at 11:31 PM, Yury Sulsky wrote:

> This isn't as nice, but you can execute some commands by blocking on Async in a separate thread:
> 
> # open Core.Std
> # open Async.Std;;
> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
> - : Core.Std.Thread.t = <abstr>
> # Thread_safe.block_on_async_exn (fun () ->
>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
> 
> 
> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Looping in Stephen.  I think there's no option now, but there could
> be.  One issue now is that the scheduler never shuts down on its own
> accord --- even when no jobs are left, it still sits there, waiting in
> case, say, a C thread wants to jump into the runtime and do something.
> 
> To make this work, we probably need to fix both facts.
> 
> y
> 
> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > I can use Lwt from the top-level (especially utop) very easily since the main function (Lwt_main.run) returns when the input thread has completed, and more commands can be typed in.
> >
> > Scheduler.go () in Async never returns control the toplevel.  Is there a variant you all use to interactively play with Async threads?
> >
> > -anil
> >
> >
> 



From nlinger at janestreet.com  Wed Oct 10 14:02:16 2012
From: nlinger at janestreet.com (Nathan Linger)
Date: Wed, 10 Oct 2012 09:02:16 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
Message-ID: <CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com>


I remember Stephen and I wishing for a version of the toplevel that
would allow you to apply a macro like this to each input, for this
very reason.

E --> Thread_safe.block_on_async_exn (fun () -> E)

On Tue, Oct 9, 2012 at 5:31 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> This isn't as nice, but you can execute some commands by blocking on Async
> in a separate thread:
>
> # open Core.Std
> # open Async.Std;;
> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
> - : Core.Std.Thread.t = <abstr>
> # Thread_safe.block_on_async_exn (fun () ->
>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
>
>
>
> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>
>> Looping in Stephen.  I think there's no option now, but there could
>> be.  One issue now is that the scheduler never shuts down on its own
>> accord --- even when no jobs are left, it still sits there, waiting in
>> case, say, a C thread wants to jump into the runtime and do something.
>>
>> To make this work, we probably need to fix both facts.
>>
>> y
>>
>> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> > I can use Lwt from the top-level (especially utop) very easily since the
>> > main function (Lwt_main.run) returns when the input thread has completed,
>> > and more commands can be typed in.
>> >
>> > Scheduler.go () in Async never returns control the toplevel.  Is there a
>> > variant you all use to interactively play with Async threads?
>> >
>> > -anil
>> >
>> >
>
>


From yminsky at janestreet.com  Wed Oct 10 14:03:55 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 10 Oct 2012 09:03:55 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAK=fH+jfnrRhzadV=Pv4k3krHPoutohzmsbe6im=BuXvWoLv_Q@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
	<CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
	<CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>
	<CAK=fH+jfnrRhzadV=Pv4k3krHPoutohzmsbe6im=BuXvWoLv_Q@mail.gmail.com>
Message-ID: <CACLX4jTNWQai_W8VcShSD9hu1qwR6QkHeb6ZrkGC3jO7MgLwjg@mail.gmail.com>


I do think something like this would make sense.  You might still need
to keep the scheduler open indefinitely for other cases, like when a
thread created in some other way (e.g., 3rd-party library spins up its
own thread), but one can specify this as necessary.

y

On Wed, Oct 10, 2012 at 4:55 AM, David House <dhouse at janestreet.com> wrote:
> I've thought about that before, but didn't you answer that yourself a
> few emails ago? What if one does an In_thread.run that blocks for some
> time and then schedules a job?
>
> But actually, I think this can gotten around. The criterion for
> returning from the scheduler would be:
>
> * No jobs on the job queue
> * No fds being select()ed for writing
> * The only fd being select()ed for reading is the interruptor
> * No timer events
> * No threads in the thread pool have work (Thread_pool.unfinished_work
> is 0 -- this is currently not exposed, but I think it could be).
>
> This adds the requirement that if one wants to create threads in
> async, you must go through In_thread. At the moment, one could
> presumably do a Core.Std.Thread.create that essentially reimplements
> In_thread.run. It seems fine to disallow this. We'd probably want to
> shadow Thread.create in the same way we do other verboten functions
> from Core.
>
> Stephen, what do you think?
>
> On Wed, Oct 10, 2012 at 1:21 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> On a related note, have you ever considered having the async scheduler
>> stop running when it runs out of jobs?  It has been argued that this
>> would make simple command-line apps simpler, since they would exit
>> automatically when the work was done.  I'm sure there are complexities
>> here...
>>
>> y
>>
>> On Tue, Oct 9, 2012 at 7:25 PM, Stephen Weeks <sweeks at janestreet.com> wrote:
>>> With the OCaml toplevel and async scheduler running in different
>>> threads, we need to guarantee that they don't interfere with each
>>> other.  It is not necessary to stop the async scheduler; we just have
>>> to prevent it from running while the toplevel is evaluating an input
>>> expression.  This can be accomplished by having the toplevel hold the
>>> async lock while it is evaluating an input expression, and is part of
>>> what is done by wrapping the expression in [block_on_async_exn]:
>>>
>>>   val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a
>>>
>>> [block_on_async_exn] also waits until the deferred becomes determined,
>>> which may or may not be desirable.  The only key point for correctness
>>> is the locking.  So, all we really need is [run_in_async_exn], which
>>> acquires the lock, but does not block:
>>>
>>>   val run_in_async_exn : (unit -> 'a) -> 'a
>>>
>>> If people want the ability to block the async scheduler from running,
>>> we could easily add the following functions to [Async.Thread_safe]:
>>>
>>>   val  pause_scheduler : unit -> unit
>>>   val resume_scheduler : unit -> unit
>>>
>>> Calling [pause_scheduler] would block until it can acquire the async
>>> lock, at which point the scheduler would be prevented from running.
>>> One can then do whatever one wants, without interference from async,
>>> and then, when one is finished, call [resume_scheduler].
>>>
>>> But, I've never heard a need for these at Jane Street; we've been able
>>> to get by with [{block_on,run_in}_async_exn].


From yminsky at janestreet.com  Wed Oct 10 14:04:59 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 10 Oct 2012 09:04:59 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com>
Message-ID: <CACLX4jSsCy9ghvXwgbj8CW3V=ubfcvYL4rOq3C_-JNWr2Z0T8Q@mail.gmail.com>


I think Anil is working on a hack for utop (Jeremie Dimino's
alternative toplevel) to do just this, based on the type of the return
value.

y

On Wed, Oct 10, 2012 at 9:02 AM, Nathan Linger <nlinger at janestreet.com> wrote:
> I remember Stephen and I wishing for a version of the toplevel that
> would allow you to apply a macro like this to each input, for this
> very reason.
>
> E --> Thread_safe.block_on_async_exn (fun () -> E)
>
> On Tue, Oct 9, 2012 at 5:31 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> This isn't as nice, but you can execute some commands by blocking on Async
>> in a separate thread:
>>
>> # open Core.Std
>> # open Async.Std;;
>> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
>> - : Core.Std.Thread.t = <abstr>
>> # Thread_safe.block_on_async_exn (fun () ->
>>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
>>
>>
>>
>> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>
>>> Looping in Stephen.  I think there's no option now, but there could
>>> be.  One issue now is that the scheduler never shuts down on its own
>>> accord --- even when no jobs are left, it still sits there, waiting in
>>> case, say, a C thread wants to jump into the runtime and do something.
>>>
>>> To make this work, we probably need to fix both facts.
>>>
>>> y
>>>
>>> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> > I can use Lwt from the top-level (especially utop) very easily since the
>>> > main function (Lwt_main.run) returns when the input thread has completed,
>>> > and more commands can be typed in.
>>> >
>>> > Scheduler.go () in Async never returns control the toplevel.  Is there a
>>> > variant you all use to interactively play with Async threads?
>>> >
>>> > -anil
>>> >
>>> >
>>
>>


From gildor478 at gmail.com  Wed Oct 10 08:16:14 2012
From: gildor478 at gmail.com (Sylvain Le Gall)
Date: Wed, 10 Oct 2012 09:16:14 +0200
Subject: Faster preprocessing
In-Reply-To: <90E08C02-80EA-4220-BC94-827A4FC2E171@recoil.org>
References: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>
	<90E08C02-80EA-4220-BC94-827A4FC2E171@recoil.org>
Message-ID: <CAOCAUGMJjGGkza1zJdoimT_0ErzrCONnd7W2Fk2vubQfy1UBDw@mail.gmail.com>

A traverse trick avoiding .git is already implemented is  OASIS. I will
think about the native camlp4/cmxs when implementing syntax-extension.
Le 10 oct. 2012 00:08, "Anil Madhavapeddy" <anil at recoil.org> a ?crit :

> That -traverse trick is also really useful when using version-controlled
> source trees!
>
> FWIW, when I switched the Mirage build (which builds a complete OS
> environment)
> from byte to native camlp4 [1], the build time dropped from 6.50min to
> 2.10min.
> There was also a significant benefit from bundling all the extensions into
> a
> single pa_mirage, which is also easier from the perspective of ensuring
> that all
> extensions work together.
>
> Have you considered building a Core syntax bundle which could be linked in
> *instead* of the individual equivalents?  Until OASIS gets first-class
> syntax
> extension support, this would make the instructions for modifying _tags
> easier
> too.
>
> -anil
>
> [1]
> https://github.com/avsm/mirage/commit/7468a6129c56b89663615836f4a2314ad88538c9#lib/myocamlbuild.ml
>
> On 9 Oct 2012, at 15:01, Markus Mottl <markus.mottl at gmail.com> wrote:
>
> > This might be a good idea to add to the Core build process:
> > https://mancoosi.org/~abate/two-simple-tips-speed-ocaml-compilation
> >
> > Since probably most files depend on syntax extensions, using the
> > native code preprocessor (camlp4o.opt) and .cmxs preprocessing modules
> > could lead to a pretty noticeable speedup.  Adding support for this to
> > Oasis should make this even more seamless.
> >
> > Regards,
> > Markus
> >
> > --
> > Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121010/8fc5bc6f/attachment.html>

From dhouse at janestreet.com  Wed Oct 10 09:55:51 2012
From: dhouse at janestreet.com (David House)
Date: Wed, 10 Oct 2012 09:55:51 +0100
Subject: using Async from the toplevel
In-Reply-To: <CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
	<CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
	<CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>
Message-ID: <CAK=fH+jfnrRhzadV=Pv4k3krHPoutohzmsbe6im=BuXvWoLv_Q@mail.gmail.com>


I've thought about that before, but didn't you answer that yourself a
few emails ago? What if one does an In_thread.run that blocks for some
time and then schedules a job?

But actually, I think this can gotten around. The criterion for
returning from the scheduler would be:

* No jobs on the job queue
* No fds being select()ed for writing
* The only fd being select()ed for reading is the interruptor
* No timer events
* No threads in the thread pool have work (Thread_pool.unfinished_work
is 0 -- this is currently not exposed, but I think it could be).

This adds the requirement that if one wants to create threads in
async, you must go through In_thread. At the moment, one could
presumably do a Core.Std.Thread.create that essentially reimplements
In_thread.run. It seems fine to disallow this. We'd probably want to
shadow Thread.create in the same way we do other verboten functions
from Core.

Stephen, what do you think?

On Wed, Oct 10, 2012 at 1:21 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On a related note, have you ever considered having the async scheduler
> stop running when it runs out of jobs?  It has been argued that this
> would make simple command-line apps simpler, since they would exit
> automatically when the work was done.  I'm sure there are complexities
> here...
>
> y
>
> On Tue, Oct 9, 2012 at 7:25 PM, Stephen Weeks <sweeks at janestreet.com> wrote:
>> With the OCaml toplevel and async scheduler running in different
>> threads, we need to guarantee that they don't interfere with each
>> other.  It is not necessary to stop the async scheduler; we just have
>> to prevent it from running while the toplevel is evaluating an input
>> expression.  This can be accomplished by having the toplevel hold the
>> async lock while it is evaluating an input expression, and is part of
>> what is done by wrapping the expression in [block_on_async_exn]:
>>
>>   val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a
>>
>> [block_on_async_exn] also waits until the deferred becomes determined,
>> which may or may not be desirable.  The only key point for correctness
>> is the locking.  So, all we really need is [run_in_async_exn], which
>> acquires the lock, but does not block:
>>
>>   val run_in_async_exn : (unit -> 'a) -> 'a
>>
>> If people want the ability to block the async scheduler from running,
>> we could easily add the following functions to [Async.Thread_safe]:
>>
>>   val  pause_scheduler : unit -> unit
>>   val resume_scheduler : unit -> unit
>>
>> Calling [pause_scheduler] would block until it can acquire the async
>> lock, at which point the scheduler would be prevented from running.
>> One can then do whatever one wants, without interference from async,
>> and then, when one is finished, call [resume_scheduler].
>>
>> But, I've never heard a need for these at Jane Street; we've been able
>> to get by with [{block_on,run_in}_async_exn].


From yury.sulsky at gmail.com  Wed Oct 10 15:30:15 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Wed, 10 Oct 2012 10:30:15 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
	<CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>
Message-ID: <CAEDxudxJ2KoT2qyHLJd=i82hXnZCe2HbfzuNbzMB4jiELTegCA@mail.gmail.com>

Malcolm,

The source on bitbucket is out of date (this will be rectified with the
next release). You should get the release tarballs here:
http://ocaml.janestreet.com/ocaml-core/latest

Yury

On Wed, Oct 10, 2012 at 10:11 AM, Malcolm Matalka <mmatalka at gmail.com>wrote:

> Thanks Nathan,
>
> Where can I find core-108.07.01/examples/command/main.ml?  Bitbucket
> doesn't appear to have that version up.  AFAIK Bitbucket is the only
> place to get the source, is there another location?
>
> Many thanks!
>
> /M
>
> On Mon, Oct 8, 2012 at 3:38 PM, Nathan Linger <nlinger at janestreet.com>
> wrote:
> > On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com>
> wrote:
> >> CC'ing Nathan, who is the primary author of Command.
> >>
> >> The new Command uses some pretty clever types to give a good
> >> interface, and we should really publish some examples (which we have
> >> internally).  Nathan, do you have some ideas as to what we can do to
> >> improve the docs?
> >
> > Malcolm, there is code showing how to use Command in
> >
> >   core-108.07.01/examples/command/main.ml
> >
> > There are several examples there.  I will clean up that module in the
> > future to be even more didatic.  Also, I'll add a reference to this
> > file in command.mli.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121010/dfc394a4/attachment.html>

From mmatalka at gmail.com  Wed Oct 10 15:11:33 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Wed, 10 Oct 2012 16:11:33 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
Message-ID: <CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>


Thanks Nathan,

Where can I find core-108.07.01/examples/command/main.ml?  Bitbucket
doesn't appear to have that version up.  AFAIK Bitbucket is the only
place to get the source, is there another location?

Many thanks!

/M

On Mon, Oct 8, 2012 at 3:38 PM, Nathan Linger <nlinger at janestreet.com> wrote:
> On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> CC'ing Nathan, who is the primary author of Command.
>>
>> The new Command uses some pretty clever types to give a good
>> interface, and we should really publish some examples (which we have
>> internally).  Nathan, do you have some ideas as to what we can do to
>> improve the docs?
>
> Malcolm, there is code showing how to use Command in
>
>   core-108.07.01/examples/command/main.ml
>
> There are several examples there.  I will clean up that module in the
> future to be even more didatic.  Also, I'll add a reference to this
> file in command.mli.


From mmatalka at gmail.com  Wed Oct 10 15:41:59 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Wed, 10 Oct 2012 16:41:59 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAEDxudxJ2KoT2qyHLJd=i82hXnZCe2HbfzuNbzMB4jiELTegCA@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
	<CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>
	<CAEDxudxJ2KoT2qyHLJd=i82hXnZCe2HbfzuNbzMB4jiELTegCA@mail.gmail.com>
Message-ID: <CAKziXDU38U5x22B1Fukxf7+288LuvLG9EJPD7GErn=oG3qSBew@mail.gmail.com>


Ah great thank you.  It looks like only the docs dir is linked to off
ocaml.janestreet.com, perhaps adding a link to this dir would be a
good idea too, unless I'm missing it.

Thanks again.

On Wed, Oct 10, 2012 at 4:30 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> Malcolm,
>
> The source on bitbucket is out of date (this will be rectified with the next
> release). You should get the release tarballs here:
> http://ocaml.janestreet.com/ocaml-core/latest
>
> Yury
>
>
> On Wed, Oct 10, 2012 at 10:11 AM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
>>
>> Thanks Nathan,
>>
>> Where can I find core-108.07.01/examples/command/main.ml?  Bitbucket
>> doesn't appear to have that version up.  AFAIK Bitbucket is the only
>> place to get the source, is there another location?
>>
>> Many thanks!
>>
>> /M
>>
>> On Mon, Oct 8, 2012 at 3:38 PM, Nathan Linger <nlinger at janestreet.com>
>> wrote:
>> > On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com>
>> > wrote:
>> >> CC'ing Nathan, who is the primary author of Command.
>> >>
>> >> The new Command uses some pretty clever types to give a good
>> >> interface, and we should really publish some examples (which we have
>> >> internally).  Nathan, do you have some ideas as to what we can do to
>> >> improve the docs?
>> >
>> > Malcolm, there is code showing how to use Command in
>> >
>> >   core-108.07.01/examples/command/main.ml
>> >
>> > There are several examples there.  I will clean up that module in the
>> > future to be even more didatic.  Also, I'll add a reference to this
>> > file in command.mli.
>
>


From dmhouse at gmail.com  Thu Oct 11 21:48:00 2012
From: dmhouse at gmail.com (David House)
Date: Thu, 11 Oct 2012 21:48:00 +0100
Subject: Async: Fd not getting closed?
In-Reply-To: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>
References: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>
Message-ID: <CADy1MaskAfTX4nO+Lhb_RB+f96im3RicSaRuhvVms084A-K9xA@mail.gmail.com>


Some general comments first:

* read_all seems to be trying to achieve the same thing as Reader.contents

* Is there any reason why you're using Core's waitpid function over
Async.Std.Unix.wait?

* Ivar.read (background foo) is equivalent to just foo, and you only
ever use the result of background inside an Ivar.read, so I think
background is pointless.

It's not immediately apparent where the actual bug is. One thing to
ask: do you get past the wait call, or are you getting stuck inside
one of the Deferred.both's? I.e. if you put a printf straight after
wait, do you see it? (Best to use [Printf.printf "foo\n%!"]; the
Printf module avoids going via Writer's buffer in case something weird
is going on, and you should always flush your debugging statements
with "%!"!)

On 11 October 2012 21:29, Malcolm Matalka <mmatalka at gmail.com> wrote:
> I have some dirty code here: http://ideone.com/WG9mN
>
> To compile:
>
> ocamlfind ocamlopt -package core,async -thread -linkpkg -o foo foo.ml
>
> The problem is the 'wait' never seems to come back. This appears to be
> because the cat is still waiting on reading stdin.  But the stdin
> should be closed on line 77, shouldn't it?
>
> What am I doing wrong?
>
> Thanks!
>
> /M


From mmatalka at gmail.com  Thu Oct 11 21:29:34 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Thu, 11 Oct 2012 22:29:34 +0200
Subject: Async: Fd not getting closed?
Message-ID: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>


I have some dirty code here: http://ideone.com/WG9mN

To compile:

ocamlfind ocamlopt -package core,async -thread -linkpkg -o foo foo.ml

The problem is the 'wait' never seems to come back. This appears to be
because the cat is still waiting on reading stdin.  But the stdin
should be closed on line 77, shouldn't it?

What am I doing wrong?

Thanks!

/M


From mmatalka at gmail.com  Thu Oct 11 22:00:25 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Thu, 11 Oct 2012 23:00:25 +0200
Subject: Async: Fd not getting closed?
In-Reply-To: <CADy1MaskAfTX4nO+Lhb_RB+f96im3RicSaRuhvVms084A-K9xA@mail.gmail.com>
References: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>
	<CADy1MaskAfTX4nO+Lhb_RB+f96im3RicSaRuhvVms084A-K9xA@mail.gmail.com>
Message-ID: <CAKziXDVW-fvD4WPYC+OHCekc=sVD8L3Fg2vM+bmrpOt=eo0KrA@mail.gmail.com>


Yes the code is in transition as I learn more about Async, so take all
non essentials with a grain of salt.

I switched the wait function to:

let wait pi =
  Unix.wait (`Pid (Core.Std.Pid.of_int pi.pid)) >>= function
    | (_, Result.Ok ()) ->
      Deferred.return (`Exited 0)
    | (_, Result.Error (`Exit_non_zero n)) ->
      Deferred.return (`Exited n)
    | (_, _) ->
      Deferred.return `Unknown


with no change in behaviour.

I do not get past the wait call and a ps shows the cat is still
running.  This function works properly for a program that doesn't read
from stdin such as an ls, which is what leads me to think somehow
stdin is not getting closed properly.

Thanks for the quick response,
/M

On Thu, Oct 11, 2012 at 10:48 PM, David House <dmhouse at gmail.com> wrote:
> Some general comments first:
>
> * read_all seems to be trying to achieve the same thing as Reader.contents
>
> * Is there any reason why you're using Core's waitpid function over
> Async.Std.Unix.wait?
>
> * Ivar.read (background foo) is equivalent to just foo, and you only
> ever use the result of background inside an Ivar.read, so I think
> background is pointless.
>
> It's not immediately apparent where the actual bug is. One thing to
> ask: do you get past the wait call, or are you getting stuck inside
> one of the Deferred.both's? I.e. if you put a printf straight after
> wait, do you see it? (Best to use [Printf.printf "foo\n%!"]; the
> Printf module avoids going via Writer's buffer in case something weird
> is going on, and you should always flush your debugging statements
> with "%!"!)
>
> On 11 October 2012 21:29, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> I have some dirty code here: http://ideone.com/WG9mN
>>
>> To compile:
>>
>> ocamlfind ocamlopt -package core,async -thread -linkpkg -o foo foo.ml
>>
>> The problem is the 'wait' never seems to come back. This appears to be
>> because the cat is still waiting on reading stdin.  But the stdin
>> should be closed on line 77, shouldn't it?
>>
>> What am I doing wrong?
>>
>> Thanks!
>>
>> /M


From anil at recoil.org  Mon Oct 15 07:11:22 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Sun, 14 Oct 2012 23:11:22 -0700
Subject: using Async from the toplevel
In-Reply-To: <CACLX4jSsCy9ghvXwgbj8CW3V=ubfcvYL4rOq3C_-JNWr2Z0T8Q@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org> <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com> <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com> <CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com> <CACLX4jSsCy9ghvXwgbj8CW3V=ubfcvYL4rOq3C_-JNWr2Z0T8Q@mail.gmail.com>
Message-ID: <1E4167A1-4A09-4B8C-A225-8C26EDFF7531@recoil.org>

Yeah, patch attached works fine for me.  It could use some factoring with
the Lwt Parsetree manipulation to reduce duplicated code, but the functionality
works great...

utop $ after (Time.Span.of_sec 2.0);;
<waits 2 seconds>
- : unit = ()                                                                                                                                                                    
utop $ let x = after (Time.Span.of_sec 2.0);;
val x : unit Async_core.Deferred.t = <abstr> 

Darcs diff attached.  I'm going to try and get the native code utop patches
working in OPAM next, to make the top-level less sluggish when using Async.

-------------- next part --------------

-anil

On 10 Oct 2012, at 06:04, Yaron Minsky <yminsky at janestreet.com> wrote:

> I think Anil is working on a hack for utop (Jeremie Dimino's
> alternative toplevel) to do just this, based on the type of the return
> value.
> 
> y
> 
> On Wed, Oct 10, 2012 at 9:02 AM, Nathan Linger <nlinger at janestreet.com> wrote:
>> I remember Stephen and I wishing for a version of the toplevel that
>> would allow you to apply a macro like this to each input, for this
>> very reason.
>> 
>> E --> Thread_safe.block_on_async_exn (fun () -> E)
>> 
>> On Tue, Oct 9, 2012 at 5:31 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>> This isn't as nice, but you can execute some commands by blocking on Async
>>> in a separate thread:
>>> 
>>> # open Core.Std
>>> # open Async.Std;;
>>> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
>>> - : Core.Std.Thread.t = <abstr>
>>> # Thread_safe.block_on_async_exn (fun () ->
>>>      Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
>>> 
>>> 
>>> 
>>> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>> 
>>>> Looping in Stephen.  I think there's no option now, but there could
>>>> be.  One issue now is that the scheduler never shuts down on its own
>>>> accord --- even when no jobs are left, it still sits there, waiting in
>>>> case, say, a C thread wants to jump into the runtime and do something.
>>>> 
>>>> To make this work, we probably need to fix both facts.
>>>> 
>>>> y
>>>> 
>>>> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> I can use Lwt from the top-level (especially utop) very easily since the
>>>>> main function (Lwt_main.run) returns when the input thread has completed,
>>>>> and more commands can be typed in.
>>>>> 
>>>>> Scheduler.go () in Async never returns control the toplevel.  Is there a
>>>>> variant you all use to interactively play with Async threads?
>>>>> 
>>>>> -anil
>>>>> 
>>>>> 
>>> 
>>> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: utop-async-darcs.diff
Type: application/octet-stream
Size: 7922 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121014/f7406997/attachment.obj>

From mmatalka at gmail.com  Mon Oct 15 09:01:02 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 10:01:02 +0200
Subject: File descriptor semantics in Core/Async?
Message-ID: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>


Hello, I'm wondering if Core or Async addresses this bug:
http://caml.inria.fr/mantis/view.php?id=5256

I have a situation where I'm reading/writing many files and spawning
subprocesses in Async and the subprocesses are inheriting the opened
FDs which is problematic for me.  I am using the ocaml stdlib
create_process for this as the Core version was causing segfaults for
me on OS X, but now I am mainly targeting Linux so I can switch batch
to Core's create_process if it solves this issue.  I poked around the
source code but didn't see anything in the comments about what happens
to open fd's after forking.

Thanks,
/M


From dhouse at janestreet.com  Mon Oct 15 10:01:48 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:01:48 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
Message-ID: <CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>


Hmm, how are you opening the files? Xavier in that thread claims that
if you use Pervasives.open_in or Pervasives.open_out, then
close-on-exec will be set for those file descriptors. The same is true
of Core.{In,Out}_channel.create.

That being said, I'm not actually sure that Async's Reader and Writer
are doing this, which is a little embarrassing. It's quite possible
this is deliberate; let me follow up internally,

On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Hello, I'm wondering if Core or Async addresses this bug:
> http://caml.inria.fr/mantis/view.php?id=5256
>
> I have a situation where I'm reading/writing many files and spawning
> subprocesses in Async and the subprocesses are inheriting the opened
> FDs which is problematic for me.  I am using the ocaml stdlib
> create_process for this as the Core version was causing segfaults for
> me on OS X, but now I am mainly targeting Linux so I can switch batch
> to Core's create_process if it solves this issue.  I poked around the
> source code but didn't see anything in the comments about what happens
> to open fd's after forking.
>
> Thanks,
> /M


From dhouse at janestreet.com  Mon Oct 15 10:06:40 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:06:40 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
Message-ID: <CAK=fH+hgfp3RhVmxvKZPc_7BcJsogecvq6iTAfc66h2OZZ6oDQ@mail.gmail.com>


By the way, the slightly scary (rather than merely inconvenient) case
is covered by async: if you use the tcp library to start a server,
that *will* call set_close_on_exec on the new file descriptor.

On Mon, Oct 15, 2012 at 10:01 AM, David House <dhouse at janestreet.com> wrote:
> Hmm, how are you opening the files? Xavier in that thread claims that
> if you use Pervasives.open_in or Pervasives.open_out, then
> close-on-exec will be set for those file descriptors. The same is true
> of Core.{In,Out}_channel.create.
>
> That being said, I'm not actually sure that Async's Reader and Writer
> are doing this, which is a little embarrassing. It's quite possible
> this is deliberate; let me follow up internally,
>
> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Hello, I'm wondering if Core or Async addresses this bug:
>> http://caml.inria.fr/mantis/view.php?id=5256
>>
>> I have a situation where I'm reading/writing many files and spawning
>> subprocesses in Async and the subprocesses are inheriting the opened
>> FDs which is problematic for me.  I am using the ocaml stdlib
>> create_process for this as the Core version was causing segfaults for
>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>> to Core's create_process if it solves this issue.  I poked around the
>> source code but didn't see anything in the comments about what happens
>> to open fd's after forking.
>>
>> Thanks,
>> /M


From dhouse at janestreet.com  Mon Oct 15 10:26:28 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:26:28 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
Message-ID: <CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>


Oh, there is an easier fix than that. One can either call
Unix.set_close_on_exec on the underlying file descriptor (use
Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)

On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> One option I have is to write to a temporary filename then spawn a
> 'cp' to copy the temp file to the actual file, but that seems less
> than ideal.  The specific problem is I am writing shell scripts that
> will be run, and I'm spawning shell scripts at the same time, so if I
> spawn a shell script while writing a shell script, the written script
> cannot be executed until the running one is completed.
>
> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> I'm using Writer.with_file in this case.  I poked around the source
>> code but my Unix knowledge isn't strong enough to know what's right or
>> wrong.
>>
>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>> close-on-exec will be set for those file descriptors. The same is true
>>> of Core.{In,Out}_channel.create.
>>>
>>> That being said, I'm not actually sure that Async's Reader and Writer
>>> are doing this, which is a little embarrassing. It's quite possible
>>> this is deliberate; let me follow up internally,
>>>
>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>
>>>> I have a situation where I'm reading/writing many files and spawning
>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>> create_process for this as the Core version was causing segfaults for
>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>> to Core's create_process if it solves this issue.  I poked around the
>>>> source code but didn't see anything in the comments about what happens
>>>> to open fd's after forking.
>>>>
>>>> Thanks,
>>>> /M


From dhouse at janestreet.com  Mon Oct 15 10:35:20 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:35:20 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
Message-ID: <CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>


The context switch points in async are exactly the points where bind
appears. Blocks of code without a bind (or >>|, of course) inside them
are guaranteed to run uninterruptedly.

Looking at the source of Writer.with_file, it looks like you do not
have the guarantee that you want. It calls Unix.openfile, and then
there is a bind, so something else could run (depending, of course, on
the exact pattern of concurrency in your program).

Writer.of_out_channel, however, will give you the guarantees you want.
(It does not have a deferred return type so cannot be doing binds
internally.)

On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Am I guaranteed that no code will run between Writer.with_file
> creating the FD and my handler being run so I can set close on exec?
>
> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>> Oh, there is an easier fix than that. One can either call
>> Unix.set_close_on_exec on the underlying file descriptor (use
>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>
>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> One option I have is to write to a temporary filename then spawn a
>>> 'cp' to copy the temp file to the actual file, but that seems less
>>> than ideal.  The specific problem is I am writing shell scripts that
>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>> spawn a shell script while writing a shell script, the written script
>>> cannot be executed until the running one is completed.
>>>
>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>> wrong.
>>>>
>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>> of Core.{In,Out}_channel.create.
>>>>>
>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>> this is deliberate; let me follow up internally,
>>>>>
>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>
>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>> source code but didn't see anything in the comments about what happens
>>>>>> to open fd's after forking.
>>>>>>
>>>>>> Thanks,
>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 10:06:56 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:06:56 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
Message-ID: <CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>


I'm using Writer.with_file in this case.  I poked around the source
code but my Unix knowledge isn't strong enough to know what's right or
wrong.

On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
> Hmm, how are you opening the files? Xavier in that thread claims that
> if you use Pervasives.open_in or Pervasives.open_out, then
> close-on-exec will be set for those file descriptors. The same is true
> of Core.{In,Out}_channel.create.
>
> That being said, I'm not actually sure that Async's Reader and Writer
> are doing this, which is a little embarrassing. It's quite possible
> this is deliberate; let me follow up internally,
>
> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Hello, I'm wondering if Core or Async addresses this bug:
>> http://caml.inria.fr/mantis/view.php?id=5256
>>
>> I have a situation where I'm reading/writing many files and spawning
>> subprocesses in Async and the subprocesses are inheriting the opened
>> FDs which is problematic for me.  I am using the ocaml stdlib
>> create_process for this as the Core version was causing segfaults for
>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>> to Core's create_process if it solves this issue.  I poked around the
>> source code but didn't see anything in the comments about what happens
>> to open fd's after forking.
>>
>> Thanks,
>> /M


From mmatalka at gmail.com  Mon Oct 15 10:19:21 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:19:21 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
Message-ID: <CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>


One option I have is to write to a temporary filename then spawn a
'cp' to copy the temp file to the actual file, but that seems less
than ideal.  The specific problem is I am writing shell scripts that
will be run, and I'm spawning shell scripts at the same time, so if I
spawn a shell script while writing a shell script, the written script
cannot be executed until the running one is completed.

On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> I'm using Writer.with_file in this case.  I poked around the source
> code but my Unix knowledge isn't strong enough to know what's right or
> wrong.
>
> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>> Hmm, how are you opening the files? Xavier in that thread claims that
>> if you use Pervasives.open_in or Pervasives.open_out, then
>> close-on-exec will be set for those file descriptors. The same is true
>> of Core.{In,Out}_channel.create.
>>
>> That being said, I'm not actually sure that Async's Reader and Writer
>> are doing this, which is a little embarrassing. It's quite possible
>> this is deliberate; let me follow up internally,
>>
>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Hello, I'm wondering if Core or Async addresses this bug:
>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>
>>> I have a situation where I'm reading/writing many files and spawning
>>> subprocesses in Async and the subprocesses are inheriting the opened
>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>> create_process for this as the Core version was causing segfaults for
>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>> to Core's create_process if it solves this issue.  I poked around the
>>> source code but didn't see anything in the comments about what happens
>>> to open fd's after forking.
>>>
>>> Thanks,
>>> /M


From mmatalka at gmail.com  Mon Oct 15 10:28:29 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:28:29 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
Message-ID: <CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>


Am I guaranteed that no code will run between Writer.with_file
creating the FD and my handler being run so I can set close on exec?

On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
> Oh, there is an easier fix than that. One can either call
> Unix.set_close_on_exec on the underlying file descriptor (use
> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>
> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> One option I have is to write to a temporary filename then spawn a
>> 'cp' to copy the temp file to the actual file, but that seems less
>> than ideal.  The specific problem is I am writing shell scripts that
>> will be run, and I'm spawning shell scripts at the same time, so if I
>> spawn a shell script while writing a shell script, the written script
>> cannot be executed until the running one is completed.
>>
>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> I'm using Writer.with_file in this case.  I poked around the source
>>> code but my Unix knowledge isn't strong enough to know what's right or
>>> wrong.
>>>
>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>> close-on-exec will be set for those file descriptors. The same is true
>>>> of Core.{In,Out}_channel.create.
>>>>
>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>> are doing this, which is a little embarrassing. It's quite possible
>>>> this is deliberate; let me follow up internally,
>>>>
>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>
>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>> create_process for this as the Core version was causing segfaults for
>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>> source code but didn't see anything in the comments about what happens
>>>>> to open fd's after forking.
>>>>>
>>>>> Thanks,
>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 11:48:22 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 11:48:22 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
Message-ID: <CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>


You should not normally use the In_channel or Out_channel modules from
async, preferring Reader and Writer. This is because, as blocking
operations, they will kill all concurrency by blocking the main async
thread.

But in this case, I guess its use is warranted.

Anyway, since {In,Out}_channel.create does not have a deferred result
type (it's in core, so this is impossible!), they do not use binds.
I.e. the following code should run without interruptions:

  let out_chan = Out_channel.create "foo.txt" in
  let fd = Fd.of_out_channel out_chan Fd.Kind.File in
  Unix.set_close_on_exec fd;
  let writer = Writer.create writer in
  ...

On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Does creating an out channel require a bind though?  If so, can I
> atomically create an out channel with close on exec set?
>
> Thanks
>
> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>> The context switch points in async are exactly the points where bind
>> appears. Blocks of code without a bind (or >>|, of course) inside them
>> are guaranteed to run uninterruptedly.
>>
>> Looking at the source of Writer.with_file, it looks like you do not
>> have the guarantee that you want. It calls Unix.openfile, and then
>> there is a bind, so something else could run (depending, of course, on
>> the exact pattern of concurrency in your program).
>>
>> Writer.of_out_channel, however, will give you the guarantees you want.
>> (It does not have a deferred return type so cannot be doing binds
>> internally.)
>>
>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Am I guaranteed that no code will run between Writer.with_file
>>> creating the FD and my handler being run so I can set close on exec?
>>>
>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>> Oh, there is an easier fix than that. One can either call
>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>
>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> One option I have is to write to a temporary filename then spawn a
>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>> spawn a shell script while writing a shell script, the written script
>>>>> cannot be executed until the running one is completed.
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>> wrong.
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>
>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>
>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>> to open fd's after forking.
>>>>>>>>
>>>>>>>> Thanks,
>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 10:53:56 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:53:56 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
Message-ID: <CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>


Does creating an out channel require a bind though?  If so, can I
atomically create an out channel with close on exec set?

Thanks

On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
> The context switch points in async are exactly the points where bind
> appears. Blocks of code without a bind (or >>|, of course) inside them
> are guaranteed to run uninterruptedly.
>
> Looking at the source of Writer.with_file, it looks like you do not
> have the guarantee that you want. It calls Unix.openfile, and then
> there is a bind, so something else could run (depending, of course, on
> the exact pattern of concurrency in your program).
>
> Writer.of_out_channel, however, will give you the guarantees you want.
> (It does not have a deferred return type so cannot be doing binds
> internally.)
>
> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Am I guaranteed that no code will run between Writer.with_file
>> creating the FD and my handler being run so I can set close on exec?
>>
>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>> Oh, there is an easier fix than that. One can either call
>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>
>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> One option I have is to write to a temporary filename then spawn a
>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>> spawn a shell script while writing a shell script, the written script
>>>> cannot be executed until the running one is completed.
>>>>
>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>> wrong.
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>> of Core.{In,Out}_channel.create.
>>>>>>
>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>> this is deliberate; let me follow up internally,
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>
>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>> to open fd's after forking.
>>>>>>>
>>>>>>> Thanks,
>>>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 13:07:40 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 13:07:40 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
Message-ID: <CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>


It's very easy to make the blocking thing be non-blocking: throw the
whole thing into an In_thread.run.

On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Many thanks David, at least in this case a blocking open will mean I
> have bigger problems.
>
> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>> You should not normally use the In_channel or Out_channel modules from
>> async, preferring Reader and Writer. This is because, as blocking
>> operations, they will kill all concurrency by blocking the main async
>> thread.
>>
>> But in this case, I guess its use is warranted.
>>
>> Anyway, since {In,Out}_channel.create does not have a deferred result
>> type (it's in core, so this is impossible!), they do not use binds.
>> I.e. the following code should run without interruptions:
>>
>>   let out_chan = Out_channel.create "foo.txt" in
>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>   Unix.set_close_on_exec fd;
>>   let writer = Writer.create writer in
>>   ...
>>
>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Does creating an out channel require a bind though?  If so, can I
>>> atomically create an out channel with close on exec set?
>>>
>>> Thanks
>>>
>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>> The context switch points in async are exactly the points where bind
>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>> are guaranteed to run uninterruptedly.
>>>>
>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>> there is a bind, so something else could run (depending, of course, on
>>>> the exact pattern of concurrency in your program).
>>>>
>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>> (It does not have a deferred return type so cannot be doing binds
>>>> internally.)
>>>>
>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>> cannot be executed until the running one is completed.
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>> wrong.
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>
>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>
>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>
>>>>>>>>>> Thanks,
>>>>>>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 13:17:30 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 13:17:30 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
Message-ID: <CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>


How so?

let make_writer file =
  In_thread.run (fun () ->
    let out_chan = Out_channel.create file in
    let fd = Fd.of_out_channel out_chan Fd.Kind.File in
    Unix.set_close_on_exec fd;
    Writer.create writer)

The closure will run still without being interrupted.

On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> That won't work for me because making an fd and setting it to close on
> exec would become non-atomic again.
>
> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com> wrote:
>> It's very easy to make the blocking thing be non-blocking: throw the
>> whole thing into an In_thread.run.
>>
>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Many thanks David, at least in this case a blocking open will mean I
>>> have bigger problems.
>>>
>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>>>> You should not normally use the In_channel or Out_channel modules from
>>>> async, preferring Reader and Writer. This is because, as blocking
>>>> operations, they will kill all concurrency by blocking the main async
>>>> thread.
>>>>
>>>> But in this case, I guess its use is warranted.
>>>>
>>>> Anyway, since {In,Out}_channel.create does not have a deferred result
>>>> type (it's in core, so this is impossible!), they do not use binds.
>>>> I.e. the following code should run without interruptions:
>>>>
>>>>   let out_chan = Out_channel.create "foo.txt" in
>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>>>   Unix.set_close_on_exec fd;
>>>>   let writer = Writer.create writer in
>>>>   ...
>>>>
>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Does creating an out channel require a bind though?  If so, can I
>>>>> atomically create an out channel with close on exec set?
>>>>>
>>>>> Thanks
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>>>> The context switch points in async are exactly the points where bind
>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>>>> are guaranteed to run uninterruptedly.
>>>>>>
>>>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>>>> there is a bind, so something else could run (depending, of course, on
>>>>>> the exact pattern of concurrency in your program).
>>>>>>
>>>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>>>> (It does not have a deferred return type so cannot be doing binds
>>>>>> internally.)
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>>>> cannot be executed until the running one is completed.
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>>>> wrong.
>>>>>>>>>>
>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>>>
>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>>>
>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>>>
>>>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>>>
>>>>>>>>>>>> Thanks,
>>>>>>>>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 13:26:40 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 13:26:40 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
Message-ID: <CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>


Sorry, I was thinking of something else. Of course when one uses
In_thread, you give away interruptability guarantees. (This is the
whole point.)

You're also not allowed to use async code inside In_thread.run. (It
runs without the async lock.)

In principle, it is just a matter of aping the code for
Writer.open_file, but adding in a call to set_close_on_exec. So this
is definitely possible, it just depends how much code you're willing
to duplicate.

I think it should be possible to just do this all the time on Writer
and Reader; I'll see if I can push that through.

On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com> wrote:
> How so?
>
> let make_writer file =
>   In_thread.run (fun () ->
>     let out_chan = Out_channel.create file in
>     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>     Unix.set_close_on_exec fd;
>     Writer.create writer)
>
> The closure will run still without being interrupted.
>
> On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> That won't work for me because making an fd and setting it to close on
>> exec would become non-atomic again.
>>
>> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com> wrote:
>>> It's very easy to make the blocking thing be non-blocking: throw the
>>> whole thing into an In_thread.run.
>>>
>>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Many thanks David, at least in this case a blocking open will mean I
>>>> have bigger problems.
>>>>
>>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>>>>> You should not normally use the In_channel or Out_channel modules from
>>>>> async, preferring Reader and Writer. This is because, as blocking
>>>>> operations, they will kill all concurrency by blocking the main async
>>>>> thread.
>>>>>
>>>>> But in this case, I guess its use is warranted.
>>>>>
>>>>> Anyway, since {In,Out}_channel.create does not have a deferred result
>>>>> type (it's in core, so this is impossible!), they do not use binds.
>>>>> I.e. the following code should run without interruptions:
>>>>>
>>>>>   let out_chan = Out_channel.create "foo.txt" in
>>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>>>>   Unix.set_close_on_exec fd;
>>>>>   let writer = Writer.create writer in
>>>>>   ...
>>>>>
>>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Does creating an out channel require a bind though?  If so, can I
>>>>>> atomically create an out channel with close on exec set?
>>>>>>
>>>>>> Thanks
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>> The context switch points in async are exactly the points where bind
>>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>>>>> are guaranteed to run uninterruptedly.
>>>>>>>
>>>>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>>>>> there is a bind, so something else could run (depending, of course, on
>>>>>>> the exact pattern of concurrency in your program).
>>>>>>>
>>>>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>>>>> (It does not have a deferred return type so cannot be doing binds
>>>>>>> internally.)
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>>>>> cannot be executed until the running one is completed.
>>>>>>>>>>
>>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>>>>> wrong.
>>>>>>>>>>>
>>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>>>>
>>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>>>>
>>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>>>>
>>>>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>>>>
>>>>>>>>>>>>> Thanks,
>>>>>>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 12:55:16 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 13:55:16 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
Message-ID: <CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>


Many thanks David, at least in this case a blocking open will mean I
have bigger problems.

On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
> You should not normally use the In_channel or Out_channel modules from
> async, preferring Reader and Writer. This is because, as blocking
> operations, they will kill all concurrency by blocking the main async
> thread.
>
> But in this case, I guess its use is warranted.
>
> Anyway, since {In,Out}_channel.create does not have a deferred result
> type (it's in core, so this is impossible!), they do not use binds.
> I.e. the following code should run without interruptions:
>
>   let out_chan = Out_channel.create "foo.txt" in
>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>   Unix.set_close_on_exec fd;
>   let writer = Writer.create writer in
>   ...
>
> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Does creating an out channel require a bind though?  If so, can I
>> atomically create an out channel with close on exec set?
>>
>> Thanks
>>
>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>> The context switch points in async are exactly the points where bind
>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>> are guaranteed to run uninterruptedly.
>>>
>>> Looking at the source of Writer.with_file, it looks like you do not
>>> have the guarantee that you want. It calls Unix.openfile, and then
>>> there is a bind, so something else could run (depending, of course, on
>>> the exact pattern of concurrency in your program).
>>>
>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>> (It does not have a deferred return type so cannot be doing binds
>>> internally.)
>>>
>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Am I guaranteed that no code will run between Writer.with_file
>>>> creating the FD and my handler being run so I can set close on exec?
>>>>
>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>> Oh, there is an easier fix than that. One can either call
>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>
>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>> cannot be executed until the running one is completed.
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>> wrong.
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>
>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>
>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>> to open fd's after forking.
>>>>>>>>>
>>>>>>>>> Thanks,
>>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 13:15:31 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 14:15:31 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
Message-ID: <CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>


That won't work for me because making an fd and setting it to close on
exec would become non-atomic again.

On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com> wrote:
> It's very easy to make the blocking thing be non-blocking: throw the
> whole thing into an In_thread.run.
>
> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Many thanks David, at least in this case a blocking open will mean I
>> have bigger problems.
>>
>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>>> You should not normally use the In_channel or Out_channel modules from
>>> async, preferring Reader and Writer. This is because, as blocking
>>> operations, they will kill all concurrency by blocking the main async
>>> thread.
>>>
>>> But in this case, I guess its use is warranted.
>>>
>>> Anyway, since {In,Out}_channel.create does not have a deferred result
>>> type (it's in core, so this is impossible!), they do not use binds.
>>> I.e. the following code should run without interruptions:
>>>
>>>   let out_chan = Out_channel.create "foo.txt" in
>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>>   Unix.set_close_on_exec fd;
>>>   let writer = Writer.create writer in
>>>   ...
>>>
>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Does creating an out channel require a bind though?  If so, can I
>>>> atomically create an out channel with close on exec set?
>>>>
>>>> Thanks
>>>>
>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>>> The context switch points in async are exactly the points where bind
>>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>>> are guaranteed to run uninterruptedly.
>>>>>
>>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>>> there is a bind, so something else could run (depending, of course, on
>>>>> the exact pattern of concurrency in your program).
>>>>>
>>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>>> (It does not have a deferred return type so cannot be doing binds
>>>>> internally.)
>>>>>
>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>>> cannot be executed until the running one is completed.
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>>> wrong.
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>>
>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>>
>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>>
>>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>>
>>>>>>>>>>> Thanks,
>>>>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 13:28:42 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 14:28:42 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
Message-ID: <CAKziXDV4KU5erWkE_wSBOgA_JWw1PD-j+XuDyL6raYfRNwEYvg@mail.gmail.com>

Can't the thread be preempted?
On Oct 15, 2012 2:17 PM, "David House" <dhouse at janestreet.com> wrote:

> How so?
>
> let make_writer file =
>   In_thread.run (fun () ->
>     let out_chan = Out_channel.create file in
>     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>     Unix.set_close_on_exec fd;
>     Writer.create writer)
>
> The closure will run still without being interrupted.
>
> On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> > That won't work for me because making an fd and setting it to close on
> > exec would become non-atomic again.
> >
> > On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
> wrote:
> >> It's very easy to make the blocking thing be non-blocking: throw the
> >> whole thing into an In_thread.run.
> >>
> >> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >>> Many thanks David, at least in this case a blocking open will mean I
> >>> have bigger problems.
> >>>
> >>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com>
> wrote:
> >>>> You should not normally use the In_channel or Out_channel modules from
> >>>> async, preferring Reader and Writer. This is because, as blocking
> >>>> operations, they will kill all concurrency by blocking the main async
> >>>> thread.
> >>>>
> >>>> But in this case, I guess its use is warranted.
> >>>>
> >>>> Anyway, since {In,Out}_channel.create does not have a deferred result
> >>>> type (it's in core, so this is impossible!), they do not use binds.
> >>>> I.e. the following code should run without interruptions:
> >>>>
> >>>>   let out_chan = Out_channel.create "foo.txt" in
> >>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >>>>   Unix.set_close_on_exec fd;
> >>>>   let writer = Writer.create writer in
> >>>>   ...
> >>>>
> >>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >>>>> Does creating an out channel require a bind though?  If so, can I
> >>>>> atomically create an out channel with close on exec set?
> >>>>>
> >>>>> Thanks
> >>>>>
> >>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com>
> wrote:
> >>>>>> The context switch points in async are exactly the points where bind
> >>>>>> appears. Blocks of code without a bind (or >>|, of course) inside
> them
> >>>>>> are guaranteed to run uninterruptedly.
> >>>>>>
> >>>>>> Looking at the source of Writer.with_file, it looks like you do not
> >>>>>> have the guarantee that you want. It calls Unix.openfile, and then
> >>>>>> there is a bind, so something else could run (depending, of course,
> on
> >>>>>> the exact pattern of concurrency in your program).
> >>>>>>
> >>>>>> Writer.of_out_channel, however, will give you the guarantees you
> want.
> >>>>>> (It does not have a deferred return type so cannot be doing binds
> >>>>>> internally.)
> >>>>>>
> >>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>> Am I guaranteed that no code will run between Writer.with_file
> >>>>>>> creating the FD and my handler being run so I can set close on
> exec?
> >>>>>>>
> >>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>> Oh, there is an easier fix than that. One can either call
> >>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
> >>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
> >>>>>>>>
> >>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>> One option I have is to write to a temporary filename then spawn
> a
> >>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
> less
> >>>>>>>>> than ideal.  The specific problem is I am writing shell scripts
> that
> >>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so
> if I
> >>>>>>>>> spawn a shell script while writing a shell script, the written
> script
> >>>>>>>>> cannot be executed until the running one is completed.
> >>>>>>>>>
> >>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
> source
> >>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's
> right or
> >>>>>>>>>> wrong.
> >>>>>>>>>>
> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
> claims that
> >>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
> >>>>>>>>>>> close-on-exec will be set for those file descriptors. The same
> is true
> >>>>>>>>>>> of Core.{In,Out}_channel.create.
> >>>>>>>>>>>
> >>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and
> Writer
> >>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
> possible
> >>>>>>>>>>> this is deliberate; let me follow up internally,
> >>>>>>>>>>>
> >>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
> >>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
> >>>>>>>>>>>>
> >>>>>>>>>>>> I have a situation where I'm reading/writing many files and
> spawning
> >>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the
> opened
> >>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
> >>>>>>>>>>>> create_process for this as the Core version was causing
> segfaults for
> >>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
> switch batch
> >>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
> around the
> >>>>>>>>>>>> source code but didn't see anything in the comments about
> what happens
> >>>>>>>>>>>> to open fd's after forking.
> >>>>>>>>>>>>
> >>>>>>>>>>>> Thanks,
> >>>>>>>>>>>> /M
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121015/44f7bc14/attachment.html>

From mmatalka at gmail.com  Mon Oct 15 13:30:04 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 14:30:04 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
Message-ID: <CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>

Thanksgiving!  The problematic code for me is in a pretty limited place so
doing it by hand isn't a problem. Thanks again for the help!
On Oct 15, 2012 2:26 PM, "David House" <dhouse at janestreet.com> wrote:

> Sorry, I was thinking of something else. Of course when one uses
> In_thread, you give away interruptability guarantees. (This is the
> whole point.)
>
> You're also not allowed to use async code inside In_thread.run. (It
> runs without the async lock.)
>
> In principle, it is just a matter of aping the code for
> Writer.open_file, but adding in a call to set_close_on_exec. So this
> is definitely possible, it just depends how much code you're willing
> to duplicate.
>
> I think it should be possible to just do this all the time on Writer
> and Reader; I'll see if I can push that through.
>
> On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com>
> wrote:
> > How so?
> >
> > let make_writer file =
> >   In_thread.run (fun () ->
> >     let out_chan = Out_channel.create file in
> >     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >     Unix.set_close_on_exec fd;
> >     Writer.create writer)
> >
> > The closure will run still without being interrupted.
> >
> > On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >> That won't work for me because making an fd and setting it to close on
> >> exec would become non-atomic again.
> >>
> >> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
> wrote:
> >>> It's very easy to make the blocking thing be non-blocking: throw the
> >>> whole thing into an In_thread.run.
> >>>
> >>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >>>> Many thanks David, at least in this case a blocking open will mean I
> >>>> have bigger problems.
> >>>>
> >>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com>
> wrote:
> >>>>> You should not normally use the In_channel or Out_channel modules
> from
> >>>>> async, preferring Reader and Writer. This is because, as blocking
> >>>>> operations, they will kill all concurrency by blocking the main async
> >>>>> thread.
> >>>>>
> >>>>> But in this case, I guess its use is warranted.
> >>>>>
> >>>>> Anyway, since {In,Out}_channel.create does not have a deferred result
> >>>>> type (it's in core, so this is impossible!), they do not use binds.
> >>>>> I.e. the following code should run without interruptions:
> >>>>>
> >>>>>   let out_chan = Out_channel.create "foo.txt" in
> >>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >>>>>   Unix.set_close_on_exec fd;
> >>>>>   let writer = Writer.create writer in
> >>>>>   ...
> >>>>>
> >>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>> Does creating an out channel require a bind though?  If so, can I
> >>>>>> atomically create an out channel with close on exec set?
> >>>>>>
> >>>>>> Thanks
> >>>>>>
> >>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>> The context switch points in async are exactly the points where
> bind
> >>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside
> them
> >>>>>>> are guaranteed to run uninterruptedly.
> >>>>>>>
> >>>>>>> Looking at the source of Writer.with_file, it looks like you do not
> >>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
> >>>>>>> there is a bind, so something else could run (depending, of
> course, on
> >>>>>>> the exact pattern of concurrency in your program).
> >>>>>>>
> >>>>>>> Writer.of_out_channel, however, will give you the guarantees you
> want.
> >>>>>>> (It does not have a deferred return type so cannot be doing binds
> >>>>>>> internally.)
> >>>>>>>
> >>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>> Am I guaranteed that no code will run between Writer.with_file
> >>>>>>>> creating the FD and my handler being run so I can set close on
> exec?
> >>>>>>>>
> >>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>>> Oh, there is an easier fix than that. One can either call
> >>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
> >>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
> >>>>>>>>>
> >>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>> One option I have is to write to a temporary filename then
> spawn a
> >>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
> less
> >>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts
> that
> >>>>>>>>>> will be run, and I'm spawning shell scripts at the same time,
> so if I
> >>>>>>>>>> spawn a shell script while writing a shell script, the written
> script
> >>>>>>>>>> cannot be executed until the running one is completed.
> >>>>>>>>>>
> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
> source
> >>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's
> right or
> >>>>>>>>>>> wrong.
> >>>>>>>>>>>
> >>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
> claims that
> >>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
> >>>>>>>>>>>> close-on-exec will be set for those file descriptors. The
> same is true
> >>>>>>>>>>>> of Core.{In,Out}_channel.create.
> >>>>>>>>>>>>
> >>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader
> and Writer
> >>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
> possible
> >>>>>>>>>>>> this is deliberate; let me follow up internally,
> >>>>>>>>>>>>
> >>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
> >>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> I have a situation where I'm reading/writing many files and
> spawning
> >>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting
> the opened
> >>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
> >>>>>>>>>>>>> create_process for this as the Core version was causing
> segfaults for
> >>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
> switch batch
> >>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
> around the
> >>>>>>>>>>>>> source code but didn't see anything in the comments about
> what happens
> >>>>>>>>>>>>> to open fd's after forking.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> Thanks,
> >>>>>>>>>>>>> /M
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121015/677bc04e/attachment.html>

From sweeks at janestreet.com  Thu Oct 18 20:00:53 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Thu, 18 Oct 2012 15:00:53 -0400
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
	<CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
Message-ID: <CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>


I ended up adding an optional [?close_on_exec:bool] argument to:

  |                  | default |
  |------------------+---------|
  | Reader.open_file | true    |
  | Writer.open_file | true    |
  | Unix.openfile    | false   |

I could be convinced to make the default [true] for [Unix.openfile]
also.  As a drawback, it would be inconsistent with OCaml's and Core's
[Unix.openfile].  But perhaps that inconsistency isn't bad.  As Xavier
said on:

  http://caml.inria.fr/mantis/view.php?id=5256

perhaps he should have had [Unix.openfile] set close-on-exec in the
first place, and he is considering doing it now.

As to the implementation, [Async.Unix.openfile] now looks like:

  In_thread.syscall_exn ~name:"openfile" (fun () ->
    let file_descr = Unix.openfile ?perm file ~mode in
    if close_on_exec then Unix.set_close_on_exec file_descr;
    file_descr)

Once [Core.Unix] supports O_CLOEXEC, we'll pass it to [Unix.openfile]
and eliminate the race.

On Mon, Oct 15, 2012 at 8:30 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Thanksgiving!  The problematic code for me is in a pretty limited place so
> doing it by hand isn't a problem. Thanks again for the help!
>
> On Oct 15, 2012 2:26 PM, "David House" <dhouse at janestreet.com> wrote:
>>
>> Sorry, I was thinking of something else. Of course when one uses
>> In_thread, you give away interruptability guarantees. (This is the
>> whole point.)
>>
>> You're also not allowed to use async code inside In_thread.run. (It
>> runs without the async lock.)
>>
>> In principle, it is just a matter of aping the code for
>> Writer.open_file, but adding in a call to set_close_on_exec. So this
>> is definitely possible, it just depends how much code you're willing
>> to duplicate.
>>
>> I think it should be possible to just do this all the time on Writer
>> and Reader; I'll see if I can push that through.
>>
>> On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com>
>> wrote:
>> > How so?
>> >
>> > let make_writer file =
>> >   In_thread.run (fun () ->
>> >     let out_chan = Out_channel.create file in
>> >     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>> >     Unix.set_close_on_exec fd;
>> >     Writer.create writer)
>> >
>> > The closure will run still without being interrupted.
>> >
>> > On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
>> > wrote:
>> >> That won't work for me because making an fd and setting it to close on
>> >> exec would become non-atomic again.
>> >>
>> >> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
>> >> wrote:
>> >>> It's very easy to make the blocking thing be non-blocking: throw the
>> >>> whole thing into an In_thread.run.
>> >>>
>> >>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com>
>> >>> wrote:
>> >>>> Many thanks David, at least in this case a blocking open will mean I
>> >>>> have bigger problems.
>> >>>>
>> >>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com>
>> >>>> wrote:
>> >>>>> You should not normally use the In_channel or Out_channel modules
>> >>>>> from
>> >>>>> async, preferring Reader and Writer. This is because, as blocking
>> >>>>> operations, they will kill all concurrency by blocking the main
>> >>>>> async
>> >>>>> thread.
>> >>>>>
>> >>>>> But in this case, I guess its use is warranted.
>> >>>>>
>> >>>>> Anyway, since {In,Out}_channel.create does not have a deferred
>> >>>>> result
>> >>>>> type (it's in core, so this is impossible!), they do not use binds.
>> >>>>> I.e. the following code should run without interruptions:
>> >>>>>
>> >>>>>   let out_chan = Out_channel.create "foo.txt" in
>> >>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>> >>>>>   Unix.set_close_on_exec fd;
>> >>>>>   let writer = Writer.create writer in
>> >>>>>   ...
>> >>>>>
>> >>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka
>> >>>>> <mmatalka at gmail.com> wrote:
>> >>>>>> Does creating an out channel require a bind though?  If so, can I
>> >>>>>> atomically create an out channel with close on exec set?
>> >>>>>>
>> >>>>>> Thanks
>> >>>>>>
>> >>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House
>> >>>>>> <dhouse at janestreet.com> wrote:
>> >>>>>>> The context switch points in async are exactly the points where
>> >>>>>>> bind
>> >>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside
>> >>>>>>> them
>> >>>>>>> are guaranteed to run uninterruptedly.
>> >>>>>>>
>> >>>>>>> Looking at the source of Writer.with_file, it looks like you do
>> >>>>>>> not
>> >>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>> >>>>>>> there is a bind, so something else could run (depending, of
>> >>>>>>> course, on
>> >>>>>>> the exact pattern of concurrency in your program).
>> >>>>>>>
>> >>>>>>> Writer.of_out_channel, however, will give you the guarantees you
>> >>>>>>> want.
>> >>>>>>> (It does not have a deferred return type so cannot be doing binds
>> >>>>>>> internally.)
>> >>>>>>>
>> >>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka
>> >>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>> Am I guaranteed that no code will run between Writer.with_file
>> >>>>>>>> creating the FD and my handler being run so I can set close on
>> >>>>>>>> exec?
>> >>>>>>>>
>> >>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House
>> >>>>>>>> <dhouse at janestreet.com> wrote:
>> >>>>>>>>> Oh, there is an easier fix than that. One can either call
>> >>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>> >>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for
>> >>>>>>>>> Reader.)
>> >>>>>>>>>
>> >>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka
>> >>>>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>>>> One option I have is to write to a temporary filename then
>> >>>>>>>>>> spawn a
>> >>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
>> >>>>>>>>>> less
>> >>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts
>> >>>>>>>>>> that
>> >>>>>>>>>> will be run, and I'm spawning shell scripts at the same time,
>> >>>>>>>>>> so if I
>> >>>>>>>>>> spawn a shell script while writing a shell script, the written
>> >>>>>>>>>> script
>> >>>>>>>>>> cannot be executed until the running one is completed.
>> >>>>>>>>>>
>> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka
>> >>>>>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
>> >>>>>>>>>>> source
>> >>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's
>> >>>>>>>>>>> right or
>> >>>>>>>>>>> wrong.
>> >>>>>>>>>>>
>> >>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House
>> >>>>>>>>>>> <dhouse at janestreet.com> wrote:
>> >>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
>> >>>>>>>>>>>> claims that
>> >>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>> >>>>>>>>>>>> close-on-exec will be set for those file descriptors. The
>> >>>>>>>>>>>> same is true
>> >>>>>>>>>>>> of Core.{In,Out}_channel.create.
>> >>>>>>>>>>>>
>> >>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader
>> >>>>>>>>>>>> and Writer
>> >>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
>> >>>>>>>>>>>> possible
>> >>>>>>>>>>>> this is deliberate; let me follow up internally,
>> >>>>>>>>>>>>
>> >>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka
>> >>>>>>>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>> >>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>> >>>>>>>>>>>>>
>> >>>>>>>>>>>>> I have a situation where I'm reading/writing many files and
>> >>>>>>>>>>>>> spawning
>> >>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting
>> >>>>>>>>>>>>> the opened
>> >>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml
>> >>>>>>>>>>>>> stdlib
>> >>>>>>>>>>>>> create_process for this as the Core version was causing
>> >>>>>>>>>>>>> segfaults for
>> >>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
>> >>>>>>>>>>>>> switch batch
>> >>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
>> >>>>>>>>>>>>> around the
>> >>>>>>>>>>>>> source code but didn't see anything in the comments about
>> >>>>>>>>>>>>> what happens
>> >>>>>>>>>>>>> to open fd's after forking.
>> >>>>>>>>>>>>>
>> >>>>>>>>>>>>> Thanks,
>> >>>>>>>>>>>>> /M


From sweeks at janestreet.com  Thu Oct 18 20:21:30 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Thu, 18 Oct 2012 15:21:30 -0400
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXB-i5rduvxhD7=5CRuiXVyOf4stcwQ9uSTy_S=xK5FEw@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
	<CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
	<CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>
	<CAKziXDXB-i5rduvxhD7=5CRuiXVyOf4stcwQ9uSTy_S=xK5FEw@mail.gmail.com>
Message-ID: <CAPYVAiLcxzoBJrkrsVudQptxFRybARymGAof0MH1JY5y0g0mTw@mail.gmail.com>


> Do you have a timeline for removing the race?

As of OCaml 4.00, the stdlib Unix module doesn't support O_CLOEXEC.
So, we'd have to do a little extra work in Core to add it to
Core.Unix.  I added a note to our codebase to add it, but I haven't
seen anything that makes doing so a high priority.  So, your best bet
if you want it anytime in the next six months is to add it yourself
and send us a patch.


From mmatalka at gmail.com  Thu Oct 18 20:07:15 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Thu, 18 Oct 2012 21:07:15 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
	<CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
	<CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>
Message-ID: <CAKziXDXB-i5rduvxhD7=5CRuiXVyOf4stcwQ9uSTy_S=xK5FEw@mail.gmail.com>

Great!  Thanks for adding to Core/Async.  Do you have a timeline for
removing the race?

Thanks again for the quick responses fixes everyone.

/M
 On Oct 18, 2012 9:00 PM, "Stephen Weeks" <sweeks at janestreet.com> wrote:

> I ended up adding an optional [?close_on_exec:bool] argument to:
>
>   |                  | default |
>   |------------------+---------|
>   | Reader.open_file | true    |
>   | Writer.open_file | true    |
>   | Unix.openfile    | false   |
>
> I could be convinced to make the default [true] for [Unix.openfile]
> also.  As a drawback, it would be inconsistent with OCaml's and Core's
> [Unix.openfile].  But perhaps that inconsistency isn't bad.  As Xavier
> said on:
>
>   http://caml.inria.fr/mantis/view.php?id=5256
>
> perhaps he should have had [Unix.openfile] set close-on-exec in the
> first place, and he is considering doing it now.
>
> As to the implementation, [Async.Unix.openfile] now looks like:
>
>   In_thread.syscall_exn ~name:"openfile" (fun () ->
>     let file_descr = Unix.openfile ?perm file ~mode in
>     if close_on_exec then Unix.set_close_on_exec file_descr;
>     file_descr)
>
> Once [Core.Unix] supports O_CLOEXEC, we'll pass it to [Unix.openfile]
> and eliminate the race.
>
> On Mon, Oct 15, 2012 at 8:30 AM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> > Thanksgiving!  The problematic code for me is in a pretty limited place
> so
> > doing it by hand isn't a problem. Thanks again for the help!
> >
> > On Oct 15, 2012 2:26 PM, "David House" <dhouse at janestreet.com> wrote:
> >>
> >> Sorry, I was thinking of something else. Of course when one uses
> >> In_thread, you give away interruptability guarantees. (This is the
> >> whole point.)
> >>
> >> You're also not allowed to use async code inside In_thread.run. (It
> >> runs without the async lock.)
> >>
> >> In principle, it is just a matter of aping the code for
> >> Writer.open_file, but adding in a call to set_close_on_exec. So this
> >> is definitely possible, it just depends how much code you're willing
> >> to duplicate.
> >>
> >> I think it should be possible to just do this all the time on Writer
> >> and Reader; I'll see if I can push that through.
> >>
> >> On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com>
> >> wrote:
> >> > How so?
> >> >
> >> > let make_writer file =
> >> >   In_thread.run (fun () ->
> >> >     let out_chan = Out_channel.create file in
> >> >     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >> >     Unix.set_close_on_exec fd;
> >> >     Writer.create writer)
> >> >
> >> > The closure will run still without being interrupted.
> >> >
> >> > On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
> >> > wrote:
> >> >> That won't work for me because making an fd and setting it to close
> on
> >> >> exec would become non-atomic again.
> >> >>
> >> >> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
> >> >> wrote:
> >> >>> It's very easy to make the blocking thing be non-blocking: throw the
> >> >>> whole thing into an In_thread.run.
> >> >>>
> >> >>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <
> mmatalka at gmail.com>
> >> >>> wrote:
> >> >>>> Many thanks David, at least in this case a blocking open will mean
> I
> >> >>>> have bigger problems.
> >> >>>>
> >> >>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <
> dhouse at janestreet.com>
> >> >>>> wrote:
> >> >>>>> You should not normally use the In_channel or Out_channel modules
> >> >>>>> from
> >> >>>>> async, preferring Reader and Writer. This is because, as blocking
> >> >>>>> operations, they will kill all concurrency by blocking the main
> >> >>>>> async
> >> >>>>> thread.
> >> >>>>>
> >> >>>>> But in this case, I guess its use is warranted.
> >> >>>>>
> >> >>>>> Anyway, since {In,Out}_channel.create does not have a deferred
> >> >>>>> result
> >> >>>>> type (it's in core, so this is impossible!), they do not use
> binds.
> >> >>>>> I.e. the following code should run without interruptions:
> >> >>>>>
> >> >>>>>   let out_chan = Out_channel.create "foo.txt" in
> >> >>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >> >>>>>   Unix.set_close_on_exec fd;
> >> >>>>>   let writer = Writer.create writer in
> >> >>>>>   ...
> >> >>>>>
> >> >>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka
> >> >>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>> Does creating an out channel require a bind though?  If so, can I
> >> >>>>>> atomically create an out channel with close on exec set?
> >> >>>>>>
> >> >>>>>> Thanks
> >> >>>>>>
> >> >>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House
> >> >>>>>> <dhouse at janestreet.com> wrote:
> >> >>>>>>> The context switch points in async are exactly the points where
> >> >>>>>>> bind
> >> >>>>>>> appears. Blocks of code without a bind (or >>|, of course)
> inside
> >> >>>>>>> them
> >> >>>>>>> are guaranteed to run uninterruptedly.
> >> >>>>>>>
> >> >>>>>>> Looking at the source of Writer.with_file, it looks like you do
> >> >>>>>>> not
> >> >>>>>>> have the guarantee that you want. It calls Unix.openfile, and
> then
> >> >>>>>>> there is a bind, so something else could run (depending, of
> >> >>>>>>> course, on
> >> >>>>>>> the exact pattern of concurrency in your program).
> >> >>>>>>>
> >> >>>>>>> Writer.of_out_channel, however, will give you the guarantees you
> >> >>>>>>> want.
> >> >>>>>>> (It does not have a deferred return type so cannot be doing
> binds
> >> >>>>>>> internally.)
> >> >>>>>>>
> >> >>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka
> >> >>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>> Am I guaranteed that no code will run between Writer.with_file
> >> >>>>>>>> creating the FD and my handler being run so I can set close on
> >> >>>>>>>> exec?
> >> >>>>>>>>
> >> >>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House
> >> >>>>>>>> <dhouse at janestreet.com> wrote:
> >> >>>>>>>>> Oh, there is an easier fix than that. One can either call
> >> >>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
> >> >>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for
> >> >>>>>>>>> Reader.)
> >> >>>>>>>>>
> >> >>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka
> >> >>>>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>>>> One option I have is to write to a temporary filename then
> >> >>>>>>>>>> spawn a
> >> >>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
> >> >>>>>>>>>> less
> >> >>>>>>>>>> than ideal.  The specific problem is I am writing shell
> scripts
> >> >>>>>>>>>> that
> >> >>>>>>>>>> will be run, and I'm spawning shell scripts at the same time,
> >> >>>>>>>>>> so if I
> >> >>>>>>>>>> spawn a shell script while writing a shell script, the
> written
> >> >>>>>>>>>> script
> >> >>>>>>>>>> cannot be executed until the running one is completed.
> >> >>>>>>>>>>
> >> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka
> >> >>>>>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
> >> >>>>>>>>>>> source
> >> >>>>>>>>>>> code but my Unix knowledge isn't strong enough to know
> what's
> >> >>>>>>>>>>> right or
> >> >>>>>>>>>>> wrong.
> >> >>>>>>>>>>>
> >> >>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House
> >> >>>>>>>>>>> <dhouse at janestreet.com> wrote:
> >> >>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
> >> >>>>>>>>>>>> claims that
> >> >>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
> >> >>>>>>>>>>>> close-on-exec will be set for those file descriptors. The
> >> >>>>>>>>>>>> same is true
> >> >>>>>>>>>>>> of Core.{In,Out}_channel.create.
> >> >>>>>>>>>>>>
> >> >>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader
> >> >>>>>>>>>>>> and Writer
> >> >>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
> >> >>>>>>>>>>>> possible
> >> >>>>>>>>>>>> this is deliberate; let me follow up internally,
> >> >>>>>>>>>>>>
> >> >>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka
> >> >>>>>>>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
> >> >>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
> >> >>>>>>>>>>>>>
> >> >>>>>>>>>>>>> I have a situation where I'm reading/writing many files
> and
> >> >>>>>>>>>>>>> spawning
> >> >>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting
> >> >>>>>>>>>>>>> the opened
> >> >>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml
> >> >>>>>>>>>>>>> stdlib
> >> >>>>>>>>>>>>> create_process for this as the Core version was causing
> >> >>>>>>>>>>>>> segfaults for
> >> >>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
> >> >>>>>>>>>>>>> switch batch
> >> >>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
> >> >>>>>>>>>>>>> around the
> >> >>>>>>>>>>>>> source code but didn't see anything in the comments about
> >> >>>>>>>>>>>>> what happens
> >> >>>>>>>>>>>>> to open fd's after forking.
> >> >>>>>>>>>>>>>
> >> >>>>>>>>>>>>> Thanks,
> >> >>>>>>>>>>>>> /M
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121018/2c852781/attachment.html>

From yminsky at janestreet.com  Sat Oct 27 14:51:54 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sat, 27 Oct 2012 09:51:54 -0400
Subject: short-types patch
Message-ID: <CACLX4jTR=bR8R-ZKMqPLkeCm6fuBpT6vLzH2BO4xBtAAYo85ZQ@mail.gmail.com>


If you use Core or Async, you may have been frustrated by the way that
OCaml reports types, both in the toplevel and, more importantly, in
error messages.  Here's a mildly contrived example.

    let f l x =
      List.Assoc.add l (Int.of_string x) (String.to_list x)
      |! List.Assoc.map ~f:(fun x ->
           List.filter_map x ~f:(fun c ->
             if Char.is_alpha c then Some (String.of_char c)
             else None))

If you run this through the toplevel, you'll get the following
monstrous type.

val f :
  (Core.Std.Int.t, Core.Std.Char.t Core.Std.List.t) Core.Std.List.Assoc.t ->
  Core.Std.String.t ->
  (Core.Std.Int.t, Core.Std.String.t Core.Std.List.t) Core.Std.List.Assoc.t =
  <fun>
As you can see, the inferred types are a little ugly.

Happily, Jacques Garrigue wrote a patch to improve this, which you can
now try out in OPAM by typing:

    opam switch 4.00.1+short-types

Now, if you try the same thing, you get something far easier to read:

val f :
  (int, char list) List.Assoc.t -> string -> (int, string list) List.Assoc.t =
  <fun>

The basic heuristic is that OCaml looks at all of the different names
for a given type that it learns about during the inference process,
and among those, it displays the one with the fewest number of dots,
and among those with the minimal number of dots, it picks the most
recent definition.

Please try it out, and report any problems you run into!

y


From anil at recoil.org  Mon Oct  1 18:23:46 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 10:23:46 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
Message-ID: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>


Hi Yury,

I got a little lost in the new type_conv control flow (objects, why is it always objects!), but it looks like the bug is at:

  class vars_of = object
    inherit fold as super
    val vars = []
    method vars = vars
    method ident = function
    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
    | ident -> super#ident ident
  end
  let lids_of_patt patt =
    ((new vars_of)#patt patt)#vars

This extracts out all the identifiers in a pattern binding. In the case of dyntype, we generate output like:

let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
  <snip> in
   fun ?id_seed t =
     <snip>

I've simplified the Dyntype generation to be simply:

let value_of_t, value_of_foo =
   (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)

and it works fine now. The changeset is:
https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
and is present in dyntype-0.9.0.

Where would you like Core bugs such as this type_conv one to be reported?  The bitbucket issue tracker?

-anil

On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> Hi Anil,
> 
> I'll take a look at the dyntype extension to see how type_conv is broken, but the point of these assignments is to avoid ocaml 4's unused value warnings by from generated code. Apparently, type_conv thinks that values called "t", "ref", "t_of_value", and "value_of_t" have been generated by this extension.
> 
> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I've been porting some of our syntax extensions to the new type_conv (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of some extra bits that are generated:
> 
> For a simple:
> 
> # type t = int with value;;
> 
> This diff happens between the output of 108.00.02 and 108.07.00:
> 
> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> @@ -22,6 +22,12 @@
>            then Dyntype.Value.Rec ((("t", __id__), __x__))
>            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)), __x__))
> 
> +let _ = t
> +and _ = t
> +and _ = t
> +and _ = ref
> +and _ = value_of_t
> +
>  let (t_of_value : Dyntype.Value.t -> t) =
>    let module Deps =
>      struct
> @@ -73,4 +79,8 @@
>               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>      in t_of_value_aux { Deps.t = []; }
> 
> +let _ = t
> +and _ = t
> +and _ = t_of_value
> +
> 
> These are unbound, and so compilation breaks... what are they for?
> 
> -anil
> 



From anil at recoil.org  Mon Oct  1 18:49:25 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 10:49:25 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
Message-ID: <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>


Great!  The workaround was pretty straightforward, so I'll leave the simpler code generation in place.

Let me know when the bugfix is out, and we'll update OPAM.  Can your release system issue only a bumped version number for Core and Type_conv, instead of a complete set of new packages with new versions? This is a good test of the constraint system, as our constraints are probably way too specific (="108.07.00"). 

-a

On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> Hi Anil,
> 
> This was definitely a bug in type-conv. Valentin has a fix for this:
> 
> diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/pa_type_conv.ml
> --- a/base/type_conv/lib/pa_type_conv.ml
> +++ b/base/type_conv/lib/pa_type_conv.ml
> @@ -371,10 +371,11 @@
>        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc< '$var$ >>
>        | tp -> tp))#ctyp
>  
> -  class vars_of = object
> +  class vars_of = object (self)
>      inherit fold as super
>      val vars = []
>      method vars = vars
> +    method! ctyp _ = self
>      method ident = function
>      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>      | ident -> super#ident ident
> 
> I'd like to get a quick bugfix out the door that includes this and more portable use of mktemp in base/core/lib/discover.sh.
> 
> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> Hi Yury,
> 
> I got a little lost in the new type_conv control flow (objects, why is it always objects!), but it looks like the bug is at:
> 
>   class vars_of = object
>     inherit fold as super
>     val vars = []
>     method vars = vars
>     method ident = function
>     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>     | ident -> super#ident ident
>   end
>   let lids_of_patt patt =
>     ((new vars_of)#patt patt)#vars
> 
> This extracts out all the identifiers in a pattern binding. In the case of dyntype, we generate output like:
> 
> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>   <snip> in
>    fun ?id_seed t =
>      <snip>
> 
> I've simplified the Dyntype generation to be simply:
> 
> let value_of_t, value_of_foo =
>    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> 
> and it works fine now. The changeset is:
> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> and is present in dyntype-0.9.0.
> 
> Where would you like Core bugs such as this type_conv one to be reported?  The bitbucket issue tracker?
> 
> -anil
> 
> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> 
> > Hi Anil,
> >
> > I'll take a look at the dyntype extension to see how type_conv is broken, but the point of these assignments is to avoid ocaml 4's unused value warnings by from generated code. Apparently, type_conv thinks that values called "t", "ref", "t_of_value", and "value_of_t" have been generated by this extension.
> >
> > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > I've been porting some of our syntax extensions to the new type_conv (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of some extra bits that are generated:
> >
> > For a simple:
> >
> > # type t = int with value;;
> >
> > This diff happens between the output of 108.00.02 and 108.07.00:
> >
> > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > @@ -22,6 +22,12 @@
> >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)), __x__))
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t
> > +and _ = ref
> > +and _ = value_of_t
> > +
> >  let (t_of_value : Dyntype.Value.t -> t) =
> >    let module Deps =
> >      struct
> > @@ -73,4 +79,8 @@
> >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> >      in t_of_value_aux { Deps.t = []; }
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t_of_value
> > +
> >
> > These are unbound, and so compilation breaks... what are they for?
> >
> > -anil
> >
> 
> 



From anil at recoil.org  Mon Oct  1 19:36:02 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 11:36:02 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
Message-ID: <88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org>


On 1 Oct 2012, at 11:28, Markus Mottl <markus.mottl at gmail.com> wrote:

> Hi Yuri,
> 
> On Mon, Oct 1, 2012 at 1:37 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> This was definitely a bug in type-conv. Valentin has a fix for this:
> 
> It seems your latest version of type_conv has diverged already quite a
> lot from what's in the Core development tree or even patch queue.  I'm
> not sure what your release plans are for the future, but I find it
> rather hard to merge or even keep track of changes that happen in
> tarball releases but not in the development tree.  What are your
> future plans for the development process and release cycles?  I'd hope
> we'll see more activity in the development tree or at least patch
> queue.

I had a quick chat with Yaron about this at OUD.  It seems that the best
way to export changes from the JSC dev trees is via tarballs (that lose
history).  However, if we do not need patches to go *bidirectionally*, then
the Mercurial export infrastructure could be significantly simplified.

I propose something along these lines:

- JSC releases tarballs that are similar to the current ones, but with
  preX releases so we can see some changes before they're committed to
  the final release.

- These tarballs are committed by script against a Github repository of
  Core. This will lose renames if changes are made, but this can't be
  helped for now.

- Any patches or pull requests against the Github version are transformed
  into e-mail patches and sent to JSC for incorporation into a future
  version.  A Git merge will naturally resolve these.

It's not an ideal workflow as the external consumers lose all the version
history, but it would be a lot better than the current tarball/dev sync
issues.

An alternative, if JSC can keep the Bitbucket repo up-to-date more
frequently, is for us to setup a unidirectional Bitbucket->Github mirror.
In practical terms, there seems little advantage though, as the Bitbucket
repo also loses version history of changesets at present (I think).

Whatever happens, a Github repo would extremely useful to fit into other
project workflows such as http://github.com/xen-org/xen-api (where there
are autobuildbots that could work against forks and pre-release for
continuous build coverage tests).

-anil


From anil at recoil.org  Mon Oct  1 20:23:06 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 1 Oct 2012 12:23:06 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAP_800rBTJW9wcbRYad87iFojk=KmSE+GCOSaZp8hWh_25rOsQ@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com> <88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org> <CAP_800rBTJW9wcbRYad87iFojk=KmSE+GCOSaZp8hWh_25rOsQ@mail.gmail.com>
Message-ID: <475013F1-3C0A-4BDC-A617-9AFF0E7E56D1@recoil.org>



On 1 Oct 2012, at 12:20, Markus Mottl <markus.mottl at gmail.com> wrote:

> On Mon, Oct 1, 2012 at 2:36 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> I had a quick chat with Yaron about this at OUD.  It seems that the best
>> way to export changes from the JSC dev trees is via tarballs (that lose
>> history).  However, if we do not need patches to go *bidirectionally*, then
>> the Mercurial export infrastructure could be significantly simplified.
> 
> I was under the (wrong?) impression that the bidirectional issues had
> been successfully resolved with the patch queue repository.  I can
> imagine that releasing the internal dev tree (Core part) via tarballs
> is less work for Jane Street than pushing changes to the external dev
> tree.  OTOH, it would be great if we could at least see changes in the
> patch queue, even if it's just one huge blob rather than more
> fine-grained patches.
> 
> For example, I don't even know which ones of my patches (if any) have
> made it into the internal tree.  If JS placed a patch into the queue
> such that it takes already existing, internally applied patches into
> account, external developers' lives would be much easier.  If you want
> to do things quickly without too much fine-grained control, you'd just
> have to apply the internally applied patches to the last release and
> create a new patch in the queue from the diff to the latest dev
> release.

I agree; if the patchqueue approach works, then it would be simpler than
tarball exports. The Github mirror could also be auto-synched as a read
only (perhaps rebased) tree from this.

-anil



From yury.sulsky at gmail.com  Mon Oct  1 18:37:24 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Mon, 1 Oct 2012 13:37:24 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
Message-ID: <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>

Hi Anil,

This was definitely a bug in type-conv. Valentin has a fix for this:

diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/
pa_type_conv.ml
--- a/base/type_conv/lib/pa_type_conv.ml
+++ b/base/type_conv/lib/pa_type_conv.ml
@@ -371,10 +371,11 @@
       | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
'$var$ >>
       | tp -> tp))#ctyp

-  class vars_of = object
+  class vars_of = object (self)
     inherit fold as super
     val vars = []
     method vars = vars
+    method! ctyp _ = self
     method ident = function
     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
     | ident -> super#ident ident

I'd like to get a quick bugfix out the door that includes this and more
portable use of mktemp in base/core/lib/discover.sh.

On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> Hi Yury,
>
> I got a little lost in the new type_conv control flow (objects, why is it
> always objects!), but it looks like the bug is at:
>
>   class vars_of = object
>     inherit fold as super
>     val vars = []
>     method vars = vars
>     method ident = function
>     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>     | ident -> super#ident ident
>   end
>   let lids_of_patt patt =
>     ((new vars_of)#patt patt)#vars
>
> This extracts out all the identifiers in a pattern binding. In the case of
> dyntype, we generate output like:
>
> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>   <snip> in
>    fun ?id_seed t =
>      <snip>
>
> I've simplified the Dyntype generation to be simply:
>
> let value_of_t, value_of_foo =
>    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>
> and it works fine now. The changeset is:
>
> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> and is present in dyntype-0.9.0.
>
> Where would you like Core bugs such as this type_conv one to be reported?
>  The bitbucket issue tracker?
>
> -anil
>
> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
> > Hi Anil,
> >
> > I'll take a look at the dyntype extension to see how type_conv is
> broken, but the point of these assignments is to avoid ocaml 4's unused
> value warnings by from generated code. Apparently, type_conv thinks that
> values called "t", "ref", "t_of_value", and "value_of_t" have been
> generated by this extension.
> >
> > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > I've been porting some of our syntax extensions to the new type_conv
> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
> some extra bits that are generated:
> >
> > For a simple:
> >
> > # type t = int with value;;
> >
> > This diff happens between the output of 108.00.02 and 108.07.00:
> >
> > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > @@ -22,6 +22,12 @@
> >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
> __x__))
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t
> > +and _ = ref
> > +and _ = value_of_t
> > +
> >  let (t_of_value : Dyntype.Value.t -> t) =
> >    let module Deps =
> >      struct
> > @@ -73,4 +79,8 @@
> >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> >      in t_of_value_aux { Deps.t = []; }
> >
> > +let _ = t
> > +and _ = t
> > +and _ = t_of_value
> > +
> >
> > These are unbound, and so compilation breaks... what are they for?
> >
> > -anil
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121001/7d42b48a/attachment-0001.html>

From markus.mottl at gmail.com  Mon Oct  1 19:28:08 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Mon, 1 Oct 2012 14:28:08 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
Message-ID: <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>


Hi Yuri,

On Mon, Oct 1, 2012 at 1:37 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> This was definitely a bug in type-conv. Valentin has a fix for this:

It seems your latest version of type_conv has diverged already quite a
lot from what's in the Core development tree or even patch queue.  I'm
not sure what your release plans are for the future, but I find it
rather hard to merge or even keep track of changes that happen in
tarball releases but not in the development tree.  What are your
future plans for the development process and release cycles?  I'd hope
we'll see more activity in the development tree or at least patch
queue.

Cheers,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From markus.mottl at gmail.com  Mon Oct  1 20:20:10 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Mon, 1 Oct 2012 15:20:10 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
	<88A9DC59-F8AA-4F41-8F4E-B616236A9386@recoil.org>
Message-ID: <CAP_800rBTJW9wcbRYad87iFojk=KmSE+GCOSaZp8hWh_25rOsQ@mail.gmail.com>


On Mon, Oct 1, 2012 at 2:36 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I had a quick chat with Yaron about this at OUD.  It seems that the best
> way to export changes from the JSC dev trees is via tarballs (that lose
> history).  However, if we do not need patches to go *bidirectionally*, then
> the Mercurial export infrastructure could be significantly simplified.

I was under the (wrong?) impression that the bidirectional issues had
been successfully resolved with the patch queue repository.  I can
imagine that releasing the internal dev tree (Core part) via tarballs
is less work for Jane Street than pushing changes to the external dev
tree.  OTOH, it would be great if we could at least see changes in the
patch queue, even if it's just one huge blob rather than more
fine-grained patches.

For example, I don't even know which ones of my patches (if any) have
made it into the internal tree.  If JS placed a patch into the queue
such that it takes already existing, internally applied patches into
account, external developers' lives would be much easier.  If you want
to do things quickly without too much fine-grained control, you'd just
have to apply the internally applied patches to the last release and
create a new patch in the queue from the diff to the latest dev
release.

> I propose something along these lines:
>
> - JSC releases tarballs that are similar to the current ones, but with
>   preX releases so we can see some changes before they're committed to
>   the final release.

This seems neatly addressed by the patch queue.  E.g. we might have
the policy that "Jane Street patches come first in the queue" so that
external developers have to fix their patches to stay compatible with
pre-releases rather than the other way round.

> - These tarballs are committed by script against a Github repository of
>   Core. This will lose renames if changes are made, but this can't be
>   helped for now.
>
> - Any patches or pull requests against the Github version are transformed
>   into e-mail patches and sent to JSC for incorporation into a future
>   version.  A Git merge will naturally resolve these.
>
> An alternative, if JSC can keep the Bitbucket repo up-to-date more
> frequently, is for us to setup a unidirectional Bitbucket->Github mirror.
> In practical terms, there seems little advantage though, as the Bitbucket
> repo also loses version history of changesets at present (I think).

This seems rather involved.  I think the fewer tools, scripts,
repositories, etc., we need to support the workflow, the better.

Has there ever been any attempt at JS to use the patch queue
repository to publish updates?  I don't see any problems with this
fairly simple approach, but your mileage may vary.

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From yury.sulsky at gmail.com  Mon Oct  1 21:57:02 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Mon, 1 Oct 2012 16:57:02 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
Message-ID: <CAEDxudxVT0OUHUpPRsDBcU9jABf5rYFR1zgD_VBfMc4ouGub-w@mail.gmail.com>

Hi Markus,

I think 108.08 will be the first version where the external tree is sync'd
to our internal one. We have tarballs for 108.07, but they include
portability fixes and changes for ocaml 4 compatibility that didn't make it
into our internal release. So rather than export that merge point, the
current plan is to wait until 108.08 and from then on maintain a patch
queue between releases.

On Mon, Oct 1, 2012 at 2:28 PM, Markus Mottl <markus.mottl at gmail.com> wrote:

> Hi Yuri,
>
> On Mon, Oct 1, 2012 at 1:37 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> > This was definitely a bug in type-conv. Valentin has a fix for this:
>
> It seems your latest version of type_conv has diverged already quite a
> lot from what's in the Core development tree or even patch queue.  I'm
> not sure what your release plans are for the future, but I find it
> rather hard to merge or even keep track of changes that happen in
> tarball releases but not in the development tree.  What are your
> future plans for the development process and release cycles?  I'd hope
> we'll see more activity in the development tree or at least patch
> queue.
>
> Cheers,
> Markus
>
> --
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121001/6dfa9ca2/attachment-0001.html>

From yury.sulsky at gmail.com  Mon Oct  1 21:58:15 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Mon, 1 Oct 2012 16:58:15 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
Message-ID: <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>

Great, The tarballs are up here:
https://ocaml.janestreet.com/ocaml-core/108.07.01

Thanks!
Yury

On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> Great!  The workaround was pretty straightforward, so I'll leave the
> simpler code generation in place.
>
> Let me know when the bugfix is out, and we'll update OPAM.  Can your
> release system issue only a bumped version number for Core and Type_conv,
> instead of a complete set of new packages with new versions? This is a good
> test of the constraint system, as our constraints are probably way too
> specific (="108.07.00").
>
> -a
>
> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
> > Hi Anil,
> >
> > This was definitely a bug in type-conv. Valentin has a fix for this:
> >
> > diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/
> pa_type_conv.ml
> > --- a/base/type_conv/lib/pa_type_conv.ml
> > +++ b/base/type_conv/lib/pa_type_conv.ml
> > @@ -371,10 +371,11 @@
> >        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
> '$var$ >>
> >        | tp -> tp))#ctyp
> >
> > -  class vars_of = object
> > +  class vars_of = object (self)
> >      inherit fold as super
> >      val vars = []
> >      method vars = vars
> > +    method! ctyp _ = self
> >      method ident = function
> >      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >      | ident -> super#ident ident
> >
> > I'd like to get a quick bugfix out the door that includes this and more
> portable use of mktemp in base/core/lib/discover.sh.
> >
> > On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > Hi Yury,
> >
> > I got a little lost in the new type_conv control flow (objects, why is
> it always objects!), but it looks like the bug is at:
> >
> >   class vars_of = object
> >     inherit fold as super
> >     val vars = []
> >     method vars = vars
> >     method ident = function
> >     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >     | ident -> super#ident ident
> >   end
> >   let lids_of_patt patt =
> >     ((new vars_of)#patt patt)#vars
> >
> > This extracts out all the identifiers in a pattern binding. In the case
> of dyntype, we generate output like:
> >
> > let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
> >   <snip> in
> >    fun ?id_seed t =
> >      <snip>
> >
> > I've simplified the Dyntype generation to be simply:
> >
> > let value_of_t, value_of_foo =
> >    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> >
> > and it works fine now. The changeset is:
> >
> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> > and is present in dyntype-0.9.0.
> >
> > Where would you like Core bugs such as this type_conv one to be
> reported?  The bitbucket issue tracker?
> >
> > -anil
> >
> > On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >
> > > Hi Anil,
> > >
> > > I'll take a look at the dyntype extension to see how type_conv is
> broken, but the point of these assignments is to avoid ocaml 4's unused
> value warnings by from generated code. Apparently, type_conv thinks that
> values called "t", "ref", "t_of_value", and "value_of_t" have been
> generated by this extension.
> > >
> > > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
> wrote:
> > > I've been porting some of our syntax extensions to the new type_conv
> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
> some extra bits that are generated:
> > >
> > > For a simple:
> > >
> > > # type t = int with value;;
> > >
> > > This diff happens between the output of 108.00.02 and 108.07.00:
> > >
> > > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > > @@ -22,6 +22,12 @@
> > >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> > >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
> __x__))
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t
> > > +and _ = ref
> > > +and _ = value_of_t
> > > +
> > >  let (t_of_value : Dyntype.Value.t -> t) =
> > >    let module Deps =
> > >      struct
> > > @@ -73,4 +79,8 @@
> > >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> > >      in t_of_value_aux { Deps.t = []; }
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t_of_value
> > > +
> > >
> > > These are unbound, and so compilation breaks... what are they for?
> > >
> > > -anil
> > >
> >
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121001/d99ed71d/attachment-0001.html>

From markus.mottl at gmail.com  Tue Oct  2 14:28:03 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Tue, 2 Oct 2012 09:28:03 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudxVT0OUHUpPRsDBcU9jABf5rYFR1zgD_VBfMc4ouGub-w@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<CAP_800ogLeLwfNw2dA8++mWAheZNSyO0HzJ4OA7VPxHNwYw0Og@mail.gmail.com>
	<CAEDxudxVT0OUHUpPRsDBcU9jABf5rYFR1zgD_VBfMc4ouGub-w@mail.gmail.com>
Message-ID: <CAP_800oa2YeeNNDo9MzsGrrwEY8ow0=LrnFr6tLnZjbu=xDfiA@mail.gmail.com>


On Mon, Oct 1, 2012 at 4:57 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> I think 108.08 will be the first version where the external tree is sync'd
> to our internal one. We have tarballs for 108.07, but they include
> portability fixes and changes for ocaml 4 compatibility that didn't make it
> into our internal release. So rather than export that merge point, the
> current plan is to wait until 108.08 and from then on maintain a patch queue
> between releases.

Thanks, good to know that the development tree and patch queue are
still on the future release roadmap.

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From anil at recoil.org  Tue Oct  2 17:31:07 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 2 Oct 2012 09:31:07 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
Message-ID: <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>

This should be available on OPAM now too, if you do 'opam update'.

-anil

On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> Great, The tarballs are up here: https://ocaml.janestreet.com/ocaml-core/108.07.01
> 
> Thanks!
> Yury
> 
> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> Great!  The workaround was pretty straightforward, so I'll leave the simpler code generation in place.
> 
> Let me know when the bugfix is out, and we'll update OPAM.  Can your release system issue only a bumped version number for Core and Type_conv, instead of a complete set of new packages with new versions? This is a good test of the constraint system, as our constraints are probably way too specific (="108.07.00").
> 
> -a
> 
> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> 
> > Hi Anil,
> >
> > This was definitely a bug in type-conv. Valentin has a fix for this:
> >
> > diff --git a/base/type_conv/lib/pa_type_conv.ml b/base/type_conv/lib/pa_type_conv.ml
> > --- a/base/type_conv/lib/pa_type_conv.ml
> > +++ b/base/type_conv/lib/pa_type_conv.ml
> > @@ -371,10 +371,11 @@
> >        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc< '$var$ >>
> >        | tp -> tp))#ctyp
> >
> > -  class vars_of = object
> > +  class vars_of = object (self)
> >      inherit fold as super
> >      val vars = []
> >      method vars = vars
> > +    method! ctyp _ = self
> >      method ident = function
> >      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >      | ident -> super#ident ident
> >
> > I'd like to get a quick bugfix out the door that includes this and more portable use of mktemp in base/core/lib/discover.sh.
> >
> > On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > Hi Yury,
> >
> > I got a little lost in the new type_conv control flow (objects, why is it always objects!), but it looks like the bug is at:
> >
> >   class vars_of = object
> >     inherit fold as super
> >     val vars = []
> >     method vars = vars
> >     method ident = function
> >     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >     | ident -> super#ident ident
> >   end
> >   let lids_of_patt patt =
> >     ((new vars_of)#patt patt)#vars
> >
> > This extracts out all the identifiers in a pattern binding. In the case of dyntype, we generate output like:
> >
> > let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
> >   <snip> in
> >    fun ?id_seed t =
> >      <snip>
> >
> > I've simplified the Dyntype generation to be simply:
> >
> > let value_of_t, value_of_foo =
> >    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> >
> > and it works fine now. The changeset is:
> > https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> > and is present in dyntype-0.9.0.
> >
> > Where would you like Core bugs such as this type_conv one to be reported?  The bitbucket issue tracker?
> >
> > -anil
> >
> > On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >
> > > Hi Anil,
> > >
> > > I'll take a look at the dyntype extension to see how type_conv is broken, but the point of these assignments is to avoid ocaml 4's unused value warnings by from generated code. Apparently, type_conv thinks that values called "t", "ref", "t_of_value", and "value_of_t" have been generated by this extension.
> > >
> > > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > > I've been porting some of our syntax extensions to the new type_conv (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of some extra bits that are generated:
> > >
> > > For a simple:
> > >
> > > # type t = int with value;;
> > >
> > > This diff happens between the output of 108.00.02 and 108.07.00:
> > >
> > > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> > > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> > > @@ -22,6 +22,12 @@
> > >            then Dyntype.Value.Rec ((("t", __id__), __x__))
> > >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)), __x__))
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t
> > > +and _ = ref
> > > +and _ = value_of_t
> > > +
> > >  let (t_of_value : Dyntype.Value.t -> t) =
> > >    let module Deps =
> > >      struct
> > > @@ -73,4 +79,8 @@
> > >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> > >      in t_of_value_aux { Deps.t = []; }
> > >
> > > +let _ = t
> > > +and _ = t
> > > +and _ = t_of_value
> > > +
> > >
> > > These are unbound, and so compilation breaks... what are they for?
> > >
> > > -anil
> > >
> >
> >
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121002/084fa4a6/attachment-0001.html>

From anil at recoil.org  Thu Oct  4 05:08:44 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Wed, 3 Oct 2012 21:08:44 -0700
Subject: scripting with ocaml and core
In-Reply-To: <20120924082606.133392d8@locris.home>
References: <CAO4dZbc2vtihEW8ViBU1KPT3SvK-Rh=UP5C4FErY_Ye00meG8Q@mail.gmail.com> <CACLX4jSSV13bY_J0pswjS=HQ24C+ZawNwEf7hj3dxaVQewgCbw@mail.gmail.com> <CAO4dZbfToja39pT0s1B+9fW=xZGrSNBdw0OS+v7U1Huy7J5FOQ@mail.gmail.com> <CACLX4jRHmrxbjqsO7sMge_2ATQ+sxdi4fnZCrut3n9j_rfOKOQ@mail.gmail.com> <A6CD9DEE-D02A-472F-94C0-E1CB6EBBB999@recoil.org> <20120924082606.133392d8@locris.home>
Message-ID: <87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>


On 23 Sep 2012, at 23:26, J?r?mie Dimino <jeremie at dimino.org> wrote:

> Le Sun, 23 Sep 2012 21:57:57 -0400,
> Anil Madhavapeddy <anil at recoil.org> a ?crit :
> 
>> Jeremie, have you ever tried utop as native code?
> 
> No, but it should work with the attached patch and the latest version
> of findlib.

Do you mean findlib-1.3.3?  I took a shot at getting this to work, and
ended up patching ocaml to install the toplevel cmx files, and findlib
to install findlib_top.cmxa, and then hit various linking errors. Just
wondering if you're using a patched compiler and ocamlfind with a native
toplevel, or if I'm missing something else before I look further.

-anil

From jeremie at dimino.org  Thu Oct  4 07:34:10 2012
From: jeremie at dimino.org (=?UTF-8?B?SsOpcsOpbWll?= Dimino)
Date: Thu, 4 Oct 2012 08:34:10 +0200
Subject: scripting with ocaml and core
In-Reply-To: <87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>
References: <CAO4dZbc2vtihEW8ViBU1KPT3SvK-Rh=UP5C4FErY_Ye00meG8Q@mail.gmail.com>
	<CACLX4jSSV13bY_J0pswjS=HQ24C+ZawNwEf7hj3dxaVQewgCbw@mail.gmail.com>
	<CAO4dZbfToja39pT0s1B+9fW=xZGrSNBdw0OS+v7U1Huy7J5FOQ@mail.gmail.com>
	<CACLX4jRHmrxbjqsO7sMge_2ATQ+sxdi4fnZCrut3n9j_rfOKOQ@mail.gmail.com>
	<A6CD9DEE-D02A-472F-94C0-E1CB6EBBB999@recoil.org>
	<20120924082606.133392d8@locris.home>
	<87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>
Message-ID: <20121004083410.6aefdf79@locris.home>


Le Wed, 3 Oct 2012 21:08:44 -0700,
Anil Madhavapeddy <anil at recoil.org> a ?crit :

> Do you mean findlib-1.3.3?  I took a shot at getting this to work, and
> ended up patching ocaml to install the toplevel cmx files, and findlib
> to install findlib_top.cmxa, and then hit various linking errors. Just
> wondering if you're using a patched compiler and ocamlfind with a
> native toplevel, or if I'm missing something else before I look
> further.

Yeah, actually it is a bit more complicated than what i thought (i did
not try it). I made it work but i had to install ocaml*.cmxa, replace
Topfoo by Opttopfoo in findlib and utop, and modify a bit META files.

-- 
J?r?mie


From jeremie at dimino.org  Thu Oct  4 16:42:04 2012
From: jeremie at dimino.org (=?UTF-8?B?SsOpcsOpbWll?= Dimino)
Date: Thu, 4 Oct 2012 17:42:04 +0200
Subject: scripting with ocaml and core
In-Reply-To: <20121004083410.6aefdf79@locris.home>
References: <CAO4dZbc2vtihEW8ViBU1KPT3SvK-Rh=UP5C4FErY_Ye00meG8Q@mail.gmail.com>
	<CACLX4jSSV13bY_J0pswjS=HQ24C+ZawNwEf7hj3dxaVQewgCbw@mail.gmail.com>
	<CAO4dZbfToja39pT0s1B+9fW=xZGrSNBdw0OS+v7U1Huy7J5FOQ@mail.gmail.com>
	<CACLX4jRHmrxbjqsO7sMge_2ATQ+sxdi4fnZCrut3n9j_rfOKOQ@mail.gmail.com>
	<A6CD9DEE-D02A-472F-94C0-E1CB6EBBB999@recoil.org>
	<20120924082606.133392d8@locris.home>
	<87ADE11A-77C5-4E39-9FE2-CBEBEA5A69EE@recoil.org>
	<20121004083410.6aefdf79@locris.home>
Message-ID: <20121004174204.70ddc8f7@caladan.esterel-technologies.com>

Le Thu, 4 Oct 2012 08:34:10 +0200,
J?r?mie Dimino <jeremie at dimino.org> a ?crit :

> Yeah, actually it is a bit more complicated than what i thought (i did
> not try it). I made it work but i had to install ocaml*.cmxa, replace
> Topfoo by Opttopfoo in findlib and utop, and modify a bit META files.

I put in attachement the patches needed to build a native utop.

-- 
J?r?mie
-------------- next part --------------
A non-text attachment was scrubbed...
Name: findlib-1.3.3.diff
Type: text/x-patch
Size: 4426 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121004/7ebad83b/attachment-0003.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ocaml-trunk.diff
Type: text/x-patch
Size: 8076 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121004/7ebad83b/attachment-0004.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: utop-trunk.diff
Type: text/x-patch
Size: 24539 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121004/7ebad83b/attachment-0005.bin>

From anil at recoil.org  Fri Oct  5 01:45:40 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 4 Oct 2012 17:45:40 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <-2309447399847593243@unknownmsgid>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com> <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com> <-2309447399847593243@unknownmsgid>
Message-ID: <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>


That's correct; almost all non-Core packages are broken by the
type_conv interface change. I have some patches queued up for them,
but haven't had a chance to submit them upstream yet.  Some (such
as Dyntype) I've already fixed, but I haven't done OASIS yet.

For now, a decent workaround is to switch to a compiler alias to
install OASIS, and otherwise use the new type_conv in a separate
switch.

-anil

On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:

> It looks like ocaml-data-notation should be upgraded to work with a
> newer version of type_conv. If you're not using  oasis, can you just
> remove it?
> 
> Yury
> 
> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> 
>> I can't seem to get the new async to build, even in the latest opam.
>> By default it picks the older async, and when I pin to the latest
>> version, I get:
>> 
>> en $ opam upgrade async
>> No solution has been found:
>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>> async_core.108.07.01 <- async.108.07.01
>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>> 
>> Any thoughts on how to get this to work?
>> 
>> y
>> 
>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> This should be available on OPAM now too, if you do 'opam update'.
>>> 
>>> -anil
>>> 
>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>> 
>>> Great, The tarballs are up here:
>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>> 
>>> Thanks!
>>> Yury
>>> 
>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> 
>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>> simpler code generation in place.
>>>> 
>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>> release system issue only a bumped version number for Core and Type_conv,
>>>> instead of a complete set of new packages with new versions? This is a good
>>>> test of the constraint system, as our constraints are probably way too
>>>> specific (="108.07.00").
>>>> 
>>>> -a
>>>> 
>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>> 
>>>>> Hi Anil,
>>>>> 
>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>> 
>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>> @@ -371,10 +371,11 @@
>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>> '$var$ >>
>>>>>      | tp -> tp))#ctyp
>>>>> 
>>>>> -  class vars_of = object
>>>>> +  class vars_of = object (self)
>>>>>    inherit fold as super
>>>>>    val vars = []
>>>>>    method vars = vars
>>>>> +    method! ctyp _ = self
>>>>>    method ident = function
>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>    | ident -> super#ident ident
>>>>> 
>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>> 
>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>> wrote:
>>>>> Hi Yury,
>>>>> 
>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>> it always objects!), but it looks like the bug is at:
>>>>> 
>>>>> class vars_of = object
>>>>>   inherit fold as super
>>>>>   val vars = []
>>>>>   method vars = vars
>>>>>   method ident = function
>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>   | ident -> super#ident ident
>>>>> end
>>>>> let lids_of_patt patt =
>>>>>   ((new vars_of)#patt patt)#vars
>>>>> 
>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>> of dyntype, we generate output like:
>>>>> 
>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>> <snip> in
>>>>>  fun ?id_seed t =
>>>>>    <snip>
>>>>> 
>>>>> I've simplified the Dyntype generation to be simply:
>>>>> 
>>>>> let value_of_t, value_of_foo =
>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>> 
>>>>> and it works fine now. The changeset is:
>>>>> 
>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>> and is present in dyntype-0.9.0.
>>>>> 
>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>> reported?  The bitbucket issue tracker?
>>>>> 
>>>>> -anil
>>>>> 
>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>> 
>>>>>> Hi Anil,
>>>>>> 
>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>> by this extension.
>>>>>> 
>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>> wrote:
>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>> some extra bits that are generated:
>>>>>> 
>>>>>> For a simple:
>>>>>> 
>>>>>> # type t = int with value;;
>>>>>> 
>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>> 
>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>> @@ -22,6 +22,12 @@
>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>> __x__))
>>>>>> 
>>>>>> +let _ = t
>>>>>> +and _ = t
>>>>>> +and _ = t
>>>>>> +and _ = ref
>>>>>> +and _ = value_of_t
>>>>>> +
>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>  let module Deps =
>>>>>>    struct
>>>>>> @@ -73,4 +79,8 @@
>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>> 
>>>>>> +let _ = t
>>>>>> +and _ = t
>>>>>> +and _ = t_of_value
>>>>>> +
>>>>>> 
>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>> 
>>>>>> -anil
>>> 
>>> 
> 



From yminsky at janestreet.com  Fri Oct  5 01:34:35 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 4 Oct 2012 20:34:35 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
Message-ID: <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>


I can't seem to get the new async to build, even in the latest opam.
By default it picks the older async, and when I pin to the latest
version, I get:

en $ opam upgrade async
No solution has been found:
 - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
 + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
async_core.108.07.01 <- async.108.07.01
 + type_conv.108.00.02 <- ocaml-data-notation.0.0.9

Any thoughts on how to get this to work?

y

On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> This should be available on OPAM now too, if you do 'opam update'.
>
> -anil
>
> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
> Great, The tarballs are up here:
> https://ocaml.janestreet.com/ocaml-core/108.07.01
>
> Thanks!
> Yury
>
> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>
>> Great!  The workaround was pretty straightforward, so I'll leave the
>> simpler code generation in place.
>>
>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>> release system issue only a bumped version number for Core and Type_conv,
>> instead of a complete set of new packages with new versions? This is a good
>> test of the constraint system, as our constraints are probably way too
>> specific (="108.07.00").
>>
>> -a
>>
>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>
>> > Hi Anil,
>> >
>> > This was definitely a bug in type-conv. Valentin has a fix for this:
>> >
>> > diff --git a/base/type_conv/lib/pa_type_conv.ml
>> > b/base/type_conv/lib/pa_type_conv.ml
>> > --- a/base/type_conv/lib/pa_type_conv.ml
>> > +++ b/base/type_conv/lib/pa_type_conv.ml
>> > @@ -371,10 +371,11 @@
>> >        | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>> > '$var$ >>
>> >        | tp -> tp))#ctyp
>> >
>> > -  class vars_of = object
>> > +  class vars_of = object (self)
>> >      inherit fold as super
>> >      val vars = []
>> >      method vars = vars
>> > +    method! ctyp _ = self
>> >      method ident = function
>> >      | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >      | ident -> super#ident ident
>> >
>> > I'd like to get a quick bugfix out the door that includes this and more
>> > portable use of mktemp in base/core/lib/discover.sh.
>> >
>> > On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>> > wrote:
>> > Hi Yury,
>> >
>> > I got a little lost in the new type_conv control flow (objects, why is
>> > it always objects!), but it looks like the bug is at:
>> >
>> >   class vars_of = object
>> >     inherit fold as super
>> >     val vars = []
>> >     method vars = vars
>> >     method ident = function
>> >     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >     | ident -> super#ident ident
>> >   end
>> >   let lids_of_patt patt =
>> >     ((new vars_of)#patt patt)#vars
>> >
>> > This extracts out all the identifiers in a pattern binding. In the case
>> > of dyntype, we generate output like:
>> >
>> > let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>> >   <snip> in
>> >    fun ?id_seed t =
>> >      <snip>
>> >
>> > I've simplified the Dyntype generation to be simply:
>> >
>> > let value_of_t, value_of_foo =
>> >    (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>> >
>> > and it works fine now. The changeset is:
>> >
>> > https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>> > and is present in dyntype-0.9.0.
>> >
>> > Where would you like Core bugs such as this type_conv one to be
>> > reported?  The bitbucket issue tracker?
>> >
>> > -anil
>> >
>> > On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >
>> > > Hi Anil,
>> > >
>> > > I'll take a look at the dyntype extension to see how type_conv is
>> > > broken, but the point of these assignments is to avoid ocaml 4's unused
>> > > value warnings by from generated code. Apparently, type_conv thinks that
>> > > values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>> > > by this extension.
>> > >
>> > > On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>> > > wrote:
>> > > I've been porting some of our syntax extensions to the new type_conv
>> > > (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>> > > some extra bits that are generated:
>> > >
>> > > For a simple:
>> > >
>> > > # type t = int with value;;
>> > >
>> > > This diff happens between the output of 108.00.02 and 108.07.00:
>> > >
>> > > --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>> > > +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>> > > @@ -22,6 +22,12 @@
>> > >            then Dyntype.Value.Rec ((("t", __id__), __x__))
>> > >            else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>> > > __x__))
>> > >
>> > > +let _ = t
>> > > +and _ = t
>> > > +and _ = t
>> > > +and _ = ref
>> > > +and _ = value_of_t
>> > > +
>> > >  let (t_of_value : Dyntype.Value.t -> t) =
>> > >    let module Deps =
>> > >      struct
>> > > @@ -73,4 +79,8 @@
>> > >               raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>> > >      in t_of_value_aux { Deps.t = []; }
>> > >
>> > > +let _ = t
>> > > +and _ = t
>> > > +and _ = t_of_value
>> > > +
>> > >
>> > > These are unbound, and so compilation breaks... what are they for?
>> > >
>> > > -anil
>> > >
>> >
>> >
>>
>
>


From yury.sulsky at gmail.com  Fri Oct  5 01:40:32 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Thu, 4 Oct 2012 20:40:32 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
 <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
 <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
 <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
 <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
Message-ID: <-2309447399847593243@unknownmsgid>


It looks like ocaml-data-notation should be upgraded to work with a
newer version of type_conv. If you're not using  oasis, can you just
remove it?

Yury

On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:

> I can't seem to get the new async to build, even in the latest opam.
> By default it picks the older async, and when I pin to the latest
> version, I get:
>
> en $ opam upgrade async
> No solution has been found:
> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
> async_core.108.07.01 <- async.108.07.01
> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>
> Any thoughts on how to get this to work?
>
> y
>
> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> This should be available on OPAM now too, if you do 'opam update'.
>>
>> -anil
>>
>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>
>> Great, The tarballs are up here:
>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>
>> Thanks!
>> Yury
>>
>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>
>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>> simpler code generation in place.
>>>
>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>> release system issue only a bumped version number for Core and Type_conv,
>>> instead of a complete set of new packages with new versions? This is a good
>>> test of the constraint system, as our constraints are probably way too
>>> specific (="108.07.00").
>>>
>>> -a
>>>
>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>
>>>> Hi Anil,
>>>>
>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>
>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>> @@ -371,10 +371,11 @@
>>>>       | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>> '$var$ >>
>>>>       | tp -> tp))#ctyp
>>>>
>>>> -  class vars_of = object
>>>> +  class vars_of = object (self)
>>>>     inherit fold as super
>>>>     val vars = []
>>>>     method vars = vars
>>>> +    method! ctyp _ = self
>>>>     method ident = function
>>>>     | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>     | ident -> super#ident ident
>>>>
>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>
>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>> wrote:
>>>> Hi Yury,
>>>>
>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>> it always objects!), but it looks like the bug is at:
>>>>
>>>>  class vars_of = object
>>>>    inherit fold as super
>>>>    val vars = []
>>>>    method vars = vars
>>>>    method ident = function
>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>    | ident -> super#ident ident
>>>>  end
>>>>  let lids_of_patt patt =
>>>>    ((new vars_of)#patt patt)#vars
>>>>
>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>> of dyntype, we generate output like:
>>>>
>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>  <snip> in
>>>>   fun ?id_seed t =
>>>>     <snip>
>>>>
>>>> I've simplified the Dyntype generation to be simply:
>>>>
>>>> let value_of_t, value_of_foo =
>>>>   (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>
>>>> and it works fine now. The changeset is:
>>>>
>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>> and is present in dyntype-0.9.0.
>>>>
>>>> Where would you like Core bugs such as this type_conv one to be
>>>> reported?  The bitbucket issue tracker?
>>>>
>>>> -anil
>>>>
>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>
>>>>> Hi Anil,
>>>>>
>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>> by this extension.
>>>>>
>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>> wrote:
>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>> some extra bits that are generated:
>>>>>
>>>>> For a simple:
>>>>>
>>>>> # type t = int with value;;
>>>>>
>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>
>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>> @@ -22,6 +22,12 @@
>>>>>           then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>           else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>> __x__))
>>>>>
>>>>> +let _ = t
>>>>> +and _ = t
>>>>> +and _ = t
>>>>> +and _ = ref
>>>>> +and _ = value_of_t
>>>>> +
>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>   let module Deps =
>>>>>     struct
>>>>> @@ -73,4 +79,8 @@
>>>>>              raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>     in t_of_value_aux { Deps.t = []; }
>>>>>
>>>>> +let _ = t
>>>>> +and _ = t
>>>>> +and _ = t_of_value
>>>>> +
>>>>>
>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>
>>>>> -anil
>>
>>


From anil at recoil.org  Fri Oct  5 05:55:34 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Thu, 4 Oct 2012 21:55:34 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CACLX4jSv+32CgumdNkFfd59t07fUD=uij4KC+O_+5O_ZXM7SWg@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com> <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com> <-2309447399847593243@unknownmsgid> <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org> <CACLX4jSv+32CgumdNkFfd59t07fUD=uij4KC+O_+5O_ZXM7SWg@mail.gmail.com>
Message-ID: <7EC3CEC7-1985-4205-8518-3D161D6F47C0@recoil.org>


Well, removing OASIS should remove the constraint that should cause Async
to upgrade again.  However, the actual constraint is on ODN and not OASIS,
so I wonder if this is a transitive dependency bug...

If you uninstall ocaml-data-notation, does Core upgrade to 107.00.01?

-anil

On 4 Oct 2012, at 20:11, Yaron Minsky <yminsky at janestreet.com> wrote:

> Is it surprising that uninstalling oasis causes a rebuild of Async and Core?
> 
> en $ opam remove oasis
> The following variables are set in your environment, you should better
> unset it if you want OPAM to work correctly.
> - CAML_LD_LIBRARY_PATH
> Do you want to continue ? [Y/n]
> The following actions will be performed:
> - remove oasis.0.3.0
> - recompile async_core.108.00.02
> - recompile async_unix.108.00.02
> - recompile cow.0.3.2
> - recompile core_extended.108.00.02
> - recompile core.108.00.02
> - recompile async_extra.108.00.02
> 0 to install | 6 to reinstall | 0 to upgrade | 0 to downgrade | 1 to remove
> Do you want to continue ? [Y/n]
> 
> On Thu, Oct 4, 2012 at 8:45 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> That's correct; almost all non-Core packages are broken by the
>> type_conv interface change. I have some patches queued up for them,
>> but haven't had a chance to submit them upstream yet.  Some (such
>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>> 
>> For now, a decent workaround is to switch to a compiler alias to
>> install OASIS, and otherwise use the new type_conv in a separate
>> switch.
>> 
>> -anil
>> 
>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> 
>>> It looks like ocaml-data-notation should be upgraded to work with a
>>> newer version of type_conv. If you're not using  oasis, can you just
>>> remove it?
>>> 
>>> Yury
>>> 
>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> 
>>>> I can't seem to get the new async to build, even in the latest opam.
>>>> By default it picks the older async, and when I pin to the latest
>>>> version, I get:
>>>> 
>>>> en $ opam upgrade async
>>>> No solution has been found:
>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>> async_core.108.07.01 <- async.108.07.01
>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>> 
>>>> Any thoughts on how to get this to work?
>>>> 
>>>> y
>>>> 
>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>> 
>>>>> -anil
>>>>> 
>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>> 
>>>>> Great, The tarballs are up here:
>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>> 
>>>>> Thanks!
>>>>> Yury
>>>>> 
>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>> 
>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>> simpler code generation in place.
>>>>>> 
>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>> specific (="108.07.00").
>>>>>> 
>>>>>> -a
>>>>>> 
>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>> 
>>>>>>> Hi Anil,
>>>>>>> 
>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>> 
>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>     | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>> '$var$ >>
>>>>>>>     | tp -> tp))#ctyp
>>>>>>> 
>>>>>>> -  class vars_of = object
>>>>>>> +  class vars_of = object (self)
>>>>>>>   inherit fold as super
>>>>>>>   val vars = []
>>>>>>>   method vars = vars
>>>>>>> +    method! ctyp _ = self
>>>>>>>   method ident = function
>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>   | ident -> super#ident ident
>>>>>>> 
>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>> 
>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> Hi Yury,
>>>>>>> 
>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>> 
>>>>>>> class vars_of = object
>>>>>>>  inherit fold as super
>>>>>>>  val vars = []
>>>>>>>  method vars = vars
>>>>>>>  method ident = function
>>>>>>>  | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>  | ident -> super#ident ident
>>>>>>> end
>>>>>>> let lids_of_patt patt =
>>>>>>>  ((new vars_of)#patt patt)#vars
>>>>>>> 
>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>> of dyntype, we generate output like:
>>>>>>> 
>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>> <snip> in
>>>>>>> fun ?id_seed t =
>>>>>>>   <snip>
>>>>>>> 
>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>> 
>>>>>>> let value_of_t, value_of_foo =
>>>>>>> (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>> 
>>>>>>> and it works fine now. The changeset is:
>>>>>>> 
>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>> and is present in dyntype-0.9.0.
>>>>>>> 
>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>> 
>>>>>>> -anil
>>>>>>> 
>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>> 
>>>>>>>> Hi Anil,
>>>>>>>> 
>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>> by this extension.
>>>>>>>> 
>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>> some extra bits that are generated:
>>>>>>>> 
>>>>>>>> For a simple:
>>>>>>>> 
>>>>>>>> # type t = int with value;;
>>>>>>>> 
>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>> 
>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>         then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>         else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>> __x__))
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = ref
>>>>>>>> +and _ = value_of_t
>>>>>>>> +
>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>> let module Deps =
>>>>>>>>   struct
>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>            raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>   in t_of_value_aux { Deps.t = []; }
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t_of_value
>>>>>>>> +
>>>>>>>> 
>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>> 
>>>>>>>> -anil
>>>>> 
>>>>> 
>>> 
>> 
> 



From yminsky at janestreet.com  Fri Oct  5 04:11:24 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Thu, 4 Oct 2012 23:11:24 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
Message-ID: <CACLX4jSv+32CgumdNkFfd59t07fUD=uij4KC+O_+5O_ZXM7SWg@mail.gmail.com>


Is it surprising that uninstalling oasis causes a rebuild of Async and Core?

en $ opam remove oasis
The following variables are set in your environment, you should better
unset it if you want OPAM to work correctly.
 - CAML_LD_LIBRARY_PATH
Do you want to continue ? [Y/n]
The following actions will be performed:
 - remove oasis.0.3.0
 - recompile async_core.108.00.02
 - recompile async_unix.108.00.02
 - recompile cow.0.3.2
 - recompile core_extended.108.00.02
 - recompile core.108.00.02
 - recompile async_extra.108.00.02
0 to install | 6 to reinstall | 0 to upgrade | 0 to downgrade | 1 to remove
Do you want to continue ? [Y/n]

On Thu, Oct 4, 2012 at 8:45 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> That's correct; almost all non-Core packages are broken by the
> type_conv interface change. I have some patches queued up for them,
> but haven't had a chance to submit them upstream yet.  Some (such
> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>
> For now, a decent workaround is to switch to a compiler alias to
> install OASIS, and otherwise use the new type_conv in a separate
> switch.
>
> -anil
>
> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
>> It looks like ocaml-data-notation should be upgraded to work with a
>> newer version of type_conv. If you're not using  oasis, can you just
>> remove it?
>>
>> Yury
>>
>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>
>>> I can't seem to get the new async to build, even in the latest opam.
>>> By default it picks the older async, and when I pin to the latest
>>> version, I get:
>>>
>>> en $ opam upgrade async
>>> No solution has been found:
>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>> async_core.108.07.01 <- async.108.07.01
>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>
>>> Any thoughts on how to get this to work?
>>>
>>> y
>>>
>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>
>>>> -anil
>>>>
>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>
>>>> Great, The tarballs are up here:
>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>
>>>> Thanks!
>>>> Yury
>>>>
>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>
>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>> simpler code generation in place.
>>>>>
>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>> test of the constraint system, as our constraints are probably way too
>>>>> specific (="108.07.00").
>>>>>
>>>>> -a
>>>>>
>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>
>>>>>> Hi Anil,
>>>>>>
>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>
>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>> @@ -371,10 +371,11 @@
>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>> '$var$ >>
>>>>>>      | tp -> tp))#ctyp
>>>>>>
>>>>>> -  class vars_of = object
>>>>>> +  class vars_of = object (self)
>>>>>>    inherit fold as super
>>>>>>    val vars = []
>>>>>>    method vars = vars
>>>>>> +    method! ctyp _ = self
>>>>>>    method ident = function
>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>    | ident -> super#ident ident
>>>>>>
>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>
>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>> wrote:
>>>>>> Hi Yury,
>>>>>>
>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>
>>>>>> class vars_of = object
>>>>>>   inherit fold as super
>>>>>>   val vars = []
>>>>>>   method vars = vars
>>>>>>   method ident = function
>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>   | ident -> super#ident ident
>>>>>> end
>>>>>> let lids_of_patt patt =
>>>>>>   ((new vars_of)#patt patt)#vars
>>>>>>
>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>> of dyntype, we generate output like:
>>>>>>
>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>> <snip> in
>>>>>>  fun ?id_seed t =
>>>>>>    <snip>
>>>>>>
>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>
>>>>>> let value_of_t, value_of_foo =
>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>
>>>>>> and it works fine now. The changeset is:
>>>>>>
>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>> and is present in dyntype-0.9.0.
>>>>>>
>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>> reported?  The bitbucket issue tracker?
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>>> Hi Anil,
>>>>>>>
>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>> by this extension.
>>>>>>>
>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>> some extra bits that are generated:
>>>>>>>
>>>>>>> For a simple:
>>>>>>>
>>>>>>> # type t = int with value;;
>>>>>>>
>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>
>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>> __x__))
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = ref
>>>>>>> +and _ = value_of_t
>>>>>>> +
>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>  let module Deps =
>>>>>>>    struct
>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t_of_value
>>>>>>> +
>>>>>>>
>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>
>>>>>>> -anil
>>>>
>>>>
>>
>


From yminsky at janestreet.com  Fri Oct  5 12:55:04 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 5 Oct 2012 07:55:04 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
	<CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
Message-ID: <CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>


By the way, no love on installing async 108.07.01 on opam.  Here's the
tail of the error:

. /Users/yminsky/.opam/4.00.0/bin/ocamldep.opt -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -modules
syntax/json/extension.ml > syntax/json/extension.ml.depends
. /Users/yminsky/.opam/4.00.0/bin/ocamlc.opt -c -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -I syntax/json -I syntax
-o syntax/json/json.cmo syntax/json/json.ml
. /Users/yminsky/.opam/4.00.0/bin/ocamlc.opt -c -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -I syntax/json -I syntax
-o syntax/json/extension.cmo syntax/json/extension.ml
. + /Users/yminsky/.opam/4.00.0/bin/ocamlc.opt -c -I +camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/type_conv -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/dyntype -I
/Users/yminsky/.opam/4.00.0/lib/re -I
/Users/yminsky/.opam/4.00.0/lib/ulex -pp 'camlp4orf -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4 -I
/Users/yminsky/.opam/4.00.0/lib/ocaml/camlp4' -I syntax/json -I syntax
-o syntax/json/extension.cmo syntax/json/extension.ml
. File "syntax/json/extension.ml", line 371, characters 36-39:
. Error: This expression has type bool but an expression was expected of type
.          Camlp4.PreCast.Syntax.Ast.ctyp = Camlp4.PreCast.Ast.ctyp
. Command exited with code 2.
* make: *** [all] Error 10
  'opam upgrade' failed

Has anyone gotten this to succeed?  Also, how did json get implemented
here?  There's no json support in async as far as I know...

y

On Fri, Oct 5, 2012 at 4:54 AM, Sylvain Le Gall <sylvain at le-gall.net> wrote:
> If you send the patch for ODN, you''ll have a new upstream tarball by
> then end of the day.
>
> 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>> That's correct; almost all non-Core packages are broken by the
>> type_conv interface change. I have some patches queued up for them,
>> but haven't had a chance to submit them upstream yet.  Some (such
>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>>
>> For now, a decent workaround is to switch to a compiler alias to
>> install OASIS, and otherwise use the new type_conv in a separate
>> switch.
>>
>> -anil
>>
>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>
>>> It looks like ocaml-data-notation should be upgraded to work with a
>>> newer version of type_conv. If you're not using  oasis, can you just
>>> remove it?
>>>
>>> Yury
>>>
>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>
>>>> I can't seem to get the new async to build, even in the latest opam.
>>>> By default it picks the older async, and when I pin to the latest
>>>> version, I get:
>>>>
>>>> en $ opam upgrade async
>>>> No solution has been found:
>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>> async_core.108.07.01 <- async.108.07.01
>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>>
>>>> Any thoughts on how to get this to work?
>>>>
>>>> y
>>>>
>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>>
>>>>> -anil
>>>>>
>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>
>>>>> Great, The tarballs are up here:
>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>>
>>>>> Thanks!
>>>>> Yury
>>>>>
>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>>
>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>> simpler code generation in place.
>>>>>>
>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>> specific (="108.07.00").
>>>>>>
>>>>>> -a
>>>>>>
>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>>> Hi Anil,
>>>>>>>
>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>>
>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>> '$var$ >>
>>>>>>>      | tp -> tp))#ctyp
>>>>>>>
>>>>>>> -  class vars_of = object
>>>>>>> +  class vars_of = object (self)
>>>>>>>    inherit fold as super
>>>>>>>    val vars = []
>>>>>>>    method vars = vars
>>>>>>> +    method! ctyp _ = self
>>>>>>>    method ident = function
>>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>    | ident -> super#ident ident
>>>>>>>
>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>>
>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> Hi Yury,
>>>>>>>
>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>>
>>>>>>> class vars_of = object
>>>>>>>   inherit fold as super
>>>>>>>   val vars = []
>>>>>>>   method vars = vars
>>>>>>>   method ident = function
>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>   | ident -> super#ident ident
>>>>>>> end
>>>>>>> let lids_of_patt patt =
>>>>>>>   ((new vars_of)#patt patt)#vars
>>>>>>>
>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>> of dyntype, we generate output like:
>>>>>>>
>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>> <snip> in
>>>>>>>  fun ?id_seed t =
>>>>>>>    <snip>
>>>>>>>
>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>>
>>>>>>> let value_of_t, value_of_foo =
>>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>>
>>>>>>> and it works fine now. The changeset is:
>>>>>>>
>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>> and is present in dyntype-0.9.0.
>>>>>>>
>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>>
>>>>>>> -anil
>>>>>>>
>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>>
>>>>>>>> Hi Anil,
>>>>>>>>
>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>> by this extension.
>>>>>>>>
>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>> some extra bits that are generated:
>>>>>>>>
>>>>>>>> For a simple:
>>>>>>>>
>>>>>>>> # type t = int with value;;
>>>>>>>>
>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>>
>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>> __x__))
>>>>>>>>
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = ref
>>>>>>>> +and _ = value_of_t
>>>>>>>> +
>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>>  let module Deps =
>>>>>>>>    struct
>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>>>>
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t_of_value
>>>>>>>> +
>>>>>>>>
>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>>
>>>>>>>> -anil
>>>>>
>>>>>
>>>
>>


From sylvain at le-gall.net  Fri Oct  5 09:54:10 2012
From: sylvain at le-gall.net (Sylvain Le Gall)
Date: Fri, 5 Oct 2012 10:54:10 +0200
Subject: type_conv-108.07 breakage
In-Reply-To: <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
Message-ID: <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>


If you send the patch for ODN, you''ll have a new upstream tarball by
then end of the day.

2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
> That's correct; almost all non-Core packages are broken by the
> type_conv interface change. I have some patches queued up for them,
> but haven't had a chance to submit them upstream yet.  Some (such
> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>
> For now, a decent workaround is to switch to a compiler alias to
> install OASIS, and otherwise use the new type_conv in a separate
> switch.
>
> -anil
>
> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>
>> It looks like ocaml-data-notation should be upgraded to work with a
>> newer version of type_conv. If you're not using  oasis, can you just
>> remove it?
>>
>> Yury
>>
>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>
>>> I can't seem to get the new async to build, even in the latest opam.
>>> By default it picks the older async, and when I pin to the latest
>>> version, I get:
>>>
>>> en $ opam upgrade async
>>> No solution has been found:
>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>> async_core.108.07.01 <- async.108.07.01
>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>
>>> Any thoughts on how to get this to work?
>>>
>>> y
>>>
>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>
>>>> -anil
>>>>
>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>
>>>> Great, The tarballs are up here:
>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>
>>>> Thanks!
>>>> Yury
>>>>
>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>
>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>> simpler code generation in place.
>>>>>
>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>> test of the constraint system, as our constraints are probably way too
>>>>> specific (="108.07.00").
>>>>>
>>>>> -a
>>>>>
>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>
>>>>>> Hi Anil,
>>>>>>
>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>
>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>> @@ -371,10 +371,11 @@
>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>> '$var$ >>
>>>>>>      | tp -> tp))#ctyp
>>>>>>
>>>>>> -  class vars_of = object
>>>>>> +  class vars_of = object (self)
>>>>>>    inherit fold as super
>>>>>>    val vars = []
>>>>>>    method vars = vars
>>>>>> +    method! ctyp _ = self
>>>>>>    method ident = function
>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>    | ident -> super#ident ident
>>>>>>
>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>
>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>> wrote:
>>>>>> Hi Yury,
>>>>>>
>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>
>>>>>> class vars_of = object
>>>>>>   inherit fold as super
>>>>>>   val vars = []
>>>>>>   method vars = vars
>>>>>>   method ident = function
>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>   | ident -> super#ident ident
>>>>>> end
>>>>>> let lids_of_patt patt =
>>>>>>   ((new vars_of)#patt patt)#vars
>>>>>>
>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>> of dyntype, we generate output like:
>>>>>>
>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>> <snip> in
>>>>>>  fun ?id_seed t =
>>>>>>    <snip>
>>>>>>
>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>
>>>>>> let value_of_t, value_of_foo =
>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>
>>>>>> and it works fine now. The changeset is:
>>>>>>
>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>> and is present in dyntype-0.9.0.
>>>>>>
>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>> reported?  The bitbucket issue tracker?
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>>> Hi Anil,
>>>>>>>
>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>> by this extension.
>>>>>>>
>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>> some extra bits that are generated:
>>>>>>>
>>>>>>> For a simple:
>>>>>>>
>>>>>>> # type t = int with value;;
>>>>>>>
>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>
>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>> __x__))
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = ref
>>>>>>> +and _ = value_of_t
>>>>>>> +
>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>  let module Deps =
>>>>>>>    struct
>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>    in t_of_value_aux { Deps.t = []; }
>>>>>>>
>>>>>>> +let _ = t
>>>>>>> +and _ = t
>>>>>>> +and _ = t_of_value
>>>>>>> +
>>>>>>>
>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>
>>>>>>> -anil
>>>>
>>>>
>>
>


From yminsky at janestreet.com  Fri Oct  5 19:03:13 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Fri, 5 Oct 2012 14:03:13 -0400
Subject: type_conv-108.07 breakage
In-Reply-To: <20121005161230.GF27858@dark.recoil.org>
References: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
	<CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
	<CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>
	<20121005161230.GF27858@dark.recoil.org>
Message-ID: <CACLX4jQ7Z87usvNOspDMnqs1sn2366q3Wdp_8eE7skkbNtLDSg@mail.gmail.com>


I do have COW installed.  That makes sense.  I'll try deleting it.

On Fri, Oct 5, 2012 at 12:12 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> On Fri, Oct 05, 2012 at 07:55:04AM -0400, Yaron Minsky wrote:
>> By the way, no love on installing async 108.07.01 on opam.  Here's the
>> tail of the error:
>>
>> . File "syntax/json/extension.ml", line 371, characters 36-39:
>> . Error: This expression has type bool but an expression was expected of type
>> .          Camlp4.PreCast.Syntax.Ast.ctyp = Camlp4.PreCast.Ast.ctyp
>> . Command exited with code 2.
>> * make: *** [all] Error 10
>>   'opam upgrade' failed
>>
>> Has anyone gotten this to succeed?  Also, how did json get implemented
>> here?  There's no json support in async as far as I know...
>
> This looks like it's trying to install COW, and not Core.  I think that
> your pinning of type_conv might have confused things a little. I'll upload
> a new COW and send Sylvain the ODN patches shortly, but it would be good
> to understand why the package constraints aren't working as expected at
> present...
>
> Do you have COW installed also?
>
> -anil
>
>
>
>
>>
>> y
>>
>> On Fri, Oct 5, 2012 at 4:54 AM, Sylvain Le Gall <sylvain at le-gall.net> wrote:
>> > If you send the patch for ODN, you''ll have a new upstream tarball by
>> > then end of the day.
>> >
>> > 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>> >> That's correct; almost all non-Core packages are broken by the
>> >> type_conv interface change. I have some patches queued up for them,
>> >> but haven't had a chance to submit them upstream yet.  Some (such
>> >> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>> >>
>> >> For now, a decent workaround is to switch to a compiler alias to
>> >> install OASIS, and otherwise use the new type_conv in a separate
>> >> switch.
>> >>
>> >> -anil
>> >>
>> >> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>
>> >>> It looks like ocaml-data-notation should be upgraded to work with a
>> >>> newer version of type_conv. If you're not using  oasis, can you just
>> >>> remove it?
>> >>>
>> >>> Yury
>> >>>
>> >>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> >>>
>> >>>> I can't seem to get the new async to build, even in the latest opam.
>> >>>> By default it picks the older async, and when I pin to the latest
>> >>>> version, I get:
>> >>>>
>> >>>> en $ opam upgrade async
>> >>>> No solution has been found:
>> >>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>> >>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>> >>>> async_core.108.07.01 <- async.108.07.01
>> >>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>> >>>>
>> >>>> Any thoughts on how to get this to work?
>> >>>>
>> >>>> y
>> >>>>
>> >>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> >>>>> This should be available on OPAM now too, if you do 'opam update'.
>> >>>>>
>> >>>>> -anil
>> >>>>>
>> >>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>>>>
>> >>>>> Great, The tarballs are up here:
>> >>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>> >>>>>
>> >>>>> Thanks!
>> >>>>> Yury
>> >>>>>
>> >>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> >>>>>>
>> >>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>> >>>>>> simpler code generation in place.
>> >>>>>>
>> >>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>> >>>>>> release system issue only a bumped version number for Core and Type_conv,
>> >>>>>> instead of a complete set of new packages with new versions? This is a good
>> >>>>>> test of the constraint system, as our constraints are probably way too
>> >>>>>> specific (="108.07.00").
>> >>>>>>
>> >>>>>> -a
>> >>>>>>
>> >>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>>>>>
>> >>>>>>> Hi Anil,
>> >>>>>>>
>> >>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>> >>>>>>>
>> >>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>> >>>>>>> @@ -371,10 +371,11 @@
>> >>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>> >>>>>>> '$var$ >>
>> >>>>>>>      | tp -> tp))#ctyp
>> >>>>>>>
>> >>>>>>> -  class vars_of = object
>> >>>>>>> +  class vars_of = object (self)
>> >>>>>>>    inherit fold as super
>> >>>>>>>    val vars = []
>> >>>>>>>    method vars = vars
>> >>>>>>> +    method! ctyp _ = self
>> >>>>>>>    method ident = function
>> >>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >>>>>>>    | ident -> super#ident ident
>> >>>>>>>
>> >>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>> >>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>> >>>>>>>
>> >>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>> >>>>>>> wrote:
>> >>>>>>> Hi Yury,
>> >>>>>>>
>> >>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>> >>>>>>> it always objects!), but it looks like the bug is at:
>> >>>>>>>
>> >>>>>>> class vars_of = object
>> >>>>>>>   inherit fold as super
>> >>>>>>>   val vars = []
>> >>>>>>>   method vars = vars
>> >>>>>>>   method ident = function
>> >>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>> >>>>>>>   | ident -> super#ident ident
>> >>>>>>> end
>> >>>>>>> let lids_of_patt patt =
>> >>>>>>>   ((new vars_of)#patt patt)#vars
>> >>>>>>>
>> >>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>> >>>>>>> of dyntype, we generate output like:
>> >>>>>>>
>> >>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>> >>>>>>> <snip> in
>> >>>>>>>  fun ?id_seed t =
>> >>>>>>>    <snip>
>> >>>>>>>
>> >>>>>>> I've simplified the Dyntype generation to be simply:
>> >>>>>>>
>> >>>>>>> let value_of_t, value_of_foo =
>> >>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>> >>>>>>>
>> >>>>>>> and it works fine now. The changeset is:
>> >>>>>>>
>> >>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>> >>>>>>> and is present in dyntype-0.9.0.
>> >>>>>>>
>> >>>>>>> Where would you like Core bugs such as this type_conv one to be
>> >>>>>>> reported?  The bitbucket issue tracker?
>> >>>>>>>
>> >>>>>>> -anil
>> >>>>>>>
>> >>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> >>>>>>>
>> >>>>>>>> Hi Anil,
>> >>>>>>>>
>> >>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>> >>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>> >>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>> >>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>> >>>>>>>> by this extension.
>> >>>>>>>>
>> >>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>> >>>>>>>> wrote:
>> >>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>> >>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>> >>>>>>>> some extra bits that are generated:
>> >>>>>>>>
>> >>>>>>>> For a simple:
>> >>>>>>>>
>> >>>>>>>> # type t = int with value;;
>> >>>>>>>>
>> >>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>> >>>>>>>>
>> >>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>> >>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>> >>>>>>>> @@ -22,6 +22,12 @@
>> >>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
>> >>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>> >>>>>>>> __x__))
>> >>>>>>>>
>> >>>>>>>> +let _ = t
>> >>>>>>>> +and _ = t
>> >>>>>>>> +and _ = t
>> >>>>>>>> +and _ = ref
>> >>>>>>>> +and _ = value_of_t
>> >>>>>>>> +
>> >>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>> >>>>>>>>  let module Deps =
>> >>>>>>>>    struct
>> >>>>>>>> @@ -73,4 +79,8 @@
>> >>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>> >>>>>>>>    in t_of_value_aux { Deps.t = []; }
>> >>>>>>>>
>> >>>>>>>> +let _ = t
>> >>>>>>>> +and _ = t
>> >>>>>>>> +and _ = t_of_value
>> >>>>>>>> +
>> >>>>>>>>
>> >>>>>>>> These are unbound, and so compilation breaks... what are they for?
>> >>>>>>>>
>> >>>>>>>> -anil
>> >>>>>
>> >>>>>
>> >>>
>> >>
>>
>
> --
> Anil Madhavapeddy                                 http://anil.recoil.org


From anil at recoil.org  Sat Oct  6 00:31:22 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 5 Oct 2012 16:31:22 -0700
Subject: type_conv-108.07 breakage
In-Reply-To: <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org> <CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com> <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org> <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com> <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org> <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com> <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org> <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com> <-2309447399847593243@unknownmsgid> <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org> <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
Message-ID: <4BA6C80E-1971-4BFD-8500-664CA157A250@recoil.org>


Sylvain,

Patch put in a bug report at https://forge.ocamlcore.org/tracker/index.php?func=detail&aid=1226&group_id=148&atid=674

Would you consider moving ODN and the other OASIS dependencies to Github, since the main OASIS repo is also up there now?

Let me know when you cut a release and I'll update the OPAM constraints.

-anil

On 5 Oct 2012, at 01:54, Sylvain Le Gall <sylvain at le-gall.net> wrote:

> If you send the patch for ODN, you''ll have a new upstream tarball by
> then end of the day.
> 
> 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>> That's correct; almost all non-Core packages are broken by the
>> type_conv interface change. I have some patches queued up for them,
>> but haven't had a chance to submit them upstream yet.  Some (such
>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>> 
>> For now, a decent workaround is to switch to a compiler alias to
>> install OASIS, and otherwise use the new type_conv in a separate
>> switch.
>> 
>> -anil
>> 
>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> 
>>> It looks like ocaml-data-notation should be upgraded to work with a
>>> newer version of type_conv. If you're not using  oasis, can you just
>>> remove it?
>>> 
>>> Yury
>>> 
>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> 
>>>> I can't seem to get the new async to build, even in the latest opam.
>>>> By default it picks the older async, and when I pin to the latest
>>>> version, I get:
>>>> 
>>>> en $ opam upgrade async
>>>> No solution has been found:
>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>> async_core.108.07.01 <- async.108.07.01
>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>> 
>>>> Any thoughts on how to get this to work?
>>>> 
>>>> y
>>>> 
>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>> 
>>>>> -anil
>>>>> 
>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>> 
>>>>> Great, The tarballs are up here:
>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>> 
>>>>> Thanks!
>>>>> Yury
>>>>> 
>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>> 
>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>> simpler code generation in place.
>>>>>> 
>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>> specific (="108.07.00").
>>>>>> 
>>>>>> -a
>>>>>> 
>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>> 
>>>>>>> Hi Anil,
>>>>>>> 
>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>> 
>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>     | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>> '$var$ >>
>>>>>>>     | tp -> tp))#ctyp
>>>>>>> 
>>>>>>> -  class vars_of = object
>>>>>>> +  class vars_of = object (self)
>>>>>>>   inherit fold as super
>>>>>>>   val vars = []
>>>>>>>   method vars = vars
>>>>>>> +    method! ctyp _ = self
>>>>>>>   method ident = function
>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>   | ident -> super#ident ident
>>>>>>> 
>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>> 
>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>> wrote:
>>>>>>> Hi Yury,
>>>>>>> 
>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>> 
>>>>>>> class vars_of = object
>>>>>>>  inherit fold as super
>>>>>>>  val vars = []
>>>>>>>  method vars = vars
>>>>>>>  method ident = function
>>>>>>>  | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>  | ident -> super#ident ident
>>>>>>> end
>>>>>>> let lids_of_patt patt =
>>>>>>>  ((new vars_of)#patt patt)#vars
>>>>>>> 
>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>> of dyntype, we generate output like:
>>>>>>> 
>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>> <snip> in
>>>>>>> fun ?id_seed t =
>>>>>>>   <snip>
>>>>>>> 
>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>> 
>>>>>>> let value_of_t, value_of_foo =
>>>>>>> (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>> 
>>>>>>> and it works fine now. The changeset is:
>>>>>>> 
>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>> and is present in dyntype-0.9.0.
>>>>>>> 
>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>> 
>>>>>>> -anil
>>>>>>> 
>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>> 
>>>>>>>> Hi Anil,
>>>>>>>> 
>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>> by this extension.
>>>>>>>> 
>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>> some extra bits that are generated:
>>>>>>>> 
>>>>>>>> For a simple:
>>>>>>>> 
>>>>>>>> # type t = int with value;;
>>>>>>>> 
>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>> 
>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>         then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>         else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>> __x__))
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = ref
>>>>>>>> +and _ = value_of_t
>>>>>>>> +
>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>> let module Deps =
>>>>>>>>   struct
>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>            raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>   in t_of_value_aux { Deps.t = []; }
>>>>>>>> 
>>>>>>>> +let _ = t
>>>>>>>> +and _ = t
>>>>>>>> +and _ = t_of_value
>>>>>>>> +
>>>>>>>> 
>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>> 
>>>>>>>> -anil
>>>>> 
>>>>> 
>>> 
>> 
> 



From anil at recoil.org  Fri Oct  5 17:12:30 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Fri, 5 Oct 2012 17:12:30 +0100
Subject: type_conv-108.07 breakage
In-Reply-To: <CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>
References: <C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
 <CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
 <FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
 <CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
 <0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
 <CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
 <-2309447399847593243@unknownmsgid>
 <18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
 <CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
 <CACLX4jR-hiMACJ4oG7Yg-ecJq0CmcDiQ6fU2gCNOqOHNyaXTtg@mail.gmail.com>
Message-ID: <20121005161230.GF27858@dark.recoil.org>


On Fri, Oct 05, 2012 at 07:55:04AM -0400, Yaron Minsky wrote:
> By the way, no love on installing async 108.07.01 on opam.  Here's the
> tail of the error:
> 
> . File "syntax/json/extension.ml", line 371, characters 36-39:
> . Error: This expression has type bool but an expression was expected of type
> .          Camlp4.PreCast.Syntax.Ast.ctyp = Camlp4.PreCast.Ast.ctyp
> . Command exited with code 2.
> * make: *** [all] Error 10
>   'opam upgrade' failed
> 
> Has anyone gotten this to succeed?  Also, how did json get implemented
> here?  There's no json support in async as far as I know...

This looks like it's trying to install COW, and not Core.  I think that
your pinning of type_conv might have confused things a little. I'll upload
a new COW and send Sylvain the ODN patches shortly, but it would be good
to understand why the package constraints aren't working as expected at
present...

Do you have COW installed also?

-anil




> 
> y
> 
> On Fri, Oct 5, 2012 at 4:54 AM, Sylvain Le Gall <sylvain at le-gall.net> wrote:
> > If you send the patch for ODN, you''ll have a new upstream tarball by
> > then end of the day.
> >
> > 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
> >> That's correct; almost all non-Core packages are broken by the
> >> type_conv interface change. I have some patches queued up for them,
> >> but haven't had a chance to submit them upstream yet.  Some (such
> >> as Dyntype) I've already fixed, but I haven't done OASIS yet.
> >>
> >> For now, a decent workaround is to switch to a compiler alias to
> >> install OASIS, and otherwise use the new type_conv in a separate
> >> switch.
> >>
> >> -anil
> >>
> >> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>
> >>> It looks like ocaml-data-notation should be upgraded to work with a
> >>> newer version of type_conv. If you're not using  oasis, can you just
> >>> remove it?
> >>>
> >>> Yury
> >>>
> >>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> >>>
> >>>> I can't seem to get the new async to build, even in the latest opam.
> >>>> By default it picks the older async, and when I pin to the latest
> >>>> version, I get:
> >>>>
> >>>> en $ opam upgrade async
> >>>> No solution has been found:
> >>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
> >>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
> >>>> async_core.108.07.01 <- async.108.07.01
> >>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
> >>>>
> >>>> Any thoughts on how to get this to work?
> >>>>
> >>>> y
> >>>>
> >>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >>>>> This should be available on OPAM now too, if you do 'opam update'.
> >>>>>
> >>>>> -anil
> >>>>>
> >>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>>>>
> >>>>> Great, The tarballs are up here:
> >>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
> >>>>>
> >>>>> Thanks!
> >>>>> Yury
> >>>>>
> >>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
> >>>>>>
> >>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
> >>>>>> simpler code generation in place.
> >>>>>>
> >>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
> >>>>>> release system issue only a bumped version number for Core and Type_conv,
> >>>>>> instead of a complete set of new packages with new versions? This is a good
> >>>>>> test of the constraint system, as our constraints are probably way too
> >>>>>> specific (="108.07.00").
> >>>>>>
> >>>>>> -a
> >>>>>>
> >>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>>>>>
> >>>>>>> Hi Anil,
> >>>>>>>
> >>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
> >>>>>>>
> >>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> b/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
> >>>>>>> @@ -371,10 +371,11 @@
> >>>>>>>      | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
> >>>>>>> '$var$ >>
> >>>>>>>      | tp -> tp))#ctyp
> >>>>>>>
> >>>>>>> -  class vars_of = object
> >>>>>>> +  class vars_of = object (self)
> >>>>>>>    inherit fold as super
> >>>>>>>    val vars = []
> >>>>>>>    method vars = vars
> >>>>>>> +    method! ctyp _ = self
> >>>>>>>    method ident = function
> >>>>>>>    | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >>>>>>>    | ident -> super#ident ident
> >>>>>>>
> >>>>>>> I'd like to get a quick bugfix out the door that includes this and more
> >>>>>>> portable use of mktemp in base/core/lib/discover.sh.
> >>>>>>>
> >>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
> >>>>>>> wrote:
> >>>>>>> Hi Yury,
> >>>>>>>
> >>>>>>> I got a little lost in the new type_conv control flow (objects, why is
> >>>>>>> it always objects!), but it looks like the bug is at:
> >>>>>>>
> >>>>>>> class vars_of = object
> >>>>>>>   inherit fold as super
> >>>>>>>   val vars = []
> >>>>>>>   method vars = vars
> >>>>>>>   method ident = function
> >>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
> >>>>>>>   | ident -> super#ident ident
> >>>>>>> end
> >>>>>>> let lids_of_patt patt =
> >>>>>>>   ((new vars_of)#patt patt)#vars
> >>>>>>>
> >>>>>>> This extracts out all the identifiers in a pattern binding. In the case
> >>>>>>> of dyntype, we generate output like:
> >>>>>>>
> >>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
> >>>>>>> <snip> in
> >>>>>>>  fun ?id_seed t =
> >>>>>>>    <snip>
> >>>>>>>
> >>>>>>> I've simplified the Dyntype generation to be simply:
> >>>>>>>
> >>>>>>> let value_of_t, value_of_foo =
> >>>>>>>  (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
> >>>>>>>
> >>>>>>> and it works fine now. The changeset is:
> >>>>>>>
> >>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
> >>>>>>> and is present in dyntype-0.9.0.
> >>>>>>>
> >>>>>>> Where would you like Core bugs such as this type_conv one to be
> >>>>>>> reported?  The bitbucket issue tracker?
> >>>>>>>
> >>>>>>> -anil
> >>>>>>>
> >>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> >>>>>>>
> >>>>>>>> Hi Anil,
> >>>>>>>>
> >>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
> >>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
> >>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
> >>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
> >>>>>>>> by this extension.
> >>>>>>>>
> >>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
> >>>>>>>> wrote:
> >>>>>>>> I've been porting some of our syntax extensions to the new type_conv
> >>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
> >>>>>>>> some extra bits that are generated:
> >>>>>>>>
> >>>>>>>> For a simple:
> >>>>>>>>
> >>>>>>>> # type t = int with value;;
> >>>>>>>>
> >>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
> >>>>>>>>
> >>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
> >>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
> >>>>>>>> @@ -22,6 +22,12 @@
> >>>>>>>>          then Dyntype.Value.Rec ((("t", __id__), __x__))
> >>>>>>>>          else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
> >>>>>>>> __x__))
> >>>>>>>>
> >>>>>>>> +let _ = t
> >>>>>>>> +and _ = t
> >>>>>>>> +and _ = t
> >>>>>>>> +and _ = ref
> >>>>>>>> +and _ = value_of_t
> >>>>>>>> +
> >>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
> >>>>>>>>  let module Deps =
> >>>>>>>>    struct
> >>>>>>>> @@ -73,4 +79,8 @@
> >>>>>>>>             raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
> >>>>>>>>    in t_of_value_aux { Deps.t = []; }
> >>>>>>>>
> >>>>>>>> +let _ = t
> >>>>>>>> +and _ = t
> >>>>>>>> +and _ = t_of_value
> >>>>>>>> +
> >>>>>>>>
> >>>>>>>> These are unbound, and so compilation breaks... what are they for?
> >>>>>>>>
> >>>>>>>> -anil
> >>>>>
> >>>>>
> >>>
> >>
> 

-- 
Anil Madhavapeddy                                 http://anil.recoil.org


From sylvain at le-gall.net  Sat Oct  6 09:17:09 2012
From: sylvain at le-gall.net (Sylvain Le Gall)
Date: Sat, 6 Oct 2012 10:17:09 +0200
Subject: type_conv-108.07 breakage
In-Reply-To: <4BA6C80E-1971-4BFD-8500-664CA157A250@recoil.org>
References: <67F9CDEC-3CCB-49ED-9C0A-E0F23D0B3C10@recoil.org>
	<CAEDxudy2bk4m+an-5gUYNE-Zt16VTUwGRi_efyhmMG_3zxjQuA@mail.gmail.com>
	<C2ECDED2-1942-4AFF-A71A-60F9C25D058C@recoil.org>
	<CAEDxudwTrc3ZRTFXCfn+Kz1ZJyBZfDG3Ay7M6s2=WO+yE1AX7Q@mail.gmail.com>
	<FDE021E1-3EC0-4A76-ABC2-94FD1BB8592E@recoil.org>
	<CAEDxudwCnJp+W2rCQu7YDyYQBjBEVK=mjhUhX6RZrpkhkeVbPw@mail.gmail.com>
	<0159FFF3-28CE-4DBE-8F80-719AF92B5959@recoil.org>
	<CACLX4jRQbVPccnbdZn2AutsFPQTCyPg2HEaybUBUck096dWk6g@mail.gmail.com>
	<-2309447399847593243@unknownmsgid>
	<18E737B4-304B-4915-8F3A-118B4A3A6182@recoil.org>
	<CAOCAUGMk_OXo=T0Opc_fYiJAgAXj0xSGfg3Cj8MUX9WmD8gVpQ@mail.gmail.com>
	<4BA6C80E-1971-4BFD-8500-664CA157A250@recoil.org>
Message-ID: <CAOCAUGMEWiYrDNGxnpwo7XoYeYy+ds688fVV0C5UJc=SjNjKrg@mail.gmail.com>


2012/10/6 Anil Madhavapeddy <anil at recoil.org>:
> Sylvain,
>
> Patch put in a bug report at https://forge.ocamlcore.org/tracker/index.php?func=detail&aid=1226&group_id=148&atid=674
>
> Would you consider moving ODN and the other OASIS dependencies to Github, since the main OASIS repo is also up there now?
>

Not yet, give me time to adapt. If there were a way to have a forge
plugin that create a link between github and forge.ocamlcore.org, I
would more easily consider it, but until then, I will keep 2nd level
project where they are.

> Let me know when you cut a release and I'll update the OPAM constraints.
>

Jobs done, but don't have access to 108.07.01, so I let you check that
it compiles fine...

> -anil
>
> On 5 Oct 2012, at 01:54, Sylvain Le Gall <sylvain at le-gall.net> wrote:
>
>> If you send the patch for ODN, you''ll have a new upstream tarball by
>> then end of the day.
>>
>> 2012/10/5 Anil Madhavapeddy <anil at recoil.org>:
>>> That's correct; almost all non-Core packages are broken by the
>>> type_conv interface change. I have some patches queued up for them,
>>> but haven't had a chance to submit them upstream yet.  Some (such
>>> as Dyntype) I've already fixed, but I haven't done OASIS yet.
>>>
>>> For now, a decent workaround is to switch to a compiler alias to
>>> install OASIS, and otherwise use the new type_conv in a separate
>>> switch.
>>>
>>> -anil
>>>
>>> On 4 Oct 2012, at 17:40, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>
>>>> It looks like ocaml-data-notation should be upgraded to work with a
>>>> newer version of type_conv. If you're not using  oasis, can you just
>>>> remove it?
>>>>
>>>> Yury
>>>>
>>>> On Oct 4, 2012, at 8:34 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>>
>>>>> I can't seem to get the new async to build, even in the latest opam.
>>>>> By default it picks the older async, and when I pin to the latest
>>>>> version, I get:
>>>>>
>>>>> en $ opam upgrade async
>>>>> No solution has been found:
>>>>> - Conflict between type_conv.108.00.02 and type_conv.108.07.01.
>>>>> + type_conv.108.07.01 <- fieldslib.108.07.01 <- core.108.07.01 <-
>>>>> async_core.108.07.01 <- async.108.07.01
>>>>> + type_conv.108.00.02 <- ocaml-data-notation.0.0.9
>>>>>
>>>>> Any thoughts on how to get this to work?
>>>>>
>>>>> y
>>>>>
>>>>> On Tue, Oct 2, 2012 at 12:31 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>> This should be available on OPAM now too, if you do 'opam update'.
>>>>>>
>>>>>> -anil
>>>>>>
>>>>>> On 1 Oct 2012, at 13:58, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>
>>>>>> Great, The tarballs are up here:
>>>>>> https://ocaml.janestreet.com/ocaml-core/108.07.01
>>>>>>
>>>>>> Thanks!
>>>>>> Yury
>>>>>>
>>>>>> On Mon, Oct 1, 2012 at 1:49 PM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>>>>
>>>>>>> Great!  The workaround was pretty straightforward, so I'll leave the
>>>>>>> simpler code generation in place.
>>>>>>>
>>>>>>> Let me know when the bugfix is out, and we'll update OPAM.  Can your
>>>>>>> release system issue only a bumped version number for Core and Type_conv,
>>>>>>> instead of a complete set of new packages with new versions? This is a good
>>>>>>> test of the constraint system, as our constraints are probably way too
>>>>>>> specific (="108.07.00").
>>>>>>>
>>>>>>> -a
>>>>>>>
>>>>>>> On 1 Oct 2012, at 10:37, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>>
>>>>>>>> Hi Anil,
>>>>>>>>
>>>>>>>> This was definitely a bug in type-conv. Valentin has a fix for this:
>>>>>>>>
>>>>>>>> diff --git a/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> b/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> --- a/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> +++ b/base/type_conv/lib/pa_type_conv.ml
>>>>>>>> @@ -371,10 +371,11 @@
>>>>>>>>     | <:ctyp at loc< +'$var$ >> | <:ctyp at loc< -'$var$ >> -> <:ctyp at loc<
>>>>>>>> '$var$ >>
>>>>>>>>     | tp -> tp))#ctyp
>>>>>>>>
>>>>>>>> -  class vars_of = object
>>>>>>>> +  class vars_of = object (self)
>>>>>>>>   inherit fold as super
>>>>>>>>   val vars = []
>>>>>>>>   method vars = vars
>>>>>>>> +    method! ctyp _ = self
>>>>>>>>   method ident = function
>>>>>>>>   | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>>   | ident -> super#ident ident
>>>>>>>>
>>>>>>>> I'd like to get a quick bugfix out the door that includes this and more
>>>>>>>> portable use of mktemp in base/core/lib/discover.sh.
>>>>>>>>
>>>>>>>> On Mon, Oct 1, 2012 at 1:23 PM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>> wrote:
>>>>>>>> Hi Yury,
>>>>>>>>
>>>>>>>> I got a little lost in the new type_conv control flow (objects, why is
>>>>>>>> it always objects!), but it looks like the bug is at:
>>>>>>>>
>>>>>>>> class vars_of = object
>>>>>>>>  inherit fold as super
>>>>>>>>  val vars = []
>>>>>>>>  method vars = vars
>>>>>>>>  method ident = function
>>>>>>>>  | <:ident< $lid:v$ >> -> {< vars = v :: vars >}
>>>>>>>>  | ident -> super#ident ident
>>>>>>>> end
>>>>>>>> let lids_of_patt patt =
>>>>>>>>  ((new vars_of)#patt patt)#vars
>>>>>>>>
>>>>>>>> This extracts out all the identifiers in a pattern binding. In the case
>>>>>>>> of dyntype, we generate output like:
>>>>>>>>
>>>>>>>> let (value_of_t : ?id_seed: (Int64.t ref) -> t -> Dyntype.Value.t) =
>>>>>>>> <snip> in
>>>>>>>> fun ?id_seed t =
>>>>>>>>   <snip>
>>>>>>>>
>>>>>>>> I've simplified the Dyntype generation to be simply:
>>>>>>>>
>>>>>>>> let value_of_t, value_of_foo =
>>>>>>>> (fun ?id_seed t -> <...>), (fun ?id_seed t -> <...>)
>>>>>>>>
>>>>>>>> and it works fine now. The changeset is:
>>>>>>>>
>>>>>>>> https://github.com/mirage/dyntype/commit/3569269c8cad3f013151fb1b5d89cf76981f1df1
>>>>>>>> and is present in dyntype-0.9.0.
>>>>>>>>
>>>>>>>> Where would you like Core bugs such as this type_conv one to be
>>>>>>>> reported?  The bitbucket issue tracker?
>>>>>>>>
>>>>>>>> -anil
>>>>>>>>
>>>>>>>> On 30 Sep 2012, at 05:46, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>>>>>>>
>>>>>>>>> Hi Anil,
>>>>>>>>>
>>>>>>>>> I'll take a look at the dyntype extension to see how type_conv is
>>>>>>>>> broken, but the point of these assignments is to avoid ocaml 4's unused
>>>>>>>>> value warnings by from generated code. Apparently, type_conv thinks that
>>>>>>>>> values called "t", "ref", "t_of_value", and "value_of_t" have been generated
>>>>>>>>> by this extension.
>>>>>>>>>
>>>>>>>>> On Sun, Sep 30, 2012 at 12:32 AM, Anil Madhavapeddy <anil at recoil.org>
>>>>>>>>> wrote:
>>>>>>>>> I've been porting some of our syntax extensions to the new type_conv
>>>>>>>>> (from 108.00.02 -> 108.07), and the Dyntype extension is broken because of
>>>>>>>>> some extra bits that are generated:
>>>>>>>>>
>>>>>>>>> For a simple:
>>>>>>>>>
>>>>>>>>> # type t = int with value;;
>>>>>>>>>
>>>>>>>>> This diff happens between the output of 108.00.02 and 108.07.00:
>>>>>>>>>
>>>>>>>>> --- simple-108.00.02.ml 2012-09-29 21:29:42.000000000 -0700
>>>>>>>>> +++ _build/simple_value_test.ml 2012-09-29 21:30:04.000000000 -0700
>>>>>>>>> @@ -22,6 +22,12 @@
>>>>>>>>>         then Dyntype.Value.Rec ((("t", __id__), __x__))
>>>>>>>>>         else Dyntype.Value.Ext ((("t", (gen_t_id ~id_seed __x3__)),
>>>>>>>>> __x__))
>>>>>>>>>
>>>>>>>>> +let _ = t
>>>>>>>>> +and _ = t
>>>>>>>>> +and _ = t
>>>>>>>>> +and _ = ref
>>>>>>>>> +and _ = value_of_t
>>>>>>>>> +
>>>>>>>>> let (t_of_value : Dyntype.Value.t -> t) =
>>>>>>>>> let module Deps =
>>>>>>>>>   struct
>>>>>>>>> @@ -73,4 +79,8 @@
>>>>>>>>>            raise (Deps.Runtime_error (("Var/Rec/Ext", __x__))))
>>>>>>>>>   in t_of_value_aux { Deps.t = []; }
>>>>>>>>>
>>>>>>>>> +let _ = t
>>>>>>>>> +and _ = t
>>>>>>>>> +and _ = t_of_value
>>>>>>>>> +
>>>>>>>>>
>>>>>>>>> These are unbound, and so compilation breaks... what are they for?
>>>>>>>>>
>>>>>>>>> -anil
>>>>>>
>>>>>>
>>>>
>>>
>>
>


From yminsky at janestreet.com  Sun Oct  7 13:06:55 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 7 Oct 2012 08:06:55 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
Message-ID: <CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>


CC'ing Nathan, who is the primary author of Command.

We're in a bit of an awkward state with bitbucket right now, though it
will be fixed eventually.  That said, I'm not sure why that's
important to learning the command API: it's all available in the
tarball, after all, which you can get here:

   https://ocaml.janestreet.com/ocaml-core/108.07.01/

Also, the HTML documentation can be found here:

   https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html

Also, there's a module called Deprecated_command in Core_extended
(where the old Command lived) that has the old API on top of the new
implementation.

The new Command uses some pretty clever types to give a good
interface, and we should really publish some examples (which we have
internally).  Nathan, do you have some ideas as to what we can do to
improve the docs?

y


On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Hi, opam is installing 108.07.01 for me which seems to have a number
> of API changes to the previous release (108.00.01 I think?).  But the
> source on bitbucket seems to correspond to the older version.  Am I
> missing something obvious or will bitbucket be updated soon?  Or is
> there some kind of migration documentation available?  Specifically
> I'm trying to figure out the new Command API.
>
> Thanks,
> /M


From yminsky at janestreet.com  Sun Oct  7 13:23:15 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 7 Oct 2012 08:23:15 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
Message-ID: <CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>


I thought we'd killed that link.  Where's the bad documentation link you found?

y

On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Ah thanks, I couldn't find the docs earlier.  It looks like the
> Documentation link off the Jane St site points to something from 2009,
> thank you for the correct link.
>
> /M
>
> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> CC'ing Nathan, who is the primary author of Command.
>>
>> We're in a bit of an awkward state with bitbucket right now, though it
>> will be fixed eventually.  That said, I'm not sure why that's
>> important to learning the command API: it's all available in the
>> tarball, after all, which you can get here:
>>
>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>
>> Also, the HTML documentation can be found here:
>>
>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>
>> Also, there's a module called Deprecated_command in Core_extended
>> (where the old Command lived) that has the old API on top of the new
>> implementation.
>>
>> The new Command uses some pretty clever types to give a good
>> interface, and we should really publish some examples (which we have
>> internally).  Nathan, do you have some ideas as to what we can do to
>> improve the docs?
>>
>> y
>>
>>
>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>> of API changes to the previous release (108.00.01 I think?).  But the
>>> source on bitbucket seems to correspond to the older version.  Am I
>>> missing something obvious or will bitbucket be updated soon?  Or is
>>> there some kind of migration documentation available?  Specifically
>>> I'm trying to figure out the new Command API.
>>>
>>> Thanks,
>>> /M


From yminsky at janestreet.com  Sun Oct  7 13:36:32 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sun, 7 Oct 2012 08:36:32 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
	<CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
	<CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>
Message-ID: <CACLX4jQU80SbtFXE6y1gZPRyBm9pGcrKsuXp5+vSOUYw18oPuw@mail.gmail.com>


Got it.  Will fix.

On Sun, Oct 7, 2012 at 8:25 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> https://ocaml.janestreet.com/
>
> The Documentation link on the top next to Code points to
> http://www.janestreet.com/ocaml/janestreet-ocamldocs/
>
> /M
>
> On Sun, Oct 7, 2012 at 2:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> I thought we'd killed that link.  Where's the bad documentation link you found?
>>
>> y
>>
>> On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Ah thanks, I couldn't find the docs earlier.  It looks like the
>>> Documentation link off the Jane St site points to something from 2009,
>>> thank you for the correct link.
>>>
>>> /M
>>>
>>> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>> CC'ing Nathan, who is the primary author of Command.
>>>>
>>>> We're in a bit of an awkward state with bitbucket right now, though it
>>>> will be fixed eventually.  That said, I'm not sure why that's
>>>> important to learning the command API: it's all available in the
>>>> tarball, after all, which you can get here:
>>>>
>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>>>
>>>> Also, the HTML documentation can be found here:
>>>>
>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>>>
>>>> Also, there's a module called Deprecated_command in Core_extended
>>>> (where the old Command lived) that has the old API on top of the new
>>>> implementation.
>>>>
>>>> The new Command uses some pretty clever types to give a good
>>>> interface, and we should really publish some examples (which we have
>>>> internally).  Nathan, do you have some ideas as to what we can do to
>>>> improve the docs?
>>>>
>>>> y
>>>>
>>>>
>>>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>>>> of API changes to the previous release (108.00.01 I think?).  But the
>>>>> source on bitbucket seems to correspond to the older version.  Am I
>>>>> missing something obvious or will bitbucket be updated soon?  Or is
>>>>> there some kind of migration documentation available?  Specifically
>>>>> I'm trying to figure out the new Command API.
>>>>>
>>>>> Thanks,
>>>>> /M


From mmatalka at gmail.com  Sun Oct  7 11:10:30 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 12:10:30 +0200
Subject: opam and bitbucket out of sync?
Message-ID: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>


Hi, opam is installing 108.07.01 for me which seems to have a number
of API changes to the previous release (108.00.01 I think?).  But the
source on bitbucket seems to correspond to the older version.  Am I
missing something obvious or will bitbucket be updated soon?  Or is
there some kind of migration documentation available?  Specifically
I'm trying to figure out the new Command API.

Thanks,
/M


From mmatalka at gmail.com  Sun Oct  7 13:20:03 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 14:20:03 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
Message-ID: <CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>


Ah thanks, I couldn't find the docs earlier.  It looks like the
Documentation link off the Jane St site points to something from 2009,
thank you for the correct link.

/M

On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> CC'ing Nathan, who is the primary author of Command.
>
> We're in a bit of an awkward state with bitbucket right now, though it
> will be fixed eventually.  That said, I'm not sure why that's
> important to learning the command API: it's all available in the
> tarball, after all, which you can get here:
>
>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>
> Also, the HTML documentation can be found here:
>
>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>
> Also, there's a module called Deprecated_command in Core_extended
> (where the old Command lived) that has the old API on top of the new
> implementation.
>
> The new Command uses some pretty clever types to give a good
> interface, and we should really publish some examples (which we have
> internally).  Nathan, do you have some ideas as to what we can do to
> improve the docs?
>
> y
>
>
> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Hi, opam is installing 108.07.01 for me which seems to have a number
>> of API changes to the previous release (108.00.01 I think?).  But the
>> source on bitbucket seems to correspond to the older version.  Am I
>> missing something obvious or will bitbucket be updated soon?  Or is
>> there some kind of migration documentation available?  Specifically
>> I'm trying to figure out the new Command API.
>>
>> Thanks,
>> /M


From mmatalka at gmail.com  Sun Oct  7 13:25:28 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 14:25:28 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
	<CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
Message-ID: <CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>


https://ocaml.janestreet.com/

The Documentation link on the top next to Code points to
http://www.janestreet.com/ocaml/janestreet-ocamldocs/

/M

On Sun, Oct 7, 2012 at 2:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> I thought we'd killed that link.  Where's the bad documentation link you found?
>
> y
>
> On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Ah thanks, I couldn't find the docs earlier.  It looks like the
>> Documentation link off the Jane St site points to something from 2009,
>> thank you for the correct link.
>>
>> /M
>>
>> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> CC'ing Nathan, who is the primary author of Command.
>>>
>>> We're in a bit of an awkward state with bitbucket right now, though it
>>> will be fixed eventually.  That said, I'm not sure why that's
>>> important to learning the command API: it's all available in the
>>> tarball, after all, which you can get here:
>>>
>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>>
>>> Also, the HTML documentation can be found here:
>>>
>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>>
>>> Also, there's a module called Deprecated_command in Core_extended
>>> (where the old Command lived) that has the old API on top of the new
>>> implementation.
>>>
>>> The new Command uses some pretty clever types to give a good
>>> interface, and we should really publish some examples (which we have
>>> internally).  Nathan, do you have some ideas as to what we can do to
>>> improve the docs?
>>>
>>> y
>>>
>>>
>>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>>> of API changes to the previous release (108.00.01 I think?).  But the
>>>> source on bitbucket seems to correspond to the older version.  Am I
>>>> missing something obvious or will bitbucket be updated soon?  Or is
>>>> there some kind of migration documentation available?  Specifically
>>>> I'm trying to figure out the new Command API.
>>>>
>>>> Thanks,
>>>> /M


From mmatalka at gmail.com  Sun Oct  7 13:40:16 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Sun, 7 Oct 2012 14:40:16 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jQU80SbtFXE6y1gZPRyBm9pGcrKsuXp5+vSOUYw18oPuw@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAKziXDUCn94srFsxCvy6xWg5sgZAmW3=W4ECj36fdLMVC-DLTg@mail.gmail.com>
	<CACLX4jSfgxg4YxqY9_UEgncWnGMHtr0zFAmqAiYpLCCze9tAWg@mail.gmail.com>
	<CAKziXDWGC_vgLigUTctLyY5KMTUAp_1JhVHdY5UZUipOx3tExw@mail.gmail.com>
	<CACLX4jQU80SbtFXE6y1gZPRyBm9pGcrKsuXp5+vSOUYw18oPuw@mail.gmail.com>
Message-ID: <CAKziXDUgX+yzhR__ABzK41Xk_q2-LaBiWcwoi-6ax0qKvLnAcw@mail.gmail.com>


Great, thanks the the quick response!

On Sun, Oct 7, 2012 at 2:36 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Got it.  Will fix.
>
> On Sun, Oct 7, 2012 at 8:25 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> https://ocaml.janestreet.com/
>>
>> The Documentation link on the top next to Code points to
>> http://www.janestreet.com/ocaml/janestreet-ocamldocs/
>>
>> /M
>>
>> On Sun, Oct 7, 2012 at 2:23 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>> I thought we'd killed that link.  Where's the bad documentation link you found?
>>>
>>> y
>>>
>>> On Sun, Oct 7, 2012 at 8:20 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Ah thanks, I couldn't find the docs earlier.  It looks like the
>>>> Documentation link off the Jane St site points to something from 2009,
>>>> thank you for the correct link.
>>>>
>>>> /M
>>>>
>>>> On Sun, Oct 7, 2012 at 2:06 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>>> CC'ing Nathan, who is the primary author of Command.
>>>>>
>>>>> We're in a bit of an awkward state with bitbucket right now, though it
>>>>> will be fixed eventually.  That said, I'm not sure why that's
>>>>> important to learning the command API: it's all available in the
>>>>> tarball, after all, which you can get here:
>>>>>
>>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/
>>>>>
>>>>> Also, the HTML documentation can be found here:
>>>>>
>>>>>    https://ocaml.janestreet.com/ocaml-core/108.07.01/doc/core/Command.Spec.html
>>>>>
>>>>> Also, there's a module called Deprecated_command in Core_extended
>>>>> (where the old Command lived) that has the old API on top of the new
>>>>> implementation.
>>>>>
>>>>> The new Command uses some pretty clever types to give a good
>>>>> interface, and we should really publish some examples (which we have
>>>>> internally).  Nathan, do you have some ideas as to what we can do to
>>>>> improve the docs?
>>>>>
>>>>> y
>>>>>
>>>>>
>>>>> On Sun, Oct 7, 2012 at 6:10 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Hi, opam is installing 108.07.01 for me which seems to have a number
>>>>>> of API changes to the previous release (108.00.01 I think?).  But the
>>>>>> source on bitbucket seems to correspond to the older version.  Am I
>>>>>> missing something obvious or will bitbucket be updated soon?  Or is
>>>>>> there some kind of migration documentation available?  Specifically
>>>>>> I'm trying to figure out the new Command API.
>>>>>>
>>>>>> Thanks,
>>>>>> /M


From anil at recoil.org  Mon Oct  8 02:04:53 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Sun, 7 Oct 2012 18:04:53 -0700
Subject: Error: Unbound value OpamGlobals.os_string
In-Reply-To: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>
References: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>
Message-ID: <9E3D531E-5792-4335-919D-663F31178E4A@recoil.org>


This is fixed by:
https://github.com/OCamlPro/opam/pull/215

but you should be using the 0.7.5 release, as trunk is currently broken in other ways.

-anil

On 7 Oct 2012, at 18:01, Ralph Douglass <ralph at grayskies.net> wrote:

> I just did a git clone (git clone git://github.com/OCamlPro/opam.git), tried to build, and got this:
> 
> [1104.1] '/usr/bin/ocamlc.opt' '-g' '-annot' '-warn-error' 'A' '-c' '-o' '_obuild/1104/opamClient.cmo' '-I' './_obuild/opam-lib' '-I' '.' '-I' './_obuild/re' '-I' './src_ext' '-I' './_obuild/re_perl' '-I' './_obuild/extlib' '-I' './_obuild/cudf' '-I' '/usr/lib64/ocaml' '-I' './_obuild/graph' '-I' './_obuild/dose' '-I' './_obuild/re_glob' 'src/opamClient.ml'
> File "src/opamClient.ml", line 424, characters 16-37:
> Error: Unbound value OpamGlobals.os_string
> 
> I added 'let os_string = string_of_os;;' to src/opamGlobals.ml and was able to carry on.
> 
> Probably not important, but I'm running FC 17.
> 
> -- 
> Ralph



From ralph at grayskies.net  Mon Oct  8 02:01:00 2012
From: ralph at grayskies.net (Ralph Douglass)
Date: Sun, 7 Oct 2012 21:01:00 -0400
Subject: Error: Unbound value OpamGlobals.os_string
Message-ID: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>

I just did a git clone (git clone git://github.com/OCamlPro/opam.git),
tried to build, and got this:

[1104.1] '/usr/bin/ocamlc.opt' '-g' '-annot' '-warn-error' 'A' '-c' '-o'
'_obuild/1104/opamClient.cmo' '-I' './_obuild/opam-lib' '-I' '.' '-I'
'./_obuild/re' '-I' './src_ext' '-I' './_obuild/re_perl' '-I'
'./_obuild/extlib' '-I' './_obuild/cudf' '-I' '/usr/lib64/ocaml' '-I'
'./_obuild/graph' '-I' './_obuild/dose' '-I' './_obuild/re_glob'
'src/opamClient.ml'
File "src/opamClient.ml", line 424, characters 16-37:
Error: Unbound value OpamGlobals.os_string

I added 'let os_string = string_of_os;;' to src/opamGlobals.ml and was able
to carry on.

Probably not important, but I'm running FC 17.

-- 
Ralph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121007/8a6b0a7b/attachment-0001.html>

From ralph at grayskies.net  Mon Oct  8 02:06:01 2012
From: ralph at grayskies.net (Ralph Douglass)
Date: Sun, 7 Oct 2012 21:06:01 -0400
Subject: Error: Unbound value OpamGlobals.os_string
In-Reply-To: <9E3D531E-5792-4335-919D-663F31178E4A@recoil.org>
References: <CAL7hpAm76N36YqfHc=f6jtZvqQLEpDsdzTcEFt0syNS1w2UKCw@mail.gmail.com>
 <9E3D531E-5792-4335-919D-663F31178E4A@recoil.org>
Message-ID: <CAL7hpAkt-Hc7eY_j8PmFp_yS8TAhcFTT0E6LY7cNZ4TO-sJbrA@mail.gmail.com>

Ah got it.  Thanks!

On Sun, Oct 7, 2012 at 9:04 PM, Anil Madhavapeddy <anil at recoil.org> wrote:

> This is fixed by:
> https://github.com/OCamlPro/opam/pull/215
>
> but you should be using the 0.7.5 release, as trunk is currently broken in
> other ways.
>
> -anil
>
> On 7 Oct 2012, at 18:01, Ralph Douglass <ralph at grayskies.net> wrote:
>
> > I just did a git clone (git clone git://github.com/OCamlPro/opam.git),
> tried to build, and got this:
> >
> > [1104.1] '/usr/bin/ocamlc.opt' '-g' '-annot' '-warn-error' 'A' '-c' '-o'
> '_obuild/1104/opamClient.cmo' '-I' './_obuild/opam-lib' '-I' '.' '-I'
> './_obuild/re' '-I' './src_ext' '-I' './_obuild/re_perl' '-I'
> './_obuild/extlib' '-I' './_obuild/cudf' '-I' '/usr/lib64/ocaml' '-I'
> './_obuild/graph' '-I' './_obuild/dose' '-I' './_obuild/re_glob'
> 'src/opamClient.ml'
> > File "src/opamClient.ml", line 424, characters 16-37:
> > Error: Unbound value OpamGlobals.os_string
> >
> > I added 'let os_string = string_of_os;;' to src/opamGlobals.ml and was
> able to carry on.
> >
> > Probably not important, but I'm running FC 17.
> >
> > --
> > Ralph
>
>


-- 
Ralph
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121007/c0777f01/attachment-0001.html>

From nlinger at janestreet.com  Mon Oct  8 14:38:19 2012
From: nlinger at janestreet.com (Nathan Linger)
Date: Mon, 8 Oct 2012 09:38:19 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
Message-ID: <CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>


On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> CC'ing Nathan, who is the primary author of Command.
>
> The new Command uses some pretty clever types to give a good
> interface, and we should really publish some examples (which we have
> internally).  Nathan, do you have some ideas as to what we can do to
> improve the docs?

Malcolm, there is code showing how to use Command in

  core-108.07.01/examples/command/main.ml

There are several examples there.  I will clean up that module in the
future to be even more didatic.  Also, I'll add a reference to this
file in command.mli.


From anil at recoil.org  Tue Oct  9 06:04:16 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Mon, 8 Oct 2012 22:04:16 -0700
Subject: using Async from the toplevel
Message-ID: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>


I can use Lwt from the top-level (especially utop) very easily since the main function (Lwt_main.run) returns when the input thread has completed, and more commands can be typed in.

Scheduler.go () in Async never returns control the toplevel.  Is there a variant you all use to interactively play with Async threads?

-anil




From anil at recoil.org  Tue Oct  9 23:08:10 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Tue, 9 Oct 2012 15:08:10 -0700
Subject: Faster preprocessing
In-Reply-To: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>
References: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>
Message-ID: <90E08C02-80EA-4220-BC94-827A4FC2E171@recoil.org>


That -traverse trick is also really useful when using version-controlled
source trees!

FWIW, when I switched the Mirage build (which builds a complete OS environment)
from byte to native camlp4 [1], the build time dropped from 6.50min to 2.10min.
There was also a significant benefit from bundling all the extensions into a
single pa_mirage, which is also easier from the perspective of ensuring that all
extensions work together.

Have you considered building a Core syntax bundle which could be linked in
*instead* of the individual equivalents?  Until OASIS gets first-class syntax
extension support, this would make the instructions for modifying _tags easier
too.

-anil

[1] https://github.com/avsm/mirage/commit/7468a6129c56b89663615836f4a2314ad88538c9#lib/myocamlbuild.ml

On 9 Oct 2012, at 15:01, Markus Mottl <markus.mottl at gmail.com> wrote:

> This might be a good idea to add to the Core build process:
> https://mancoosi.org/~abate/two-simple-tips-speed-ocaml-compilation
> 
> Since probably most files depend on syntax extensions, using the
> native code preprocessor (camlp4o.opt) and .cmxs preprocessing modules
> could lead to a pretty noticeable speedup.  Adding support for this to
> Oasis should make this even more seamless.
> 
> Regards,
> Markus
> 
> -- 
> Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
> 



From yminsky at janestreet.com  Tue Oct  9 22:19:10 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 9 Oct 2012 17:19:10 -0400
Subject: using Async from the toplevel
In-Reply-To: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
Message-ID: <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>


Looping in Stephen.  I think there's no option now, but there could
be.  One issue now is that the scheduler never shuts down on its own
accord --- even when no jobs are left, it still sits there, waiting in
case, say, a C thread wants to jump into the runtime and do something.

To make this work, we probably need to fix both facts.

y

On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> I can use Lwt from the top-level (especially utop) very easily since the main function (Lwt_main.run) returns when the input thread has completed, and more commands can be typed in.
>
> Scheduler.go () in Async never returns control the toplevel.  Is there a variant you all use to interactively play with Async threads?
>
> -anil
>
>


From yury.sulsky at gmail.com  Tue Oct  9 22:31:57 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Tue, 9 Oct 2012 17:31:57 -0400
Subject: using Async from the toplevel
In-Reply-To: <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
Message-ID: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>

This isn't as nice, but you can execute some commands by blocking on Async
in a separate thread:

# open Core.Std
# open Async.Std;;
# Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
- : Core.Std.Thread.t = <abstr>
# Thread_safe.block_on_async_exn (fun () ->
      Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;


On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:

> Looping in Stephen.  I think there's no option now, but there could
> be.  One issue now is that the scheduler never shuts down on its own
> accord --- even when no jobs are left, it still sits there, waiting in
> case, say, a C thread wants to jump into the runtime and do something.
>
> To make this work, we probably need to fix both facts.
>
> y
>
> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > I can use Lwt from the top-level (especially utop) very easily since the
> main function (Lwt_main.run) returns when the input thread has completed,
> and more commands can be typed in.
> >
> > Scheduler.go () in Async never returns control the toplevel.  Is there a
> variant you all use to interactively play with Async threads?
> >
> > -anil
> >
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121009/87a7427f/attachment-0001.html>

From sweeks at janestreet.com  Tue Oct  9 22:53:56 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Tue, 9 Oct 2012 17:53:56 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
Message-ID: <CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>


> This isn't as nice, but you can execute some commands by blocking on Async
> in a separate thread:
>
> # open Core.Std
> # open Async.Std;;
> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
> - : Core.Std.Thread.t = <abstr>
> # Thread_safe.block_on_async_exn (fun () ->
>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;

I know nothing about the toplevel, but it seems plausible to me that
one could hook something in that wrapped every expression [e] in:

  Thread_safe.block_on_async_exn (fun () -> e)


From markus.mottl at gmail.com  Tue Oct  9 23:01:40 2012
From: markus.mottl at gmail.com (Markus Mottl)
Date: Tue, 9 Oct 2012 18:01:40 -0400
Subject: Faster preprocessing
Message-ID: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>


This might be a good idea to add to the Core build process:
https://mancoosi.org/~abate/two-simple-tips-speed-ocaml-compilation

Since probably most files depend on syntax extensions, using the
native code preprocessor (camlp4o.opt) and .cmxs preprocessing modules
could lead to a pretty noticeable speedup.  Adding support for this to
Oasis should make this even more seamless.

Regards,
Markus

-- 
Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com


From sweeks at janestreet.com  Wed Oct 10 00:25:27 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Tue, 9 Oct 2012 19:25:27 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
Message-ID: <CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>


With the OCaml toplevel and async scheduler running in different
threads, we need to guarantee that they don't interfere with each
other.  It is not necessary to stop the async scheduler; we just have
to prevent it from running while the toplevel is evaluating an input
expression.  This can be accomplished by having the toplevel hold the
async lock while it is evaluating an input expression, and is part of
what is done by wrapping the expression in [block_on_async_exn]:

  val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a

[block_on_async_exn] also waits until the deferred becomes determined,
which may or may not be desirable.  The only key point for correctness
is the locking.  So, all we really need is [run_in_async_exn], which
acquires the lock, but does not block:

  val run_in_async_exn : (unit -> 'a) -> 'a

If people want the ability to block the async scheduler from running,
we could easily add the following functions to [Async.Thread_safe]:

  val  pause_scheduler : unit -> unit
  val resume_scheduler : unit -> unit

Calling [pause_scheduler] would block until it can acquire the async
lock, at which point the scheduler would be prevented from running.
One can then do whatever one wants, without interference from async,
and then, when one is finished, call [resume_scheduler].

But, I've never heard a need for these at Jane Street; we've been able
to get by with [{block_on,run_in}_async_exn].


From yminsky at janestreet.com  Wed Oct 10 01:21:07 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Tue, 9 Oct 2012 20:21:07 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
	<CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
Message-ID: <CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>


On a related note, have you ever considered having the async scheduler
stop running when it runs out of jobs?  It has been argued that this
would make simple command-line apps simpler, since they would exit
automatically when the work was done.  I'm sure there are complexities
here...

y

On Tue, Oct 9, 2012 at 7:25 PM, Stephen Weeks <sweeks at janestreet.com> wrote:
> With the OCaml toplevel and async scheduler running in different
> threads, we need to guarantee that they don't interfere with each
> other.  It is not necessary to stop the async scheduler; we just have
> to prevent it from running while the toplevel is evaluating an input
> expression.  This can be accomplished by having the toplevel hold the
> async lock while it is evaluating an input expression, and is part of
> what is done by wrapping the expression in [block_on_async_exn]:
>
>   val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a
>
> [block_on_async_exn] also waits until the deferred becomes determined,
> which may or may not be desirable.  The only key point for correctness
> is the locking.  So, all we really need is [run_in_async_exn], which
> acquires the lock, but does not block:
>
>   val run_in_async_exn : (unit -> 'a) -> 'a
>
> If people want the ability to block the async scheduler from running,
> we could easily add the following functions to [Async.Thread_safe]:
>
>   val  pause_scheduler : unit -> unit
>   val resume_scheduler : unit -> unit
>
> Calling [pause_scheduler] would block until it can acquire the async
> lock, at which point the scheduler would be prevented from running.
> One can then do whatever one wants, without interference from async,
> and then, when one is finished, call [resume_scheduler].
>
> But, I've never heard a need for these at Jane Street; we've been able
> to get by with [{block_on,run_in}_async_exn].


From mmatalka at gmail.com  Tue Oct  9 22:40:15 2012
From: mmatalka at gmail.com (Malcolm)
Date: Tue, 9 Oct 2012 23:40:15 +0200
Subject: using Async from the toplevel
In-Reply-To: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org> <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com> <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
Message-ID: <A6DE786C-E82B-4DFF-9E0A-9B8726084761@gmail.com>


Once nice thing about the Lwt way is sometimes I have a program that is 80% sequential work and at a few key places I want to do concurrent things, which just likes like thing1 (); thing2 (); let res = Lwt.run (thing_that_returns_a_lwt_thread ()); thing3 ();  etc.  Having an interface similar to Lwt's here gets my vote.

/Malcolm

On Oct 9, 2012, at 11:31 PM, Yury Sulsky wrote:

> This isn't as nice, but you can execute some commands by blocking on Async in a separate thread:
> 
> # open Core.Std
> # open Async.Std;;
> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
> - : Core.Std.Thread.t = <abstr>
> # Thread_safe.block_on_async_exn (fun () ->
>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
> 
> 
> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
> Looping in Stephen.  I think there's no option now, but there could
> be.  One issue now is that the scheduler never shuts down on its own
> accord --- even when no jobs are left, it still sits there, waiting in
> case, say, a C thread wants to jump into the runtime and do something.
> 
> To make this work, we probably need to fix both facts.
> 
> y
> 
> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
> > I can use Lwt from the top-level (especially utop) very easily since the main function (Lwt_main.run) returns when the input thread has completed, and more commands can be typed in.
> >
> > Scheduler.go () in Async never returns control the toplevel.  Is there a variant you all use to interactively play with Async threads?
> >
> > -anil
> >
> >
> 



From nlinger at janestreet.com  Wed Oct 10 14:02:16 2012
From: nlinger at janestreet.com (Nathan Linger)
Date: Wed, 10 Oct 2012 09:02:16 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
Message-ID: <CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com>


I remember Stephen and I wishing for a version of the toplevel that
would allow you to apply a macro like this to each input, for this
very reason.

E --> Thread_safe.block_on_async_exn (fun () -> E)

On Tue, Oct 9, 2012 at 5:31 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> This isn't as nice, but you can execute some commands by blocking on Async
> in a separate thread:
>
> # open Core.Std
> # open Async.Std;;
> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
> - : Core.Std.Thread.t = <abstr>
> # Thread_safe.block_on_async_exn (fun () ->
>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
>
>
>
> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>
>> Looping in Stephen.  I think there's no option now, but there could
>> be.  One issue now is that the scheduler never shuts down on its own
>> accord --- even when no jobs are left, it still sits there, waiting in
>> case, say, a C thread wants to jump into the runtime and do something.
>>
>> To make this work, we probably need to fix both facts.
>>
>> y
>>
>> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>> > I can use Lwt from the top-level (especially utop) very easily since the
>> > main function (Lwt_main.run) returns when the input thread has completed,
>> > and more commands can be typed in.
>> >
>> > Scheduler.go () in Async never returns control the toplevel.  Is there a
>> > variant you all use to interactively play with Async threads?
>> >
>> > -anil
>> >
>> >
>
>


From yminsky at janestreet.com  Wed Oct 10 14:03:55 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 10 Oct 2012 09:03:55 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAK=fH+jfnrRhzadV=Pv4k3krHPoutohzmsbe6im=BuXvWoLv_Q@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
	<CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
	<CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>
	<CAK=fH+jfnrRhzadV=Pv4k3krHPoutohzmsbe6im=BuXvWoLv_Q@mail.gmail.com>
Message-ID: <CACLX4jTNWQai_W8VcShSD9hu1qwR6QkHeb6ZrkGC3jO7MgLwjg@mail.gmail.com>


I do think something like this would make sense.  You might still need
to keep the scheduler open indefinitely for other cases, like when a
thread created in some other way (e.g., 3rd-party library spins up its
own thread), but one can specify this as necessary.

y

On Wed, Oct 10, 2012 at 4:55 AM, David House <dhouse at janestreet.com> wrote:
> I've thought about that before, but didn't you answer that yourself a
> few emails ago? What if one does an In_thread.run that blocks for some
> time and then schedules a job?
>
> But actually, I think this can gotten around. The criterion for
> returning from the scheduler would be:
>
> * No jobs on the job queue
> * No fds being select()ed for writing
> * The only fd being select()ed for reading is the interruptor
> * No timer events
> * No threads in the thread pool have work (Thread_pool.unfinished_work
> is 0 -- this is currently not exposed, but I think it could be).
>
> This adds the requirement that if one wants to create threads in
> async, you must go through In_thread. At the moment, one could
> presumably do a Core.Std.Thread.create that essentially reimplements
> In_thread.run. It seems fine to disallow this. We'd probably want to
> shadow Thread.create in the same way we do other verboten functions
> from Core.
>
> Stephen, what do you think?
>
> On Wed, Oct 10, 2012 at 1:21 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> On a related note, have you ever considered having the async scheduler
>> stop running when it runs out of jobs?  It has been argued that this
>> would make simple command-line apps simpler, since they would exit
>> automatically when the work was done.  I'm sure there are complexities
>> here...
>>
>> y
>>
>> On Tue, Oct 9, 2012 at 7:25 PM, Stephen Weeks <sweeks at janestreet.com> wrote:
>>> With the OCaml toplevel and async scheduler running in different
>>> threads, we need to guarantee that they don't interfere with each
>>> other.  It is not necessary to stop the async scheduler; we just have
>>> to prevent it from running while the toplevel is evaluating an input
>>> expression.  This can be accomplished by having the toplevel hold the
>>> async lock while it is evaluating an input expression, and is part of
>>> what is done by wrapping the expression in [block_on_async_exn]:
>>>
>>>   val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a
>>>
>>> [block_on_async_exn] also waits until the deferred becomes determined,
>>> which may or may not be desirable.  The only key point for correctness
>>> is the locking.  So, all we really need is [run_in_async_exn], which
>>> acquires the lock, but does not block:
>>>
>>>   val run_in_async_exn : (unit -> 'a) -> 'a
>>>
>>> If people want the ability to block the async scheduler from running,
>>> we could easily add the following functions to [Async.Thread_safe]:
>>>
>>>   val  pause_scheduler : unit -> unit
>>>   val resume_scheduler : unit -> unit
>>>
>>> Calling [pause_scheduler] would block until it can acquire the async
>>> lock, at which point the scheduler would be prevented from running.
>>> One can then do whatever one wants, without interference from async,
>>> and then, when one is finished, call [resume_scheduler].
>>>
>>> But, I've never heard a need for these at Jane Street; we've been able
>>> to get by with [{block_on,run_in}_async_exn].


From yminsky at janestreet.com  Wed Oct 10 14:04:59 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Wed, 10 Oct 2012 09:04:59 -0400
Subject: using Async from the toplevel
In-Reply-To: <CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com>
Message-ID: <CACLX4jSsCy9ghvXwgbj8CW3V=ubfcvYL4rOq3C_-JNWr2Z0T8Q@mail.gmail.com>


I think Anil is working on a hack for utop (Jeremie Dimino's
alternative toplevel) to do just this, based on the type of the return
value.

y

On Wed, Oct 10, 2012 at 9:02 AM, Nathan Linger <nlinger at janestreet.com> wrote:
> I remember Stephen and I wishing for a version of the toplevel that
> would allow you to apply a macro like this to each input, for this
> very reason.
>
> E --> Thread_safe.block_on_async_exn (fun () -> E)
>
> On Tue, Oct 9, 2012 at 5:31 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>> This isn't as nice, but you can execute some commands by blocking on Async
>> in a separate thread:
>>
>> # open Core.Std
>> # open Async.Std;;
>> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
>> - : Core.Std.Thread.t = <abstr>
>> # Thread_safe.block_on_async_exn (fun () ->
>>       Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
>>
>>
>>
>> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>
>>> Looping in Stephen.  I think there's no option now, but there could
>>> be.  One issue now is that the scheduler never shuts down on its own
>>> accord --- even when no jobs are left, it still sits there, waiting in
>>> case, say, a C thread wants to jump into the runtime and do something.
>>>
>>> To make this work, we probably need to fix both facts.
>>>
>>> y
>>>
>>> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>> > I can use Lwt from the top-level (especially utop) very easily since the
>>> > main function (Lwt_main.run) returns when the input thread has completed,
>>> > and more commands can be typed in.
>>> >
>>> > Scheduler.go () in Async never returns control the toplevel.  Is there a
>>> > variant you all use to interactively play with Async threads?
>>> >
>>> > -anil
>>> >
>>> >
>>
>>


From gildor478 at gmail.com  Wed Oct 10 08:16:14 2012
From: gildor478 at gmail.com (Sylvain Le Gall)
Date: Wed, 10 Oct 2012 09:16:14 +0200
Subject: Faster preprocessing
In-Reply-To: <90E08C02-80EA-4220-BC94-827A4FC2E171@recoil.org>
References: <CAP_800ocLocj2BG6Gf7HF=8tryYN177=EpgkV4kUKUG7W5koVw@mail.gmail.com>
	<90E08C02-80EA-4220-BC94-827A4FC2E171@recoil.org>
Message-ID: <CAOCAUGMJjGGkza1zJdoimT_0ErzrCONnd7W2Fk2vubQfy1UBDw@mail.gmail.com>

A traverse trick avoiding .git is already implemented is  OASIS. I will
think about the native camlp4/cmxs when implementing syntax-extension.
Le 10 oct. 2012 00:08, "Anil Madhavapeddy" <anil at recoil.org> a ?crit :

> That -traverse trick is also really useful when using version-controlled
> source trees!
>
> FWIW, when I switched the Mirage build (which builds a complete OS
> environment)
> from byte to native camlp4 [1], the build time dropped from 6.50min to
> 2.10min.
> There was also a significant benefit from bundling all the extensions into
> a
> single pa_mirage, which is also easier from the perspective of ensuring
> that all
> extensions work together.
>
> Have you considered building a Core syntax bundle which could be linked in
> *instead* of the individual equivalents?  Until OASIS gets first-class
> syntax
> extension support, this would make the instructions for modifying _tags
> easier
> too.
>
> -anil
>
> [1]
> https://github.com/avsm/mirage/commit/7468a6129c56b89663615836f4a2314ad88538c9#lib/myocamlbuild.ml
>
> On 9 Oct 2012, at 15:01, Markus Mottl <markus.mottl at gmail.com> wrote:
>
> > This might be a good idea to add to the Core build process:
> > https://mancoosi.org/~abate/two-simple-tips-speed-ocaml-compilation
> >
> > Since probably most files depend on syntax extensions, using the
> > native code preprocessor (camlp4o.opt) and .cmxs preprocessing modules
> > could lead to a pretty noticeable speedup.  Adding support for this to
> > Oasis should make this even more seamless.
> >
> > Regards,
> > Markus
> >
> > --
> > Markus Mottl        http://www.ocaml.info        markus.mottl at gmail.com
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121010/8fc5bc6f/attachment-0001.html>

From dhouse at janestreet.com  Wed Oct 10 09:55:51 2012
From: dhouse at janestreet.com (David House)
Date: Wed, 10 Oct 2012 09:55:51 +0100
Subject: using Async from the toplevel
In-Reply-To: <CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org>
	<CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com>
	<CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com>
	<CAPYVAi+VCAhT4XNRgHLG0PL68-jpgugxjju998M3=vyhomEwgw@mail.gmail.com>
	<CAPYVAiLmp7zTc5xrVXVJ9GRZacK4ojCBYkOHs8wRwxQPw5XqXw@mail.gmail.com>
	<CACLX4jRY5j7wmYMj975yTcncnU0BdsJXwCDgFaL=H4gcYcyELQ@mail.gmail.com>
Message-ID: <CAK=fH+jfnrRhzadV=Pv4k3krHPoutohzmsbe6im=BuXvWoLv_Q@mail.gmail.com>


I've thought about that before, but didn't you answer that yourself a
few emails ago? What if one does an In_thread.run that blocks for some
time and then schedules a job?

But actually, I think this can gotten around. The criterion for
returning from the scheduler would be:

* No jobs on the job queue
* No fds being select()ed for writing
* The only fd being select()ed for reading is the interruptor
* No timer events
* No threads in the thread pool have work (Thread_pool.unfinished_work
is 0 -- this is currently not exposed, but I think it could be).

This adds the requirement that if one wants to create threads in
async, you must go through In_thread. At the moment, one could
presumably do a Core.Std.Thread.create that essentially reimplements
In_thread.run. It seems fine to disallow this. We'd probably want to
shadow Thread.create in the same way we do other verboten functions
from Core.

Stephen, what do you think?

On Wed, Oct 10, 2012 at 1:21 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
> On a related note, have you ever considered having the async scheduler
> stop running when it runs out of jobs?  It has been argued that this
> would make simple command-line apps simpler, since they would exit
> automatically when the work was done.  I'm sure there are complexities
> here...
>
> y
>
> On Tue, Oct 9, 2012 at 7:25 PM, Stephen Weeks <sweeks at janestreet.com> wrote:
>> With the OCaml toplevel and async scheduler running in different
>> threads, we need to guarantee that they don't interfere with each
>> other.  It is not necessary to stop the async scheduler; we just have
>> to prevent it from running while the toplevel is evaluating an input
>> expression.  This can be accomplished by having the toplevel hold the
>> async lock while it is evaluating an input expression, and is part of
>> what is done by wrapping the expression in [block_on_async_exn]:
>>
>>   val block_on_async_exn : (unit -> 'a Deferred.t) -> 'a
>>
>> [block_on_async_exn] also waits until the deferred becomes determined,
>> which may or may not be desirable.  The only key point for correctness
>> is the locking.  So, all we really need is [run_in_async_exn], which
>> acquires the lock, but does not block:
>>
>>   val run_in_async_exn : (unit -> 'a) -> 'a
>>
>> If people want the ability to block the async scheduler from running,
>> we could easily add the following functions to [Async.Thread_safe]:
>>
>>   val  pause_scheduler : unit -> unit
>>   val resume_scheduler : unit -> unit
>>
>> Calling [pause_scheduler] would block until it can acquire the async
>> lock, at which point the scheduler would be prevented from running.
>> One can then do whatever one wants, without interference from async,
>> and then, when one is finished, call [resume_scheduler].
>>
>> But, I've never heard a need for these at Jane Street; we've been able
>> to get by with [{block_on,run_in}_async_exn].


From yury.sulsky at gmail.com  Wed Oct 10 15:30:15 2012
From: yury.sulsky at gmail.com (Yury Sulsky)
Date: Wed, 10 Oct 2012 10:30:15 -0400
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
	<CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>
Message-ID: <CAEDxudxJ2KoT2qyHLJd=i82hXnZCe2HbfzuNbzMB4jiELTegCA@mail.gmail.com>

Malcolm,

The source on bitbucket is out of date (this will be rectified with the
next release). You should get the release tarballs here:
http://ocaml.janestreet.com/ocaml-core/latest

Yury

On Wed, Oct 10, 2012 at 10:11 AM, Malcolm Matalka <mmatalka at gmail.com>wrote:

> Thanks Nathan,
>
> Where can I find core-108.07.01/examples/command/main.ml?  Bitbucket
> doesn't appear to have that version up.  AFAIK Bitbucket is the only
> place to get the source, is there another location?
>
> Many thanks!
>
> /M
>
> On Mon, Oct 8, 2012 at 3:38 PM, Nathan Linger <nlinger at janestreet.com>
> wrote:
> > On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com>
> wrote:
> >> CC'ing Nathan, who is the primary author of Command.
> >>
> >> The new Command uses some pretty clever types to give a good
> >> interface, and we should really publish some examples (which we have
> >> internally).  Nathan, do you have some ideas as to what we can do to
> >> improve the docs?
> >
> > Malcolm, there is code showing how to use Command in
> >
> >   core-108.07.01/examples/command/main.ml
> >
> > There are several examples there.  I will clean up that module in the
> > future to be even more didatic.  Also, I'll add a reference to this
> > file in command.mli.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121010/dfc394a4/attachment-0001.html>

From mmatalka at gmail.com  Wed Oct 10 15:11:33 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Wed, 10 Oct 2012 16:11:33 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
Message-ID: <CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>


Thanks Nathan,

Where can I find core-108.07.01/examples/command/main.ml?  Bitbucket
doesn't appear to have that version up.  AFAIK Bitbucket is the only
place to get the source, is there another location?

Many thanks!

/M

On Mon, Oct 8, 2012 at 3:38 PM, Nathan Linger <nlinger at janestreet.com> wrote:
> On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com> wrote:
>> CC'ing Nathan, who is the primary author of Command.
>>
>> The new Command uses some pretty clever types to give a good
>> interface, and we should really publish some examples (which we have
>> internally).  Nathan, do you have some ideas as to what we can do to
>> improve the docs?
>
> Malcolm, there is code showing how to use Command in
>
>   core-108.07.01/examples/command/main.ml
>
> There are several examples there.  I will clean up that module in the
> future to be even more didatic.  Also, I'll add a reference to this
> file in command.mli.


From mmatalka at gmail.com  Wed Oct 10 15:41:59 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Wed, 10 Oct 2012 16:41:59 +0200
Subject: opam and bitbucket out of sync?
In-Reply-To: <CAEDxudxJ2KoT2qyHLJd=i82hXnZCe2HbfzuNbzMB4jiELTegCA@mail.gmail.com>
References: <CAKziXDWi5_48=K4By=UB2vd_qZEW5tJ_v=WhXYFpW-d8kReUZA@mail.gmail.com>
	<CACLX4jSMGZQ0zHWMD9FBE7SaLzA=yyZhW6RX6ZRCe_Nz-6HJ+w@mail.gmail.com>
	<CAB1twEaG0gg6GviBaBdA1P7W1O8n9oPh7nhHn1osh+f=VPeU3w@mail.gmail.com>
	<CAKziXDUKJT1QxPH_NYs3Z_nLieZg+hF7iCrvT81aOq2sJDfgUw@mail.gmail.com>
	<CAEDxudxJ2KoT2qyHLJd=i82hXnZCe2HbfzuNbzMB4jiELTegCA@mail.gmail.com>
Message-ID: <CAKziXDU38U5x22B1Fukxf7+288LuvLG9EJPD7GErn=oG3qSBew@mail.gmail.com>


Ah great thank you.  It looks like only the docs dir is linked to off
ocaml.janestreet.com, perhaps adding a link to this dir would be a
good idea too, unless I'm missing it.

Thanks again.

On Wed, Oct 10, 2012 at 4:30 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
> Malcolm,
>
> The source on bitbucket is out of date (this will be rectified with the next
> release). You should get the release tarballs here:
> http://ocaml.janestreet.com/ocaml-core/latest
>
> Yury
>
>
> On Wed, Oct 10, 2012 at 10:11 AM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
>>
>> Thanks Nathan,
>>
>> Where can I find core-108.07.01/examples/command/main.ml?  Bitbucket
>> doesn't appear to have that version up.  AFAIK Bitbucket is the only
>> place to get the source, is there another location?
>>
>> Many thanks!
>>
>> /M
>>
>> On Mon, Oct 8, 2012 at 3:38 PM, Nathan Linger <nlinger at janestreet.com>
>> wrote:
>> > On Sun, Oct 7, 2012 at 8:06 AM, Yaron Minsky <yminsky at janestreet.com>
>> > wrote:
>> >> CC'ing Nathan, who is the primary author of Command.
>> >>
>> >> The new Command uses some pretty clever types to give a good
>> >> interface, and we should really publish some examples (which we have
>> >> internally).  Nathan, do you have some ideas as to what we can do to
>> >> improve the docs?
>> >
>> > Malcolm, there is code showing how to use Command in
>> >
>> >   core-108.07.01/examples/command/main.ml
>> >
>> > There are several examples there.  I will clean up that module in the
>> > future to be even more didatic.  Also, I'll add a reference to this
>> > file in command.mli.
>
>


From dmhouse at gmail.com  Thu Oct 11 21:48:00 2012
From: dmhouse at gmail.com (David House)
Date: Thu, 11 Oct 2012 21:48:00 +0100
Subject: Async: Fd not getting closed?
In-Reply-To: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>
References: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>
Message-ID: <CADy1MaskAfTX4nO+Lhb_RB+f96im3RicSaRuhvVms084A-K9xA@mail.gmail.com>


Some general comments first:

* read_all seems to be trying to achieve the same thing as Reader.contents

* Is there any reason why you're using Core's waitpid function over
Async.Std.Unix.wait?

* Ivar.read (background foo) is equivalent to just foo, and you only
ever use the result of background inside an Ivar.read, so I think
background is pointless.

It's not immediately apparent where the actual bug is. One thing to
ask: do you get past the wait call, or are you getting stuck inside
one of the Deferred.both's? I.e. if you put a printf straight after
wait, do you see it? (Best to use [Printf.printf "foo\n%!"]; the
Printf module avoids going via Writer's buffer in case something weird
is going on, and you should always flush your debugging statements
with "%!"!)

On 11 October 2012 21:29, Malcolm Matalka <mmatalka at gmail.com> wrote:
> I have some dirty code here: http://ideone.com/WG9mN
>
> To compile:
>
> ocamlfind ocamlopt -package core,async -thread -linkpkg -o foo foo.ml
>
> The problem is the 'wait' never seems to come back. This appears to be
> because the cat is still waiting on reading stdin.  But the stdin
> should be closed on line 77, shouldn't it?
>
> What am I doing wrong?
>
> Thanks!
>
> /M


From mmatalka at gmail.com  Thu Oct 11 21:29:34 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Thu, 11 Oct 2012 22:29:34 +0200
Subject: Async: Fd not getting closed?
Message-ID: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>


I have some dirty code here: http://ideone.com/WG9mN

To compile:

ocamlfind ocamlopt -package core,async -thread -linkpkg -o foo foo.ml

The problem is the 'wait' never seems to come back. This appears to be
because the cat is still waiting on reading stdin.  But the stdin
should be closed on line 77, shouldn't it?

What am I doing wrong?

Thanks!

/M


From mmatalka at gmail.com  Thu Oct 11 22:00:25 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Thu, 11 Oct 2012 23:00:25 +0200
Subject: Async: Fd not getting closed?
In-Reply-To: <CADy1MaskAfTX4nO+Lhb_RB+f96im3RicSaRuhvVms084A-K9xA@mail.gmail.com>
References: <CAKziXDUM65NckRku0Uh5LPKjTHaNdP4_xna4QXvS-pwh8jfLhA@mail.gmail.com>
	<CADy1MaskAfTX4nO+Lhb_RB+f96im3RicSaRuhvVms084A-K9xA@mail.gmail.com>
Message-ID: <CAKziXDVW-fvD4WPYC+OHCekc=sVD8L3Fg2vM+bmrpOt=eo0KrA@mail.gmail.com>


Yes the code is in transition as I learn more about Async, so take all
non essentials with a grain of salt.

I switched the wait function to:

let wait pi =
  Unix.wait (`Pid (Core.Std.Pid.of_int pi.pid)) >>= function
    | (_, Result.Ok ()) ->
      Deferred.return (`Exited 0)
    | (_, Result.Error (`Exit_non_zero n)) ->
      Deferred.return (`Exited n)
    | (_, _) ->
      Deferred.return `Unknown


with no change in behaviour.

I do not get past the wait call and a ps shows the cat is still
running.  This function works properly for a program that doesn't read
from stdin such as an ls, which is what leads me to think somehow
stdin is not getting closed properly.

Thanks for the quick response,
/M

On Thu, Oct 11, 2012 at 10:48 PM, David House <dmhouse at gmail.com> wrote:
> Some general comments first:
>
> * read_all seems to be trying to achieve the same thing as Reader.contents
>
> * Is there any reason why you're using Core's waitpid function over
> Async.Std.Unix.wait?
>
> * Ivar.read (background foo) is equivalent to just foo, and you only
> ever use the result of background inside an Ivar.read, so I think
> background is pointless.
>
> It's not immediately apparent where the actual bug is. One thing to
> ask: do you get past the wait call, or are you getting stuck inside
> one of the Deferred.both's? I.e. if you put a printf straight after
> wait, do you see it? (Best to use [Printf.printf "foo\n%!"]; the
> Printf module avoids going via Writer's buffer in case something weird
> is going on, and you should always flush your debugging statements
> with "%!"!)
>
> On 11 October 2012 21:29, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> I have some dirty code here: http://ideone.com/WG9mN
>>
>> To compile:
>>
>> ocamlfind ocamlopt -package core,async -thread -linkpkg -o foo foo.ml
>>
>> The problem is the 'wait' never seems to come back. This appears to be
>> because the cat is still waiting on reading stdin.  But the stdin
>> should be closed on line 77, shouldn't it?
>>
>> What am I doing wrong?
>>
>> Thanks!
>>
>> /M


From anil at recoil.org  Mon Oct 15 07:11:22 2012
From: anil at recoil.org (Anil Madhavapeddy)
Date: Sun, 14 Oct 2012 23:11:22 -0700
Subject: using Async from the toplevel
In-Reply-To: <CACLX4jSsCy9ghvXwgbj8CW3V=ubfcvYL4rOq3C_-JNWr2Z0T8Q@mail.gmail.com>
References: <88912021-305D-4278-A28F-02272EFDCF40@recoil.org> <CACLX4jTpwUaAk_cb3ZcPPyqi+Kn4Cf9fMXShFJtypigHLTm-gQ@mail.gmail.com> <CAEDxudx7vGnA-w_c3ezWf=p3ZTVUH+-O-9tLZAgQRhoGBjGPPA@mail.gmail.com> <CAB1twEbPCqdKHYFZLEzPsV_rUhYO=sSKyF3SuUvVv2H-Zn3kSQ@mail.gmail.com> <CACLX4jSsCy9ghvXwgbj8CW3V=ubfcvYL4rOq3C_-JNWr2Z0T8Q@mail.gmail.com>
Message-ID: <1E4167A1-4A09-4B8C-A225-8C26EDFF7531@recoil.org>

Yeah, patch attached works fine for me.  It could use some factoring with
the Lwt Parsetree manipulation to reduce duplicated code, but the functionality
works great...

utop $ after (Time.Span.of_sec 2.0);;
<waits 2 seconds>
- : unit = ()                                                                                                                                                                    
utop $ let x = after (Time.Span.of_sec 2.0);;
val x : unit Async_core.Deferred.t = <abstr> 

Darcs diff attached.  I'm going to try and get the native code utop patches
working in OPAM next, to make the top-level less sluggish when using Async.

-------------- next part --------------

-anil

On 10 Oct 2012, at 06:04, Yaron Minsky <yminsky at janestreet.com> wrote:

> I think Anil is working on a hack for utop (Jeremie Dimino's
> alternative toplevel) to do just this, based on the type of the return
> value.
> 
> y
> 
> On Wed, Oct 10, 2012 at 9:02 AM, Nathan Linger <nlinger at janestreet.com> wrote:
>> I remember Stephen and I wishing for a version of the toplevel that
>> would allow you to apply a macro like this to each input, for this
>> very reason.
>> 
>> E --> Thread_safe.block_on_async_exn (fun () -> E)
>> 
>> On Tue, Oct 9, 2012 at 5:31 PM, Yury Sulsky <yury.sulsky at gmail.com> wrote:
>>> This isn't as nice, but you can execute some commands by blocking on Async
>>> in a separate thread:
>>> 
>>> # open Core.Std
>>> # open Async.Std;;
>>> # Thread.create (fun () -> never_returns (Scheduler.go ())) ();;
>>> - : Core.Std.Thread.t = <abstr>
>>> # Thread_safe.block_on_async_exn (fun () ->
>>>      Clock.after (sec 1.0) >>| fun () -> printf "hi from async\n%!");;
>>> 
>>> 
>>> 
>>> On Tue, Oct 9, 2012 at 5:19 PM, Yaron Minsky <yminsky at janestreet.com> wrote:
>>>> 
>>>> Looping in Stephen.  I think there's no option now, but there could
>>>> be.  One issue now is that the scheduler never shuts down on its own
>>>> accord --- even when no jobs are left, it still sits there, waiting in
>>>> case, say, a C thread wants to jump into the runtime and do something.
>>>> 
>>>> To make this work, we probably need to fix both facts.
>>>> 
>>>> y
>>>> 
>>>> On Tue, Oct 9, 2012 at 1:04 AM, Anil Madhavapeddy <anil at recoil.org> wrote:
>>>>> I can use Lwt from the top-level (especially utop) very easily since the
>>>>> main function (Lwt_main.run) returns when the input thread has completed,
>>>>> and more commands can be typed in.
>>>>> 
>>>>> Scheduler.go () in Async never returns control the toplevel.  Is there a
>>>>> variant you all use to interactively play with Async threads?
>>>>> 
>>>>> -anil
>>>>> 
>>>>> 
>>> 
>>> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: utop-async-darcs.diff
Type: application/octet-stream
Size: 7922 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121014/f7406997/attachment-0001.obj>

From mmatalka at gmail.com  Mon Oct 15 09:01:02 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 10:01:02 +0200
Subject: File descriptor semantics in Core/Async?
Message-ID: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>


Hello, I'm wondering if Core or Async addresses this bug:
http://caml.inria.fr/mantis/view.php?id=5256

I have a situation where I'm reading/writing many files and spawning
subprocesses in Async and the subprocesses are inheriting the opened
FDs which is problematic for me.  I am using the ocaml stdlib
create_process for this as the Core version was causing segfaults for
me on OS X, but now I am mainly targeting Linux so I can switch batch
to Core's create_process if it solves this issue.  I poked around the
source code but didn't see anything in the comments about what happens
to open fd's after forking.

Thanks,
/M


From dhouse at janestreet.com  Mon Oct 15 10:01:48 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:01:48 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
Message-ID: <CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>


Hmm, how are you opening the files? Xavier in that thread claims that
if you use Pervasives.open_in or Pervasives.open_out, then
close-on-exec will be set for those file descriptors. The same is true
of Core.{In,Out}_channel.create.

That being said, I'm not actually sure that Async's Reader and Writer
are doing this, which is a little embarrassing. It's quite possible
this is deliberate; let me follow up internally,

On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Hello, I'm wondering if Core or Async addresses this bug:
> http://caml.inria.fr/mantis/view.php?id=5256
>
> I have a situation where I'm reading/writing many files and spawning
> subprocesses in Async and the subprocesses are inheriting the opened
> FDs which is problematic for me.  I am using the ocaml stdlib
> create_process for this as the Core version was causing segfaults for
> me on OS X, but now I am mainly targeting Linux so I can switch batch
> to Core's create_process if it solves this issue.  I poked around the
> source code but didn't see anything in the comments about what happens
> to open fd's after forking.
>
> Thanks,
> /M


From dhouse at janestreet.com  Mon Oct 15 10:06:40 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:06:40 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
Message-ID: <CAK=fH+hgfp3RhVmxvKZPc_7BcJsogecvq6iTAfc66h2OZZ6oDQ@mail.gmail.com>


By the way, the slightly scary (rather than merely inconvenient) case
is covered by async: if you use the tcp library to start a server,
that *will* call set_close_on_exec on the new file descriptor.

On Mon, Oct 15, 2012 at 10:01 AM, David House <dhouse at janestreet.com> wrote:
> Hmm, how are you opening the files? Xavier in that thread claims that
> if you use Pervasives.open_in or Pervasives.open_out, then
> close-on-exec will be set for those file descriptors. The same is true
> of Core.{In,Out}_channel.create.
>
> That being said, I'm not actually sure that Async's Reader and Writer
> are doing this, which is a little embarrassing. It's quite possible
> this is deliberate; let me follow up internally,
>
> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Hello, I'm wondering if Core or Async addresses this bug:
>> http://caml.inria.fr/mantis/view.php?id=5256
>>
>> I have a situation where I'm reading/writing many files and spawning
>> subprocesses in Async and the subprocesses are inheriting the opened
>> FDs which is problematic for me.  I am using the ocaml stdlib
>> create_process for this as the Core version was causing segfaults for
>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>> to Core's create_process if it solves this issue.  I poked around the
>> source code but didn't see anything in the comments about what happens
>> to open fd's after forking.
>>
>> Thanks,
>> /M


From dhouse at janestreet.com  Mon Oct 15 10:26:28 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:26:28 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
Message-ID: <CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>


Oh, there is an easier fix than that. One can either call
Unix.set_close_on_exec on the underlying file descriptor (use
Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)

On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> One option I have is to write to a temporary filename then spawn a
> 'cp' to copy the temp file to the actual file, but that seems less
> than ideal.  The specific problem is I am writing shell scripts that
> will be run, and I'm spawning shell scripts at the same time, so if I
> spawn a shell script while writing a shell script, the written script
> cannot be executed until the running one is completed.
>
> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> I'm using Writer.with_file in this case.  I poked around the source
>> code but my Unix knowledge isn't strong enough to know what's right or
>> wrong.
>>
>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>> close-on-exec will be set for those file descriptors. The same is true
>>> of Core.{In,Out}_channel.create.
>>>
>>> That being said, I'm not actually sure that Async's Reader and Writer
>>> are doing this, which is a little embarrassing. It's quite possible
>>> this is deliberate; let me follow up internally,
>>>
>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>
>>>> I have a situation where I'm reading/writing many files and spawning
>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>> create_process for this as the Core version was causing segfaults for
>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>> to Core's create_process if it solves this issue.  I poked around the
>>>> source code but didn't see anything in the comments about what happens
>>>> to open fd's after forking.
>>>>
>>>> Thanks,
>>>> /M


From dhouse at janestreet.com  Mon Oct 15 10:35:20 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 10:35:20 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
Message-ID: <CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>


The context switch points in async are exactly the points where bind
appears. Blocks of code without a bind (or >>|, of course) inside them
are guaranteed to run uninterruptedly.

Looking at the source of Writer.with_file, it looks like you do not
have the guarantee that you want. It calls Unix.openfile, and then
there is a bind, so something else could run (depending, of course, on
the exact pattern of concurrency in your program).

Writer.of_out_channel, however, will give you the guarantees you want.
(It does not have a deferred return type so cannot be doing binds
internally.)

On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Am I guaranteed that no code will run between Writer.with_file
> creating the FD and my handler being run so I can set close on exec?
>
> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>> Oh, there is an easier fix than that. One can either call
>> Unix.set_close_on_exec on the underlying file descriptor (use
>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>
>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> One option I have is to write to a temporary filename then spawn a
>>> 'cp' to copy the temp file to the actual file, but that seems less
>>> than ideal.  The specific problem is I am writing shell scripts that
>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>> spawn a shell script while writing a shell script, the written script
>>> cannot be executed until the running one is completed.
>>>
>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>> wrong.
>>>>
>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>> of Core.{In,Out}_channel.create.
>>>>>
>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>> this is deliberate; let me follow up internally,
>>>>>
>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>
>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>> source code but didn't see anything in the comments about what happens
>>>>>> to open fd's after forking.
>>>>>>
>>>>>> Thanks,
>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 10:06:56 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:06:56 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
Message-ID: <CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>


I'm using Writer.with_file in this case.  I poked around the source
code but my Unix knowledge isn't strong enough to know what's right or
wrong.

On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
> Hmm, how are you opening the files? Xavier in that thread claims that
> if you use Pervasives.open_in or Pervasives.open_out, then
> close-on-exec will be set for those file descriptors. The same is true
> of Core.{In,Out}_channel.create.
>
> That being said, I'm not actually sure that Async's Reader and Writer
> are doing this, which is a little embarrassing. It's quite possible
> this is deliberate; let me follow up internally,
>
> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Hello, I'm wondering if Core or Async addresses this bug:
>> http://caml.inria.fr/mantis/view.php?id=5256
>>
>> I have a situation where I'm reading/writing many files and spawning
>> subprocesses in Async and the subprocesses are inheriting the opened
>> FDs which is problematic for me.  I am using the ocaml stdlib
>> create_process for this as the Core version was causing segfaults for
>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>> to Core's create_process if it solves this issue.  I poked around the
>> source code but didn't see anything in the comments about what happens
>> to open fd's after forking.
>>
>> Thanks,
>> /M


From mmatalka at gmail.com  Mon Oct 15 10:19:21 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:19:21 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
Message-ID: <CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>


One option I have is to write to a temporary filename then spawn a
'cp' to copy the temp file to the actual file, but that seems less
than ideal.  The specific problem is I am writing shell scripts that
will be run, and I'm spawning shell scripts at the same time, so if I
spawn a shell script while writing a shell script, the written script
cannot be executed until the running one is completed.

On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> I'm using Writer.with_file in this case.  I poked around the source
> code but my Unix knowledge isn't strong enough to know what's right or
> wrong.
>
> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>> Hmm, how are you opening the files? Xavier in that thread claims that
>> if you use Pervasives.open_in or Pervasives.open_out, then
>> close-on-exec will be set for those file descriptors. The same is true
>> of Core.{In,Out}_channel.create.
>>
>> That being said, I'm not actually sure that Async's Reader and Writer
>> are doing this, which is a little embarrassing. It's quite possible
>> this is deliberate; let me follow up internally,
>>
>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Hello, I'm wondering if Core or Async addresses this bug:
>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>
>>> I have a situation where I'm reading/writing many files and spawning
>>> subprocesses in Async and the subprocesses are inheriting the opened
>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>> create_process for this as the Core version was causing segfaults for
>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>> to Core's create_process if it solves this issue.  I poked around the
>>> source code but didn't see anything in the comments about what happens
>>> to open fd's after forking.
>>>
>>> Thanks,
>>> /M


From mmatalka at gmail.com  Mon Oct 15 10:28:29 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:28:29 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
Message-ID: <CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>


Am I guaranteed that no code will run between Writer.with_file
creating the FD and my handler being run so I can set close on exec?

On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
> Oh, there is an easier fix than that. One can either call
> Unix.set_close_on_exec on the underlying file descriptor (use
> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>
> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> One option I have is to write to a temporary filename then spawn a
>> 'cp' to copy the temp file to the actual file, but that seems less
>> than ideal.  The specific problem is I am writing shell scripts that
>> will be run, and I'm spawning shell scripts at the same time, so if I
>> spawn a shell script while writing a shell script, the written script
>> cannot be executed until the running one is completed.
>>
>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> I'm using Writer.with_file in this case.  I poked around the source
>>> code but my Unix knowledge isn't strong enough to know what's right or
>>> wrong.
>>>
>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>> close-on-exec will be set for those file descriptors. The same is true
>>>> of Core.{In,Out}_channel.create.
>>>>
>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>> are doing this, which is a little embarrassing. It's quite possible
>>>> this is deliberate; let me follow up internally,
>>>>
>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>
>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>> create_process for this as the Core version was causing segfaults for
>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>> source code but didn't see anything in the comments about what happens
>>>>> to open fd's after forking.
>>>>>
>>>>> Thanks,
>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 11:48:22 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 11:48:22 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
Message-ID: <CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>


You should not normally use the In_channel or Out_channel modules from
async, preferring Reader and Writer. This is because, as blocking
operations, they will kill all concurrency by blocking the main async
thread.

But in this case, I guess its use is warranted.

Anyway, since {In,Out}_channel.create does not have a deferred result
type (it's in core, so this is impossible!), they do not use binds.
I.e. the following code should run without interruptions:

  let out_chan = Out_channel.create "foo.txt" in
  let fd = Fd.of_out_channel out_chan Fd.Kind.File in
  Unix.set_close_on_exec fd;
  let writer = Writer.create writer in
  ...

On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Does creating an out channel require a bind though?  If so, can I
> atomically create an out channel with close on exec set?
>
> Thanks
>
> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>> The context switch points in async are exactly the points where bind
>> appears. Blocks of code without a bind (or >>|, of course) inside them
>> are guaranteed to run uninterruptedly.
>>
>> Looking at the source of Writer.with_file, it looks like you do not
>> have the guarantee that you want. It calls Unix.openfile, and then
>> there is a bind, so something else could run (depending, of course, on
>> the exact pattern of concurrency in your program).
>>
>> Writer.of_out_channel, however, will give you the guarantees you want.
>> (It does not have a deferred return type so cannot be doing binds
>> internally.)
>>
>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Am I guaranteed that no code will run between Writer.with_file
>>> creating the FD and my handler being run so I can set close on exec?
>>>
>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>> Oh, there is an easier fix than that. One can either call
>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>
>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> One option I have is to write to a temporary filename then spawn a
>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>> spawn a shell script while writing a shell script, the written script
>>>>> cannot be executed until the running one is completed.
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>> wrong.
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>
>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>
>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>> to open fd's after forking.
>>>>>>>>
>>>>>>>> Thanks,
>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 10:53:56 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 11:53:56 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
Message-ID: <CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>


Does creating an out channel require a bind though?  If so, can I
atomically create an out channel with close on exec set?

Thanks

On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
> The context switch points in async are exactly the points where bind
> appears. Blocks of code without a bind (or >>|, of course) inside them
> are guaranteed to run uninterruptedly.
>
> Looking at the source of Writer.with_file, it looks like you do not
> have the guarantee that you want. It calls Unix.openfile, and then
> there is a bind, so something else could run (depending, of course, on
> the exact pattern of concurrency in your program).
>
> Writer.of_out_channel, however, will give you the guarantees you want.
> (It does not have a deferred return type so cannot be doing binds
> internally.)
>
> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Am I guaranteed that no code will run between Writer.with_file
>> creating the FD and my handler being run so I can set close on exec?
>>
>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>> Oh, there is an easier fix than that. One can either call
>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>
>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> One option I have is to write to a temporary filename then spawn a
>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>> spawn a shell script while writing a shell script, the written script
>>>> cannot be executed until the running one is completed.
>>>>
>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>> wrong.
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>> of Core.{In,Out}_channel.create.
>>>>>>
>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>> this is deliberate; let me follow up internally,
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>
>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>> to open fd's after forking.
>>>>>>>
>>>>>>> Thanks,
>>>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 13:07:40 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 13:07:40 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
Message-ID: <CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>


It's very easy to make the blocking thing be non-blocking: throw the
whole thing into an In_thread.run.

On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Many thanks David, at least in this case a blocking open will mean I
> have bigger problems.
>
> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>> You should not normally use the In_channel or Out_channel modules from
>> async, preferring Reader and Writer. This is because, as blocking
>> operations, they will kill all concurrency by blocking the main async
>> thread.
>>
>> But in this case, I guess its use is warranted.
>>
>> Anyway, since {In,Out}_channel.create does not have a deferred result
>> type (it's in core, so this is impossible!), they do not use binds.
>> I.e. the following code should run without interruptions:
>>
>>   let out_chan = Out_channel.create "foo.txt" in
>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>   Unix.set_close_on_exec fd;
>>   let writer = Writer.create writer in
>>   ...
>>
>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Does creating an out channel require a bind though?  If so, can I
>>> atomically create an out channel with close on exec set?
>>>
>>> Thanks
>>>
>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>> The context switch points in async are exactly the points where bind
>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>> are guaranteed to run uninterruptedly.
>>>>
>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>> there is a bind, so something else could run (depending, of course, on
>>>> the exact pattern of concurrency in your program).
>>>>
>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>> (It does not have a deferred return type so cannot be doing binds
>>>> internally.)
>>>>
>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>> cannot be executed until the running one is completed.
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>> wrong.
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>
>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>
>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>
>>>>>>>>>> Thanks,
>>>>>>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 13:17:30 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 13:17:30 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
Message-ID: <CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>


How so?

let make_writer file =
  In_thread.run (fun () ->
    let out_chan = Out_channel.create file in
    let fd = Fd.of_out_channel out_chan Fd.Kind.File in
    Unix.set_close_on_exec fd;
    Writer.create writer)

The closure will run still without being interrupted.

On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> That won't work for me because making an fd and setting it to close on
> exec would become non-atomic again.
>
> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com> wrote:
>> It's very easy to make the blocking thing be non-blocking: throw the
>> whole thing into an In_thread.run.
>>
>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>> Many thanks David, at least in this case a blocking open will mean I
>>> have bigger problems.
>>>
>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>>>> You should not normally use the In_channel or Out_channel modules from
>>>> async, preferring Reader and Writer. This is because, as blocking
>>>> operations, they will kill all concurrency by blocking the main async
>>>> thread.
>>>>
>>>> But in this case, I guess its use is warranted.
>>>>
>>>> Anyway, since {In,Out}_channel.create does not have a deferred result
>>>> type (it's in core, so this is impossible!), they do not use binds.
>>>> I.e. the following code should run without interruptions:
>>>>
>>>>   let out_chan = Out_channel.create "foo.txt" in
>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>>>   Unix.set_close_on_exec fd;
>>>>   let writer = Writer.create writer in
>>>>   ...
>>>>
>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>> Does creating an out channel require a bind though?  If so, can I
>>>>> atomically create an out channel with close on exec set?
>>>>>
>>>>> Thanks
>>>>>
>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>>>> The context switch points in async are exactly the points where bind
>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>>>> are guaranteed to run uninterruptedly.
>>>>>>
>>>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>>>> there is a bind, so something else could run (depending, of course, on
>>>>>> the exact pattern of concurrency in your program).
>>>>>>
>>>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>>>> (It does not have a deferred return type so cannot be doing binds
>>>>>> internally.)
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>>>> cannot be executed until the running one is completed.
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>>>> wrong.
>>>>>>>>>>
>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>>>
>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>>>
>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>>>
>>>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>>>
>>>>>>>>>>>> Thanks,
>>>>>>>>>>>> /M


From dhouse at janestreet.com  Mon Oct 15 13:26:40 2012
From: dhouse at janestreet.com (David House)
Date: Mon, 15 Oct 2012 13:26:40 +0100
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
Message-ID: <CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>


Sorry, I was thinking of something else. Of course when one uses
In_thread, you give away interruptability guarantees. (This is the
whole point.)

You're also not allowed to use async code inside In_thread.run. (It
runs without the async lock.)

In principle, it is just a matter of aping the code for
Writer.open_file, but adding in a call to set_close_on_exec. So this
is definitely possible, it just depends how much code you're willing
to duplicate.

I think it should be possible to just do this all the time on Writer
and Reader; I'll see if I can push that through.

On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com> wrote:
> How so?
>
> let make_writer file =
>   In_thread.run (fun () ->
>     let out_chan = Out_channel.create file in
>     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>     Unix.set_close_on_exec fd;
>     Writer.create writer)
>
> The closure will run still without being interrupted.
>
> On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> That won't work for me because making an fd and setting it to close on
>> exec would become non-atomic again.
>>
>> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com> wrote:
>>> It's very easy to make the blocking thing be non-blocking: throw the
>>> whole thing into an In_thread.run.
>>>
>>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Many thanks David, at least in this case a blocking open will mean I
>>>> have bigger problems.
>>>>
>>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>>>>> You should not normally use the In_channel or Out_channel modules from
>>>>> async, preferring Reader and Writer. This is because, as blocking
>>>>> operations, they will kill all concurrency by blocking the main async
>>>>> thread.
>>>>>
>>>>> But in this case, I guess its use is warranted.
>>>>>
>>>>> Anyway, since {In,Out}_channel.create does not have a deferred result
>>>>> type (it's in core, so this is impossible!), they do not use binds.
>>>>> I.e. the following code should run without interruptions:
>>>>>
>>>>>   let out_chan = Out_channel.create "foo.txt" in
>>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>>>>   Unix.set_close_on_exec fd;
>>>>>   let writer = Writer.create writer in
>>>>>   ...
>>>>>
>>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Does creating an out channel require a bind though?  If so, can I
>>>>>> atomically create an out channel with close on exec set?
>>>>>>
>>>>>> Thanks
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>> The context switch points in async are exactly the points where bind
>>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>>>>> are guaranteed to run uninterruptedly.
>>>>>>>
>>>>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>>>>> there is a bind, so something else could run (depending, of course, on
>>>>>>> the exact pattern of concurrency in your program).
>>>>>>>
>>>>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>>>>> (It does not have a deferred return type so cannot be doing binds
>>>>>>> internally.)
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>>>>> cannot be executed until the running one is completed.
>>>>>>>>>>
>>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>>>>> wrong.
>>>>>>>>>>>
>>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>>>>
>>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>>>>
>>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>>>>
>>>>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>>>>
>>>>>>>>>>>>> Thanks,
>>>>>>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 12:55:16 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 13:55:16 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
Message-ID: <CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>


Many thanks David, at least in this case a blocking open will mean I
have bigger problems.

On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
> You should not normally use the In_channel or Out_channel modules from
> async, preferring Reader and Writer. This is because, as blocking
> operations, they will kill all concurrency by blocking the main async
> thread.
>
> But in this case, I guess its use is warranted.
>
> Anyway, since {In,Out}_channel.create does not have a deferred result
> type (it's in core, so this is impossible!), they do not use binds.
> I.e. the following code should run without interruptions:
>
>   let out_chan = Out_channel.create "foo.txt" in
>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>   Unix.set_close_on_exec fd;
>   let writer = Writer.create writer in
>   ...
>
> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Does creating an out channel require a bind though?  If so, can I
>> atomically create an out channel with close on exec set?
>>
>> Thanks
>>
>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>> The context switch points in async are exactly the points where bind
>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>> are guaranteed to run uninterruptedly.
>>>
>>> Looking at the source of Writer.with_file, it looks like you do not
>>> have the guarantee that you want. It calls Unix.openfile, and then
>>> there is a bind, so something else could run (depending, of course, on
>>> the exact pattern of concurrency in your program).
>>>
>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>> (It does not have a deferred return type so cannot be doing binds
>>> internally.)
>>>
>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Am I guaranteed that no code will run between Writer.with_file
>>>> creating the FD and my handler being run so I can set close on exec?
>>>>
>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>> Oh, there is an easier fix than that. One can either call
>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>
>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>> cannot be executed until the running one is completed.
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>> wrong.
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>
>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>
>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>> to open fd's after forking.
>>>>>>>>>
>>>>>>>>> Thanks,
>>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 13:15:31 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 14:15:31 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
Message-ID: <CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>


That won't work for me because making an fd and setting it to close on
exec would become non-atomic again.

On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com> wrote:
> It's very easy to make the blocking thing be non-blocking: throw the
> whole thing into an In_thread.run.
>
> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>> Many thanks David, at least in this case a blocking open will mean I
>> have bigger problems.
>>
>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com> wrote:
>>> You should not normally use the In_channel or Out_channel modules from
>>> async, preferring Reader and Writer. This is because, as blocking
>>> operations, they will kill all concurrency by blocking the main async
>>> thread.
>>>
>>> But in this case, I guess its use is warranted.
>>>
>>> Anyway, since {In,Out}_channel.create does not have a deferred result
>>> type (it's in core, so this is impossible!), they do not use binds.
>>> I.e. the following code should run without interruptions:
>>>
>>>   let out_chan = Out_channel.create "foo.txt" in
>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>>>   Unix.set_close_on_exec fd;
>>>   let writer = Writer.create writer in
>>>   ...
>>>
>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>> Does creating an out channel require a bind though?  If so, can I
>>>> atomically create an out channel with close on exec set?
>>>>
>>>> Thanks
>>>>
>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com> wrote:
>>>>> The context switch points in async are exactly the points where bind
>>>>> appears. Blocks of code without a bind (or >>|, of course) inside them
>>>>> are guaranteed to run uninterruptedly.
>>>>>
>>>>> Looking at the source of Writer.with_file, it looks like you do not
>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>>>>> there is a bind, so something else could run (depending, of course, on
>>>>> the exact pattern of concurrency in your program).
>>>>>
>>>>> Writer.of_out_channel, however, will give you the guarantees you want.
>>>>> (It does not have a deferred return type so cannot be doing binds
>>>>> internally.)
>>>>>
>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>> Am I guaranteed that no code will run between Writer.with_file
>>>>>> creating the FD and my handler being run so I can set close on exec?
>>>>>>
>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>> Oh, there is an easier fix than that. One can either call
>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
>>>>>>>
>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>> One option I have is to write to a temporary filename then spawn a
>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems less
>>>>>>>> than ideal.  The specific problem is I am writing shell scripts that
>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so if I
>>>>>>>> spawn a shell script while writing a shell script, the written script
>>>>>>>> cannot be executed until the running one is completed.
>>>>>>>>
>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the source
>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's right or
>>>>>>>>> wrong.
>>>>>>>>>
>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <dhouse at janestreet.com> wrote:
>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread claims that
>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>>>>>>>>>> close-on-exec will be set for those file descriptors. The same is true
>>>>>>>>>> of Core.{In,Out}_channel.create.
>>>>>>>>>>
>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and Writer
>>>>>>>>>> are doing this, which is a little embarrassing. It's quite possible
>>>>>>>>>> this is deliberate; let me follow up internally,
>>>>>>>>>>
>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>>>>>>>>>>>
>>>>>>>>>>> I have a situation where I'm reading/writing many files and spawning
>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the opened
>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
>>>>>>>>>>> create_process for this as the Core version was causing segfaults for
>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can switch batch
>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked around the
>>>>>>>>>>> source code but didn't see anything in the comments about what happens
>>>>>>>>>>> to open fd's after forking.
>>>>>>>>>>>
>>>>>>>>>>> Thanks,
>>>>>>>>>>> /M


From mmatalka at gmail.com  Mon Oct 15 13:28:42 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 14:28:42 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
Message-ID: <CAKziXDV4KU5erWkE_wSBOgA_JWw1PD-j+XuDyL6raYfRNwEYvg@mail.gmail.com>

Can't the thread be preempted?
On Oct 15, 2012 2:17 PM, "David House" <dhouse at janestreet.com> wrote:

> How so?
>
> let make_writer file =
>   In_thread.run (fun () ->
>     let out_chan = Out_channel.create file in
>     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>     Unix.set_close_on_exec fd;
>     Writer.create writer)
>
> The closure will run still without being interrupted.
>
> On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> > That won't work for me because making an fd and setting it to close on
> > exec would become non-atomic again.
> >
> > On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
> wrote:
> >> It's very easy to make the blocking thing be non-blocking: throw the
> >> whole thing into an In_thread.run.
> >>
> >> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >>> Many thanks David, at least in this case a blocking open will mean I
> >>> have bigger problems.
> >>>
> >>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com>
> wrote:
> >>>> You should not normally use the In_channel or Out_channel modules from
> >>>> async, preferring Reader and Writer. This is because, as blocking
> >>>> operations, they will kill all concurrency by blocking the main async
> >>>> thread.
> >>>>
> >>>> But in this case, I guess its use is warranted.
> >>>>
> >>>> Anyway, since {In,Out}_channel.create does not have a deferred result
> >>>> type (it's in core, so this is impossible!), they do not use binds.
> >>>> I.e. the following code should run without interruptions:
> >>>>
> >>>>   let out_chan = Out_channel.create "foo.txt" in
> >>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >>>>   Unix.set_close_on_exec fd;
> >>>>   let writer = Writer.create writer in
> >>>>   ...
> >>>>
> >>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >>>>> Does creating an out channel require a bind though?  If so, can I
> >>>>> atomically create an out channel with close on exec set?
> >>>>>
> >>>>> Thanks
> >>>>>
> >>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <dhouse at janestreet.com>
> wrote:
> >>>>>> The context switch points in async are exactly the points where bind
> >>>>>> appears. Blocks of code without a bind (or >>|, of course) inside
> them
> >>>>>> are guaranteed to run uninterruptedly.
> >>>>>>
> >>>>>> Looking at the source of Writer.with_file, it looks like you do not
> >>>>>> have the guarantee that you want. It calls Unix.openfile, and then
> >>>>>> there is a bind, so something else could run (depending, of course,
> on
> >>>>>> the exact pattern of concurrency in your program).
> >>>>>>
> >>>>>> Writer.of_out_channel, however, will give you the guarantees you
> want.
> >>>>>> (It does not have a deferred return type so cannot be doing binds
> >>>>>> internally.)
> >>>>>>
> >>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>> Am I guaranteed that no code will run between Writer.with_file
> >>>>>>> creating the FD and my handler being run so I can set close on
> exec?
> >>>>>>>
> >>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>> Oh, there is an easier fix than that. One can either call
> >>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
> >>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
> >>>>>>>>
> >>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>> One option I have is to write to a temporary filename then spawn
> a
> >>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
> less
> >>>>>>>>> than ideal.  The specific problem is I am writing shell scripts
> that
> >>>>>>>>> will be run, and I'm spawning shell scripts at the same time, so
> if I
> >>>>>>>>> spawn a shell script while writing a shell script, the written
> script
> >>>>>>>>> cannot be executed until the running one is completed.
> >>>>>>>>>
> >>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
> source
> >>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's
> right or
> >>>>>>>>>> wrong.
> >>>>>>>>>>
> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
> claims that
> >>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
> >>>>>>>>>>> close-on-exec will be set for those file descriptors. The same
> is true
> >>>>>>>>>>> of Core.{In,Out}_channel.create.
> >>>>>>>>>>>
> >>>>>>>>>>> That being said, I'm not actually sure that Async's Reader and
> Writer
> >>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
> possible
> >>>>>>>>>>> this is deliberate; let me follow up internally,
> >>>>>>>>>>>
> >>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
> >>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
> >>>>>>>>>>>>
> >>>>>>>>>>>> I have a situation where I'm reading/writing many files and
> spawning
> >>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting the
> opened
> >>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
> >>>>>>>>>>>> create_process for this as the Core version was causing
> segfaults for
> >>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
> switch batch
> >>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
> around the
> >>>>>>>>>>>> source code but didn't see anything in the comments about
> what happens
> >>>>>>>>>>>> to open fd's after forking.
> >>>>>>>>>>>>
> >>>>>>>>>>>> Thanks,
> >>>>>>>>>>>> /M
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121015/44f7bc14/attachment-0001.html>

From mmatalka at gmail.com  Mon Oct 15 13:30:04 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Mon, 15 Oct 2012 14:30:04 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
Message-ID: <CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>

Thanksgiving!  The problematic code for me is in a pretty limited place so
doing it by hand isn't a problem. Thanks again for the help!
On Oct 15, 2012 2:26 PM, "David House" <dhouse at janestreet.com> wrote:

> Sorry, I was thinking of something else. Of course when one uses
> In_thread, you give away interruptability guarantees. (This is the
> whole point.)
>
> You're also not allowed to use async code inside In_thread.run. (It
> runs without the async lock.)
>
> In principle, it is just a matter of aping the code for
> Writer.open_file, but adding in a call to set_close_on_exec. So this
> is definitely possible, it just depends how much code you're willing
> to duplicate.
>
> I think it should be possible to just do this all the time on Writer
> and Reader; I'll see if I can push that through.
>
> On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com>
> wrote:
> > How so?
> >
> > let make_writer file =
> >   In_thread.run (fun () ->
> >     let out_chan = Out_channel.create file in
> >     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >     Unix.set_close_on_exec fd;
> >     Writer.create writer)
> >
> > The closure will run still without being interrupted.
> >
> > On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >> That won't work for me because making an fd and setting it to close on
> >> exec would become non-atomic again.
> >>
> >> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
> wrote:
> >>> It's very easy to make the blocking thing be non-blocking: throw the
> >>> whole thing into an In_thread.run.
> >>>
> >>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> >>>> Many thanks David, at least in this case a blocking open will mean I
> >>>> have bigger problems.
> >>>>
> >>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com>
> wrote:
> >>>>> You should not normally use the In_channel or Out_channel modules
> from
> >>>>> async, preferring Reader and Writer. This is because, as blocking
> >>>>> operations, they will kill all concurrency by blocking the main async
> >>>>> thread.
> >>>>>
> >>>>> But in this case, I guess its use is warranted.
> >>>>>
> >>>>> Anyway, since {In,Out}_channel.create does not have a deferred result
> >>>>> type (it's in core, so this is impossible!), they do not use binds.
> >>>>> I.e. the following code should run without interruptions:
> >>>>>
> >>>>>   let out_chan = Out_channel.create "foo.txt" in
> >>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >>>>>   Unix.set_close_on_exec fd;
> >>>>>   let writer = Writer.create writer in
> >>>>>   ...
> >>>>>
> >>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>> Does creating an out channel require a bind though?  If so, can I
> >>>>>> atomically create an out channel with close on exec set?
> >>>>>>
> >>>>>> Thanks
> >>>>>>
> >>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>> The context switch points in async are exactly the points where
> bind
> >>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside
> them
> >>>>>>> are guaranteed to run uninterruptedly.
> >>>>>>>
> >>>>>>> Looking at the source of Writer.with_file, it looks like you do not
> >>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
> >>>>>>> there is a bind, so something else could run (depending, of
> course, on
> >>>>>>> the exact pattern of concurrency in your program).
> >>>>>>>
> >>>>>>> Writer.of_out_channel, however, will give you the guarantees you
> want.
> >>>>>>> (It does not have a deferred return type so cannot be doing binds
> >>>>>>> internally.)
> >>>>>>>
> >>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>> Am I guaranteed that no code will run between Writer.with_file
> >>>>>>>> creating the FD and my handler being run so I can set close on
> exec?
> >>>>>>>>
> >>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>>> Oh, there is an easier fix than that. One can either call
> >>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
> >>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for Reader.)
> >>>>>>>>>
> >>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>> One option I have is to write to a temporary filename then
> spawn a
> >>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
> less
> >>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts
> that
> >>>>>>>>>> will be run, and I'm spawning shell scripts at the same time,
> so if I
> >>>>>>>>>> spawn a shell script while writing a shell script, the written
> script
> >>>>>>>>>> cannot be executed until the running one is completed.
> >>>>>>>>>>
> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
> source
> >>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's
> right or
> >>>>>>>>>>> wrong.
> >>>>>>>>>>>
> >>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House <
> dhouse at janestreet.com> wrote:
> >>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
> claims that
> >>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
> >>>>>>>>>>>> close-on-exec will be set for those file descriptors. The
> same is true
> >>>>>>>>>>>> of Core.{In,Out}_channel.create.
> >>>>>>>>>>>>
> >>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader
> and Writer
> >>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
> possible
> >>>>>>>>>>>> this is deliberate; let me follow up internally,
> >>>>>>>>>>>>
> >>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka <
> mmatalka at gmail.com> wrote:
> >>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
> >>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> I have a situation where I'm reading/writing many files and
> spawning
> >>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting
> the opened
> >>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml stdlib
> >>>>>>>>>>>>> create_process for this as the Core version was causing
> segfaults for
> >>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
> switch batch
> >>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
> around the
> >>>>>>>>>>>>> source code but didn't see anything in the comments about
> what happens
> >>>>>>>>>>>>> to open fd's after forking.
> >>>>>>>>>>>>>
> >>>>>>>>>>>>> Thanks,
> >>>>>>>>>>>>> /M
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121015/677bc04e/attachment-0001.html>

From sweeks at janestreet.com  Thu Oct 18 20:00:53 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Thu, 18 Oct 2012 15:00:53 -0400
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
	<CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
Message-ID: <CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>


I ended up adding an optional [?close_on_exec:bool] argument to:

  |                  | default |
  |------------------+---------|
  | Reader.open_file | true    |
  | Writer.open_file | true    |
  | Unix.openfile    | false   |

I could be convinced to make the default [true] for [Unix.openfile]
also.  As a drawback, it would be inconsistent with OCaml's and Core's
[Unix.openfile].  But perhaps that inconsistency isn't bad.  As Xavier
said on:

  http://caml.inria.fr/mantis/view.php?id=5256

perhaps he should have had [Unix.openfile] set close-on-exec in the
first place, and he is considering doing it now.

As to the implementation, [Async.Unix.openfile] now looks like:

  In_thread.syscall_exn ~name:"openfile" (fun () ->
    let file_descr = Unix.openfile ?perm file ~mode in
    if close_on_exec then Unix.set_close_on_exec file_descr;
    file_descr)

Once [Core.Unix] supports O_CLOEXEC, we'll pass it to [Unix.openfile]
and eliminate the race.

On Mon, Oct 15, 2012 at 8:30 AM, Malcolm Matalka <mmatalka at gmail.com> wrote:
> Thanksgiving!  The problematic code for me is in a pretty limited place so
> doing it by hand isn't a problem. Thanks again for the help!
>
> On Oct 15, 2012 2:26 PM, "David House" <dhouse at janestreet.com> wrote:
>>
>> Sorry, I was thinking of something else. Of course when one uses
>> In_thread, you give away interruptability guarantees. (This is the
>> whole point.)
>>
>> You're also not allowed to use async code inside In_thread.run. (It
>> runs without the async lock.)
>>
>> In principle, it is just a matter of aping the code for
>> Writer.open_file, but adding in a call to set_close_on_exec. So this
>> is definitely possible, it just depends how much code you're willing
>> to duplicate.
>>
>> I think it should be possible to just do this all the time on Writer
>> and Reader; I'll see if I can push that through.
>>
>> On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com>
>> wrote:
>> > How so?
>> >
>> > let make_writer file =
>> >   In_thread.run (fun () ->
>> >     let out_chan = Out_channel.create file in
>> >     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>> >     Unix.set_close_on_exec fd;
>> >     Writer.create writer)
>> >
>> > The closure will run still without being interrupted.
>> >
>> > On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
>> > wrote:
>> >> That won't work for me because making an fd and setting it to close on
>> >> exec would become non-atomic again.
>> >>
>> >> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
>> >> wrote:
>> >>> It's very easy to make the blocking thing be non-blocking: throw the
>> >>> whole thing into an In_thread.run.
>> >>>
>> >>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <mmatalka at gmail.com>
>> >>> wrote:
>> >>>> Many thanks David, at least in this case a blocking open will mean I
>> >>>> have bigger problems.
>> >>>>
>> >>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <dhouse at janestreet.com>
>> >>>> wrote:
>> >>>>> You should not normally use the In_channel or Out_channel modules
>> >>>>> from
>> >>>>> async, preferring Reader and Writer. This is because, as blocking
>> >>>>> operations, they will kill all concurrency by blocking the main
>> >>>>> async
>> >>>>> thread.
>> >>>>>
>> >>>>> But in this case, I guess its use is warranted.
>> >>>>>
>> >>>>> Anyway, since {In,Out}_channel.create does not have a deferred
>> >>>>> result
>> >>>>> type (it's in core, so this is impossible!), they do not use binds.
>> >>>>> I.e. the following code should run without interruptions:
>> >>>>>
>> >>>>>   let out_chan = Out_channel.create "foo.txt" in
>> >>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
>> >>>>>   Unix.set_close_on_exec fd;
>> >>>>>   let writer = Writer.create writer in
>> >>>>>   ...
>> >>>>>
>> >>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka
>> >>>>> <mmatalka at gmail.com> wrote:
>> >>>>>> Does creating an out channel require a bind though?  If so, can I
>> >>>>>> atomically create an out channel with close on exec set?
>> >>>>>>
>> >>>>>> Thanks
>> >>>>>>
>> >>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House
>> >>>>>> <dhouse at janestreet.com> wrote:
>> >>>>>>> The context switch points in async are exactly the points where
>> >>>>>>> bind
>> >>>>>>> appears. Blocks of code without a bind (or >>|, of course) inside
>> >>>>>>> them
>> >>>>>>> are guaranteed to run uninterruptedly.
>> >>>>>>>
>> >>>>>>> Looking at the source of Writer.with_file, it looks like you do
>> >>>>>>> not
>> >>>>>>> have the guarantee that you want. It calls Unix.openfile, and then
>> >>>>>>> there is a bind, so something else could run (depending, of
>> >>>>>>> course, on
>> >>>>>>> the exact pattern of concurrency in your program).
>> >>>>>>>
>> >>>>>>> Writer.of_out_channel, however, will give you the guarantees you
>> >>>>>>> want.
>> >>>>>>> (It does not have a deferred return type so cannot be doing binds
>> >>>>>>> internally.)
>> >>>>>>>
>> >>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka
>> >>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>> Am I guaranteed that no code will run between Writer.with_file
>> >>>>>>>> creating the FD and my handler being run so I can set close on
>> >>>>>>>> exec?
>> >>>>>>>>
>> >>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House
>> >>>>>>>> <dhouse at janestreet.com> wrote:
>> >>>>>>>>> Oh, there is an easier fix than that. One can either call
>> >>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
>> >>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for
>> >>>>>>>>> Reader.)
>> >>>>>>>>>
>> >>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka
>> >>>>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>>>> One option I have is to write to a temporary filename then
>> >>>>>>>>>> spawn a
>> >>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
>> >>>>>>>>>> less
>> >>>>>>>>>> than ideal.  The specific problem is I am writing shell scripts
>> >>>>>>>>>> that
>> >>>>>>>>>> will be run, and I'm spawning shell scripts at the same time,
>> >>>>>>>>>> so if I
>> >>>>>>>>>> spawn a shell script while writing a shell script, the written
>> >>>>>>>>>> script
>> >>>>>>>>>> cannot be executed until the running one is completed.
>> >>>>>>>>>>
>> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka
>> >>>>>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
>> >>>>>>>>>>> source
>> >>>>>>>>>>> code but my Unix knowledge isn't strong enough to know what's
>> >>>>>>>>>>> right or
>> >>>>>>>>>>> wrong.
>> >>>>>>>>>>>
>> >>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House
>> >>>>>>>>>>> <dhouse at janestreet.com> wrote:
>> >>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
>> >>>>>>>>>>>> claims that
>> >>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
>> >>>>>>>>>>>> close-on-exec will be set for those file descriptors. The
>> >>>>>>>>>>>> same is true
>> >>>>>>>>>>>> of Core.{In,Out}_channel.create.
>> >>>>>>>>>>>>
>> >>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader
>> >>>>>>>>>>>> and Writer
>> >>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
>> >>>>>>>>>>>> possible
>> >>>>>>>>>>>> this is deliberate; let me follow up internally,
>> >>>>>>>>>>>>
>> >>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka
>> >>>>>>>>>>>> <mmatalka at gmail.com> wrote:
>> >>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
>> >>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
>> >>>>>>>>>>>>>
>> >>>>>>>>>>>>> I have a situation where I'm reading/writing many files and
>> >>>>>>>>>>>>> spawning
>> >>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting
>> >>>>>>>>>>>>> the opened
>> >>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml
>> >>>>>>>>>>>>> stdlib
>> >>>>>>>>>>>>> create_process for this as the Core version was causing
>> >>>>>>>>>>>>> segfaults for
>> >>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
>> >>>>>>>>>>>>> switch batch
>> >>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
>> >>>>>>>>>>>>> around the
>> >>>>>>>>>>>>> source code but didn't see anything in the comments about
>> >>>>>>>>>>>>> what happens
>> >>>>>>>>>>>>> to open fd's after forking.
>> >>>>>>>>>>>>>
>> >>>>>>>>>>>>> Thanks,
>> >>>>>>>>>>>>> /M


From sweeks at janestreet.com  Thu Oct 18 20:21:30 2012
From: sweeks at janestreet.com (Stephen Weeks)
Date: Thu, 18 Oct 2012 15:21:30 -0400
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAKziXDXB-i5rduvxhD7=5CRuiXVyOf4stcwQ9uSTy_S=xK5FEw@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
	<CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
	<CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>
	<CAKziXDXB-i5rduvxhD7=5CRuiXVyOf4stcwQ9uSTy_S=xK5FEw@mail.gmail.com>
Message-ID: <CAPYVAiLcxzoBJrkrsVudQptxFRybARymGAof0MH1JY5y0g0mTw@mail.gmail.com>


> Do you have a timeline for removing the race?

As of OCaml 4.00, the stdlib Unix module doesn't support O_CLOEXEC.
So, we'd have to do a little extra work in Core to add it to
Core.Unix.  I added a note to our codebase to add it, but I haven't
seen anything that makes doing so a high priority.  So, your best bet
if you want it anytime in the next six months is to add it yourself
and send us a patch.


From mmatalka at gmail.com  Thu Oct 18 20:07:15 2012
From: mmatalka at gmail.com (Malcolm Matalka)
Date: Thu, 18 Oct 2012 21:07:15 +0200
Subject: File descriptor semantics in Core/Async?
In-Reply-To: <CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>
References: <CAKziXDVkxNsVii4ivJn8VG=6mwcykgBuWMTP_x-+WX4UpS2XrQ@mail.gmail.com>
	<CAK=fH+jhwHH35ui3gnCsYA6-NnuqoqMETMdjRdwUD5hcZEFfpA@mail.gmail.com>
	<CAKziXDUKfw65gKQ=sh=6KtX--Jszf-5fXDFHBxDUFty_z7vu7Q@mail.gmail.com>
	<CAKziXDUxDLzxp+vEWnM94=+pmyHQBMnOvwyKmRtYg4EN2a7BBQ@mail.gmail.com>
	<CAK=fH+hfjPnmMb0tCO04cFhpH_i3A1Te_kCLBswqOh2vj_cE4A@mail.gmail.com>
	<CAKziXDX0yNsUMvkbsxCCZng1WyRy9p0ptcKwNiaXNyPeg3a5Cw@mail.gmail.com>
	<CAK=fH+huh7jF+Fk79+nySnyPQzHP5TNRs+xR-VgK5c1wHrVAGg@mail.gmail.com>
	<CAKziXDXSdULiOro5i7hoHCNAESG1K2BZxeXcVRXGaQ1QkiP7Xg@mail.gmail.com>
	<CAK=fH+gBqLg96YsnT2Ak87ArG6nCGcXU_EsDDcLtkgXnTMy=YA@mail.gmail.com>
	<CAKziXDUWECjL40JL1fYvtxURoSui-ehO5WNS+cbJqAS0Bhy1Wg@mail.gmail.com>
	<CAK=fH+ifdiWR-GR2xQEHvXhDHUsRfvUQ6gQO4NjsQVVbsAHgFA@mail.gmail.com>
	<CAKziXDXmLRSX=p2XrtGXhUanYL0WqRofiFq3rY6CcOhtu--gMA@mail.gmail.com>
	<CAK=fH+hRP_pV+_o+p_shnFz9mLteL3qxUM=d5Q9xc-7FB8RTag@mail.gmail.com>
	<CAK=fH+g7OqR_j6bxS3r_k6k8dCAgE_PkYkPwsOF4ykXoxci4+g@mail.gmail.com>
	<CAKziXDXHhhBSyoMY96ruLQ++MjHELiiMigBOFrCY6ra9DrrFgg@mail.gmail.com>
	<CAPYVAiLLTUSVACCBry6pWx-Y8CgObwtRyTECvQmuKE0tas2G_Q@mail.gmail.com>
Message-ID: <CAKziXDXB-i5rduvxhD7=5CRuiXVyOf4stcwQ9uSTy_S=xK5FEw@mail.gmail.com>

Great!  Thanks for adding to Core/Async.  Do you have a timeline for
removing the race?

Thanks again for the quick responses fixes everyone.

/M
 On Oct 18, 2012 9:00 PM, "Stephen Weeks" <sweeks at janestreet.com> wrote:

> I ended up adding an optional [?close_on_exec:bool] argument to:
>
>   |                  | default |
>   |------------------+---------|
>   | Reader.open_file | true    |
>   | Writer.open_file | true    |
>   | Unix.openfile    | false   |
>
> I could be convinced to make the default [true] for [Unix.openfile]
> also.  As a drawback, it would be inconsistent with OCaml's and Core's
> [Unix.openfile].  But perhaps that inconsistency isn't bad.  As Xavier
> said on:
>
>   http://caml.inria.fr/mantis/view.php?id=5256
>
> perhaps he should have had [Unix.openfile] set close-on-exec in the
> first place, and he is considering doing it now.
>
> As to the implementation, [Async.Unix.openfile] now looks like:
>
>   In_thread.syscall_exn ~name:"openfile" (fun () ->
>     let file_descr = Unix.openfile ?perm file ~mode in
>     if close_on_exec then Unix.set_close_on_exec file_descr;
>     file_descr)
>
> Once [Core.Unix] supports O_CLOEXEC, we'll pass it to [Unix.openfile]
> and eliminate the race.
>
> On Mon, Oct 15, 2012 at 8:30 AM, Malcolm Matalka <mmatalka at gmail.com>
> wrote:
> > Thanksgiving!  The problematic code for me is in a pretty limited place
> so
> > doing it by hand isn't a problem. Thanks again for the help!
> >
> > On Oct 15, 2012 2:26 PM, "David House" <dhouse at janestreet.com> wrote:
> >>
> >> Sorry, I was thinking of something else. Of course when one uses
> >> In_thread, you give away interruptability guarantees. (This is the
> >> whole point.)
> >>
> >> You're also not allowed to use async code inside In_thread.run. (It
> >> runs without the async lock.)
> >>
> >> In principle, it is just a matter of aping the code for
> >> Writer.open_file, but adding in a call to set_close_on_exec. So this
> >> is definitely possible, it just depends how much code you're willing
> >> to duplicate.
> >>
> >> I think it should be possible to just do this all the time on Writer
> >> and Reader; I'll see if I can push that through.
> >>
> >> On Mon, Oct 15, 2012 at 1:17 PM, David House <dhouse at janestreet.com>
> >> wrote:
> >> > How so?
> >> >
> >> > let make_writer file =
> >> >   In_thread.run (fun () ->
> >> >     let out_chan = Out_channel.create file in
> >> >     let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >> >     Unix.set_close_on_exec fd;
> >> >     Writer.create writer)
> >> >
> >> > The closure will run still without being interrupted.
> >> >
> >> > On Mon, Oct 15, 2012 at 1:15 PM, Malcolm Matalka <mmatalka at gmail.com>
> >> > wrote:
> >> >> That won't work for me because making an fd and setting it to close
> on
> >> >> exec would become non-atomic again.
> >> >>
> >> >> On Mon, Oct 15, 2012 at 2:07 PM, David House <dhouse at janestreet.com>
> >> >> wrote:
> >> >>> It's very easy to make the blocking thing be non-blocking: throw the
> >> >>> whole thing into an In_thread.run.
> >> >>>
> >> >>> On Mon, Oct 15, 2012 at 12:55 PM, Malcolm Matalka <
> mmatalka at gmail.com>
> >> >>> wrote:
> >> >>>> Many thanks David, at least in this case a blocking open will mean
> I
> >> >>>> have bigger problems.
> >> >>>>
> >> >>>> On Mon, Oct 15, 2012 at 12:48 PM, David House <
> dhouse at janestreet.com>
> >> >>>> wrote:
> >> >>>>> You should not normally use the In_channel or Out_channel modules
> >> >>>>> from
> >> >>>>> async, preferring Reader and Writer. This is because, as blocking
> >> >>>>> operations, they will kill all concurrency by blocking the main
> >> >>>>> async
> >> >>>>> thread.
> >> >>>>>
> >> >>>>> But in this case, I guess its use is warranted.
> >> >>>>>
> >> >>>>> Anyway, since {In,Out}_channel.create does not have a deferred
> >> >>>>> result
> >> >>>>> type (it's in core, so this is impossible!), they do not use
> binds.
> >> >>>>> I.e. the following code should run without interruptions:
> >> >>>>>
> >> >>>>>   let out_chan = Out_channel.create "foo.txt" in
> >> >>>>>   let fd = Fd.of_out_channel out_chan Fd.Kind.File in
> >> >>>>>   Unix.set_close_on_exec fd;
> >> >>>>>   let writer = Writer.create writer in
> >> >>>>>   ...
> >> >>>>>
> >> >>>>> On Mon, Oct 15, 2012 at 10:53 AM, Malcolm Matalka
> >> >>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>> Does creating an out channel require a bind though?  If so, can I
> >> >>>>>> atomically create an out channel with close on exec set?
> >> >>>>>>
> >> >>>>>> Thanks
> >> >>>>>>
> >> >>>>>> On Mon, Oct 15, 2012 at 11:35 AM, David House
> >> >>>>>> <dhouse at janestreet.com> wrote:
> >> >>>>>>> The context switch points in async are exactly the points where
> >> >>>>>>> bind
> >> >>>>>>> appears. Blocks of code without a bind (or >>|, of course)
> inside
> >> >>>>>>> them
> >> >>>>>>> are guaranteed to run uninterruptedly.
> >> >>>>>>>
> >> >>>>>>> Looking at the source of Writer.with_file, it looks like you do
> >> >>>>>>> not
> >> >>>>>>> have the guarantee that you want. It calls Unix.openfile, and
> then
> >> >>>>>>> there is a bind, so something else could run (depending, of
> >> >>>>>>> course, on
> >> >>>>>>> the exact pattern of concurrency in your program).
> >> >>>>>>>
> >> >>>>>>> Writer.of_out_channel, however, will give you the guarantees you
> >> >>>>>>> want.
> >> >>>>>>> (It does not have a deferred return type so cannot be doing
> binds
> >> >>>>>>> internally.)
> >> >>>>>>>
> >> >>>>>>> On Mon, Oct 15, 2012 at 10:28 AM, Malcolm Matalka
> >> >>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>> Am I guaranteed that no code will run between Writer.with_file
> >> >>>>>>>> creating the FD and my handler being run so I can set close on
> >> >>>>>>>> exec?
> >> >>>>>>>>
> >> >>>>>>>> On Mon, Oct 15, 2012 at 11:26 AM, David House
> >> >>>>>>>> <dhouse at janestreet.com> wrote:
> >> >>>>>>>>> Oh, there is an easier fix than that. One can either call
> >> >>>>>>>>> Unix.set_close_on_exec on the underlying file descriptor (use
> >> >>>>>>>>> Writer.fd), or use Writer.of_out_channel. (Similarly for
> >> >>>>>>>>> Reader.)
> >> >>>>>>>>>
> >> >>>>>>>>> On Mon, Oct 15, 2012 at 10:19 AM, Malcolm Matalka
> >> >>>>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>>>> One option I have is to write to a temporary filename then
> >> >>>>>>>>>> spawn a
> >> >>>>>>>>>> 'cp' to copy the temp file to the actual file, but that seems
> >> >>>>>>>>>> less
> >> >>>>>>>>>> than ideal.  The specific problem is I am writing shell
> scripts
> >> >>>>>>>>>> that
> >> >>>>>>>>>> will be run, and I'm spawning shell scripts at the same time,
> >> >>>>>>>>>> so if I
> >> >>>>>>>>>> spawn a shell script while writing a shell script, the
> written
> >> >>>>>>>>>> script
> >> >>>>>>>>>> cannot be executed until the running one is completed.
> >> >>>>>>>>>>
> >> >>>>>>>>>> On Mon, Oct 15, 2012 at 11:06 AM, Malcolm Matalka
> >> >>>>>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>>>>> I'm using Writer.with_file in this case.  I poked around the
> >> >>>>>>>>>>> source
> >> >>>>>>>>>>> code but my Unix knowledge isn't strong enough to know
> what's
> >> >>>>>>>>>>> right or
> >> >>>>>>>>>>> wrong.
> >> >>>>>>>>>>>
> >> >>>>>>>>>>> On Mon, Oct 15, 2012 at 11:01 AM, David House
> >> >>>>>>>>>>> <dhouse at janestreet.com> wrote:
> >> >>>>>>>>>>>> Hmm, how are you opening the files? Xavier in that thread
> >> >>>>>>>>>>>> claims that
> >> >>>>>>>>>>>> if you use Pervasives.open_in or Pervasives.open_out, then
> >> >>>>>>>>>>>> close-on-exec will be set for those file descriptors. The
> >> >>>>>>>>>>>> same is true
> >> >>>>>>>>>>>> of Core.{In,Out}_channel.create.
> >> >>>>>>>>>>>>
> >> >>>>>>>>>>>> That being said, I'm not actually sure that Async's Reader
> >> >>>>>>>>>>>> and Writer
> >> >>>>>>>>>>>> are doing this, which is a little embarrassing. It's quite
> >> >>>>>>>>>>>> possible
> >> >>>>>>>>>>>> this is deliberate; let me follow up internally,
> >> >>>>>>>>>>>>
> >> >>>>>>>>>>>> On Mon, Oct 15, 2012 at 9:01 AM, Malcolm Matalka
> >> >>>>>>>>>>>> <mmatalka at gmail.com> wrote:
> >> >>>>>>>>>>>>> Hello, I'm wondering if Core or Async addresses this bug:
> >> >>>>>>>>>>>>> http://caml.inria.fr/mantis/view.php?id=5256
> >> >>>>>>>>>>>>>
> >> >>>>>>>>>>>>> I have a situation where I'm reading/writing many files
> and
> >> >>>>>>>>>>>>> spawning
> >> >>>>>>>>>>>>> subprocesses in Async and the subprocesses are inheriting
> >> >>>>>>>>>>>>> the opened
> >> >>>>>>>>>>>>> FDs which is problematic for me.  I am using the ocaml
> >> >>>>>>>>>>>>> stdlib
> >> >>>>>>>>>>>>> create_process for this as the Core version was causing
> >> >>>>>>>>>>>>> segfaults for
> >> >>>>>>>>>>>>> me on OS X, but now I am mainly targeting Linux so I can
> >> >>>>>>>>>>>>> switch batch
> >> >>>>>>>>>>>>> to Core's create_process if it solves this issue.  I poked
> >> >>>>>>>>>>>>> around the
> >> >>>>>>>>>>>>> source code but didn't see anything in the comments about
> >> >>>>>>>>>>>>> what happens
> >> >>>>>>>>>>>>> to open fd's after forking.
> >> >>>>>>>>>>>>>
> >> >>>>>>>>>>>>> Thanks,
> >> >>>>>>>>>>>>> /M
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/core/attachments/20121018/2c852781/attachment-0001.html>

From yminsky at janestreet.com  Sat Oct 27 14:51:54 2012
From: yminsky at janestreet.com (Yaron Minsky)
Date: Sat, 27 Oct 2012 09:51:54 -0400
Subject: short-types patch
Message-ID: <CACLX4jTR=bR8R-ZKMqPLkeCm6fuBpT6vLzH2BO4xBtAAYo85ZQ@mail.gmail.com>


If you use Core or Async, you may have been frustrated by the way that
OCaml reports types, both in the toplevel and, more importantly, in
error messages.  Here's a mildly contrived example.

    let f l x =
      List.Assoc.add l (Int.of_string x) (String.to_list x)
      |! List.Assoc.map ~f:(fun x ->
           List.filter_map x ~f:(fun c ->
             if Char.is_alpha c then Some (String.of_char c)
             else None))

If you run this through the toplevel, you'll get the following
monstrous type.

val f :
  (Core.Std.Int.t, Core.Std.Char.t Core.Std.List.t) Core.Std.List.Assoc.t ->
  Core.Std.String.t ->
  (Core.Std.Int.t, Core.Std.String.t Core.Std.List.t) Core.Std.List.Assoc.t =
  <fun>
As you can see, the inferred types are a little ugly.

Happily, Jacques Garrigue wrote a patch to improve this, which you can
now try out in OPAM by typing:

    opam switch 4.00.1+short-types

Now, if you try the same thing, you get something far easier to read:

val f :
  (int, char list) List.Assoc.t -> string -> (int, string list) List.Assoc.t =
  <fun>

The basic heuristic is that OCaml looks at all of the different names
for a given type that it learns about during the inference process,
and among those, it displays the one with the fewest number of dots,
and among those with the minimal number of dots, it picks the most
recent definition.

Please try it out, and report any problems you run into!

y


