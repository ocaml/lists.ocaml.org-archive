From jprodi04 at gmail.com  Fri Feb  2 16:52:43 2018
From: jprodi04 at gmail.com (JP R)
Date: Fri, 2 Feb 2018 17:52:43 +0100
Subject: [containers-users] Commentaires Containers - questions diverses
Message-ID: <CAFAmcKqdxrQsG15BsmF9rcKwRU5=0LXhhpvX2XbSLe1-VSUXeA@mail.gmail.com>

D'abord merci pour l'acceptation rapide de mes 2/3 derniers PRs
(@Fourchaux). C'est sympa.

J'ai pris des notes durant l'?criture de ces PRs et je me permets de t'en
envoyer quelques-unes pour avoir ton avis, ?ventuellement (c'est tout en
vrac, sorry).

(Les commentaires viennent surtout de Batteries et JST_Base).

Le r?pertoire src/core est principalement concern?.

* Noms de modules: ?crits en camlCase sauf CCArray_slice.

* CCArray.to_seq:
Correspond ? (Base.Array_ to_sequence :) 'the input array is copied
internally so that future modifications of it do not change the sequence. '

ou ? (Base.Array_to_sequence_mutable :) 'the input array is shared with the
sequence and modifications of it will result in modification of the
sequence.' ?

* CCHashtbl.S.keys_list & CCHashtbl.Poly.keys_list :
Rajout de: 'If the key is in the Hashtable multiple times, all occurrences
will be returned' ?

* CCHeap.S :
Les fonctions of_seq, of_klist, of_gen & to_seq, to_klist, to_gen
sont-elles de Complexity: O(n log n) ?

* CCList.of_seq / of_gen / of_klist :
Rajout de: 'In the result, elements appear in the same order as they did in
the source sequence/gen/klist.' ?

* CCList.mli :
(** {2 Lists of pairs} *) : derni?re ligne ? supprimer ?

* CCList.foldi & CCListlabels.foldi :
Fonctions Tail-recursive ?

* CCOpt.exists & CCOpt.for_all:
Rajout de : 'This is a short-circuiting operation' ?

* CCVector.of_array:
Rajout de: 'Operates in O(n) time.' ?


De mani?re plus g?n?rale :

* Est-il n?cessaire de garder les (tr?s laides lignes !) Since: dans la doc
finale ?
Il serait bien d'avoir une premi?re page avec les seules infos de base
(noms fonctions + types + descriptions) et une autre page avec des infos
diverses (versions, exemples d'utilisation, sources ...) comme dans les
docs de F#, Rust, etc... etc...
Mais bon, c'est un autre probl?me.

A propos, tu g?n?res comment tes docs Containers ?
Actuellement si je lance $ make doc
j'ai des messages d'erreur du genre :

odoc: internal error, uncaught exception:
      File "src/docOckIdentEnv.ml", line 260, characters 22-28: Assertion
failed ...
Pb odoc, jbuilder, autre ????

* Des fonctions identiques ont des noms diff?rents dans Containers,
Batteries ou Base.
Plus g?nant des noms identiques correspondent ? des fonctions diff?rentes.
Base.Array.findi <> CCArray.findi <> BatArray.findi
Un peu dommage !

* Des fonctions s'appellent mapi, findi, foldi sauf CCArray.find_map_i
(pourquoi pas CCArray.find_mapi ?)

* Des fichiers *.mli (CCFormat.mli - CCList.mli - CCListLabels.mli et
surtout CCString.mli) poss?dent des tests qtest.
Pas pr?f?rable de mettre tous les tests dans les fichiers *.ml ?

* Inversement on trouve des Comments identiques dans des fichiers foo.ml et
foo.mli. (Ex: CCSet.ml et CCSet.mli).
Pas mieux de r?server les commentaires aux seuls fichiers *.mli ?
Rem: dans ces cas-l? je n'ai modifi? que les seuls *.mli. D?sol?.

* Je n'ai pas trop de commentaires pour les fonctions:

- 'add_foo'
- 'array'
- 'bool'
- 'float/3'
- 'int' & 'int32' & 'int64'
- 'nativeint'
- 'CCHash.combine/2/3/4'
- beaucoup de fonctions 'compare' et 'equal'
- 'fold_l' & 'fold_m'
- 'gen' & 'gen_cpy'
- 'klist' & 'klist_cpy'
-'list' & 'list_cpy'
- 'hash'
- 'map_m'
- 'pair'
- 'pop'
- 'push'
- 'quad'
- 'random' & 'random_foo'
- 'sequence_m'
- 'string'
- 'triple'
- 'write_lines_l'

Grrrrrr .....

* Il serait bien de d?velopper/?crire des pr?sentations pour chaque module.
Dans ce domaine, Batteries est plut?t bien fait, je trouve. (mais l? mes
connaissances sont trop faibles pour pouvoir ?crire du texte technique
pertinent).

* Rem: le module CCMonomorphic semble important. Quelqu'un (jpdeplaix ?)
?crive une pr?sentation dans CCMonomorphic.mli.

Sinon, j'ignore tes intentions mais j'esp?re que tu vas continuer ?
d?velopper Containers.
Je suis curieux de voir l'influence que va avoir Base (avec l'arriv?e
annonc?e d'une documentation, la r?-?criture des exemples de RWO et la
propagande de JST ...) .
Je serais ?galement curieux d'avoir l'avis des Gourous OCaml (qui refusent
presque toutes modifs de la Std librairie) ? propos de Base.
En faisant 'open Base' et en tapant les tout premiers exemples de la doc
OCaml officielle on re?oit des tonnes de "Warning - deprecated" mais aussi
des erreurs sur du code tr?s tr?s basique (# (1 < 2) = false) . C'est quand
m?me chaud !

Mais bon, si c'est l'avenir.

Bien, on va stopper l?.

A+

PS : lors des ?lections de novembre prochain tu vas ?tre aux premi?res
loges pour assister au basculement politique du Texas (m?me si Austin est
d?j? d?mocrate ). Le Texas. Un Blue State. MAGA !!!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180202/ef3c1ebc/attachment.html>

From simon.cruanes.2007 at m4x.org  Sat Feb  3 02:47:11 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Fri, 2 Feb 2018 20:47:11 -0600
Subject: [containers-users] Commentaires Containers - questions diverses
In-Reply-To: <CAFAmcKqdxrQsG15BsmF9rcKwRU5=0LXhhpvX2XbSLe1-VSUXeA@mail.gmail.com>
References: <CAFAmcKqdxrQsG15BsmF9rcKwRU5=0LXhhpvX2XbSLe1-VSUXeA@mail.gmail.com>
Message-ID: <20180203024710.GK16191@carty>

Might have been better to redirect to my private email, sorry folks
(altough, if you speak french, there's a lot of interesting questions
and remarks in JP's email). He's contributed a lot of typographic
improvements and added documentation (patience > 9000).

You can disregard my answers otherwise, it's going to be weird out of
context.

Le Fri, 02 Feb 2018, JP R wrote:
> J'ai pris des notes durant l'?criture de ces PRs et je me permets de t'en
> envoyer quelques-unes pour avoir ton avis, ?ventuellement (c'est tout en
> vrac, sorry).
> 
> (Les commentaires viennent surtout de Batteries et JST_Base).
> 
> Le r?pertoire src/core est principalement concern?.
> 
> * Noms de modules: ?crits en camlCase sauf CCArray_slice.

Consistency in style is not one of my strengths :/

> * CCArray.to_seq:
> Correspond ? (Base.Array_ to_sequence :) 'the input array is copied
> internally so that future modifications of it do not change the sequence. '
> 
> ou ? (Base.Array_to_sequence_mutable :) 'the input array is shared with the
> sequence and modifications of it will result in modification of the
> sequence.' ?

Shared (the second one). Copying would ruin the point of using a
sequence in the first place.

> * CCHashtbl.S.keys_list & CCHashtbl.Poly.keys_list :
> Rajout de: 'If the key is in the Hashtable multiple times, all occurrences
> will be returned' ?

?

> * CCHeap.S :
> Les fonctions of_seq, of_klist, of_gen & to_seq, to_klist, to_gen
> sont-elles de Complexity: O(n log n) ?

`of_*` probably are (just a sequence of inserts); `to_*` I'm not sure
how the amortized costs combine if we traverse the whole structure.
Might be less.

> * CCList.of_seq / of_gen / of_klist :
> Rajout de: 'In the result, elements appear in the same order as they did in
> the source sequence/gen/klist.' ?

why not.

> * CCList.mli :
> (** {2 Lists of pairs} *) : derni?re ligne ? supprimer ?
? 
> * CCList.foldi & CCListlabels.foldi :
> Fonctions Tail-recursive ?

?

> 
> * CCOpt.exists & CCOpt.for_all:
> Rajout de : 'This is a short-circuiting operation' ?

for options that doesn't really make sense, does it?

> 
> * CCVector.of_array:
> Rajout de: 'Operates in O(n) time.' ?

?

> De mani?re plus g?n?rale :
> 
> * Est-il n?cessaire de garder les (tr?s laides lignes !) Since: dans la doc
> finale ?
> Il serait bien d'avoir une premi?re page avec les seules infos de base
> (noms fonctions + types + descriptions) et une autre page avec des infos
> diverses (versions, exemples d'utilisation, sources ...) comme dans les
> docs de F#, Rust, etc... etc...
> Mais bon, c'est un autre probl?me.

Yes, that's useful info and it's also available in ocp-browser.

> A propos, tu g?n?res comment tes docs Containers ?
> Actuellement si je lance $ make doc
> j'ai des messages d'erreur du genre :
> 
> odoc: internal error, uncaught exception:
>       File "src/docOckIdentEnv.ml", line 260, characters 22-28: Assertion
> failed ...
> Pb odoc, jbuilder, autre ????

odoc I suppose. I use 4.05.0+flambda for day to day dev fyi.

> * Des fonctions identiques ont des noms diff?rents dans Containers,
> Batteries ou Base.
> Plus g?nant des noms identiques correspondent ? des fonctions diff?rentes.
> Base.Array.findi <> CCArray.findi <> BatArray.findi
> Un peu dommage !

-> fragmentation!

> * Des fonctions s'appellent mapi, findi, foldi sauf CCArray.find_map_i
> (pourquoi pas CCArray.find_mapi ?)
> 
> * Des fichiers *.mli (CCFormat.mli - CCList.mli - CCListLabels.mli et
> surtout CCString.mli) poss?dent des tests qtest.
> Pas pr?f?rable de mettre tous les tests dans les fichiers *.ml ?

These files used to be cppo files (which would not be accepted by
qtest). We can move the tests back into the .ml files now.

> * Inversement on trouve des Comments identiques dans des fichiers foo.ml et
> foo.mli. (Ex: CCSet.ml et CCSet.mli).
> Pas mieux de r?server les commentaires aux seuls fichiers *.mli ?
> Rem: dans ces cas-l? je n'ai modifi? que les seuls *.mli. D?sol?.
> 
> * Je n'ai pas trop de commentaires pour les fonctions:
> 
> - 'add_foo'
> - 'array'
> - 'bool'
> - 'float/3'
> - 'int' & 'int32' & 'int64'
> - 'nativeint'
> - 'CCHash.combine/2/3/4'
> - beaucoup de fonctions 'compare' et 'equal'
> - 'fold_l' & 'fold_m'
> - 'gen' & 'gen_cpy'
> - 'klist' & 'klist_cpy'
> -'list' & 'list_cpy'
> - 'hash'
> - 'map_m'
> - 'pair'
> - 'pop'
> - 'push'
> - 'quad'
> - 'random' & 'random_foo'
> - 'sequence_m'
> - 'string'
> - 'triple'
> - 'write_lines_l'
> 
> Grrrrrr .....
> 
> * Il serait bien de d?velopper/?crire des pr?sentations pour chaque module.
> Dans ce domaine, Batteries est plut?t bien fait, je trouve. (mais l? mes
> connaissances sont trop faibles pour pouvoir ?crire du texte technique
> pertinent).

I agree. Even a few lines at the beginning explaining what the intended
use is, would be useful.

> * Rem: le module CCMonomorphic semble important. Quelqu'un (jpdeplaix ?)
> ?crive une pr?sentation dans CCMonomorphic.mli.
> 
> Sinon, j'ignore tes intentions mais j'esp?re que tu vas continuer ?
> d?velopper Containers.

I do intend to continue :-)

> Je suis curieux de voir l'influence que va avoir Base (avec l'arriv?e
> annonc?e d'une documentation, la r?-?criture des exemples de RWO et la
> propagande de JST ...) .

Base seems to have a good design but I don't want to rewrite tens of
thousands of lines of code (probably not far from 100k) just because
they decided to be incompatible with the stdlib.

> Je serais ?galement curieux d'avoir l'avis des Gourous OCaml (qui refusent
> presque toutes modifs de la Std librairie) ? propos de Base.
> En faisant 'open Base' et en tapant les tout premiers exemples de la doc
> OCaml officielle on re?oit des tonnes de "Warning - deprecated" mais aussi
> des erreurs sur du code tr?s tr?s basique (# (1 < 2) = false) . C'est quand
> m?me chaud !
> 
> Mais bon, si c'est l'avenir.

^^
who knows?

> PS : lors des ?lections de novembre prochain tu vas ?tre aux premi?res
> loges pour assister au basculement politique du Texas (m?me si Austin est
> d?j? d?mocrate ). Le Texas. Un Blue State. MAGA !!!

Heh, wait and see! 


-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180202/e1e0bc40/attachment.sig>

From pjfrey at sympatico.ca  Sat Feb 10 19:38:13 2018
From: pjfrey at sympatico.ca (peter frey)
Date: Sat, 10 Feb 2018 14:38:13 -0500
Subject: [containers-users] Possible additions to Containers and Friends
Message-ID: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>

(*
Reading recent posts on discuss.ocal.org gives me the impression that 
some tiny
number of utf related routines should be more easily available.
Container's Sequence.t and Gen.t, in particular could benefit from a 
couple of
simple routines.? The code below fits well into that frame work.
I am treating it as public domain code but feel free to make it your own 
and to
include it where appropriate. (Perhaps some of the tests could go into the
example directory...)
The routines here DO NOT verify unless its unavoidable.? In particular they
accept ALL code points that can be encoded by the original Utf8 definition.
It is only a matter of language; we could call it utf31 ...
Restricting the range is trivial; as would be including some 
verification code.



*)

open Containers

(* Create a generator from a utf8-string. Each call produces a code point.
 ?* The optional parameter srcIdx specifies then start point in the string.
 ?* srcIdx must point to a valid suffix of a utf8 string.
 ?* *)
let gen_of_utf8 ?(srcIdx=ref 0) str =
 ??? let lim = String.length str in
 ??? let assemble_next () =???? (* we come here only for multi-byte 
characters *)
 ????? let cv jmax accu =????? (* utf8 character length; construction of 
uchar *)
 ??????? let rec cv' j accu' =????????? (* inner loop j = 1..jmax ; each 
uchar *)
 ????????? let ch = Char.code str.[ !srcIdx + j] in
 ????????? let next = ( (accu' lsl 6) lor ( ch land 0x7f )) in
 ????????? if j = jmax then begin???? (* except for 1st, each char gives 
6 bits*)
 ??????????? srcIdx := !srcIdx + j +1; Some next??????????? (* +1 for 
1st char *)
 ????????? end else cv' (succ j) next
 ????? in cv' 1? (* 1st char is already proccessed! *) accu
 ??? in if !srcIdx >= lim then None else
 ??? let n = str.[ !srcIdx ] in match n with
 ??? (* 0xxxxxxx *) | '\000' .. '\127' -> incr srcIdx; Some (int_of_char n)
 ??? (* 110yyyyy *) | '\128' .. '\223' -> cv 1 ((Char.code n) land 0b11111 )
 ??? (* 1110zzzz *) | '\224' .. '\239' -> cv 2 ((Char.code n) land 0b1111 )
 ??? (* 11110uuu *) | '\240' .. '\247' -> cv 3 ((Char.code n) land 0b111 )
 ??? (* 111110vv *) | '\248' .. '\251' -> cv 4 ((Char.code n) land 0b11 )
 ??? (* 1111110w *) | '\252' .. '\253' -> cv 5 ((Char.code n) land 0b1 )
 ??? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
 ? in? assemble_next;;


(* The 'natural' stream representation of a utf-string is a generator.
 ?* But Sequences are not far away ... *)
let makeUtf8Seq ?(srcIdx=ref 0) str = Sequence.of_gen (gen_of_utf8 
~srcIdx str)



(* Convert a code point to a string; Hopefully some day this will be in the
 ?* standard library. There are various equally trivial versions of this 
around.
 ?* The returned string is created (allocated) fresh for each k.
 ?* *)

let code_to_string k =
 ? let mask = 0b111111 in
 ? if k < 0 || k >= 0x4000000 then begin
 ??? let s = Bytes.create 6 in
 ??? Bytes.unsafe_set s 0 (Char.chr (0xfc + (k lsr 30)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 24) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 18) land 
mask)));
 ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 12) land 
mask)));
 ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 5 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? s end
 ? else if k <= 0x7f then
 ??? Bytes.make 1 (Char.unsafe_chr k)
 ? else if k <= 0x7ff then begin
 ??? let s = Bytes.create 2 in
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xc0 lor (k lsr 6)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? s end
 ? else if k <= 0xffff then begin
 ??? let s = Bytes.create 3 in
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xe0 lor (k lsr 12)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? s end
 ? else if k <= 0x1fffff then begin
 ??? let s = Bytes.create 4 in
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf0 + (k lsr 18)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 12) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? s end
 ? else begin
 ??? let s = Bytes.create 5 in
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf8 + (k lsr 24)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 18) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 12) land 
mask)));
 ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? s end

let string_to_code str =
 ??? let cv jmax accu =????? (* utf8 character length; construction of 
uchar *)
 ??? if jmax >? String.length str then raise (Failure "string_to_code")
 ??? else let rec cv' j accu' =?????? (* inner loop j = 1..jmax ; each 
uchar *)
 ????? let ch = Char.code (String.unsafe_get str j) in
 ????? let next = ( (accu' lsl 6) lor ( ch land 0x7f )) in
 ????? if j = jmax then next else cv' (succ j) next
 ????? in cv' 1? (* 1st char is already proccessed! *) accu
 ??? in let n = str.[0] in match n with
 ??? (* 0xxxxxxx *) | '\000' .. '\127' -> int_of_char n
 ??? (* 110yyyyy *) | '\128' .. '\223' -> cv 1 ((Char.code n) land 0b11111 )
 ??? (* 1110zzzz *) | '\224' .. '\239' -> cv 2 ((Char.code n) land 0b1111 )
 ??? (* 11110uuu *) | '\240' .. '\247' -> cv 3 ((Char.code n) land 0b111 )
 ??? (* 111110vv *) | '\248' .. '\251' -> cv 4 ((Char.code n) land 0b11 )
 ??? (* 1111110w *) | '\252' .. '\253' -> cv 5 ((Char.code n) land 0b1 )
 ??? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")


(* code_into_string over-writes string s which must be 7-byte string.
 ?* n-byte String ends with '\000' which is set as needed (in case you 
feed it
 ?* to a c-program). The last byte of a string contains the # of unused 
bytes in
 ?* then string. It is set here, for example, by "Bytes.unsafe_set s 6 
'\000'"
 ?* If the string is longer than 1 word (plus header) all hell breaks loose.
 ?* Use only if the string is copied afterwards. (Buffer.add_string ... etc)
 ?* DUBIOUS (and about twice as fast because allocation is not needed)
 ?* js_of_ocaml might be unhappy with this...
*)
let code_into_string s k =
 ? let mask = 0b111111 in
 ? if k < 0 || k >= 0x4000000 then begin
 ??? Bytes.unsafe_set s 0 (Char.chr (0xfc + (k lsr 30)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 24) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 18) land 
mask)));
 ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 12) land 
mask)));
 ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 5 (Char.unsafe_chr (0x80 lor ( k land mask)));
 ??? Bytes.unsafe_set s 6 '\000';?????????????????? (* string internals 
s/b OK *)
 ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 1 );?? (* string internals 
DUBIOUS *)
 ??? () end
 ? else if k <= 0x7f then begin
 ??? Bytes.unsafe_set s 0 (Char.chr k);
 ??? Bytes.unsafe_set s 1 '\000';
 ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 6 );
 ??? () end
 ? else if k <= 0x7ff then begin
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xc0 lor (k lsr 6)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? Bytes.unsafe_set s 2 '\000';
 ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 5 );
 ??? () end
 ? else if k <= 0xffff then begin
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xe0 lor (k lsr 12)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? Bytes.unsafe_set s 3 '\000';
 ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 4 );
 ??? () end
 ? else if k <= 0x1fffff then begin
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf0 + (k lsr 18)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 12) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? Bytes.unsafe_set s 4 '\000';
 ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 3 );
 ??? () end
 ? else begin
 ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf8 + (k lsr 24)));
 ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 18) land 
mask)));
 ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 12) land 
mask)));
 ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 6) land 
mask)));
 ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor (k land mask)));
 ??? Bytes.unsafe_set s 5 '\000';
 ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 2 );
 ??? () end

(* Automaton to map a (utf8) char Sequence.t into an int Sequence.t
 ?? Accept up to 6 characters, converting them to an integer to feed to k.
 ?? This code demonstrates that being at the receiving end of a sequence can
 ?? cause hardship ... It needs often a state-machine
 ?? ... and perhaps a better name? *)
 ? let mapUtf8Char2Code (k: int -> unit) =
 ??? let rec next = ref first
 ??? and accu = ref 0
 ??? and first ch = match ch with
 ????? (* 0xxxxxxx *) | '\000' .. '\127' -> k (int_of_char ch); accu := 0
 ????? (* 110yyyyy *) | '\128' .. '\223' -> cv s1 ch 0b11111
 ????? (* 1110zzzz *) | '\224' .. '\239' -> cv s2 ch 0b1111
 ????? (* 11110uuu *) | '\240' .. '\247' -> cv s3 ch 0b111
 ????? (* 111110vv *) | '\248' .. '\251' -> cv s4 ch 0b11
 ????? (* 1111110w *) | '\252' .. '\253' -> cv s5 ch 0b1
 ????? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
 ??? and inline ch = accu := (!accu lsl 6) lor ((Char.code ch) land 0x7f )
 ??? and s1 ch = inline ch; next := first; k !accu
 ??? and s2 ch = inline ch; next := s1 and s3 ch = inline ch; next := s2
 ??? and s4 ch = inline ch; next := s3 and s5 ch = inline ch; next := s4
 ??? and cv startState initialValue mask =
 ??????? next := startState;
 ??????? accu := (Char.code initialValue) land mask
 ? in (fun c -> !next c) ;;

let code_len k =
 ? if k < 0 || k >= 0x4000000 then 6 else if k <= 0x7f then 1
 ? else if k <= 0x7ff then 2 else if k <= 0xffff then 3
 ? else if k <= 0x1fffff then 4 else 5


(*
(* 
===========================================================================
 ?*?????????? various tests of above
*)


(* measure.ml
 ?* included to avoid dependency on some other (more capable) measuring tool
 ?*??????????????????????????????? *)
let measure fn arg (units:int)? comment =
 ? (* arg is last argument of fn (or unit not belonging to fn);
 ???? argument units is only used for ratio (units /. elapsed) *)
 ? let start = Unix.gettimeofday() in
 ? let res = fn arg in
 ? let endt = Unix.gettimeofday() in let elapsed = endt -. start in
 ? let open Printf in
 ? printf"\n%s\n\tTime:%f Units:%i Units/sec:%s uSecs/Unit:%s\n%!"
 ??????? (sprintf"Measured <<%s>>" comment)
 ??????? elapsed units
 ??????? ( if units <= 1 then "N/A" else
 ????????? sprintf"%8.0f" ((float_of_int units) /. elapsed ) )
 ??????? ( if units <= 1 then "N/A" else
 ????????? sprintf"%2.8f" (elapsed /. (float_of_int units) *. 1000000.0 ) );
 ? res


open Printf
module S = Sequence
module V = Vector

let code_to_string_test last =????????????????????????????? (* 
code_to_string *)
 ? for i = 0 to last do ignore (code_to_string i)? done ;;

let code_into_string_test last =????????????????????????? (* 
code_into_string *)
 ? let str = Bytes.create 6 in
 ? for i = 0 to last do ignore (code_into_string str i)? done ;;

let round_about2 last =??????????????????????????? (* code_to_string and 
back *)
 ? for i = 0 to last do
 ??? let str = code_to_string i in (* convert code point to char string *)
 ??? let j = string_to_code str in? (* convert the char string back to 
code *)
 ??? assert( i = j)
 ? done

let round_about3 last =????????????????????????? (* code_into_string and 
back *)
 ? let len = ref 1 in
 ? let str = Bytes.create 6 in
 ? for i = 0 to last do
 ??? code_into_string str i; (* convert code point to char string *)
 ??? let j = string_to_code str in? (* convert the char string back to 
code *)
 ??? assert( i = j);
 ??? if code_len i <> !len then (printf"New len at %x:%s\n" i str;
 ?????????????????????????????? len := code_len i )
 ? done


let make_big_string last = (* create a utf8 string of consecutive code 
points *)
 ? let buf = Buffer.create (16 * 1024 * 1024 ) in (* ocaml tolerates 
large *)
 ? let str = Bytes.create 6 in
 ? for i = 0 to last do
 ??? code_into_string str i;
 ??? Buffer.add_string buf str;
 ? done;
 ? Buffer.contents buf
 ? ;;

let make_big_string last = (* create a utf8 string of consecutive code 
points *)
 ? let buf = Buffer.create (16 * 1024 * 1024 ) in (* ocaml tolerates 
large *)
 ? let str = Bytes.create 7 in
 ? for i = 0 to last do
 ??? code_into_string str i;
 ??? Buffer.add_string buf str;
 ? done;
 ? let b = Buffer.contents buf in
 ? printf"\n\ncreated %i strings. \nfinal length: %i bytes. \
 ???????? \nAvg len %f\n%!"
 ???????? last
 ???????? (String.length b)
 ???????? ((float_of_int (String.length b)) /. (float_of_int last));
 ? b

let decode_big big =????????????? (* create a utf8 string; convert to 
int S.t *)
 ? let check = ref 0 in???????????? (* map char S.t to int S.t and test 
result *)
 ? (String.to_seq big)
 ? (mapUtf8Char2Code (fun j -> assert (j = !check) ; incr check))


let last1 = 0x3ffffff;; (*??? 67_108_863 *)
let last2 = 0x7fffffff;; (* 1073_741_823 *)
let last = last2 (* last2 uses ALL code points and takes a while *)

(* Sample: Convert a utf8 char string to a Vector *)
let utf8_to_vector str = str |> gen_of_utf8 |> V.of_gen

let _ = printf "\"SK????f\" |> utf8_to_vector \n\t |> Vector.to_seq |> 
S.map code_to_string |> fun seq -> seq (printf\"%s\t\")\n!";;

"SK????f" |> utf8_to_vector |> Vector.to_seq |> S.map code_to_string |>
 ?fun seq -> seq (printf"%s\t");;

(* Test below does not work for last 2 because it allocates a to big 
string *)
let big = measure make_big_string last1 last1 "make_big_string";;
measure decode_big big last1 "decode_big";;

(* Here last2 encodes/decodes ALL possible code points *)
measure round_about2 last last "round_about2";;
measure round_about3 last last "round_about3";;
measure code_into_string_test last last "code_into_string";;
measure code_to_string_test last last "code_to_string";;

let _ = (* One can never have to many samples ... *)
 ?printf"\n\n??? "; S.( 0 -- 15) (fun i -> printf" %2x" i);
 ?S.( 0 -- 15)
 ? (fun i -> printf"\n%4x? " (i * 16 + 0x2500);
 ??? S.( (0x2500 + i * 16) -- (0x250F + i * 16))
 ??? |> S.map code_to_string
 ??? |> S.to_list |> String.concat "? " |> print_string
 ? );;
*)



From simon.cruanes.2007 at m4x.org  Sat Feb 10 19:53:52 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Sat, 10 Feb 2018 13:53:52 -0600
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
Message-ID: <20180210195351.GE1388@carty>

Hi Peter,

Thanks for the suggestions. I'm no expert in unicode, but I do agree
that such basic functionalities should be more easily available.
Maybe a `Ustring` module in containers would make sense (as a private
alias to `string`); most functionalities below would fit there, I think.

Would you consider opening PRs against gen, sequence, and containers
repositories so we can discuss that without spamming the list? I can
help if needed, or do it myself.
I'm interested in tests too, but will probably write some (possibly
using Uutf as a reference); some of the tests you wrote below I can
retrofit in the qtest mechanism.

Cheers!


Le Sat, 10 Feb 2018, peter frey wrote:
> (*
> Reading recent posts on discuss.ocal.org gives me the impression that some
> tiny
> number of utf related routines should be more easily available.
> Container's Sequence.t and Gen.t, in particular could benefit from a couple
> of
> simple routines.? The code below fits well into that frame work.
> I am treating it as public domain code but feel free to make it your own and
> to
> include it where appropriate. (Perhaps some of the tests could go into the
> example directory...)
> The routines here DO NOT verify unless its unavoidable.? In particular they
> accept ALL code points that can be encoded by the original Utf8 definition.
> It is only a matter of language; we could call it utf31 ...
> Restricting the range is trivial; as would be including some verification
> code.
> 
> 
> 
> *)
> 
> open Containers
> 
> (* Create a generator from a utf8-string. Each call produces a code point.
> ?* The optional parameter srcIdx specifies then start point in the string.
> ?* srcIdx must point to a valid suffix of a utf8 string.
> ?* *)
> let gen_of_utf8 ?(srcIdx=ref 0) str =
> ??? let lim = String.length str in
> ??? let assemble_next () =???? (* we come here only for multi-byte
> characters *)
> ????? let cv jmax accu =????? (* utf8 character length; construction of
> uchar *)
> ??????? let rec cv' j accu' =????????? (* inner loop j = 1..jmax ; each
> uchar *)
> ????????? let ch = Char.code str.[ !srcIdx + j] in
> ????????? let next = ( (accu' lsl 6) lor ( ch land 0x7f )) in
> ????????? if j = jmax then begin???? (* except for 1st, each char gives 6
> bits*)
> ??????????? srcIdx := !srcIdx + j +1; Some next??????????? (* +1 for 1st
> char *)
> ????????? end else cv' (succ j) next
> ????? in cv' 1? (* 1st char is already proccessed! *) accu
> ??? in if !srcIdx >= lim then None else
> ??? let n = str.[ !srcIdx ] in match n with
> ??? (* 0xxxxxxx *) | '\000' .. '\127' -> incr srcIdx; Some (int_of_char n)
> ??? (* 110yyyyy *) | '\128' .. '\223' -> cv 1 ((Char.code n) land 0b11111 )
> ??? (* 1110zzzz *) | '\224' .. '\239' -> cv 2 ((Char.code n) land 0b1111 )
> ??? (* 11110uuu *) | '\240' .. '\247' -> cv 3 ((Char.code n) land 0b111 )
> ??? (* 111110vv *) | '\248' .. '\251' -> cv 4 ((Char.code n) land 0b11 )
> ??? (* 1111110w *) | '\252' .. '\253' -> cv 5 ((Char.code n) land 0b1 )
> ??? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
> ? in? assemble_next;;
> 
> 
> (* The 'natural' stream representation of a utf-string is a generator.
> ?* But Sequences are not far away ... *)
> let makeUtf8Seq ?(srcIdx=ref 0) str = Sequence.of_gen (gen_of_utf8 ~srcIdx
> str)
> 
> 
> 
> (* Convert a code point to a string; Hopefully some day this will be in the
> ?* standard library. There are various equally trivial versions of this
> around.
> ?* The returned string is created (allocated) fresh for each k.
> ?* *)
> 
> let code_to_string k =
> ? let mask = 0b111111 in
> ? if k < 0 || k >= 0x4000000 then begin
> ??? let s = Bytes.create 6 in
> ??? Bytes.unsafe_set s 0 (Char.chr (0xfc + (k lsr 30)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 24) land
> mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
> mask)));
> ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
> mask)));
> ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 5 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? s end
> ? else if k <= 0x7f then
> ??? Bytes.make 1 (Char.unsafe_chr k)
> ? else if k <= 0x7ff then begin
> ??? let s = Bytes.create 2 in
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xc0 lor (k lsr 6)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? s end
> ? else if k <= 0xffff then begin
> ??? let s = Bytes.create 3 in
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xe0 lor (k lsr 12)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? s end
> ? else if k <= 0x1fffff then begin
> ??? let s = Bytes.create 4 in
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf0 + (k lsr 18)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
> mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? s end
> ? else begin
> ??? let s = Bytes.create 5 in
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf8 + (k lsr 24)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
> mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
> mask)));
> ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? s end
> 
> let string_to_code str =
> ??? let cv jmax accu =????? (* utf8 character length; construction of uchar
> *)
> ??? if jmax >? String.length str then raise (Failure "string_to_code")
> ??? else let rec cv' j accu' =?????? (* inner loop j = 1..jmax ; each uchar
> *)
> ????? let ch = Char.code (String.unsafe_get str j) in
> ????? let next = ( (accu' lsl 6) lor ( ch land 0x7f )) in
> ????? if j = jmax then next else cv' (succ j) next
> ????? in cv' 1? (* 1st char is already proccessed! *) accu
> ??? in let n = str.[0] in match n with
> ??? (* 0xxxxxxx *) | '\000' .. '\127' -> int_of_char n
> ??? (* 110yyyyy *) | '\128' .. '\223' -> cv 1 ((Char.code n) land 0b11111 )
> ??? (* 1110zzzz *) | '\224' .. '\239' -> cv 2 ((Char.code n) land 0b1111 )
> ??? (* 11110uuu *) | '\240' .. '\247' -> cv 3 ((Char.code n) land 0b111 )
> ??? (* 111110vv *) | '\248' .. '\251' -> cv 4 ((Char.code n) land 0b11 )
> ??? (* 1111110w *) | '\252' .. '\253' -> cv 5 ((Char.code n) land 0b1 )
> ??? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
> 
> 
> (* code_into_string over-writes string s which must be 7-byte string.
> ?* n-byte String ends with '\000' which is set as needed (in case you feed
> it
> ?* to a c-program). The last byte of a string contains the # of unused bytes
> in
> ?* then string. It is set here, for example, by "Bytes.unsafe_set s 6
> '\000'"
> ?* If the string is longer than 1 word (plus header) all hell breaks loose.
> ?* Use only if the string is copied afterwards. (Buffer.add_string ... etc)
> ?* DUBIOUS (and about twice as fast because allocation is not needed)
> ?* js_of_ocaml might be unhappy with this...
> *)
> let code_into_string s k =
> ? let mask = 0b111111 in
> ? if k < 0 || k >= 0x4000000 then begin
> ??? Bytes.unsafe_set s 0 (Char.chr (0xfc + (k lsr 30)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 24) land
> mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
> mask)));
> ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
> mask)));
> ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 5 (Char.unsafe_chr (0x80 lor ( k land mask)));
> ??? Bytes.unsafe_set s 6 '\000';?????????????????? (* string internals s/b
> OK *)
> ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 1 );?? (* string internals
> DUBIOUS *)
> ??? () end
> ? else if k <= 0x7f then begin
> ??? Bytes.unsafe_set s 0 (Char.chr k);
> ??? Bytes.unsafe_set s 1 '\000';
> ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 6 );
> ??? () end
> ? else if k <= 0x7ff then begin
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xc0 lor (k lsr 6)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? Bytes.unsafe_set s 2 '\000';
> ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 5 );
> ??? () end
> ? else if k <= 0xffff then begin
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xe0 lor (k lsr 12)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? Bytes.unsafe_set s 3 '\000';
> ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 4 );
> ??? () end
> ? else if k <= 0x1fffff then begin
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf0 + (k lsr 18)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
> mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? Bytes.unsafe_set s 4 '\000';
> ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 3 );
> ??? () end
> ? else begin
> ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf8 + (k lsr 24)));
> ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
> mask)));
> ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
> mask)));
> ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
> ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor (k land mask)));
> ??? Bytes.unsafe_set s 5 '\000';
> ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 2 );
> ??? () end
> 
> (* Automaton to map a (utf8) char Sequence.t into an int Sequence.t
> ?? Accept up to 6 characters, converting them to an integer to feed to k.
> ?? This code demonstrates that being at the receiving end of a sequence can
> ?? cause hardship ... It needs often a state-machine
> ?? ... and perhaps a better name? *)
> ? let mapUtf8Char2Code (k: int -> unit) =
> ??? let rec next = ref first
> ??? and accu = ref 0
> ??? and first ch = match ch with
> ????? (* 0xxxxxxx *) | '\000' .. '\127' -> k (int_of_char ch); accu := 0
> ????? (* 110yyyyy *) | '\128' .. '\223' -> cv s1 ch 0b11111
> ????? (* 1110zzzz *) | '\224' .. '\239' -> cv s2 ch 0b1111
> ????? (* 11110uuu *) | '\240' .. '\247' -> cv s3 ch 0b111
> ????? (* 111110vv *) | '\248' .. '\251' -> cv s4 ch 0b11
> ????? (* 1111110w *) | '\252' .. '\253' -> cv s5 ch 0b1
> ????? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
> ??? and inline ch = accu := (!accu lsl 6) lor ((Char.code ch) land 0x7f )
> ??? and s1 ch = inline ch; next := first; k !accu
> ??? and s2 ch = inline ch; next := s1 and s3 ch = inline ch; next := s2
> ??? and s4 ch = inline ch; next := s3 and s5 ch = inline ch; next := s4
> ??? and cv startState initialValue mask =
> ??????? next := startState;
> ??????? accu := (Char.code initialValue) land mask
> ? in (fun c -> !next c) ;;
> 
> let code_len k =
> ? if k < 0 || k >= 0x4000000 then 6 else if k <= 0x7f then 1
> ? else if k <= 0x7ff then 2 else if k <= 0xffff then 3
> ? else if k <= 0x1fffff then 4 else 5
> 
> 
> (*
> (*
> ===========================================================================
> ?*?????????? various tests of above
> *)
> 
> 
> (* measure.ml
> ?* included to avoid dependency on some other (more capable) measuring tool
> ?*??????????????????????????????? *)
> let measure fn arg (units:int)? comment =
> ? (* arg is last argument of fn (or unit not belonging to fn);
> ???? argument units is only used for ratio (units /. elapsed) *)
> ? let start = Unix.gettimeofday() in
> ? let res = fn arg in
> ? let endt = Unix.gettimeofday() in let elapsed = endt -. start in
> ? let open Printf in
> ? printf"\n%s\n\tTime:%f Units:%i Units/sec:%s uSecs/Unit:%s\n%!"
> ??????? (sprintf"Measured <<%s>>" comment)
> ??????? elapsed units
> ??????? ( if units <= 1 then "N/A" else
> ????????? sprintf"%8.0f" ((float_of_int units) /. elapsed ) )
> ??????? ( if units <= 1 then "N/A" else
> ????????? sprintf"%2.8f" (elapsed /. (float_of_int units) *. 1000000.0 ) );
> ? res
> 
> 
> open Printf
> module S = Sequence
> module V = Vector
> 
> let code_to_string_test last =????????????????????????????? (*
> code_to_string *)
> ? for i = 0 to last do ignore (code_to_string i)? done ;;
> 
> let code_into_string_test last =????????????????????????? (*
> code_into_string *)
> ? let str = Bytes.create 6 in
> ? for i = 0 to last do ignore (code_into_string str i)? done ;;
> 
> let round_about2 last =??????????????????????????? (* code_to_string and
> back *)
> ? for i = 0 to last do
> ??? let str = code_to_string i in (* convert code point to char string *)
> ??? let j = string_to_code str in? (* convert the char string back to code
> *)
> ??? assert( i = j)
> ? done
> 
> let round_about3 last =????????????????????????? (* code_into_string and
> back *)
> ? let len = ref 1 in
> ? let str = Bytes.create 6 in
> ? for i = 0 to last do
> ??? code_into_string str i; (* convert code point to char string *)
> ??? let j = string_to_code str in? (* convert the char string back to code
> *)
> ??? assert( i = j);
> ??? if code_len i <> !len then (printf"New len at %x:%s\n" i str;
> ?????????????????????????????? len := code_len i )
> ? done
> 
> 
> let make_big_string last = (* create a utf8 string of consecutive code
> points *)
> ? let buf = Buffer.create (16 * 1024 * 1024 ) in (* ocaml tolerates large *)
> ? let str = Bytes.create 6 in
> ? for i = 0 to last do
> ??? code_into_string str i;
> ??? Buffer.add_string buf str;
> ? done;
> ? Buffer.contents buf
> ? ;;
> 
> let make_big_string last = (* create a utf8 string of consecutive code
> points *)
> ? let buf = Buffer.create (16 * 1024 * 1024 ) in (* ocaml tolerates large *)
> ? let str = Bytes.create 7 in
> ? for i = 0 to last do
> ??? code_into_string str i;
> ??? Buffer.add_string buf str;
> ? done;
> ? let b = Buffer.contents buf in
> ? printf"\n\ncreated %i strings. \nfinal length: %i bytes. \
> ???????? \nAvg len %f\n%!"
> ???????? last
> ???????? (String.length b)
> ???????? ((float_of_int (String.length b)) /. (float_of_int last));
> ? b
> 
> let decode_big big =????????????? (* create a utf8 string; convert to int
> S.t *)
> ? let check = ref 0 in???????????? (* map char S.t to int S.t and test
> result *)
> ? (String.to_seq big)
> ? (mapUtf8Char2Code (fun j -> assert (j = !check) ; incr check))
> 
> 
> let last1 = 0x3ffffff;; (*??? 67_108_863 *)
> let last2 = 0x7fffffff;; (* 1073_741_823 *)
> let last = last2 (* last2 uses ALL code points and takes a while *)
> 
> (* Sample: Convert a utf8 char string to a Vector *)
> let utf8_to_vector str = str |> gen_of_utf8 |> V.of_gen
> 
> let _ = printf "\"SK????f\" |> utf8_to_vector \n\t |> Vector.to_seq |>
> S.map code_to_string |> fun seq -> seq (printf\"%s\t\")\n!";;
> 
> "SK????f" |> utf8_to_vector |> Vector.to_seq |> S.map code_to_string |>
> ?fun seq -> seq (printf"%s\t");;
> 
> (* Test below does not work for last 2 because it allocates a to big string
> *)
> let big = measure make_big_string last1 last1 "make_big_string";;
> measure decode_big big last1 "decode_big";;
> 
> (* Here last2 encodes/decodes ALL possible code points *)
> measure round_about2 last last "round_about2";;
> measure round_about3 last last "round_about3";;
> measure code_into_string_test last last "code_into_string";;
> measure code_to_string_test last last "code_to_string";;
> 
> let _ = (* One can never have to many samples ... *)
> ?printf"\n\n??? "; S.( 0 -- 15) (fun i -> printf" %2x" i);
> ?S.( 0 -- 15)
> ? (fun i -> printf"\n%4x? " (i * 16 + 0x2500);
> ??? S.( (0x2500 + i * 16) -- (0x250F + i * 16))
> ??? |> S.map code_to_string
> ??? |> S.to_list |> String.concat "? " |> print_string
> ? );;
> *)
> 


-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180210/614f93a1/attachment-0001.sig>

From sp at orbitalfox.eu  Fri Feb 23 00:37:29 2018
From: sp at orbitalfox.eu (SP)
Date: Fri, 23 Feb 2018 00:37:29 +0000
Subject: [containers-users] Request for comments on BiMap
Message-ID: <20180223003729.lnkfx5fncnyiqxvd@darkstar>

I've started working on a BiMap, a map where (key, value) is also
(value, key) in a one-to-one relationship.

https://github.com/c-cube/ocaml-containers/compare/master...orbifx:bimap

As I'm writing this I have written `empty`, `add`, `find_left` and
`find_right`.

The idea is that when adding a left-key, right-value to the BiMap, it
doesn't just check for the preexistence of the left key, but also checks
if the right value already has a left key and removes it if so. Vice
versa for right key, left value.

Please provide any comments and thoughts.

One question I have is why are map values first in the order of
parameters? For example:

https://github.com/c-cube/ocaml-containers/blob/master/src/data/CCMultiMap.ml#L294
 
-- 
	SP

From sp at orbitalfox.eu  Fri Feb 23 00:48:59 2018
From: sp at orbitalfox.eu (SP)
Date: Fri, 23 Feb 2018 00:48:59 +0000
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <20180210195351.GE1388@carty>
Message-ID: <20180223004859.50f10c99@darkstar>

> Thanks for the suggestions. I'm no expert in unicode, but I do agree
> that such basic functionalities should be more easily available.
> Maybe a `Ustring` module in containers would make sense (as a private
> alias to `string`); most functionalities below would fit there

Is this for facilitation or implementation of UTF?

There is an implementation here <https://opam.ocaml.org/packages/uutf/>

-- 
	SP

From simon.cruanes.2007 at m4x.org  Fri Feb 23 02:07:02 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Thu, 22 Feb 2018 20:07:02 -0600
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
Message-ID: <20180223020701.GA2041@carty>

Nice!

This looks pretty ok (albeit far from complete, a proper module will
have to have conversion from/to lists, from/to sequences, and probably
some other convenient functions such as membership testing or
cardinality or is_empty).

Some comments for future inclusion in containers:

- The module type Bimap should be called S (main signature).
- Also, what add does on collision over any key should be clearly
specified in the docs
- that find functions can raise Not_found must be properly documented (@raise)
- in the implementation of add, don't use !=, use L.compare (resp.
  R.compare). != will be almost always wrong.

Le Fri, 23 Feb 2018, SP wrote:

> I've started working on a BiMap, a map where (key, value) is also
> (value, key) in a one-to-one relationship.
> 
> https://github.com/c-cube/ocaml-containers/compare/master...orbifx:bimap
> 
> As I'm writing this I have written `empty`, `add`, `find_left` and
> `find_right`.
> 
> The idea is that when adding a left-key, right-value to the BiMap, it
> doesn't just check for the preexistence of the left key, but also checks
> if the right value already has a left key and removes it if so. Vice
> versa for right key, left value.


> One question I have is why are map values first in the order of
> parameters? For example:
> 
> https://github.com/c-cube/ocaml-containers/blob/master/src/data/CCMultiMap.ml#L294

Oversight.


-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180222/509c92aa/attachment.sig>

From simon.cruanes.2007 at m4x.org  Fri Feb 23 02:07:39 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Thu, 22 Feb 2018 20:07:39 -0600
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <20180223004859.50f10c99@darkstar>
References: <20180210195351.GE1388@carty>
 <20180223004859.50f10c99@darkstar>
Message-ID: <20180223020738.GB2041@carty>

Le Fri, 23 Feb 2018, SP wrote:
> > Thanks for the suggestions. I'm no expert in unicode, but I do agree
> > that such basic functionalities should be more easily available.
> > Maybe a `Ustring` module in containers would make sense (as a private
> > alias to `string`); most functionalities below would fit there
> 
> Is this for facilitation or implementation of UTF?
> 
> There is an implementation here <https://opam.ocaml.org/packages/uutf/>

Yes, but we can avoid using it for the most basic facilities.
It'd be nice to compare with in tests, though.

-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180222/928ba217/attachment.sig>

From sp at orbitalfox.eu  Fri Feb 23 08:19:54 2018
From: sp at orbitalfox.eu (SP)
Date: Fri, 23 Feb 2018 08:19:54 +0000
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <20180223020701.GA2041@carty>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
 <20180223020701.GA2041@carty>
Message-ID: <20180223081954.ixpelivkeqhvmxfu@darkstar>

I think is_empty is there. Will be adding the rest you mentioned and
whatever else I can think of being useful.

Will also fix the signature and do the docs near the end, once the
functionality is starting to solidify.

On Thu, Feb 22, 2018 at 08:07:02PM -0600, Simon Cruanes wrote:
>- in the implementation of add, don't use !=, use L.compare (resp.
>  R.compare). != will be almost always wrong.

Oops. I mean to use <>, but you are right (L|R).compare is better
anyway. This is what happens on a late night after only a few days of C.
:P

>> One question I have is why are map values first in the order of
>> parameters? For example:
>> https://github.com/c-cube/ocaml-containers/blob/master/src/data/CCMultiMap.ml#L294
>
>Oversight.

Shall I revert the order for this module, or has the "new convention"
have to be upheld?

-- 
	SP

From simon.cruanes.2007 at m4x.org  Fri Feb 23 13:32:48 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Fri, 23 Feb 2018 07:32:48 -0600
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <20180223081954.ixpelivkeqhvmxfu@darkstar>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
 <20180223020701.GA2041@carty> <20180223081954.ixpelivkeqhvmxfu@darkstar>
Message-ID: <A2FB9223-200F-466E-8D09-85BBB3BEA859@m4x.org>




>Shall I revert the order for this module, or has the "new convention"
>have to be upheld?

Put the map last, as is convenient for piping. 

-- 
Simon 


From drupyog at zoho.com  Sat Feb 24 12:01:45 2018
From: drupyog at zoho.com (Drup)
Date: Sat, 24 Feb 2018 13:01:45 +0100
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
Message-ID: <a8d6653c-537d-47b0-9dcc-c0fcec4d1a7f@zoho.com>

Why not call this "Bijection" or "BijMap" ? BiMap simply implies two 
maps. This a bit more specific.


Le 23/02/2018 ? 01:37, SP a ?crit?:
> I've started working on a BiMap, a map where (key, value) is also
> (value, key) in a one-to-one relationship.
>
> https://github.com/c-cube/ocaml-containers/compare/master...orbifx:bimap
>
> As I'm writing this I have written `empty`, `add`, `find_left` and
> `find_right`.
>
> The idea is that when adding a left-key, right-value to the BiMap, it
> doesn't just check for the preexistence of the left key, but also checks
> if the right value already has a left key and removes it if so. Vice
> versa for right key, left value.
>
> Please provide any comments and thoughts.
>
> One question I have is why are map values first in the order of
> parameters? For example:
>
> https://github.com/c-cube/ocaml-containers/blob/master/src/data/CCMultiMap.ml#L294 
>
>



From drupyog at zoho.com  Sat Feb 24 12:09:43 2018
From: drupyog at zoho.com (Drup)
Date: Sat, 24 Feb 2018 13:09:43 +0100
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <20180210195351.GE1388@carty>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
 <20180210195351.GE1388@carty>
Message-ID: <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>

Shouldn't we just standardize on bunzli's libraries (including the new 
https://github.com/dbuenzli/utext) instead of trying to re-write code 
that usually ends up being quite subtle in each standard library ?


Le 10/02/2018 ? 20:53, Simon Cruanes a ?crit?:
> Hi Peter,
>
> Thanks for the suggestions. I'm no expert in unicode, but I do agree
> that such basic functionalities should be more easily available.
> Maybe a `Ustring` module in containers would make sense (as a private
> alias to `string`); most functionalities below would fit there, I think.
>
> Would you consider opening PRs against gen, sequence, and containers
> repositories so we can discuss that without spamming the list? I can
> help if needed, or do it myself.
> I'm interested in tests too, but will probably write some (possibly
> using Uutf as a reference); some of the tests you wrote below I can
> retrofit in the qtest mechanism.
>
> Cheers!
>
>
> Le Sat, 10 Feb 2018, peter frey wrote:
>> (*
>> Reading recent posts on discuss.ocal.org gives me the impression that some
>> tiny
>> number of utf related routines should be more easily available.
>> Container's Sequence.t and Gen.t, in particular could benefit from a couple
>> of
>> simple routines.? The code below fits well into that frame work.
>> I am treating it as public domain code but feel free to make it your own and
>> to
>> include it where appropriate. (Perhaps some of the tests could go into the
>> example directory...)
>> The routines here DO NOT verify unless its unavoidable.? In particular they
>> accept ALL code points that can be encoded by the original Utf8 definition.
>> It is only a matter of language; we could call it utf31 ...
>> Restricting the range is trivial; as would be including some verification
>> code.
>>
>>
>>
>> *)
>>
>> open Containers
>>
>> (* Create a generator from a utf8-string. Each call produces a code point.
>>  ?* The optional parameter srcIdx specifies then start point in the string.
>>  ?* srcIdx must point to a valid suffix of a utf8 string.
>>  ?* *)
>> let gen_of_utf8 ?(srcIdx=ref 0) str =
>>  ??? let lim = String.length str in
>>  ??? let assemble_next () =???? (* we come here only for multi-byte
>> characters *)
>>  ????? let cv jmax accu =????? (* utf8 character length; construction of
>> uchar *)
>>  ??????? let rec cv' j accu' =????????? (* inner loop j = 1..jmax ; each
>> uchar *)
>>  ????????? let ch = Char.code str.[ !srcIdx + j] in
>>  ????????? let next = ( (accu' lsl 6) lor ( ch land 0x7f )) in
>>  ????????? if j = jmax then begin???? (* except for 1st, each char gives 6
>> bits*)
>>  ??????????? srcIdx := !srcIdx + j +1; Some next??????????? (* +1 for 1st
>> char *)
>>  ????????? end else cv' (succ j) next
>>  ????? in cv' 1? (* 1st char is already proccessed! *) accu
>>  ??? in if !srcIdx >= lim then None else
>>  ??? let n = str.[ !srcIdx ] in match n with
>>  ??? (* 0xxxxxxx *) | '\000' .. '\127' -> incr srcIdx; Some (int_of_char n)
>>  ??? (* 110yyyyy *) | '\128' .. '\223' -> cv 1 ((Char.code n) land 0b11111 )
>>  ??? (* 1110zzzz *) | '\224' .. '\239' -> cv 2 ((Char.code n) land 0b1111 )
>>  ??? (* 11110uuu *) | '\240' .. '\247' -> cv 3 ((Char.code n) land 0b111 )
>>  ??? (* 111110vv *) | '\248' .. '\251' -> cv 4 ((Char.code n) land 0b11 )
>>  ??? (* 1111110w *) | '\252' .. '\253' -> cv 5 ((Char.code n) land 0b1 )
>>  ??? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
>>  ? in? assemble_next;;
>>
>>
>> (* The 'natural' stream representation of a utf-string is a generator.
>>  ?* But Sequences are not far away ... *)
>> let makeUtf8Seq ?(srcIdx=ref 0) str = Sequence.of_gen (gen_of_utf8 ~srcIdx
>> str)
>>
>>
>>
>> (* Convert a code point to a string; Hopefully some day this will be in the
>>  ?* standard library. There are various equally trivial versions of this
>> around.
>>  ?* The returned string is created (allocated) fresh for each k.
>>  ?* *)
>>
>> let code_to_string k =
>>  ? let mask = 0b111111 in
>>  ? if k < 0 || k >= 0x4000000 then begin
>>  ??? let s = Bytes.create 6 in
>>  ??? Bytes.unsafe_set s 0 (Char.chr (0xfc + (k lsr 30)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 24) land
>> mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
>> mask)));
>>  ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
>> mask)));
>>  ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 5 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? s end
>>  ? else if k <= 0x7f then
>>  ??? Bytes.make 1 (Char.unsafe_chr k)
>>  ? else if k <= 0x7ff then begin
>>  ??? let s = Bytes.create 2 in
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xc0 lor (k lsr 6)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? s end
>>  ? else if k <= 0xffff then begin
>>  ??? let s = Bytes.create 3 in
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xe0 lor (k lsr 12)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? s end
>>  ? else if k <= 0x1fffff then begin
>>  ??? let s = Bytes.create 4 in
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf0 + (k lsr 18)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
>> mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? s end
>>  ? else begin
>>  ??? let s = Bytes.create 5 in
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf8 + (k lsr 24)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
>> mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
>> mask)));
>>  ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? s end
>>
>> let string_to_code str =
>>  ??? let cv jmax accu =????? (* utf8 character length; construction of uchar
>> *)
>>  ??? if jmax >? String.length str then raise (Failure "string_to_code")
>>  ??? else let rec cv' j accu' =?????? (* inner loop j = 1..jmax ; each uchar
>> *)
>>  ????? let ch = Char.code (String.unsafe_get str j) in
>>  ????? let next = ( (accu' lsl 6) lor ( ch land 0x7f )) in
>>  ????? if j = jmax then next else cv' (succ j) next
>>  ????? in cv' 1? (* 1st char is already proccessed! *) accu
>>  ??? in let n = str.[0] in match n with
>>  ??? (* 0xxxxxxx *) | '\000' .. '\127' -> int_of_char n
>>  ??? (* 110yyyyy *) | '\128' .. '\223' -> cv 1 ((Char.code n) land 0b11111 )
>>  ??? (* 1110zzzz *) | '\224' .. '\239' -> cv 2 ((Char.code n) land 0b1111 )
>>  ??? (* 11110uuu *) | '\240' .. '\247' -> cv 3 ((Char.code n) land 0b111 )
>>  ??? (* 111110vv *) | '\248' .. '\251' -> cv 4 ((Char.code n) land 0b11 )
>>  ??? (* 1111110w *) | '\252' .. '\253' -> cv 5 ((Char.code n) land 0b1 )
>>  ??? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
>>
>>
>> (* code_into_string over-writes string s which must be 7-byte string.
>>  ?* n-byte String ends with '\000' which is set as needed (in case you feed
>> it
>>  ?* to a c-program). The last byte of a string contains the # of unused bytes
>> in
>>  ?* then string. It is set here, for example, by "Bytes.unsafe_set s 6
>> '\000'"
>>  ?* If the string is longer than 1 word (plus header) all hell breaks loose.
>>  ?* Use only if the string is copied afterwards. (Buffer.add_string ... etc)
>>  ?* DUBIOUS (and about twice as fast because allocation is not needed)
>>  ?* js_of_ocaml might be unhappy with this...
>> *)
>> let code_into_string s k =
>>  ? let mask = 0b111111 in
>>  ? if k < 0 || k >= 0x4000000 then begin
>>  ??? Bytes.unsafe_set s 0 (Char.chr (0xfc + (k lsr 30)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 24) land
>> mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
>> mask)));
>>  ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
>> mask)));
>>  ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 5 (Char.unsafe_chr (0x80 lor ( k land mask)));
>>  ??? Bytes.unsafe_set s 6 '\000';?????????????????? (* string internals s/b
>> OK *)
>>  ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 1 );?? (* string internals
>> DUBIOUS *)
>>  ??? () end
>>  ? else if k <= 0x7f then begin
>>  ??? Bytes.unsafe_set s 0 (Char.chr k);
>>  ??? Bytes.unsafe_set s 1 '\000';
>>  ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 6 );
>>  ??? () end
>>  ? else if k <= 0x7ff then begin
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xc0 lor (k lsr 6)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? Bytes.unsafe_set s 2 '\000';
>>  ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 5 );
>>  ??? () end
>>  ? else if k <= 0xffff then begin
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xe0 lor (k lsr 12)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? Bytes.unsafe_set s 3 '\000';
>>  ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 4 );
>>  ??? () end
>>  ? else if k <= 0x1fffff then begin
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf0 + (k lsr 18)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
>> mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? Bytes.unsafe_set s 4 '\000';
>>  ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 3 );
>>  ??? () end
>>  ? else begin
>>  ??? Bytes.unsafe_set s 0 (Char.unsafe_chr (0xf8 + (k lsr 24)));
>>  ??? Bytes.unsafe_set s 1 (Char.unsafe_chr (0x80 lor ((k lsr 18) land
>> mask)));
>>  ??? Bytes.unsafe_set s 2 (Char.unsafe_chr (0x80 lor ((k lsr 12) land
>> mask)));
>>  ??? Bytes.unsafe_set s 3 (Char.unsafe_chr (0x80 lor ((k lsr 6) land mask)));
>>  ??? Bytes.unsafe_set s 4 (Char.unsafe_chr (0x80 lor (k land mask)));
>>  ??? Bytes.unsafe_set s 5 '\000';
>>  ??? Bytes.unsafe_set s 7 (Char.unsafe_chr? 2 );
>>  ??? () end
>>
>> (* Automaton to map a (utf8) char Sequence.t into an int Sequence.t
>>  ?? Accept up to 6 characters, converting them to an integer to feed to k.
>>  ?? This code demonstrates that being at the receiving end of a sequence can
>>  ?? cause hardship ... It needs often a state-machine
>>  ?? ... and perhaps a better name? *)
>>  ? let mapUtf8Char2Code (k: int -> unit) =
>>  ??? let rec next = ref first
>>  ??? and accu = ref 0
>>  ??? and first ch = match ch with
>>  ????? (* 0xxxxxxx *) | '\000' .. '\127' -> k (int_of_char ch); accu := 0
>>  ????? (* 110yyyyy *) | '\128' .. '\223' -> cv s1 ch 0b11111
>>  ????? (* 1110zzzz *) | '\224' .. '\239' -> cv s2 ch 0b1111
>>  ????? (* 11110uuu *) | '\240' .. '\247' -> cv s3 ch 0b111
>>  ????? (* 111110vv *) | '\248' .. '\251' -> cv s4 ch 0b11
>>  ????? (* 1111110w *) | '\252' .. '\253' -> cv s5 ch 0b1
>>  ????? (* 1111111X *) | '\254' .. '\255' -> raise (Failure "Bad stream")
>>  ??? and inline ch = accu := (!accu lsl 6) lor ((Char.code ch) land 0x7f )
>>  ??? and s1 ch = inline ch; next := first; k !accu
>>  ??? and s2 ch = inline ch; next := s1 and s3 ch = inline ch; next := s2
>>  ??? and s4 ch = inline ch; next := s3 and s5 ch = inline ch; next := s4
>>  ??? and cv startState initialValue mask =
>>  ??????? next := startState;
>>  ??????? accu := (Char.code initialValue) land mask
>>  ? in (fun c -> !next c) ;;
>>
>> let code_len k =
>>  ? if k < 0 || k >= 0x4000000 then 6 else if k <= 0x7f then 1
>>  ? else if k <= 0x7ff then 2 else if k <= 0xffff then 3
>>  ? else if k <= 0x1fffff then 4 else 5
>>
>>
>> (*
>> (*
>> ===========================================================================
>>  ?*?????????? various tests of above
>> *)
>>
>>
>> (* measure.ml
>>  ?* included to avoid dependency on some other (more capable) measuring tool
>>  ?*??????????????????????????????? *)
>> let measure fn arg (units:int)? comment =
>>  ? (* arg is last argument of fn (or unit not belonging to fn);
>>  ???? argument units is only used for ratio (units /. elapsed) *)
>>  ? let start = Unix.gettimeofday() in
>>  ? let res = fn arg in
>>  ? let endt = Unix.gettimeofday() in let elapsed = endt -. start in
>>  ? let open Printf in
>>  ? printf"\n%s\n\tTime:%f Units:%i Units/sec:%s uSecs/Unit:%s\n%!"
>>  ??????? (sprintf"Measured <<%s>>" comment)
>>  ??????? elapsed units
>>  ??????? ( if units <= 1 then "N/A" else
>>  ????????? sprintf"%8.0f" ((float_of_int units) /. elapsed ) )
>>  ??????? ( if units <= 1 then "N/A" else
>>  ????????? sprintf"%2.8f" (elapsed /. (float_of_int units) *. 1000000.0 ) );
>>  ? res
>>
>>
>> open Printf
>> module S = Sequence
>> module V = Vector
>>
>> let code_to_string_test last =????????????????????????????? (*
>> code_to_string *)
>>  ? for i = 0 to last do ignore (code_to_string i)? done ;;
>>
>> let code_into_string_test last =????????????????????????? (*
>> code_into_string *)
>>  ? let str = Bytes.create 6 in
>>  ? for i = 0 to last do ignore (code_into_string str i)? done ;;
>>
>> let round_about2 last =??????????????????????????? (* code_to_string and
>> back *)
>>  ? for i = 0 to last do
>>  ??? let str = code_to_string i in (* convert code point to char string *)
>>  ??? let j = string_to_code str in? (* convert the char string back to code
>> *)
>>  ??? assert( i = j)
>>  ? done
>>
>> let round_about3 last =????????????????????????? (* code_into_string and
>> back *)
>>  ? let len = ref 1 in
>>  ? let str = Bytes.create 6 in
>>  ? for i = 0 to last do
>>  ??? code_into_string str i; (* convert code point to char string *)
>>  ??? let j = string_to_code str in? (* convert the char string back to code
>> *)
>>  ??? assert( i = j);
>>  ??? if code_len i <> !len then (printf"New len at %x:%s\n" i str;
>>  ?????????????????????????????? len := code_len i )
>>  ? done
>>
>>
>> let make_big_string last = (* create a utf8 string of consecutive code
>> points *)
>>  ? let buf = Buffer.create (16 * 1024 * 1024 ) in (* ocaml tolerates large *)
>>  ? let str = Bytes.create 6 in
>>  ? for i = 0 to last do
>>  ??? code_into_string str i;
>>  ??? Buffer.add_string buf str;
>>  ? done;
>>  ? Buffer.contents buf
>>  ? ;;
>>
>> let make_big_string last = (* create a utf8 string of consecutive code
>> points *)
>>  ? let buf = Buffer.create (16 * 1024 * 1024 ) in (* ocaml tolerates large *)
>>  ? let str = Bytes.create 7 in
>>  ? for i = 0 to last do
>>  ??? code_into_string str i;
>>  ??? Buffer.add_string buf str;
>>  ? done;
>>  ? let b = Buffer.contents buf in
>>  ? printf"\n\ncreated %i strings. \nfinal length: %i bytes. \
>>  ???????? \nAvg len %f\n%!"
>>  ???????? last
>>  ???????? (String.length b)
>>  ???????? ((float_of_int (String.length b)) /. (float_of_int last));
>>  ? b
>>
>> let decode_big big =????????????? (* create a utf8 string; convert to int
>> S.t *)
>>  ? let check = ref 0 in???????????? (* map char S.t to int S.t and test
>> result *)
>>  ? (String.to_seq big)
>>  ? (mapUtf8Char2Code (fun j -> assert (j = !check) ; incr check))
>>
>>
>> let last1 = 0x3ffffff;; (*??? 67_108_863 *)
>> let last2 = 0x7fffffff;; (* 1073_741_823 *)
>> let last = last2 (* last2 uses ALL code points and takes a while *)
>>
>> (* Sample: Convert a utf8 char string to a Vector *)
>> let utf8_to_vector str = str |> gen_of_utf8 |> V.of_gen
>>
>> let _ = printf "\"SK????f\" |> utf8_to_vector \n\t |> Vector.to_seq |>
>> S.map code_to_string |> fun seq -> seq (printf\"%s\t\")\n!";;
>>
>> "SK????f" |> utf8_to_vector |> Vector.to_seq |> S.map code_to_string |>
>>  ?fun seq -> seq (printf"%s\t");;
>>
>> (* Test below does not work for last 2 because it allocates a to big string
>> *)
>> let big = measure make_big_string last1 last1 "make_big_string";;
>> measure decode_big big last1 "decode_big";;
>>
>> (* Here last2 encodes/decodes ALL possible code points *)
>> measure round_about2 last last "round_about2";;
>> measure round_about3 last last "round_about3";;
>> measure code_into_string_test last last "code_into_string";;
>> measure code_to_string_test last last "code_to_string";;
>>
>> let _ = (* One can never have to many samples ... *)
>>  ?printf"\n\n??? "; S.( 0 -- 15) (fun i -> printf" %2x" i);
>>  ?S.( 0 -- 15)
>>  ? (fun i -> printf"\n%4x? " (i * 16 + 0x2500);
>>  ??? S.( (0x2500 + i * 16) -- (0x250F + i * 16))
>>  ??? |> S.map code_to_string
>>  ??? |> S.to_list |> String.concat "? " |> print_string
>>  ? );;
>> *)
>>
>
>
>
> _______________________________________________
> Containers-users mailing list
> Containers-users at lists.ocaml.org
> http://lists.ocaml.org/listinfo/containers-users

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180224/217e393a/attachment-0001.html>

From sp at orbitalfox.eu  Sat Feb 24 18:06:12 2018
From: sp at orbitalfox.eu (SP)
Date: Sat, 24 Feb 2018 18:06:12 +0000
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <a8d6653c-537d-47b0-9dcc-c0fcec4d1a7f@zoho.com>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
 <a8d6653c-537d-47b0-9dcc-c0fcec4d1a7f@zoho.com>
Message-ID: <20180224180612.qk3uawdfocbxypff@darkstar>

On Sat, Feb 24, 2018 at 01:01:45PM +0100, Drup wrote:
>Why not call this "Bijection" or "BijMap" ? BiMap simply implies two 
>maps. This a bit more specific.

With BiMap I was hoping to do a catch-all for Two-maps, bidirectional
maps, etc. Bijection map would get caught in there too.

I've not decided if the fact that it's two maps will be exposed or not.

Exposing it means the interfaces don't have to be written, but it won't
allow for future optimisations.

Bijection map is an apt name. Thinking about it...

-- 
	SP

From simon.cruanes.2007 at m4x.org  Sat Feb 24 18:11:10 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Sat, 24 Feb 2018 12:11:10 -0600
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <a8d6653c-537d-47b0-9dcc-c0fcec4d1a7f@zoho.com>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
 <a8d6653c-537d-47b0-9dcc-c0fcec4d1a7f@zoho.com>
Message-ID: <20180224175318.GA1900@carty>

Le Sat, 24 Feb 2018, Drup wrote:
> Why not call this "Bijection" or "BijMap" ? BiMap simply implies two maps.
> This a bit more specific.

It makes sense! `Bijection` is about the intent, `BiMap` ties to an
implementation. However if we change the name we still have to convey
that it's a functional bijection (rather than imperative).


-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180224/b58b4c80/attachment.sig>

From simon.cruanes.2007 at m4x.org  Sat Feb 24 18:21:52 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Sat, 24 Feb 2018 12:21:52 -0600
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
 <20180210195351.GE1388@carty>
 <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>
Message-ID: <20180224182152.GA1858@carty>

Le Sat, 24 Feb 2018, Drup wrote:
> Shouldn't we just standardize on bunzli's libraries (including the new
> https://github.com/dbuenzli/utext) instead of trying to re-write code that
> usually ends up being quite subtle in each standard library ?

We could build on uutf, it's relatively small and doesn't have too many
deps. However, I also don't think utf8 is that complicated that we
couldn't just redo the codepoint<-> byte conversions in a simpler (and
arguably lower overhead) way. In particular,
`Utf8string.to_seq : t -> codepoint sequence` could be faster than
calling uutf with all its poly variants.

For utext, meh. It's not stable yet, and relies on a complicated non
standard underlying vec structure. Ustring (or Utf8string, possibly, as
it's the only reasonable string to support) should be a (possibly
private) alias to string. There should be a similar Utf8buffer where you
can push/pop codepoints and append other Utf8buffers.


-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180224/75087804/attachment.sig>

From sp at orbitalfox.eu  Sun Feb 25 10:12:55 2018
From: sp at orbitalfox.eu (SP)
Date: Sun, 25 Feb 2018 10:12:55 +0000
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <20180224182152.GA1858@carty>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
 <20180210195351.GE1388@carty>
 <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>
 <20180224182152.GA1858@carty>
Message-ID: <20180225101255.56q7gebfamvrrgz4@darkstar>

On Sat, Feb 24, 2018 at 12:21:52PM -0600, Simon Cruanes wrote:
>We could build on uutf, it's relatively small and doesn't have too many
>deps. However, I also don't think utf8 is that complicated that we
>couldn't just redo the codepoint<-> byte conversions in a simpler

Make it uutf compatible then, so one can either use uutf for full
functionality or use a few basic converters provided in Containers.

-- 
	SP

From simon.cruanes.2007 at m4x.org  Sun Feb 25 14:37:10 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Sun, 25 Feb 2018 08:37:10 -0600
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <20180225101255.56q7gebfamvrrgz4@darkstar>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
 <20180210195351.GE1388@carty> <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>
 <20180224182152.GA1858@carty> <20180225101255.56q7gebfamvrrgz4@darkstar>
Message-ID: <099985F3-ACA1-490E-A451-7E93971FB92E@m4x.org>

Well, there's the standard uchar type, I think compatibility is achievable :) 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180225/ba1ff365/attachment.html>

From pjfrey at sympatico.ca  Mon Feb 26 23:52:24 2018
From: pjfrey at sympatico.ca (peter frey)
Date: Mon, 26 Feb 2018 18:52:24 -0500
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <20180225101255.56q7gebfamvrrgz4@darkstar>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
 <20180210195351.GE1388@carty> <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>
 <20180224182152.GA1858@carty> <20180225101255.56q7gebfamvrrgz4@darkstar>
Message-ID: <46bcd6d5-35cf-c84c-a4c1-94774eeb9580@sympatico.ca>

Simon occasionally includes code from some other part of the libraries 
to avoid requiring, say, Gen to access Sequence or Containers; I don't 
remember offhand.? In the case of some tiny piece of code thats 
sensible. (And so far that is all I have provided)

Pervasives has now a type uchar which Uutf uses consistently. In the 
case that one is not dealing with the many exigencies that Uutf deals 
with, thats a bit overkill?? Alain Frisch used ints in Ulex and I 
remember another usage of uchar only in Camomille.

Uutf has a smaller range of codes that it accepts; namely Utf8.
Thats 0 to (1024 * 16) + (1024 * 16) + (64 * 1024) where 64k portion at 
the end is also excluded from the 1Mb range before.

Originally Utf8 encoded all possible codes in the positive int32 range.
I prefer to revert to the old standard; (and call it Utf31) since I this 
allows me to encode alphabets that are larger than, but include, the 
utf8 range.? (This may not work with js_of_ocaml; but not all 
applications involve the web)
When it comes to comparing utf8 chars (codes; ints) consider the following:

utop # ((=));;
- : 'a -> 'a -> bool = <fun> after loading utop
utop # open Containers;;
utop # ((=));;
- : int -> int -> bool = <fun>????????????????????? type is overloaded
utop #

( I noticed this also in Jane Streets's "Sequence" .? Possibly they want 
to avoid 'polymorphic'? comparisons; i.e.: comparisons that examine the 
internal structure)

Did you intend to do that?

Peter


On 2018-02-25 05:12 AM, SP wrote:
> On Sat, Feb 24, 2018 at 12:21:52PM -0600, Simon Cruanes wrote:
>> We could build on uutf, it's relatively small and doesn't have too many
>> deps. However, I also don't think utf8 is that complicated that we
>> couldn't just redo the codepoint<-> byte conversions in a simpler
>
> Make it uutf compatible then, so one can either use uutf for full
> functionality or use a few basic converters provided in Containers.
>


From simon.cruanes.2007 at m4x.org  Tue Feb 27 00:11:32 2018
From: simon.cruanes.2007 at m4x.org (Simon Cruanes)
Date: Mon, 26 Feb 2018 18:11:32 -0600
Subject: [containers-users] Possible additions to Containers and Friends
In-Reply-To: <46bcd6d5-35cf-c84c-a4c1-94774eeb9580@sympatico.ca>
References: <2be2d373-c3ad-535a-0510-834aa92ae678@sympatico.ca>
 <20180210195351.GE1388@carty>
 <c48eeb40-1529-5e14-57fa-ff4102807040@zoho.com>
 <20180224182152.GA1858@carty>
 <20180225101255.56q7gebfamvrrgz4@darkstar>
 <46bcd6d5-35cf-c84c-a4c1-94774eeb9580@sympatico.ca>
Message-ID: <20180227001131.GU29073@church>

Le Mon, 26 Feb 2018, peter frey wrote:
> Simon occasionally includes code from some other part of the libraries to
> avoid requiring, say, Gen to access Sequence or Containers; I don't remember
> offhand.? In the case of some tiny piece of code thats sensible. (And so far
> that is all I have provided)

Indeed, and I find it sensible too to have a basic UTF8 encoder/decoder.

> Pervasives has now a type uchar which Uutf uses consistently. In the case
> that one is not dealing with the many exigencies that Uutf deals with, thats
> a bit overkill?? Alain Frisch used ints in Ulex and I remember another usage
> of uchar only in Camomille.
> 
> Uutf has a smaller range of codes that it accepts; namely Utf8.
> Thats 0 to (1024 * 16) + (1024 * 16) + (64 * 1024) where 64k portion at the
> end is also excluded from the 1Mb range before.
> 
> Originally Utf8 encoded all possible codes in the positive int32 range.
> I prefer to revert to the old standard; (and call it Utf31) since I this
> allows me to encode alphabets that are larger than, but include, the utf8
> range.? (This may not work with js_of_ocaml; but not all applications
> involve the web)

I'm not sure I understand, what is the point of supporting "more" than
utf8?

> When it comes to comparing utf8 chars (codes; ints) consider the following:
> 
> utop # ((=));;
> - : 'a -> 'a -> bool = <fun> after loading utop
> utop # open Containers;;
> utop # ((=));;
> - : int -> int -> bool = <fun>????????????????????? type is overloaded
> utop #
> 
> ( I noticed this also in Jane Streets's "Sequence" .? Possibly they want to
> avoid 'polymorphic'? comparisons; i.e.: comparisons that examine the
> internal structure)
> 
> Did you intend to do that?

It's intended, yes. You can find a rationale for it in the CHANGELOG
file or on release notes for 2.0.


-- 
Simon Cruanes

http://weusepgp.info/
key 49AA62B6, fingerprint 949F EB87 8F06 59C6 D7D3  7D8D 4AC0 1D08 49AA 62B6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.ocaml.org/pipermail/containers-users/attachments/20180226/7509e82b/attachment.sig>

From sp at orbitalfox.eu  Tue Feb 27 17:53:47 2018
From: sp at orbitalfox.eu (SP)
Date: Tue, 27 Feb 2018 17:53:47 +0000
Subject: [containers-users] Request for comments on BiMap
In-Reply-To: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
References: <20180223003729.lnkfx5fncnyiqxvd@darkstar>
Message-ID: <20180227175347.4j24ofy5qcuvxffg@tiger>

Made progress with enriching the module's interface and done some
basic testing.

https://github.com/c-cube/ocaml-containers/compare/master...orbifx:bimap

It's missing sequence conversions, which I need to read about before I
can implement them.

Anything else?

-- 
    SP

